# Comparing `tmp/nautilus_trader-1.190.0.tar.gz` & `tmp/nautilus_trader-1.191.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "nautilus_trader-1.190.0.tar", max compression
+gzip compressed data, was "nautilus_trader-1.191.0.tar", max compression
```

## Comparing `nautilus_trader-1.190.0.tar` & `nautilus_trader-1.191.0.tar`

### file list

```diff
@@ -1,1038 +1,1103 @@
--rw-r--r--   0        0        0     7652 2024-03-22 16:42:55.462560 nautilus_trader-1.190.0/LICENSE
--rw-r--r--   0        0        0    26012 2024-03-22 16:42:55.462560 nautilus_trader-1.190.0/README.md
--rw-r--r--   0        0        0    12823 2024-03-22 16:42:55.462560 nautilus_trader-1.190.0/build.py
--rw-r--r--   0        0        0      663 2024-03-22 16:42:55.474560 nautilus_trader-1.190.0/nautilus_core/.cargo/config.toml
--rw-r--r--   0        0        0   130746 2024-03-22 16:42:55.474560 nautilus_trader-1.190.0/nautilus_core/Cargo.lock
--rw-r--r--   0        0        0     2400 2024-03-22 16:42:55.474560 nautilus_trader-1.190.0/nautilus_core/Cargo.toml
--rw-r--r--   0        0        0     7652 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/LICENSE
--rw-r--r--   0        0        0     1248 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/README.md
--rw-r--r--   0        0        0      967 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/accounting/Cargo.toml
--rw-r--r--   0        0        0     9220 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/accounting/src/account/base.rs
--rw-r--r--   0        0        0    19372 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/accounting/src/account/cash.rs
--rw-r--r--   0        0        0    21443 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/accounting/src/account/margin.rs
--rw-r--r--   0        0        0     2730 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/accounting/src/account/mod.rs
--rw-r--r--   0        0        0     2318 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/accounting/src/account/stubs.rs
--rw-r--r--   0        0        0      973 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/accounting/src/lib.rs
--rw-r--r--   0        0        0    13229 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/accounting/src/python/cash.rs
--rw-r--r--   0        0        0    10978 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/accounting/src/python/margin.rs
--rw-r--r--   0        0        0     1435 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/accounting/src/python/mod.rs
--rw-r--r--   0        0        0     2568 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/accounting/src/python/transformer.rs
--rw-r--r--   0        0        0     2542 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/accounting/src/stubs.rs
--rw-r--r--   0        0        0     1659 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/Cargo.toml
--rw-r--r--   0        0        0     1179 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/bin/sandbox.rs
--rw-r--r--   0        0        0     1351 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/common.rs
--rw-r--r--   0        0        0    32730 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/decode.rs
--rw-r--r--   0        0        0     3482 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/enums.rs
--rw-r--r--   0        0        0    16024 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/live.rs
--rw-r--r--   0        0        0    11383 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/loader.rs
--rw-r--r--   0        0        0     1039 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/mod.rs
--rw-r--r--   0        0        0    10104 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/publishers.json
--rw-r--r--   0        0        0     5323 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/python/enums.rs
--rw-r--r--   0        0        0    19444 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/python/historical.rs
--rw-r--r--   0        0        0     8186 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/python/live.rs
--rw-r--r--   0        0        0    13951 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/python/loader.rs
--rw-r--r--   0        0        0     1580 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/python/mod.rs
--rw-r--r--   0        0        0     7713 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/python/types.rs
--rw-r--r--   0        0        0     6383 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/symbology.rs
--rw-r--r--   0        0        0     6868 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/types.rs
--rw-r--r--   0        0        0      933 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/adapters/src/lib.rs
--rw-r--r--   0        0        0     1177 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/backtest/Cargo.toml
--rw-r--r--   0        0        0     2046 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/backtest/build.rs
--rw-r--r--   0        0        0      484 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/backtest/cbindgen.toml
--rw-r--r--   0        0        0      807 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/backtest/cbindgen_cython.toml
--rw-r--r--   0        0        0     5870 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/backtest/src/engine.rs
--rw-r--r--   0        0        0      925 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/backtest/src/lib.rs
--rw-r--r--   0        0        0     2440 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/backtest/src/matching_engine.rs
--rw-r--r--   0        0        0       65 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/clippy.toml
--rw-r--r--   0        0        0     1566 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/Cargo.toml
--rw-r--r--   0        0        0     2735 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/build.rs
--rw-r--r--   0        0        0      548 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/cbindgen.toml
--rw-r--r--   0        0        0      823 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/cbindgen_cython.toml
--rw-r--r--   0        0        0     6245 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/cache.rs
--rw-r--r--   0        0        0    11039 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/clock.rs
--rw-r--r--   0        0        0     8638 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/enums.rs
--rw-r--r--   0        0        0     7937 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/factories.rs
--rw-r--r--   0        0        0    11782 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/ffi/clock.rs
--rw-r--r--   0        0        0     3086 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/ffi/enums.rs
--rw-r--r--   0        0        0     5864 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/ffi/logging.rs
--rw-r--r--   0        0        0      962 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/ffi/mod.rs
--rw-r--r--   0        0        0    12282 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/ffi/msgbus.rs
--rw-r--r--   0        0        0     1718 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/ffi/timer.rs
--rw-r--r--   0        0        0     5028 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/generators/client_order_id.rs
--rw-r--r--   0        0        0     1298 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/generators/mod.rs
--rw-r--r--   0        0        0     4982 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/generators/order_list_id.rs
--rw-r--r--   0        0        0     5582 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/generators/position_id.rs
--rw-r--r--   0        0        0     3393 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/handlers.rs
--rw-r--r--   0        0        0     1234 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/lib.rs
--rw-r--r--   0        0        0     7651 2024-03-22 16:42:55.478560 nautilus_trader-1.190.0/nautilus_core/common/src/logging/headers.rs
--rw-r--r--   0        0        0    23482 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/logging/logger.rs
--rw-r--r--   0        0        0     5295 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/logging/mod.rs
--rw-r--r--   0        0        0     7675 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/logging/writer.rs
--rw-r--r--   0        0        0    23294 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/msgbus.rs
--rw-r--r--   0        0        0     5708 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/python/clock.rs
--rw-r--r--   0        0        0     4513 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/python/enums.rs
--rw-r--r--   0        0        0     4896 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/python/logging.rs
--rw-r--r--   0        0        0     1877 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/python/mod.rs
--rw-r--r--   0        0        0     3267 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/python/timer.rs
--rw-r--r--   0        0        0     2848 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/python/versioning.rs
--rw-r--r--   0        0        0    12982 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/redis.rs
--rw-r--r--   0        0        0     1205 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/runtime.rs
--rw-r--r--   0        0        0     1302 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/stubs.rs
--rw-r--r--   0        0        0     2473 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/testing.rs
--rw-r--r--   0        0        0    11790 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/common/src/timer.rs
--rw-r--r--   0        0        0      809 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/Cargo.toml
--rw-r--r--   0        0        0     2731 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/build.rs
--rw-r--r--   0        0        0      717 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/cbindgen.toml
--rw-r--r--   0        0        0      824 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/cbindgen_cython.toml
--rw-r--r--   0        0        0    11552 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/correctness.rs
--rw-r--r--   0        0        0     8614 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/datetime.rs
--rw-r--r--   0        0        0     5699 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/ffi/cvec.rs
--rw-r--r--   0        0        0     1241 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/ffi/datetime.rs
--rw-r--r--   0        0        0      963 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/ffi/mod.rs
--rw-r--r--   0        0        0     8229 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/ffi/parsing.rs
--rw-r--r--   0        0        0     6642 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/ffi/string.rs
--rw-r--r--   0        0        0     3986 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/ffi/uuid.rs
--rw-r--r--   0        0        0     1089 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/lib.rs
--rw-r--r--   0        0        0     1373 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/message.rs
--rw-r--r--   0        0        0     3385 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/parsing.rs
--rw-r--r--   0        0        0     1067 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/python/casing.rs
--rw-r--r--   0        0        0     2584 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/python/datetime.rs
--rw-r--r--   0        0        0     2772 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/python/mod.rs
--rw-r--r--   0        0        0     1407 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/python/serialization.rs
--rw-r--r--   0        0        0     3123 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/python/uuid.rs
--rw-r--r--   0        0        0     1772 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/serialization.rs
--rw-r--r--   0        0        0     8670 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/time.rs
--rw-r--r--   0        0        0     5409 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/core/src/uuid.rs
--rw-r--r--   0        0        0     1333 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/execution/Cargo.toml
--rw-r--r--   0        0        0      907 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/execution/src/lib.rs
--rw-r--r--   0        0        0    17982 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/execution/src/matching_core.rs
--rw-r--r--   0        0        0      746 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/Cargo.toml
--rw-r--r--   0        0        0     8897 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/average/ama.rs
--rw-r--r--   0        0        0     6979 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/average/dema.rs
--rw-r--r--   0        0        0     6902 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/average/ema.rs
--rw-r--r--   0        0        0     8322 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/average/hma.rs
--rw-r--r--   0        0        0     2838 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/average/mod.rs
--rw-r--r--   0        0        0     6925 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/average/rma.rs
--rw-r--r--   0        0        0     6142 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/average/sma.rs
--rw-r--r--   0        0        0     7476 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/average/vidya.rs
--rw-r--r--   0        0        0     7727 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/average/wma.rs
--rw-r--r--   0        0        0     6602 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/book/imbalance.rs
--rw-r--r--   0        0        0      903 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/book/mod.rs
--rw-r--r--   0        0        0     3386 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/indicator.rs
--rw-r--r--   0        0        0     1056 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/lib.rs
--rw-r--r--   0        0        0     4976 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/momentum/aroon.rs
--rw-r--r--   0        0        0     7008 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/momentum/cmo.rs
--rw-r--r--   0        0        0      925 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/momentum/mod.rs
--rw-r--r--   0        0        0     7876 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/momentum/rsi.rs
--rw-r--r--   0        0        0     2922 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/ama.rs
--rw-r--r--   0        0        0     2799 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/dema.rs
--rw-r--r--   0        0        0     2880 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/ema.rs
--rw-r--r--   0        0        0     2759 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/hma.rs
--rw-r--r--   0        0        0      976 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/mod.rs
--rw-r--r--   0        0        0     2865 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/rma.rs
--rw-r--r--   0        0        0     2765 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/sma.rs
--rw-r--r--   0        0        0     3101 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/vidya.rs
--rw-r--r--   0        0        0     2755 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/wma.rs
--rw-r--r--   0        0        0     2421 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/book/imbalance.rs
--rw-r--r--   0        0        0      903 2024-03-22 16:42:55.482560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/book/mod.rs
--rw-r--r--   0        0        0     2044 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/mod.rs
--rw-r--r--   0        0        0     2901 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/momentum/aroon.rs
--rw-r--r--   0        0        0     2748 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/momentum/cmo.rs
--rw-r--r--   0        0        0      925 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/momentum/mod.rs
--rw-r--r--   0        0        0     2583 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/momentum/rsi.rs
--rw-r--r--   0        0        0     2005 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/ratio/efficiency_ratio.rs
--rw-r--r--   0        0        0      910 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/ratio/mod.rs
--rw-r--r--   0        0        0     3005 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/volatility/atr.rs
--rw-r--r--   0        0        0      897 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/python/volatility/mod.rs
--rw-r--r--   0        0        0     8102 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/ratio/efficiency_ratio.rs
--rw-r--r--   0        0        0      910 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/ratio/mod.rs
--rw-r--r--   0        0        0     5624 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/stubs.rs
--rw-r--r--   0        0        0     4194 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/volatility/atr.rs
--rw-r--r--   0        0        0      897 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/indicators/src/volatility/mod.rs
--rw-r--r--   0        0        0      962 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/infrastructure/Cargo.toml
--rw-r--r--   0        0        0      969 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/infrastructure/src/lib.rs
--rw-r--r--   0        0        0     3278 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/infrastructure/src/python/cache.rs
--rw-r--r--   0        0        0     1085 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/infrastructure/src/python/mod.rs
--rw-r--r--   0        0        0    20407 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/infrastructure/src/redis.rs
--rw-r--r--   0        0        0     1418 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/Cargo.toml
--rw-r--r--   0        0        0      400 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/benches/criterion_fixed_precision_benchmark.rs
--rw-r--r--   0        0        0      225 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/benches/iai_fixed_precision_benchmark.rs
--rw-r--r--   0        0        0     2733 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/build.rs
--rw-r--r--   0        0        0     1617 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/cbindgen.toml
--rw-r--r--   0        0        0     1839 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/cbindgen_cython.toml
--rw-r--r--   0        0        0    33823 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/currencies.rs
--rw-r--r--   0        0        0    19952 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/data/bar.rs
--rw-r--r--   0        0        0     9163 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/data/delta.rs
--rw-r--r--   0        0        0    11277 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/data/deltas.rs
--rw-r--r--   0        0        0    13182 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/data/depth.rs
--rw-r--r--   0        0        0     3532 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/data/mod.rs
--rw-r--r--   0        0        0    10092 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/data/order.rs
--rw-r--r--   0        0        0     8618 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/data/quote.rs
--rw-r--r--   0        0        0     1685 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/data/stubs.rs
--rw-r--r--   0        0        0     7316 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/data/trade.rs
--rw-r--r--   0        0        0    29097 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/enums.rs
--rw-r--r--   0        0        0      940 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/account/mod.rs
--rw-r--r--   0        0        0     4917 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/account/state.rs
--rw-r--r--   0        0        0     3994 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/account/stubs.rs
--rw-r--r--   0        0        0      934 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/mod.rs
--rw-r--r--   0        0        0     3620 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/accepted.rs
--rw-r--r--   0        0        0     4024 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/cancel_rejected.rs
--rw-r--r--   0        0        0     3373 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/canceled.rs
--rw-r--r--   0        0        0     3195 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/denied.rs
--rw-r--r--   0        0        0     3069 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/emulated.rs
--rw-r--r--   0        0        0     5441 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/event.rs
--rw-r--r--   0        0        0     3805 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/expired.rs
--rw-r--r--   0        0        0     6634 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/filled.rs
--rw-r--r--   0        0        0    10893 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/initialized.rs
--rw-r--r--   0        0        0     1254 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/mod.rs
--rw-r--r--   0        0        0     4039 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/modify_rejected.rs
--rw-r--r--   0        0        0     3788 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/pending_cancel.rs
--rw-r--r--   0        0        0     3806 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/pending_update.rs
--rw-r--r--   0        0        0     3477 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/rejected.rs
--rw-r--r--   0        0        0     3182 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/released.rs
--rw-r--r--   0        0        0    10905 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/stubs.rs
--rw-r--r--   0        0        0     3278 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/submitted.rs
--rw-r--r--   0        0        0     3841 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/triggered.rs
--rw-r--r--   0        0        0     4446 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/order/updated.rs
--rw-r--r--   0        0        0     1986 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/position/changed.rs
--rw-r--r--   0        0        0     2107 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/position/closed.rs
--rw-r--r--   0        0        0     1200 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/position/mod.rs
--rw-r--r--   0        0        0     1790 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/position/opened.rs
--rw-r--r--   0        0        0     1984 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/events/position/state.rs
--rw-r--r--   0        0        0     6049 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/bar.rs
--rw-r--r--   0        0        0     1844 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/delta.rs
--rw-r--r--   0        0        0     3546 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/deltas.rs
--rw-r--r--   0        0        0     3786 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/depth.rs
--rw-r--r--   0        0        0      988 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/mod.rs
--rw-r--r--   0        0        0     2417 2024-03-22 16:42:55.486560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/order.rs
--rw-r--r--   0        0        0     2790 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/quote.rs
--rw-r--r--   0        0        0     2189 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/trade.rs
--rw-r--r--   0        0        0    14505 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/enums.rs
--rw-r--r--   0        0        0      899 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/events/mod.rs
--rw-r--r--   0        0        0     9626 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/events/order.rs
--rw-r--r--   0        0        0     3273 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/account_id.rs
--rw-r--r--   0        0        0     2230 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/client_id.rs
--rw-r--r--   0        0        0     1396 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/client_order_id.rs
--rw-r--r--   0        0        0     1379 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/component_id.rs
--rw-r--r--   0        0        0     1410 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/exec_algorithm_id.rs
--rw-r--r--   0        0        0     4223 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/instrument_id.rs
--rw-r--r--   0        0        0     1177 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/mod.rs
--rw-r--r--   0        0        0     1382 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/order_list_id.rs
--rw-r--r--   0        0        0     1372 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/position_id.rs
--rw-r--r--   0        0        0     1372 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/strategy_id.rs
--rw-r--r--   0        0        0     1341 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/symbol.rs
--rw-r--r--   0        0        0     1603 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/trade_id.rs
--rw-r--r--   0        0        0     1358 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/trader_id.rs
--rw-r--r--   0        0        0     2001 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/venue.rs
--rw-r--r--   0        0        0     1389 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/venue_order_id.rs
--rw-r--r--   0        0        0      903 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/instruments/mod.rs
--rw-r--r--   0        0        0     5653 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/instruments/synthetic.rs
--rw-r--r--   0        0        0     1005 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/mod.rs
--rw-r--r--   0        0        0     8074 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/orderbook/book.rs
--rw-r--r--   0        0        0    12915 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/orderbook/container.rs
--rw-r--r--   0        0        0     3621 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/orderbook/level.rs
--rw-r--r--   0        0        0      932 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/orderbook/mod.rs
--rw-r--r--   0        0        0     5719 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/types/currency.rs
--rw-r--r--   0        0        0      950 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/types/mod.rs
--rw-r--r--   0        0        0     1596 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/types/money.rs
--rw-r--r--   0        0        0     1589 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/types/price.rs
--rw-r--r--   0        0        0     1845 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/ffi/types/quantity.rs
--rw-r--r--   0        0        0     3316 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/account_id.rs
--rw-r--r--   0        0        0     2378 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/client_id.rs
--rw-r--r--   0        0        0     4504 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/client_order_id.rs
--rw-r--r--   0        0        0     2429 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/component_id.rs
--rw-r--r--   0        0        0     2437 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/exec_algorithm_id.rs
--rw-r--r--   0        0        0     4783 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/instrument_id.rs
--rw-r--r--   0        0        0     1907 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/macros.rs
--rw-r--r--   0        0        0     2976 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/mod.rs
--rw-r--r--   0        0        0     2432 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/order_list_id.rs
--rw-r--r--   0        0        0     2537 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/position_id.rs
--rw-r--r--   0        0        0     3979 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/strategy_id.rs
--rw-r--r--   0        0        0     3573 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/stubs.rs
--rw-r--r--   0        0        0     2678 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/symbol.rs
--rw-r--r--   0        0        0     4126 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/trade_id.rs
--rw-r--r--   0        0        0     3224 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/trader_id.rs
--rw-r--r--   0        0        0     3308 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/venue.rs
--rw-r--r--   0        0        0     2578 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/venue_order_id.rs
--rw-r--r--   0        0        0     6872 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/instruments/crypto_future.rs
--rw-r--r--   0        0        0     7062 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/instruments/crypto_perpetual.rs
--rw-r--r--   0        0        0     6821 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/instruments/currency_pair.rs
--rw-r--r--   0        0        0     5976 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/instruments/equity.rs
--rw-r--r--   0        0        0     6604 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/instruments/futures_contract.rs
--rw-r--r--   0        0        0     6730 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/instruments/futures_spread.rs
--rw-r--r--   0        0        0     5535 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/instruments/mod.rs
--rw-r--r--   0        0        0     6829 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/instruments/options_contract.rs
--rw-r--r--   0        0        0     6721 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/instruments/options_spread.rs
--rw-r--r--   0        0        0    12244 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/instruments/stubs.rs
--rw-r--r--   0        0        0     7460 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/instruments/synthetic.rs
--rw-r--r--   0        0        0     1213 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/lib.rs
--rw-r--r--   0        0        0     1567 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/macros.rs
--rw-r--r--   0        0        0    14073 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/orderbook/book.rs
--rw-r--r--   0        0        0    10384 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/orderbook/book_mbo.rs
--rw-r--r--   0        0        0    17289 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/orderbook/book_mbp.rs
--rw-r--r--   0        0        0     2836 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/orderbook/display.rs
--rw-r--r--   0        0        0    22467 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/orderbook/ladder.rs
--rw-r--r--   0        0        0    12998 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/orderbook/level.rs
--rw-r--r--   0        0        0      982 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/orderbook/mod.rs
--rw-r--r--   0        0        0    37766 2024-03-22 16:42:55.490560 nautilus_trader-1.190.0/nautilus_core/model/src/orders/base.rs
--rw-r--r--   0        0        0     9116 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/orders/default.rs
--rw-r--r--   0        0        0    13832 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/orders/limit.rs
--rw-r--r--   0        0        0    10736 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/orders/limit_if_touched.rs
--rw-r--r--   0        0        0    11593 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/orders/market.rs
--rw-r--r--   0        0        0    10363 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/orders/market_if_touched.rs
--rw-r--r--   0        0        0     9596 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/orders/market_to_limit.rs
--rw-r--r--   0        0        0     1188 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/orders/mod.rs
--rw-r--r--   0        0        0    10698 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/orders/stop_limit.rs
--rw-r--r--   0        0        0    10342 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/orders/stop_market.rs
--rw-r--r--   0        0        0     7092 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/orders/stubs.rs
--rw-r--r--   0        0        0    11325 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/orders/trailing_stop_limit.rs
--rw-r--r--   0        0        0    10795 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/orders/trailing_stop_market.rs
--rw-r--r--   0        0        0    71125 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/position.rs
--rw-r--r--   0        0        0     6518 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/common.rs
--rw-r--r--   0        0        0    10429 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/data/bar.rs
--rw-r--r--   0        0        0    10598 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/data/delta.rs
--rw-r--r--   0        0        0     4465 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/data/deltas.rs
--rw-r--r--   0        0        0     8919 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/data/depth.rs
--rw-r--r--   0        0        0     3371 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/data/mod.rs
--rw-r--r--   0        0        0     5615 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/data/order.rs
--rw-r--r--   0        0        0    14263 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/data/quote.rs
--rw-r--r--   0        0        0    12446 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/data/trade.rs
--rw-r--r--   0        0        0    42796 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/enums.rs
--rw-r--r--   0        0        0      899 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/account/mod.rs
--rw-r--r--   0        0        0     7432 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/account/state.rs
--rw-r--r--   0        0        0      916 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/mod.rs
--rw-r--r--   0        0        0     4306 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/accepted.rs
--rw-r--r--   0        0        0     5181 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/cancel_rejected.rs
--rw-r--r--   0        0        0     4886 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/canceled.rs
--rw-r--r--   0        0        0     3854 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/denied.rs
--rw-r--r--   0        0        0     3530 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/emulated.rs
--rw-r--r--   0        0        0     4881 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/expired.rs
--rw-r--r--   0        0        0    10194 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/filled.rs
--rw-r--r--   0        0        0    13207 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/initialized.rs
--rw-r--r--   0        0        0     1197 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/mod.rs
--rw-r--r--   0        0        0     5193 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/modify_rejected.rs
--rw-r--r--   0        0        0     4636 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/pending_cancel.rs
--rw-r--r--   0        0        0     4636 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/pending_update.rs
--rw-r--r--   0        0        0     4297 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/rejected.rs
--rw-r--r--   0        0        0     3859 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/released.rs
--rw-r--r--   0        0        0     3915 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/submitted.rs
--rw-r--r--   0        0        0     4898 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/triggered.rs
--rw-r--r--   0        0        0     6069 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/updated.rs
--rw-r--r--   0        0        0     3628 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/identifiers/instrument_id.rs
--rw-r--r--   0        0        0     1958 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/identifiers/mod.rs
--rw-r--r--   0        0        0     3411 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/identifiers/trade_id.rs
--rw-r--r--   0        0        0     9410 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/crypto_future.rs
--rw-r--r--   0        0        0     9099 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/crypto_perpetual.rs
--rw-r--r--   0        0        0     8645 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/currency_pair.rs
--rw-r--r--   0        0        0     6880 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/equity.rs
--rw-r--r--   0        0        0     8612 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/futures_contract.rs
--rw-r--r--   0        0        0     8874 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/futures_spread.rs
--rw-r--r--   0        0        0     1072 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/mod.rs
--rw-r--r--   0        0        0     9127 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/options_contract.rs
--rw-r--r--   0        0        0     8872 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/options_spread.rs
--rw-r--r--   0        0        0     3359 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/macros.rs
--rw-r--r--   0        0        0     7042 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/mod.rs
--rw-r--r--   0        0        0     5821 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/orderbook/book_mbo.rs
--rw-r--r--   0        0        0     6508 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/orderbook/book_mbp.rs
--rw-r--r--   0        0        0     2104 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/orderbook/level.rs
--rw-r--r--   0        0        0      935 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/orderbook/mod.rs
--rw-r--r--   0        0        0    21160 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/orders/limit.rs
--rw-r--r--   0        0        0    17490 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/orders/market.rs
--rw-r--r--   0        0        0      915 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/orders/mod.rs
--rw-r--r--   0        0        0    13464 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/position.rs
--rw-r--r--   0        0        0     6913 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/types/balance.rs
--rw-r--r--   0        0        0     5123 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/types/currency.rs
--rw-r--r--   0        0        0      967 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/types/mod.rs
--rw-r--r--   0        0        0    14400 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/types/money.rs
--rw-r--r--   0        0        0    14717 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/types/price.rs
--rw-r--r--   0        0        0    14627 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/python/types/quantity.rs
--rw-r--r--   0        0        0     5344 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/stubs.rs
--rw-r--r--   0        0        0     4765 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/types/balance.rs
--rw-r--r--   0        0        0     6542 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/types/currency.rs
--rw-r--r--   0        0        0     6622 2024-03-22 16:42:55.494560 nautilus_trader-1.190.0/nautilus_core/model/src/types/fixed.rs
--rw-r--r--   0        0        0     1023 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/model/src/types/mod.rs
--rw-r--r--   0        0        0    11402 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/model/src/types/money.rs
--rw-r--r--   0        0        0    14086 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/model/src/types/price.rs
--rw-r--r--   0        0        0    14263 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/model/src/types/quantity.rs
--rw-r--r--   0        0        0     1475 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/model/src/types/stubs.rs
--rw-r--r--   0        0        0     3329 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/model/src/venues.rs
--rw-r--r--   0        0        0     1037 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/Cargo.toml
--rw-r--r--   0        0        0     1655 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/benches/test_client.rs
--rw-r--r--   0        0        0     1374 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/benches/test_server.rs
--rw-r--r--   0        0        0    12283 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/src/http.rs
--rw-r--r--   0        0        0     1014 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/src/lib.rs
--rw-r--r--   0        0        0     1441 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/src/python/mod.rs
--rw-r--r--   0        0        0     6239 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/src/ratelimiter/clock.rs
--rw-r--r--   0        0        0     5417 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/src/ratelimiter/gcra.rs
--rw-r--r--   0        0        0     8865 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/src/ratelimiter/mod.rs
--rw-r--r--   0        0        0     4079 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/src/ratelimiter/nanos.rs
--rw-r--r--   0        0        0     9739 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/src/ratelimiter/quota.rs
--rw-r--r--   0        0        0    23510 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/src/socket.rs
--rw-r--r--   0        0        0    28849 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/src/websocket.rs
--rw-r--r--   0        0        0       18 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/.gitignore
--rw-r--r--   0        0        0     2862 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/CHANGELOG.md
--rw-r--r--   0        0        0     2061 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/Cargo.toml
--rw-r--r--   0        0        0     1093 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/LICENSE
--rw-r--r--   0        0        0     2861 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/README.md
--rw-r--r--   0        0        0      268 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/rustfmt.toml
--rw-r--r--   0        0        0     6900 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/src/compat.rs
--rw-r--r--   0        0        0     2747 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/src/connect.rs
--rw-r--r--   0        0        0     5469 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/src/handshake.rs
--rw-r--r--   0        0        0    14303 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/src/lib.rs
--rw-r--r--   0        0        0     2854 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/src/stream.rs
--rw-r--r--   0        0        0     8755 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/src/tls.rs
--rw-r--r--   0        0        0     1368 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/Cargo.toml
--rw-r--r--   0        0        0     3658 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/benches/bench_persistence.rs
--rw-r--r--   0        0        0    12902 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/arrow/bar.rs
--rw-r--r--   0        0        0    15765 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/arrow/delta.rs
--rw-r--r--   0        0        0    41463 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/arrow/depth.rs
--rw-r--r--   0        0        0     4605 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/arrow/mod.rs
--rw-r--r--   0        0        0    12568 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/arrow/quote.rs
--rw-r--r--   0        0        0    12886 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/arrow/trade.rs
--rw-r--r--   0        0        0    10542 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/backend/kmerge_batch.rs
--rw-r--r--   0        0        0      923 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/backend/mod.rs
--rw-r--r--   0        0        0     8042 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/backend/session.rs
--rw-r--r--   0        0        0     7561 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/db/database.rs
--rw-r--r--   0        0        0      931 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/db/mod.rs
--rw-r--r--   0        0        0      980 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/db/schema.rs
--rw-r--r--   0        0        0     3458 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/db/sql.rs
--rw-r--r--   0        0        0      972 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/lib.rs
--rw-r--r--   0        0        0      922 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/python/backend/mod.rs
--rw-r--r--   0        0        0     4269 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/python/backend/session.rs
--rw-r--r--   0        0        0    12804 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/python/backend/transformer.rs
--rw-r--r--   0        0        0     1574 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/python/mod.rs
--rw-r--r--   0        0        0     2824 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/python/wranglers/bar.rs
--rw-r--r--   0        0        0     3031 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/python/wranglers/delta.rs
--rw-r--r--   0        0        0      942 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/python/wranglers/mod.rs
--rw-r--r--   0        0        0     2955 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/python/wranglers/quote.rs
--rw-r--r--   0        0        0     2952 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/src/python/wranglers/trade.rs
--rw-r--r--   0        0        0    10633 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/tests/test_catalog.rs
--rw-r--r--   0        0        0     2159 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/persistence/tests/test_util.rs
--rw-r--r--   0        0        0     1469 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/pyo3/Cargo.toml
--rw-r--r--   0        0        0     4205 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/pyo3/src/lib.rs
--rw-r--r--   0        0        0       50 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/rust-toolchain.toml
--rw-r--r--   0        0        0      225 2024-03-22 16:42:55.498560 nautilus_trader-1.190.0/nautilus_core/rustfmt.toml
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/__init__.pxd
--rw-r--r--   0        0        0     2270 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/__init__.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/__init__.pxd
--rw-r--r--   0        0        0     1414 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/__init__.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/__init__.pxd
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/__init__.py
--rw-r--r--   0        0        0     4195 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/base.pxd
--rw-r--r--   0        0        0    14679 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/base.pyx
--rw-r--r--   0        0        0     1740 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/betting.pxd
--rw-r--r--   0        0        0     4117 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/betting.pyx
--rw-r--r--   0        0        0     2013 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/cash.pxd
--rw-r--r--   0        0        0    13218 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/cash.pyx
--rw-r--r--   0        0        0     3309 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/margin.pxd
--rw-r--r--   0        0        0    22720 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/margin.pyx
--rw-r--r--   0        0        0     1489 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/calculators.pxd
--rw-r--r--   0        0        0    10740 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/calculators.pyx
--rw-r--r--   0        0        0     2111 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/error.py
--rw-r--r--   0        0        0     1089 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/factory.pxd
--rw-r--r--   0        0        0     4065 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/factory.pyx
--rw-r--r--   0        0        0     2653 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/manager.pxd
--rw-r--r--   0        0        0    22652 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/accounting/manager.pyx
--rw-r--r--   0        0        0     1153 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/__init__.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/_template/__init__.py
--rw-r--r--   0        0        0     1013 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/_template/core.py
--rw-r--r--   0        0        0    14665 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/_template/data.py
--rw-r--r--   0        0        0     7371 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/_template/execution.py
--rw-r--r--   0        0        0     2601 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/_template/providers.py
--rw-r--r--   0        0        0      945 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/__init__.py
--rw-r--r--   0        0        0    12480 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/client.py
--rw-r--r--   0        0        0     3924 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/common.py
--rw-r--r--   0        0        0     2529 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/config.py
--rw-r--r--   0        0        0     2038 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/constants.py
--rw-r--r--   0        0        0    12453 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/data.py
--rw-r--r--   0        0        0    10896 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/data_types.py
--rw-r--r--   0        0        0    41651 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/execution.py
--rw-r--r--   0        0        0     7509 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/factories.py
--rw-r--r--   0        0        0     1257 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/orderbook.pxd
--rw-r--r--   0        0        0     1770 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/orderbook.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/parsing/__init__.py
--rw-r--r--   0        0        0     3234 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/parsing/common.py
--rw-r--r--   0        0        0     4607 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/parsing/core.py
--rw-r--r--   0        0        0    19955 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/parsing/requests.py
--rw-r--r--   0        0        0    19323 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/parsing/streaming.py
--rw-r--r--   0        0        0    12917 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/providers.py
--rw-r--r--   0        0        0     9450 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/sockets.py
--rw-r--r--   0        0        0      938 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/__init__.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/__init__.py
--rw-r--r--   0        0        0      997 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/constants.py
--rw-r--r--   0        0        0    39667 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/data.py
--rw-r--r--   0        0        0    19212 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/enums.py
--rw-r--r--   0        0        0    41935 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/execution.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/schemas/__init__.py
--rw-r--r--   0        0        0    10932 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/schemas/account.py
--rw-r--r--   0        0        0    21983 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/schemas/market.py
--rw-r--r--   0        0        0     2412 2024-03-22 16:42:55.502560 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/schemas/symbol.py
--rw-r--r--   0        0        0     1209 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/schemas/user.py
--rw-r--r--   0        0        0    15632 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/types.py
--rw-r--r--   0        0        0     5392 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/config.py
--rw-r--r--   0        0        0    16730 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/factories.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/__init__.py
--rw-r--r--   0        0        0     6430 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/data.py
--rw-r--r--   0        0        0     6637 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/enums.py
--rw-r--r--   0        0        0    13228 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/execution.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/http/__init__.py
--rw-r--r--   0        0        0    16086 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/http/account.py
--rw-r--r--   0        0        0     3629 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/http/market.py
--rw-r--r--   0        0        0     1962 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/http/user.py
--rw-r--r--   0        0        0     4854 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/http/wallet.py
--rw-r--r--   0        0        0    17612 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/providers.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/schemas/__init__.py
--rw-r--r--   0        0        0     6997 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/schemas/account.py
--rw-r--r--   0        0        0     7648 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/schemas/market.py
--rw-r--r--   0        0        0    15372 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/schemas/user.py
--rw-r--r--   0        0        0     1281 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/schemas/wallet.py
--rw-r--r--   0        0        0     5070 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/types.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/__init__.py
--rw-r--r--   0        0        0    27330 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/account.py
--rw-r--r--   0        0        0     5511 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/client.py
--rw-r--r--   0        0        0     3319 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/endpoint.py
--rw-r--r--   0        0        0     1588 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/error.py
--rw-r--r--   0        0        0    32497 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/market.py
--rw-r--r--   0        0        0     7707 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/user.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/__init__.py
--rw-r--r--   0        0        0     5455 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/data.py
--rw-r--r--   0        0        0     5563 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/enums.py
--rw-r--r--   0        0        0     9939 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/execution.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/http/__init__.py
--rw-r--r--   0        0        0    26245 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/http/account.py
--rw-r--r--   0        0        0     6645 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/http/market.py
--rw-r--r--   0        0        0     1968 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/http/user.py
--rw-r--r--   0        0        0     4614 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/http/wallet.py
--rw-r--r--   0        0        0    13699 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/providers.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/schemas/__init__.py
--rw-r--r--   0        0        0     3270 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/schemas/account.py
--rw-r--r--   0        0        0     6770 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/schemas/market.py
--rw-r--r--   0        0        0    11717 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/schemas/user.py
--rw-r--r--   0        0        0     1262 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/schemas/wallet.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/websocket/__init__.py
--rw-r--r--   0        0        0    16325 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/binance/websocket/client.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/__init__.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/common/__init__.py
--rw-r--r--   0        0        0      953 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/common/constants.py
--rw-r--r--   0        0        0     9168 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/common/enums.py
--rw-r--r--   0        0        0     1446 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/common/error.py
--rw-r--r--   0        0        0     2066 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/config.py
--rw-r--r--   0        0        0    16516 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/data.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/__init__.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/account/__init__.py
--rw-r--r--   0        0        0     2351 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/account/fee_rate.py
--rw-r--r--   0        0        0     2432 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/account/position_info.py
--rw-r--r--   0        0        0     2358 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/account/wallet_balance.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/asset/__init__.py
--rw-r--r--   0        0        0     2540 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/endpoint.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/market/__init__.py
--rw-r--r--   0        0        0     3216 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/market/instruments_info.py
--rw-r--r--   0        0        0     2239 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/market/klines.py
--rw-r--r--   0        0        0     2105 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/market/server_time.py
--rw-r--r--   0        0        0     3300 2024-03-22 16:42:55.506559 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/market/tickers.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/trade/__init__.py
--rw-r--r--   0        0        0     2443 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/trade/cancel_all_orders.py
--rw-r--r--   0        0        0     2449 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/trade/open_orders.py
--rw-r--r--   0        0        0     2790 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/trade/place_order.py
--rw-r--r--   0        0        0    22880 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/execution.py
--rw-r--r--   0        0        0    10963 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/factories.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/http/__init__.py
--rw-r--r--   0        0        0     7736 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/http/account.py
--rw-r--r--   0        0        0     6482 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/http/client.py
--rw-r--r--   0        0        0     1083 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/http/errors.py
--rw-r--r--   0        0        0     6863 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/http/market.py
--rw-r--r--   0        0        0     1180 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/http/user.py
--rw-r--r--   0        0        0     8494 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/provider.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/__init__.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/account/__init__.py
--rw-r--r--   0        0        0     3495 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/account/balance.py
--rw-r--r--   0        0        0     1204 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/account/fee_rate.py
--rw-r--r--   0        0        0     2114 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/common.py
--rw-r--r--   0        0        0    11916 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/instrument.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/market/__init__.py
--rw-r--r--   0        0        0     2184 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/market/kline.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/market/risk_limit.py
--rw-r--r--   0        0        0     1088 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/market/server_time.py
--rw-r--r--   0        0        0     4461 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/market/ticker.py
--rw-r--r--   0        0        0     6038 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/order.py
--rw-r--r--   0        0        0     2660 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/position.py
--rw-r--r--   0        0        0     2390 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/symbol.py
--rw-r--r--   0        0        0    13953 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/ws.py
--rw-r--r--   0        0        0     2569 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/utils.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/websocket/__init__.py
--rw-r--r--   0        0        0     5870 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/websocket/client.py
--rw-r--r--   0        0        0     1689 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/databento/__init__.py
--rw-r--r--   0        0        0     2749 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/databento/common.py
--rw-r--r--   0        0        0     2727 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/databento/config.py
--rw-r--r--   0        0        0     1210 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/databento/constants.py
--rw-r--r--   0        0        0    38946 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/databento/data.py
--rw-r--r--   0        0        0     1315 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/databento/enums.py
--rw-r--r--   0        0        0     6020 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/databento/factories.py
--rw-r--r--   0        0        0    10707 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/databento/loaders.py
--rw-r--r--   0        0        0    10149 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/databento/providers.py
--rw-r--r--   0        0        0    10104 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/databento/publishers.json
--rw-r--r--   0        0        0     1141 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/databento/types.py
--rw-r--r--   0        0        0     1193 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/env.py
--rw-r--r--   0        0        0      930 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/__init__.py
--rw-r--r--   0        0        0     1014 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/__init__.py
--rw-r--r--   0        0        0     6391 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/account.py
--rw-r--r--   0        0        0    22255 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/client.py
--rw-r--r--   0        0        0    15878 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/common.py
--rw-r--r--   0        0        0     9097 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/connection.py
--rw-r--r--   0        0        0     7137 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/contract.py
--rw-r--r--   0        0        0     8631 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/error.py
--rw-r--r--   0        0        0    31455 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/market_data.py
--rw-r--r--   0        0        0    10316 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/order.py
--rw-r--r--   0        0        0    40827 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/wrapper.py
--rw-r--r--   0        0        0     6868 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/common.py
--rw-r--r--   0        0        0     8127 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/config.py
--rw-r--r--   0        0        0    17264 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/data.py
--rw-r--r--   0        0        0    38544 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/execution.py
--rw-r--r--   0        0        0     8941 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/factories.py
--rw-r--r--   0        0        0     7879 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/gateway.py
--rw-r--r--   0        0        0     1054 2024-03-22 16:42:55.510560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/historic/__init__.py
--rw-r--r--   0        0        0    20953 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/historic/client.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/parsing/__init__.py
--rw-r--r--   0        0        0     3579 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/parsing/data.py
--rw-r--r--   0        0        0     3839 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/parsing/execution.py
--rw-r--r--   0        0        0    18270 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/parsing/instruments.py
--rw-r--r--   0        0        0    12263 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/providers.py
--rw-r--r--   0        0        0     4904 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/web.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/adapters/sandbox/__init__.py
--rw-r--r--   0        0        0     1360 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/adapters/sandbox/config.py
--rw-r--r--   0        0        0     7784 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/adapters/sandbox/execution.py
--rw-r--r--   0        0        0     2750 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/adapters/sandbox/factory.py
--rw-r--r--   0        0        0      937 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/adapters/tardis/__init__.py
--rw-r--r--   0        0        0     2909 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/adapters/tardis/loaders.py
--rw-r--r--   0        0        0      978 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/__init__.py
--rw-r--r--   0        0        0    15183 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/analyzer.py
--rw-r--r--   0        0        0     5714 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/reporter.py
--rw-r--r--   0        0        0     3940 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistic.py
--rw-r--r--   0        0        0     2255 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/__init__.py
--rw-r--r--   0        0        0     1997 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/expectancy.py
--rw-r--r--   0        0        0     1705 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/long_ratio.py
--rw-r--r--   0        0        0     1468 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/loser_avg.py
--rw-r--r--   0        0        0     1514 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/loser_max.py
--rw-r--r--   0        0        0     1512 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/loser_min.py
--rw-r--r--   0        0        0     1563 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/profit_factor.py
--rw-r--r--   0        0        0     1399 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/returns_avg.py
--rw-r--r--   0        0        0     1414 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/returns_avg_loss.py
--rw-r--r--   0        0        0     1413 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/returns_avg_win.py
--rw-r--r--   0        0        0     1716 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/returns_volatility.py
--rw-r--r--   0        0        0     1323 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/risk_return_ratio.py
--rw-r--r--   0        0        0     1776 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/sharpe_ratio.py
--rw-r--r--   0        0        0     1883 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/sortino_ratio.py
--rw-r--r--   0        0        0     1498 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/win_rate.py
--rw-r--r--   0        0        0     1489 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/winner_avg.py
--rw-r--r--   0        0        0     1347 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/winner_max.py
--rw-r--r--   0        0        0     1494 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/winner_min.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/__init__.pxd
--rw-r--r--   0        0        0      946 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/__init__.py
--rw-r--r--   0        0        0     1820 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/__main__.py
--rw-r--r--   0        0        0     3840 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/auction.py
--rw-r--r--   0        0        0     9265 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/config.py
--rw-r--r--   0        0        0     1100 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/data_client.pxd
--rw-r--r--   0        0        0    13942 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/data_client.pyx
--rw-r--r--   0        0        0     2162 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/engine.pxd
--rw-r--r--   0        0        0    51089 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/engine.pyx
--rw-r--r--   0        0        0     7457 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/exchange.pxd
--rw-r--r--   0        0        0    31045 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/exchange.pyx
--rw-r--r--   0        0        0     1084 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/execution_client.pxd
--rw-r--r--   0        0        0     5266 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/execution_client.pyx
--rw-r--r--   0        0        0    11886 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/matching_engine.pxd
--rw-r--r--   0        0        0    93507 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/matching_engine.pyx
--rw-r--r--   0        0        0     2075 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/models.pxd
--rw-r--r--   0        0        0     5313 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/models.pyx
--rw-r--r--   0        0        0     1893 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/modules.pxd
--rw-r--r--   0        0        0     8463 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/modules.pyx
--rw-r--r--   0        0        0    14549 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/node.py
--rw-r--r--   0        0        0     3072 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/backtest/results.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/cache/__init__.pxd
--rw-r--r--   0        0        0     1220 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/cache/__init__.py
--rw-r--r--   0        0        0    10536 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/cache/base.pxd
--rw-r--r--   0        0        0    25831 2024-03-22 16:42:55.514560 nautilus_trader-1.190.0/nautilus_trader/cache/base.pyx
--rw-r--r--   0        0        0     8077 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/cache/cache.pxd
--rw-r--r--   0        0        0   130122 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/cache/cache.pyx
--rw-r--r--   0        0        0     2884 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/cache/config.py
--rw-r--r--   0        0        0     1104 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/cache/database.pxd
--rw-r--r--   0        0        0    36056 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/cache/database.pyx
--rw-r--r--   0        0        0     5024 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/cache/facade.pxd
--rw-r--r--   0        0        0    11761 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/cache/facade.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/__init__.pxd
--rw-r--r--   0        0        0     1571 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/__init__.py
--rw-r--r--   0        0        0    11890 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/actor.pxd
--rw-r--r--   0        0        0    92325 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/actor.pyx
--rw-r--r--   0        0        0    11099 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/component.pxd
--rw-r--r--   0        0        0    88844 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/component.pyx
--rw-r--r--   0        0        0    16788 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/config.py
--rw-r--r--   0        0        0     1849 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/enums.py
--rw-r--r--   0        0        0    10769 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/executor.py
--rw-r--r--   0        0        0     9445 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/factories.pxd
--rw-r--r--   0        0        0    59588 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/factories.pyx
--rw-r--r--   0        0        0     1320 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/functions.py
--rw-r--r--   0        0        0     2143 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/generators.pxd
--rw-r--r--   0        0        0     7841 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/generators.pyx
--rw-r--r--   0        0        0     2723 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/messages.pxd
--rw-r--r--   0        0        0    11741 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/messages.pyx
--rw-r--r--   0        0        0    10415 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/common/providers.py
--rw-r--r--   0        0        0     5512 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/config/__init__.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/__init__.pxd
--rw-r--r--   0        0        0     1339 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/__init__.py
--rw-r--r--   0        0        0     1230 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/asynchronous.py
--rw-r--r--   0        0        0     3683 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/correctness.pxd
--rw-r--r--   0        0        0    37316 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/correctness.pyx
--rw-r--r--   0        0        0      897 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/data.pxd
--rw-r--r--   0        0        0     1954 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/data.pyx
--rw-r--r--   0        0        0     1363 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/datetime.pxd
--rw-r--r--   0        0        0     7364 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/datetime.pyx
--rw-r--r--   0        0        0     1230 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/fsm.pxd
--rw-r--r--   0        0        0     4364 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/fsm.pyx
--rw-r--r--   0        0        0     2511 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/includes/algorithms.h
--rw-r--r--   0        0        0      907 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/includes/backtest.h
--rw-r--r--   0        0        0    22292 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/includes/common.h
--rw-r--r--   0        0        0     3055 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/includes/core.h
--rw-r--r--   0        0        0    65021 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/includes/model.h
--rw-r--r--   0        0        0     2529 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/inspect.py
--rw-r--r--   0        0        0     2137 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/message.pxd
--rw-r--r--   0        0        0     6509 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/message.pyx
--rw-r--r--   0        0        0    75166 2024-03-22 16:42:55.518560 nautilus_trader-1.190.0/nautilus_trader/core/nautilus_pyo3.pyi
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/core/rust/__init__.pxd
--rw-r--r--   0        0        0     2685 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/core/rust/algorithms.pxd
--rw-r--r--   0        0        0     1050 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/core/rust/backtest.pxd
--rw-r--r--   0        0        0    21970 2024-03-22 16:48:28.772585 nautilus_trader-1.190.0/nautilus_trader/core/rust/common.pxd
--rw-r--r--   0        0        0     1222 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/core/rust/common.pyx
--rw-r--r--   0        0        0     3107 2024-03-22 16:45:47.293423 nautilus_trader-1.190.0/nautilus_trader/core/rust/core.pxd
--rw-r--r--   0        0        0    60921 2024-03-22 16:47:03.253004 nautilus_trader-1.190.0/nautilus_trader/core/rust/model.pxd
--rw-r--r--   0        0        0     2702 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/core/rust/model.pyx
--rw-r--r--   0        0        0     1359 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/core/stats.pxd
--rw-r--r--   0        0        0     5710 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/core/stats.pyx
--rw-r--r--   0        0        0     3870 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/core/string.pxd
--rw-r--r--   0        0        0     1049 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/core/uuid.pxd
--rw-r--r--   0        0        0     2755 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/core/uuid.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/data/__init__.pxd
--rw-r--r--   0        0        0     1360 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/data/__init__.py
--rw-r--r--   0        0        0     4191 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/data/aggregation.pxd
--rw-r--r--   0        0        0    24608 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/data/aggregation.pyx
--rw-r--r--   0        0        0     8072 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/data/client.pxd
--rw-r--r--   0        0        0    39982 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/data/client.pyx
--rw-r--r--   0        0        0     2142 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/data/config.py
--rw-r--r--   0        0        0    10088 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/data/engine.pxd
--rw-r--r--   0        0        0    65429 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/data/engine.pyx
--rw-r--r--   0        0        0     2391 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/data/messages.pxd
--rw-r--r--   0        0        0     8362 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/data/messages.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/__init__.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/algorithms/__init__.py
--rw-r--r--   0        0        0     4226 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/algorithms/blank.py
--rw-r--r--   0        0        0    11253 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/algorithms/twap.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/__init__.pxd
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/__init__.py
--rw-r--r--   0        0        0     5593 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/blank.py
--rw-r--r--   0        0        0    11778 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross.py
--rw-r--r--   0        0        0    12013 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross_bracket.py
--rw-r--r--   0        0        0    14637 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross_bracket_algo.py
--rw-r--r--   0        0        0    10633 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross_cython.pyx
--rw-r--r--   0        0        0    16089 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross_stop_entry.py
--rw-r--r--   0        0        0    14470 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross_trailing_stop.py
--rw-r--r--   0        0        0    12360 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross_twap.py
--rw-r--r--   0        0        0     5289 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/market_maker.py
--rw-r--r--   0        0        0     9278 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/orderbook_imbalance.py
--rw-r--r--   0        0        0     9672 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/orderbook_imbalance_rust.py
--rw-r--r--   0        0        0     2730 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/signal_strategy.py
--rw-r--r--   0        0        0     4610 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/subscribe.py
--rw-r--r--   0        0        0     7286 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/talib_strategy.py
--rw-r--r--   0        0        0    14215 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/examples/strategies/volatility_market_maker.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/execution/__init__.pxd
--rw-r--r--   0        0        0     1353 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/execution/__init__.py
--rw-r--r--   0        0        0     8509 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/execution/algorithm.pxd
--rw-r--r--   0        0        0    52865 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/execution/algorithm.pyx
--rw-r--r--   0        0        0     7359 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/execution/client.pxd
--rw-r--r--   0        0        0    29177 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/execution/client.pyx
--rw-r--r--   0        0        0     3738 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/execution/config.py
--rw-r--r--   0        0        0     4001 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/execution/emulator.pxd
--rw-r--r--   0        0        0    35617 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/execution/emulator.pyx
--rw-r--r--   0        0        0     7089 2024-03-22 16:42:55.522560 nautilus_trader-1.190.0/nautilus_trader/execution/engine.pxd
--rw-r--r--   0        0        0    46772 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/execution/engine.pyx
--rw-r--r--   0        0        0     4593 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/execution/manager.pxd
--rw-r--r--   0        0        0    24307 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/execution/manager.pyx
--rw-r--r--   0        0        0     3590 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/execution/matching_core.pxd
--rw-r--r--   0        0        0    16178 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/execution/matching_core.pyx
--rw-r--r--   0        0        0     5598 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/execution/messages.pxd
--rw-r--r--   0        0        0    34392 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/execution/messages.pyx
--rw-r--r--   0        0        0    22157 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/execution/reports.py
--rw-r--r--   0        0        0     1726 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/execution/trailing.pxd
--rw-r--r--   0        0        0    17089 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/execution/trailing.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/__init__.pxd
--rw-r--r--   0        0        0     1188 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/__init__.py
--rw-r--r--   0        0        0     1722 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/amat.pxd
--rw-r--r--   0        0        0     4832 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/amat.pyx
--rw-r--r--   0        0        0     1482 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/aroon.pxd
--rw-r--r--   0        0        0     3470 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/aroon.pyx
--rw-r--r--   0        0        0     1474 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/atr.pxd
--rw-r--r--   0        0        0     4320 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/atr.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/__init__.pxd
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/__init__.py
--rw-r--r--   0        0        0     1770 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/ama.pxd
--rw-r--r--   0        0        0     5185 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/ama.pyx
--rw-r--r--   0        0        0     1063 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/dema.pxd
--rw-r--r--   0        0        0     3840 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/dema.pyx
--rw-r--r--   0        0        0     1096 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/ema.pxd
--rw-r--r--   0        0        0     3454 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/ema.pyx
--rw-r--r--   0        0        0     1247 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/hma.pxd
--rw-r--r--   0        0        0     4323 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/hma.pyx
--rw-r--r--   0        0        0     3114 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/ma_factory.pyx
--rw-r--r--   0        0        0     1568 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/moving_average.pxd
--rw-r--r--   0        0        0     2960 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/moving_average.pyx
--rw-r--r--   0        0        0     1080 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/rma.pxd
--rw-r--r--   0        0        0     3466 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/rma.pyx
--rw-r--r--   0        0        0     1020 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/sma.pxd
--rw-r--r--   0        0        0     3530 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/sma.pyx
--rw-r--r--   0        0        0     1283 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/vidya.pxd
--rw-r--r--   0        0        0     4592 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/vidya.pyx
--rw-r--r--   0        0        0     1174 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/wma.pxd
--rw-r--r--   0        0        0     4700 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/average/wma.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/base/__init__.pxd
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/base/__init__.py
--rw-r--r--   0        0        0     1701 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/base/indicator.pxd
--rw-r--r--   0        0        0     3029 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/base/indicator.pyx
--rw-r--r--   0        0        0     1315 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/bias.pxd
--rw-r--r--   0        0        0     2868 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/bias.pyx
--rw-r--r--   0        0        0     1579 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/bollinger_bands.pxd
--rw-r--r--   0        0        0     5219 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/bollinger_bands.pyx
--rw-r--r--   0        0        0     1635 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/cci.pxd
--rw-r--r--   0        0        0     4056 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/cci.pyx
--rw-r--r--   0        0        0     1375 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/cmo.pxd
--rw-r--r--   0        0        0     3766 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/cmo.pyx
--rw-r--r--   0        0        0     1658 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/dm.pxd
--rw-r--r--   0        0        0     3732 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/dm.pyx
--rw-r--r--   0        0        0     1490 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/donchian_channel.pxd
--rw-r--r--   0        0        0     4374 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/donchian_channel.pyx
--rw-r--r--   0        0        0     1231 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/efficiency_ratio.pxd
--rw-r--r--   0        0        0     3119 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/efficiency_ratio.pyx
--rw-r--r--   0        0        0     3168 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_candlesticks.pxd
--rw-r--r--   0        0        0    12540 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_candlesticks.pyx
--rw-r--r--   0        0        0     1347 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enum.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/__init__.pxd
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/__init__.py
--rw-r--r--   0        0        0      976 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pxd
--rw-r--r--   0        0        0      980 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pyx
--rw-r--r--   0        0        0      947 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pxd
--rw-r--r--   0        0        0      987 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pyx
--rw-r--r--   0        0        0     1020 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pxd
--rw-r--r--   0        0        0      972 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pyx
--rw-r--r--   0        0        0      972 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pxd
--rw-r--r--   0        0        0      980 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pyx
--rw-r--r--   0        0        0     1805 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/keltner_channel.pxd
--rw-r--r--   0        0        0     4675 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/keltner_channel.pyx
--rw-r--r--   0        0        0     1395 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/keltner_position.pxd
--rw-r--r--   0        0        0     4280 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/keltner_position.pyx
--rw-r--r--   0        0        0     1713 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/kvo.pxd
--rw-r--r--   0        0        0     4727 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/kvo.pyx
--rw-r--r--   0        0        0     1636 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/linear_regression.pxd
--rw-r--r--   0        0        0     3839 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/linear_regression.pyx
--rw-r--r--   0        0        0     1664 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/macd.pxd
--rw-r--r--   0        0        0     4809 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/macd.pyx
--rw-r--r--   0        0        0     1232 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/obv.pxd
--rw-r--r--   0        0        0     2958 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/obv.pyx
--rw-r--r--   0        0        0     1514 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/pressure.pxd
--rw-r--r--   0        0        0     4383 2024-03-22 16:42:55.526559 nautilus_trader-1.190.0/nautilus_trader/indicators/pressure.pyx
--rw-r--r--   0        0        0     1476 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/psl.pxd
--rw-r--r--   0        0        0     3311 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/psl.pyx
--rw-r--r--   0        0        0     1227 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/roc.pxd
--rw-r--r--   0        0        0     2726 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/roc.pyx
--rw-r--r--   0        0        0     1393 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/rsi.pxd
--rw-r--r--   0        0        0     3767 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/rsi.pyx
--rw-r--r--   0        0        0     1763 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/rvi.pxd
--rw-r--r--   0        0        0     4539 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/rvi.pyx
--rw-r--r--   0        0        0     1444 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/spread_analyzer.pxd
--rw-r--r--   0        0        0     3391 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/spread_analyzer.pyx
--rw-r--r--   0        0        0     1485 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/stochastics.pxd
--rw-r--r--   0        0        0     3884 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/stochastics.pyx
--rw-r--r--   0        0        0     2271 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/swings.pxd
--rw-r--r--   0        0        0     4678 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/swings.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/ta_lib/__init__.py
--rw-r--r--   0        0        0     1993 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/ta_lib/common.py
--rw-r--r--   0        0        0    29549 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/ta_lib/manager.py
--rw-r--r--   0        0        0     1458 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/vhf.pxd
--rw-r--r--   0        0        0     3513 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/vhf.pyx
--rw-r--r--   0        0        0     1485 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/volatility_ratio.pxd
--rw-r--r--   0        0        0     4482 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/volatility_ratio.pyx
--rw-r--r--   0        0        0     1270 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/vwap.pxd
--rw-r--r--   0        0        0     2938 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/indicators/vwap.pyx
--rw-r--r--   0        0        0     1155 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/live/__init__.py
--rw-r--r--   0        0        0     1861 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/live/__main__.py
--rw-r--r--   0        0        0     8314 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/live/config.py
--rw-r--r--   0        0        0    30737 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/live/data_client.py
--rw-r--r--   0        0        0    16446 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/live/data_engine.py
--rw-r--r--   0        0        0    17542 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/live/execution_client.py
--rw-r--r--   0        0        0    41155 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/live/execution_engine.py
--rw-r--r--   0        0        0     3385 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/live/factories.py
--rw-r--r--   0        0        0    16778 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/live/node.py
--rw-r--r--   0        0        0     9545 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/live/node_builder.py
--rw-r--r--   0        0        0     9733 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/live/risk_engine.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/__init__.pxd
--rw-r--r--   0        0        0     1652 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/__init__.py
--rw-r--r--   0        0        0     3246 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/book.pxd
--rw-r--r--   0        0        0    22724 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/book.pyx
--rw-r--r--   0        0        0     5067 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/currencies.py
--rw-r--r--   0        0        0    11700 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/data.pxd
--rw-r--r--   0        0        0   119303 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/data.pyx
--rw-r--r--   0        0        0     7556 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/enums.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/events/__init__.pxd
--rw-r--r--   0        0        0     2829 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/events/__init__.py
--rw-r--r--   0        0        0     2220 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/events/account.pxd
--rw-r--r--   0        0        0     6658 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/events/account.pyx
--rw-r--r--   0        0        0    12290 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/events/order.pxd
--rw-r--r--   0        0        0   135685 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/events/order.pyx
--rw-r--r--   0        0        0     5628 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/events/position.pxd
--rw-r--r--   0        0        0    35329 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/events/position.pyx
--rw-r--r--   0        0        0     4989 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/functions.pxd
--rw-r--r--   0        0        0     9991 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/functions.pyx
--rw-r--r--   0        0        0     4039 2024-03-22 16:42:55.530559 nautilus_trader-1.190.0/nautilus_trader/model/identifiers.pxd
--rw-r--r--   0        0        0    27681 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/identifiers.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/__init__.pxd
--rw-r--r--   0        0        0     2154 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/__init__.py
--rw-r--r--   0        0        0     5465 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/base.pxd
--rw-r--r--   0        0        0    20904 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/base.pyx
--rw-r--r--   0        0        0     1778 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/betting.pxd
--rw-r--r--   0        0        0     8622 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/betting.pyx
--rw-r--r--   0        0        0     1756 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/crypto_future.pxd
--rw-r--r--   0        0        0    14139 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/crypto_future.pyx
--rw-r--r--   0        0        0     1563 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/crypto_perpetual.pxd
--rw-r--r--   0        0        0    13400 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/crypto_perpetual.pyx
--rw-r--r--   0        0        0     1334 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/currency_pair.pxd
--rw-r--r--   0        0        0    13464 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/currency_pair.pyx
--rw-r--r--   0        0        0     1284 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/equity.pxd
--rw-r--r--   0        0        0     9099 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/equity.pyx
--rw-r--r--   0        0        0     1736 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/futures_contract.pxd
--rw-r--r--   0        0        0    11356 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/futures_contract.pyx
--rw-r--r--   0        0        0     1824 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/futures_spread.pxd
--rw-r--r--   0        0        0    11963 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/futures_spread.pyx
--rw-r--r--   0        0        0     2068 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/options_contract.pxd
--rw-r--r--   0        0        0    12508 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/options_contract.pyx
--rw-r--r--   0        0        0     1930 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/options_spread.pxd
--rw-r--r--   0        0        0    12096 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/options_spread.pyx
--rw-r--r--   0        0        0     1555 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/synthetic.pxd
--rw-r--r--   0        0        0    12487 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/instruments/synthetic.pyx
--rw-r--r--   0        0        0     5877 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/objects.pxd
--rw-r--r--   0        0        0    51889 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/objects.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/__init__.pxd
--rw-r--r--   0        0        0     2094 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/__init__.py
--rw-r--r--   0        0        0     9436 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/base.pxd
--rw-r--r--   0        0        0    37751 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/base.pyx
--rw-r--r--   0        0        0     1768 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/limit.pxd
--rw-r--r--   0        0        0    21320 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/limit.pyx
--rw-r--r--   0        0        0     2173 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/limit_if_touched.pxd
--rw-r--r--   0        0        0    17520 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/limit_if_touched.pyx
--rw-r--r--   0        0        0     1842 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/list.pxd
--rw-r--r--   0        0        0     2365 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/list.pyx
--rw-r--r--   0        0        0     1270 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/market.pxd
--rw-r--r--   0        0        0    15929 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/market.pyx
--rw-r--r--   0        0        0     1610 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/market_if_touched.pxd
--rw-r--r--   0        0        0    15745 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/market_if_touched.pyx
--rw-r--r--   0        0        0     1644 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/market_to_limit.pxd
--rw-r--r--   0        0        0    14188 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/market_to_limit.pyx
--rw-r--r--   0        0        0     2163 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/stop_limit.pxd
--rw-r--r--   0        0        0    17598 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/stop_limit.pyx
--rw-r--r--   0        0        0     1600 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/stop_market.pxd
--rw-r--r--   0        0        0    15910 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/stop_market.pyx
--rw-r--r--   0        0        0     2645 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/trailing_stop_limit.pxd
--rw-r--r--   0        0        0    19471 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/trailing_stop_limit.pyx
--rw-r--r--   0        0        0     1951 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/trailing_stop_market.pxd
--rw-r--r--   0        0        0    17132 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/trailing_stop_market.pyx
--rw-r--r--   0        0        0     1141 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/unpacker.pxd
--rw-r--r--   0        0        0     3908 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/orders/unpacker.pyx
--rw-r--r--   0        0        0     6940 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/position.pxd
--rw-r--r--   0        0        0    23901 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/position.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/__init__.pxd
--rw-r--r--   0        0        0     1443 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/__init__.py
--rw-r--r--   0        0        0     1581 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/base.pxd
--rw-r--r--   0        0        0     3709 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/base.pyx
--rw-r--r--   0        0        0     1147 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/implementations/__init__.py
--rw-r--r--   0        0        0     1371 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/implementations/fixed.pxd
--rw-r--r--   0        0        0     3921 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/implementations/fixed.pyx
--rw-r--r--   0        0        0     1388 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/implementations/tiered.pxd
--rw-r--r--   0        0        0     5436 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/implementations/tiered.pyx
--rw-r--r--   0        0        0     1333 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/model/venues.py
--rw-r--r--   0        0        0      973 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/persistence/__init__.py
--rw-r--r--   0        0        0     1079 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/persistence/catalog/__init__.py
--rw-r--r--   0        0        0     6321 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/persistence/catalog/base.py
--rw-r--r--   0        0        0    26881 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/persistence/catalog/parquet.py
--rw-r--r--   0        0        0     2073 2024-03-22 16:42:55.534559 nautilus_trader-1.190.0/nautilus_trader/persistence/catalog/singleton.py
--rw-r--r--   0        0        0     1327 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/persistence/catalog/types.py
--rw-r--r--   0        0        0     2886 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/persistence/config.py
--rw-r--r--   0        0        0     3561 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/persistence/funcs.py
--rw-r--r--   0        0        0     7025 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/persistence/loaders.py
--rw-r--r--   0        0        0     3392 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/persistence/wranglers.pxd
--rw-r--r--   0        0        0    22501 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/persistence/wranglers.pyx
--rw-r--r--   0        0        0    16480 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/persistence/wranglers_v2.py
--rw-r--r--   0        0        0    12974 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/persistence/writer.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/portfolio/__init__.pxd
--rw-r--r--   0        0        0     1123 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/portfolio/__init__.py
--rw-r--r--   0        0        0     2132 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/portfolio/base.pxd
--rw-r--r--   0        0        0     4233 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/portfolio/base.pyx
--rw-r--r--   0        0        0     3111 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/portfolio/portfolio.pxd
--rw-r--r--   0        0        0    38158 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/portfolio/portfolio.pyx
--rw-r--r--   0        0        0        0 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/py.typed
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/risk/__init__.pxd
--rw-r--r--   0        0        0     1084 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/risk/__init__.py
--rw-r--r--   0        0        0     1974 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/risk/config.py
--rw-r--r--   0        0        0     5474 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/risk/engine.pxd
--rw-r--r--   0        0        0    37135 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/risk/engine.pyx
--rw-r--r--   0        0        0     1747 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/risk/sizing.pxd
--rw-r--r--   0        0        0     7059 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/risk/sizing.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/__init__.pxd
--rw-r--r--   0        0        0     1106 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/__init__.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/__init__.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/implementations/__init__.py
--rw-r--r--   0        0        0     5360 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/implementations/account_state.py
--rw-r--r--   0        0        0     1689 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/implementations/component_events.py
--rw-r--r--   0        0        0    12113 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/implementations/instruments.py
--rw-r--r--   0        0        0     2191 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/implementations/order_events.py
--rw-r--r--   0        0        0     5923 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/implementations/position_events.py
--rw-r--r--   0        0        0    15753 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/schema.py
--rw-r--r--   0        0        0    13886 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/serializer.py
--rw-r--r--   0        0        0     1096 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/base.pxd
--rw-r--r--   0        0        0    12014 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/base.pyx
--rw-r--r--   0        0        0     1303 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/serializer.pxd
--rw-r--r--   0        0        0     5404 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/serialization/serializer.pyx
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/system/__init__.py
--rw-r--r--   0        0        0     6506 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/system/config.py
--rw-r--r--   0        0        0    38884 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/system/kernel.py
--rw-r--r--   0        0        0     1034 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/__init__.py
--rw-r--r--   0        0        0     2316 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/functions.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/__init__.py
--rw-r--r--   0        0        0     6382 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/actors.py
--rw-r--r--   0        0        0     5793 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/cache_database.py
--rw-r--r--   0        0        0     1550 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/controller.py
--rw-r--r--   0        0        0     3177 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/data.py
--rw-r--r--   0        0        0     2976 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/engines.py
--rw-r--r--   0        0        0    12678 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/exec_clients.py
--rw-r--r--   0        0        0     6039 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/strategies.py
--rw-r--r--   0        0        0    29930 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/providers.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/__init__.py
--rw-r--r--   0        0        0     3697 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/accounting_pyo3.py
--rw-r--r--   0        0        0     6642 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/data_pyo3.py
--rw-r--r--   0        0        0    19920 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/events_pyo3.py
--rw-r--r--   0        0        0     3912 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/identifiers_pyo3.py
--rw-r--r--   0        0        0    15071 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/instruments_pyo3.py
--rw-r--r--   0        0        0     3900 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/orders_pyo3.py
--rw-r--r--   0        0        0     2451 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/types_pyo3.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/__init__.py
--rw-r--r--   0        0        0     4828 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/commands.py
--rw-r--r--   0        0        0     5842 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/component.py
--rw-r--r--   0        0        0     6357 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/config.py
--rw-r--r--   0        0        0    21479 2024-03-22 16:42:55.538559 nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/data.py
--rw-r--r--   0        0        0    14960 2024-03-22 16:42:55.542559 nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/events.py
--rw-r--r--   0        0        0     9471 2024-03-22 16:42:55.542559 nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/execution.py
--rw-r--r--   0        0        0     3991 2024-03-22 16:42:55.542559 nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/identifiers.py
--rw-r--r--   0        0        0     3415 2024-03-22 16:42:55.542559 nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/persistence.py
--rw-r--r--   0        0        0      869 2024-03-22 16:42:55.542559 nautilus_trader-1.190.0/nautilus_trader/trading/__init__.pxd
--rw-r--r--   0        0        0     1372 2024-03-22 16:42:55.542559 nautilus_trader-1.190.0/nautilus_trader/trading/__init__.py
--rw-r--r--   0        0        0     4741 2024-03-22 16:42:55.542559 nautilus_trader-1.190.0/nautilus_trader/trading/config.py
--rw-r--r--   0        0        0     5493 2024-03-22 16:42:55.542559 nautilus_trader-1.190.0/nautilus_trader/trading/controller.py
--rw-r--r--   0        0        0    18226 2024-03-22 16:42:55.542559 nautilus_trader-1.190.0/nautilus_trader/trading/filters.py
--rw-r--r--   0        0        0     8687 2024-03-22 16:42:55.542559 nautilus_trader-1.190.0/nautilus_trader/trading/strategy.pxd
--rw-r--r--   0        0        0    59205 2024-03-22 16:42:55.542559 nautilus_trader-1.190.0/nautilus_trader/trading/strategy.pyx
--rw-r--r--   0        0        0    25186 2024-03-22 16:42:55.542559 nautilus_trader-1.190.0/nautilus_trader/trading/trader.py
--rw-r--r--   0        0        0     7708 2024-03-22 16:42:55.542559 nautilus_trader-1.190.0/pyproject.toml
--rw-r--r--   0        0        0    28064 1970-01-01 00:00:00.000000 nautilus_trader-1.190.0/PKG-INFO
+-rw-r--r--   0        0        0     7651 2024-04-20 03:38:23.378917 nautilus_trader-1.191.0/LICENSE
+-rw-r--r--   0        0        0    26012 2024-04-20 03:38:23.378917 nautilus_trader-1.191.0/README.md
+-rw-r--r--   0        0        0    12823 2024-04-20 03:38:23.378917 nautilus_trader-1.191.0/build.py
+-rw-r--r--   0        0        0      663 2024-04-20 03:38:23.390917 nautilus_trader-1.191.0/nautilus_core/.cargo/config.toml
+-rw-r--r--   0        0        0   133197 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/Cargo.lock
+-rw-r--r--   0        0        0     2447 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/Cargo.toml
+-rw-r--r--   0        0        0     7652 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/LICENSE
+-rw-r--r--   0        0        0     1248 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/README.md
+-rw-r--r--   0        0        0      967 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/accounting/Cargo.toml
+-rw-r--r--   0        0        0     9214 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/accounting/src/account/base.rs
+-rw-r--r--   0        0        0    20171 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/accounting/src/account/cash.rs
+-rw-r--r--   0        0        0    22069 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/accounting/src/account/margin.rs
+-rw-r--r--   0        0        0      957 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/accounting/src/account/mod.rs
+-rw-r--r--   0        0        0     2371 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/accounting/src/account/stubs.rs
+-rw-r--r--   0        0        0      973 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/accounting/src/lib.rs
+-rw-r--r--   0        0        0     6556 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/accounting/src/python/cash.rs
+-rw-r--r--   0        0        0     8825 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/accounting/src/python/margin.rs
+-rw-r--r--   0        0        0     1523 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/accounting/src/python/mod.rs
+-rw-r--r--   0        0        0     2609 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/accounting/src/python/transformer.rs
+-rw-r--r--   0        0        0     2542 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/accounting/src/stubs.rs
+-rw-r--r--   0        0        0     1659 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/Cargo.toml
+-rw-r--r--   0        0        0     1179 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/bin/sandbox.rs
+-rw-r--r--   0        0        0     2250 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/common.rs
+-rw-r--r--   0        0        0    44305 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/decode.rs
+-rw-r--r--   0        0        0     3482 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/enums.rs
+-rw-r--r--   0        0        0    15992 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/live.rs
+-rw-r--r--   0        0        0    11642 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/loader.rs
+-rw-r--r--   0        0        0     1039 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/mod.rs
+-rw-r--r--   0        0        0    10104 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/publishers.json
+-rw-r--r--   0        0        0     5323 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/python/enums.rs
+-rw-r--r--   0        0        0    19526 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/python/historical.rs
+-rw-r--r--   0        0        0     8171 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/python/live.rs
+-rw-r--r--   0        0        0    13431 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/python/loader.rs
+-rw-r--r--   0        0        0     1668 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/python/mod.rs
+-rw-r--r--   0        0        0     7715 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/python/types.rs
+-rw-r--r--   0        0        0     6477 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/symbology.rs
+-rw-r--r--   0        0        0       81 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.cbbo.dbn.zst
+-rw-r--r--   0        0        0      693 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.definition.dbn.zst
+-rw-r--r--   0        0        0      673 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.definition.v1.dbn.zst
+-rw-r--r--   0        0        0      661 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.imbalance.dbn.zst
+-rw-r--r--   0        0        0      465 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.mbo.dbn
+-rw-r--r--   0        0        0      174 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.mbo.dbn.zst
+-rw-r--r--   0        0        0      192 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.mbp-1.dbn.zst
+-rw-r--r--   0        0        0      374 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.mbp-10.dbn.zst
+-rw-r--r--   0        0        0      103 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.ohlcv-1d.dbn.zst
+-rw-r--r--   0        0        0      186 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.ohlcv-1h.dbn.zst
+-rw-r--r--   0        0        0      165 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.ohlcv-1m.dbn.zst
+-rw-r--r--   0        0        0      157 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.ohlcv-1s.dbn.zst
+-rw-r--r--   0        0        0      139 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.statistics.dbn.zst
+-rw-r--r--   0        0        0      197 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.tbbo.dbn.zst
+-rw-r--r--   0        0        0      173 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/test_data/test_data.trades.dbn.zst
+-rw-r--r--   0        0        0     6857 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/types.rs
+-rw-r--r--   0        0        0      933 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/adapters/src/lib.rs
+-rw-r--r--   0        0        0     1234 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/backtest/Cargo.toml
+-rw-r--r--   0        0        0     2046 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/backtest/build.rs
+-rw-r--r--   0        0        0      484 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/backtest/cbindgen.toml
+-rw-r--r--   0        0        0      807 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/backtest/cbindgen_cython.toml
+-rw-r--r--   0        0        0     6146 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/backtest/src/engine.rs
+-rw-r--r--   0        0        0      925 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/backtest/src/lib.rs
+-rw-r--r--   0        0        0     8685 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/backtest/src/matching_engine.rs
+-rw-r--r--   0        0        0       65 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/clippy.toml
+-rw-r--r--   0        0        0     1611 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/common/Cargo.toml
+-rw-r--r--   0        0        0     2735 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/common/build.rs
+-rw-r--r--   0        0        0      548 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/common/cbindgen.toml
+-rw-r--r--   0        0        0      823 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/common/cbindgen_cython.toml
+-rw-r--r--   0        0        0     8603 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/common/src/cache/database.rs
+-rw-r--r--   0        0        0    39164 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/common/src/cache/mod.rs
+-rw-r--r--   0        0        0    11636 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/common/src/clock.rs
+-rw-r--r--   0        0        0     9289 2024-04-20 03:38:23.394917 nautilus_trader-1.191.0/nautilus_core/common/src/enums.rs
+-rw-r--r--   0        0        0     7937 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/factories.rs
+-rw-r--r--   0        0        0    11937 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/ffi/clock.rs
+-rw-r--r--   0        0        0     3086 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/ffi/enums.rs
+-rw-r--r--   0        0        0     5864 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/ffi/logging.rs
+-rw-r--r--   0        0        0      946 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/ffi/mod.rs
+-rw-r--r--   0        0        0     1771 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/ffi/timer.rs
+-rw-r--r--   0        0        0     5028 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/generators/client_order_id.rs
+-rw-r--r--   0        0        0     1298 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/generators/mod.rs
+-rw-r--r--   0        0        0     4982 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/generators/order_list_id.rs
+-rw-r--r--   0        0        0     5582 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/generators/position_id.rs
+-rw-r--r--   0        0        0     3373 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/handlers.rs
+-rw-r--r--   0        0        0     2951 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/interface/account.rs
+-rw-r--r--   0        0        0      901 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/interface/mod.rs
+-rw-r--r--   0        0        0     1226 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/lib.rs
+-rw-r--r--   0        0        0     7651 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/logging/headers.rs
+-rw-r--r--   0        0        0    23850 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/logging/logger.rs
+-rw-r--r--   0        0        0     5319 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/logging/mod.rs
+-rw-r--r--   0        0        0     7680 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/logging/writer.rs
+-rw-r--r--   0        0        0     1664 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/msgbus/database.rs
+-rw-r--r--   0        0        0    20905 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/msgbus/mod.rs
+-rw-r--r--   0        0        0     6121 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/python/clock.rs
+-rw-r--r--   0        0        0     4513 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/python/enums.rs
+-rw-r--r--   0        0        0     4896 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/python/logging.rs
+-rw-r--r--   0        0        0     1965 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/python/mod.rs
+-rw-r--r--   0        0        0     3479 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/python/timer.rs
+-rw-r--r--   0        0        0     2848 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/python/versioning.rs
+-rw-r--r--   0        0        0     1651 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/runtime.rs
+-rw-r--r--   0        0        0     1302 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/stubs.rs
+-rw-r--r--   0        0        0     2453 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/testing.rs
+-rw-r--r--   0        0        0    16151 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/timer.rs
+-rw-r--r--   0        0        0     5985 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/common/src/xrate.rs
+-rw-r--r--   0        0        0      809 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/Cargo.toml
+-rw-r--r--   0        0        0     2731 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/build.rs
+-rw-r--r--   0        0        0      717 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/cbindgen.toml
+-rw-r--r--   0        0        0      824 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/cbindgen_cython.toml
+-rw-r--r--   0        0        0    18381 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/correctness.rs
+-rw-r--r--   0        0        0     8946 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/datetime.rs
+-rw-r--r--   0        0        0     5695 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/ffi/cvec.rs
+-rw-r--r--   0        0        0     1248 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/ffi/datetime.rs
+-rw-r--r--   0        0        0      963 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/ffi/mod.rs
+-rw-r--r--   0        0        0     8229 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/ffi/parsing.rs
+-rw-r--r--   0        0        0     6642 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/ffi/string.rs
+-rw-r--r--   0        0        0     3986 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/ffi/uuid.rs
+-rw-r--r--   0        0        0     1104 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/lib.rs
+-rw-r--r--   0        0        0     1374 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/message.rs
+-rw-r--r--   0        0        0     8328 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/nanos.rs
+-rw-r--r--   0        0        0     3385 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/parsing.rs
+-rw-r--r--   0        0        0     1067 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/python/casing.rs
+-rw-r--r--   0        0        0     2691 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/python/datetime.rs
+-rw-r--r--   0        0        0     2860 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/python/mod.rs
+-rw-r--r--   0        0        0     1407 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/python/serialization.rs
+-rw-r--r--   0        0        0     3123 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/python/uuid.rs
+-rw-r--r--   0        0        0     1772 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/serialization.rs
+-rw-r--r--   0        0        0     8766 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/time.rs
+-rw-r--r--   0        0        0     5409 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/core/src/uuid.rs
+-rw-r--r--   0        0        0     1371 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/execution/Cargo.toml
+-rw-r--r--   0        0        0     6756 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/execution/src/client.rs
+-rw-r--r--   0        0        0     8245 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/execution/src/engine.rs
+-rw-r--r--   0        0        0      957 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/execution/src/lib.rs
+-rw-r--r--   0        0        0    18728 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/execution/src/matching_core.rs
+-rw-r--r--   0        0        0     2761 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/execution/src/messages/cancel.rs
+-rw-r--r--   0        0        0     2581 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/execution/src/messages/cancel_all.rs
+-rw-r--r--   0        0        0     2561 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/execution/src/messages/cancel_batch.rs
+-rw-r--r--   0        0        0     2744 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/execution/src/messages/mod.rs
+-rw-r--r--   0        0        0     3416 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/execution/src/messages/modify.rs
+-rw-r--r--   0        0        0     2757 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/execution/src/messages/query.rs
+-rw-r--r--   0        0        0     3171 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/execution/src/messages/submit.rs
+-rw-r--r--   0        0        0     3214 2024-04-20 03:38:23.398917 nautilus_trader-1.191.0/nautilus_core/execution/src/messages/submit_list.rs
+-rw-r--r--   0        0        0      746 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/Cargo.toml
+-rw-r--r--   0        0        0     8897 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/average/ama.rs
+-rw-r--r--   0        0        0     6979 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/average/dema.rs
+-rw-r--r--   0        0        0     6902 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/average/ema.rs
+-rw-r--r--   0        0        0     8322 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/average/hma.rs
+-rw-r--r--   0        0        0     2838 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/average/mod.rs
+-rw-r--r--   0        0        0     6925 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/average/rma.rs
+-rw-r--r--   0        0        0     6142 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/average/sma.rs
+-rw-r--r--   0        0        0     7476 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/average/vidya.rs
+-rw-r--r--   0        0        0     7727 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/average/wma.rs
+-rw-r--r--   0        0        0     6332 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/book/imbalance.rs
+-rw-r--r--   0        0        0      903 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/book/mod.rs
+-rw-r--r--   0        0        0     3165 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/indicator.rs
+-rw-r--r--   0        0        0     1073 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/lib.rs
+-rw-r--r--   0        0        0     7660 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/momentum/aroon.rs
+-rw-r--r--   0        0        0     5019 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/momentum/bias.rs
+-rw-r--r--   0        0        0     7008 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/momentum/cmo.rs
+-rw-r--r--   0        0        0      939 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/momentum/mod.rs
+-rw-r--r--   0        0        0     7876 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/momentum/rsi.rs
+-rw-r--r--   0        0        0     2922 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/ama.rs
+-rw-r--r--   0        0        0     2799 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/dema.rs
+-rw-r--r--   0        0        0     2880 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/ema.rs
+-rw-r--r--   0        0        0     2759 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/hma.rs
+-rw-r--r--   0        0        0      976 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/mod.rs
+-rw-r--r--   0        0        0     2865 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/rma.rs
+-rw-r--r--   0        0        0     2765 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/sma.rs
+-rw-r--r--   0        0        0     3101 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/vidya.rs
+-rw-r--r--   0        0        0     2755 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/wma.rs
+-rw-r--r--   0        0        0     2221 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/book/imbalance.rs
+-rw-r--r--   0        0        0      903 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/book/mod.rs
+-rw-r--r--   0        0        0     2183 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/mod.rs
+-rw-r--r--   0        0        0     2901 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/momentum/aroon.rs
+-rw-r--r--   0        0        0     2682 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/momentum/bias.rs
+-rw-r--r--   0        0        0     2748 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/momentum/cmo.rs
+-rw-r--r--   0        0        0      939 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/momentum/mod.rs
+-rw-r--r--   0        0        0     2583 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/momentum/rsi.rs
+-rw-r--r--   0        0        0     2005 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/ratio/efficiency_ratio.rs
+-rw-r--r--   0        0        0      910 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/ratio/mod.rs
+-rw-r--r--   0        0        0     3005 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/volatility/atr.rs
+-rw-r--r--   0        0        0      897 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/python/volatility/mod.rs
+-rw-r--r--   0        0        0     8102 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/ratio/efficiency_ratio.rs
+-rw-r--r--   0        0        0      910 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/ratio/mod.rs
+-rw-r--r--   0        0        0     5779 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/stubs.rs
+-rw-r--r--   0        0        0     1466 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/testing.rs
+-rw-r--r--   0        0        0     9258 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/volatility/atr.rs
+-rw-r--r--   0        0        0      897 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/indicators/src/volatility/mod.rs
+-rw-r--r--   0        0        0      963 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/infrastructure/Cargo.toml
+-rw-r--r--   0        0        0      969 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/infrastructure/src/lib.rs
+-rw-r--r--   0        0        0      883 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/infrastructure/src/postgres/mod.rs
+-rw-r--r--   0        0        0     1275 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/infrastructure/src/python/mod.rs
+-rw-r--r--   0        0        0     3422 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/infrastructure/src/python/redis/cache.rs
+-rw-r--r--   0        0        0      915 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/infrastructure/src/python/redis/mod.rs
+-rw-r--r--   0        0        0     1960 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/infrastructure/src/python/redis/msgbus.rs
+-rw-r--r--   0        0        0    21364 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/infrastructure/src/redis/cache.rs
+-rw-r--r--   0        0        0     9249 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/infrastructure/src/redis/mod.rs
+-rw-r--r--   0        0        0     6964 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/infrastructure/src/redis/msgbus.rs
+-rw-r--r--   0        0        0     1430 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/model/Cargo.toml
+-rw-r--r--   0        0        0      400 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/model/benches/criterion_fixed_precision_benchmark.rs
+-rw-r--r--   0        0        0      225 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/model/benches/iai_fixed_precision_benchmark.rs
+-rw-r--r--   0        0        0     2733 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/model/build.rs
+-rw-r--r--   0        0        0     1617 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/model/cbindgen.toml
+-rw-r--r--   0        0        0     1839 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/model/cbindgen_cython.toml
+-rw-r--r--   0        0        0    33823 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/model/src/currencies.rs
+-rw-r--r--   0        0        0    18149 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/model/src/data/bar.rs
+-rw-r--r--   0        0        0     9242 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/model/src/data/delta.rs
+-rw-r--r--   0        0        0    11508 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/model/src/data/deltas.rs
+-rw-r--r--   0        0        0    13207 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/model/src/data/depth.rs
+-rw-r--r--   0        0        0     3468 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/model/src/data/mod.rs
+-rw-r--r--   0        0        0     6235 2024-04-20 03:38:23.402917 nautilus_trader-1.191.0/nautilus_core/model/src/data/order.rs
+-rw-r--r--   0        0        0     8678 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/data/quote.rs
+-rw-r--r--   0        0        0     1699 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/data/stubs.rs
+-rw-r--r--   0        0        0     7377 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/data/trade.rs
+-rw-r--r--   0        0        0    30930 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/enums.rs
+-rw-r--r--   0        0        0      940 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/account/mod.rs
+-rw-r--r--   0        0        0     4918 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/account/state.rs
+-rw-r--r--   0        0        0     4078 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/account/stubs.rs
+-rw-r--r--   0        0        0      934 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/mod.rs
+-rw-r--r--   0        0        0     3621 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/accepted.rs
+-rw-r--r--   0        0        0     4009 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/cancel_rejected.rs
+-rw-r--r--   0        0        0     3358 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/canceled.rs
+-rw-r--r--   0        0        0     3196 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/denied.rs
+-rw-r--r--   0        0        0     3070 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/emulated.rs
+-rw-r--r--   0        0        0     5442 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/event.rs
+-rw-r--r--   0        0        0     3790 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/expired.rs
+-rw-r--r--   0        0        0     6635 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/filled.rs
+-rw-r--r--   0        0        0    10894 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/initialized.rs
+-rw-r--r--   0        0        0     1254 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/mod.rs
+-rw-r--r--   0        0        0     4024 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/modify_rejected.rs
+-rw-r--r--   0        0        0     3781 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/pending_cancel.rs
+-rw-r--r--   0        0        0     3799 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/pending_update.rs
+-rw-r--r--   0        0        0     3478 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/rejected.rs
+-rw-r--r--   0        0        0     3183 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/released.rs
+-rw-r--r--   0        0        0    11495 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/stubs.rs
+-rw-r--r--   0        0        0     3279 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/submitted.rs
+-rw-r--r--   0        0        0     3835 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/triggered.rs
+-rw-r--r--   0        0        0     4415 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/order/updated.rs
+-rw-r--r--   0        0        0     1987 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/position/changed.rs
+-rw-r--r--   0        0        0     2108 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/position/closed.rs
+-rw-r--r--   0        0        0     1200 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/position/mod.rs
+-rw-r--r--   0        0        0     1791 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/position/opened.rs
+-rw-r--r--   0        0        0     1985 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/events/position/state.rs
+-rw-r--r--   0        0        0     6050 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/bar.rs
+-rw-r--r--   0        0        0     1845 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/delta.rs
+-rw-r--r--   0        0        0     3549 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/deltas.rs
+-rw-r--r--   0        0        0     3787 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/depth.rs
+-rw-r--r--   0        0        0      988 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/mod.rs
+-rw-r--r--   0        0        0     2417 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/order.rs
+-rw-r--r--   0        0        0     2745 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/quote.rs
+-rw-r--r--   0        0        0     2203 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/trade.rs
+-rw-r--r--   0        0        0    15015 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/enums.rs
+-rw-r--r--   0        0        0      899 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/events/mod.rs
+-rw-r--r--   0        0        0     9627 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/events/order.rs
+-rw-r--r--   0        0        0     3279 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/account_id.rs
+-rw-r--r--   0        0        0     2234 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/client_id.rs
+-rw-r--r--   0        0        0     1398 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/client_order_id.rs
+-rw-r--r--   0        0        0     1381 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/component_id.rs
+-rw-r--r--   0        0        0     1412 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/exec_algorithm_id.rs
+-rw-r--r--   0        0        0     4223 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/instrument_id.rs
+-rw-r--r--   0        0        0     1177 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/mod.rs
+-rw-r--r--   0        0        0     1384 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/order_list_id.rs
+-rw-r--r--   0        0        0     1374 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/position_id.rs
+-rw-r--r--   0        0        0     1374 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/strategy_id.rs
+-rw-r--r--   0        0        0     1343 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/symbol.rs
+-rw-r--r--   0        0        0     1603 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/trade_id.rs
+-rw-r--r--   0        0        0     1360 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/trader_id.rs
+-rw-r--r--   0        0        0     2003 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/venue.rs
+-rw-r--r--   0        0        0     1391 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/venue_order_id.rs
+-rw-r--r--   0        0        0      903 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/instruments/mod.rs
+-rw-r--r--   0        0        0     5668 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/instruments/synthetic.rs
+-rw-r--r--   0        0        0     1005 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/mod.rs
+-rw-r--r--   0        0        0     8567 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/orderbook/book.rs
+-rw-r--r--   0        0        0     3621 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/orderbook/level.rs
+-rw-r--r--   0        0        0      913 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/orderbook/mod.rs
+-rw-r--r--   0        0        0     5719 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/types/currency.rs
+-rw-r--r--   0        0        0      950 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/types/mod.rs
+-rw-r--r--   0        0        0     1596 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/types/money.rs
+-rw-r--r--   0        0        0     1589 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/types/price.rs
+-rw-r--r--   0        0        0     1845 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/ffi/types/quantity.rs
+-rw-r--r--   0        0        0     3840 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/account_id.rs
+-rw-r--r--   0        0        0     2985 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/client_id.rs
+-rw-r--r--   0        0        0     4918 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/client_order_id.rs
+-rw-r--r--   0        0        0     2897 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/component_id.rs
+-rw-r--r--   0        0        0     2899 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/exec_algorithm_id.rs
+-rw-r--r--   0        0        0     4866 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/instrument_id.rs
+-rw-r--r--   0        0        0     1909 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/macros.rs
+-rw-r--r--   0        0        0     2976 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/mod.rs
+-rw-r--r--   0        0        0     2899 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/order_list_id.rs
+-rw-r--r--   0        0        0     3017 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/position_id.rs
+-rw-r--r--   0        0        0     4512 2024-04-20 03:38:23.406917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/strategy_id.rs
+-rw-r--r--   0        0        0     3573 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/stubs.rs
+-rw-r--r--   0        0        0     3194 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/symbol.rs
+-rw-r--r--   0        0        0     4320 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/trade_id.rs
+-rw-r--r--   0        0        0     3742 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/trader_id.rs
+-rw-r--r--   0        0        0     3740 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/venue.rs
+-rw-r--r--   0        0        0     3048 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/venue_order_id.rs
+-rw-r--r--   0        0        0     6988 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/instruments/crypto_future.rs
+-rw-r--r--   0        0        0     7104 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/instruments/crypto_perpetual.rs
+-rw-r--r--   0        0        0     6851 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/instruments/currency_pair.rs
+-rw-r--r--   0        0        0     6000 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/instruments/equity.rs
+-rw-r--r--   0        0        0     6637 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/instruments/futures_contract.rs
+-rw-r--r--   0        0        0     6761 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/instruments/futures_spread.rs
+-rw-r--r--   0        0        0    14814 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/instruments/mod.rs
+-rw-r--r--   0        0        0     6862 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/instruments/options_contract.rs
+-rw-r--r--   0        0        0     6752 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/instruments/options_spread.rs
+-rw-r--r--   0        0        0    12544 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/instruments/stubs.rs
+-rw-r--r--   0        0        0     7503 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/instruments/synthetic.rs
+-rw-r--r--   0        0        0     1235 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/lib.rs
+-rw-r--r--   0        0        0     1567 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/macros.rs
+-rw-r--r--   0        0        0     3536 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orderbook/aggregation.rs
+-rw-r--r--   0        0        0     4309 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orderbook/analysis.rs
+-rw-r--r--   0        0        0    23068 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orderbook/book.rs
+-rw-r--r--   0        0        0     2836 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orderbook/display.rs
+-rw-r--r--   0        0        0     1988 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orderbook/error.rs
+-rw-r--r--   0        0        0    22495 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orderbook/ladder.rs
+-rw-r--r--   0        0        0    13057 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orderbook/level.rs
+-rw-r--r--   0        0        0     1000 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orderbook/mod.rs
+-rw-r--r--   0        0        0    47045 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/base.rs
+-rw-r--r--   0        0        0     9307 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/default.rs
+-rw-r--r--   0        0        0    14240 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/limit.rs
+-rw-r--r--   0        0        0    11181 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/limit_if_touched.rs
+-rw-r--r--   0        0        0     1548 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/list.rs
+-rw-r--r--   0        0        0    11895 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/market.rs
+-rw-r--r--   0        0        0    10798 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/market_if_touched.rs
+-rw-r--r--   0        0        0     9990 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/market_to_limit.rs
+-rw-r--r--   0        0        0     1202 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/mod.rs
+-rw-r--r--   0        0        0    12206 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/stop_limit.rs
+-rw-r--r--   0        0        0    10772 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/stop_market.rs
+-rw-r--r--   0        0        0     7153 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/stubs.rs
+-rw-r--r--   0        0        0    11826 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/trailing_stop_limit.rs
+-rw-r--r--   0        0        0    11272 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/orders/trailing_stop_market.rs
+-rw-r--r--   0        0        0     2139 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/polymorphism.rs
+-rw-r--r--   0        0        0    71396 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/position.rs
+-rw-r--r--   0        0        0     6518 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/common.rs
+-rw-r--r--   0        0        0    12360 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/data/bar.rs
+-rw-r--r--   0        0        0    10587 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/data/delta.rs
+-rw-r--r--   0        0        0     4435 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/data/deltas.rs
+-rw-r--r--   0        0        0     8920 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/data/depth.rs
+-rw-r--r--   0        0        0     3371 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/data/mod.rs
+-rw-r--r--   0        0        0     5615 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/data/order.rs
+-rw-r--r--   0        0        0    14420 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/data/quote.rs
+-rw-r--r--   0        0        0    12601 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/data/trade.rs
+-rw-r--r--   0        0        0    44445 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/enums.rs
+-rw-r--r--   0        0        0      899 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/account/mod.rs
+-rw-r--r--   0        0        0     7391 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/account/state.rs
+-rw-r--r--   0        0        0      916 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/mod.rs
+-rw-r--r--   0        0        0     4385 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/accepted.rs
+-rw-r--r--   0        0        0     5266 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/cancel_rejected.rs
+-rw-r--r--   0        0        0     4965 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/canceled.rs
+-rw-r--r--   0        0        0     3931 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/denied.rs
+-rw-r--r--   0        0        0     3609 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/emulated.rs
+-rw-r--r--   0        0        0     4959 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/expired.rs
+-rw-r--r--   0        0        0    10277 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/filled.rs
+-rw-r--r--   0        0        0    13326 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/initialized.rs
+-rw-r--r--   0        0        0     6403 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/mod.rs
+-rw-r--r--   0        0        0     5246 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/modify_rejected.rs
+-rw-r--r--   0        0        0     4720 2024-04-20 03:38:23.410917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/pending_cancel.rs
+-rw-r--r--   0        0        0     4720 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/pending_update.rs
+-rw-r--r--   0        0        0     4376 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/rejected.rs
+-rw-r--r--   0        0        0     3938 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/released.rs
+-rw-r--r--   0        0        0     3995 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/submitted.rs
+-rw-r--r--   0        0        0     4946 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/triggered.rs
+-rw-r--r--   0        0        0     6083 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/updated.rs
+-rw-r--r--   0        0        0     3628 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/identifiers/instrument_id.rs
+-rw-r--r--   0        0        0     1942 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/identifiers/mod.rs
+-rw-r--r--   0        0        0     3411 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/identifiers/trade_id.rs
+-rw-r--r--   0        0        0     9611 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/crypto_future.rs
+-rw-r--r--   0        0        0     9095 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/crypto_perpetual.rs
+-rw-r--r--   0        0        0     8641 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/currency_pair.rs
+-rw-r--r--   0        0        0     7070 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/equity.rs
+-rw-r--r--   0        0        0     8592 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/futures_contract.rs
+-rw-r--r--   0        0        0     8854 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/futures_spread.rs
+-rw-r--r--   0        0        0     3810 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/mod.rs
+-rw-r--r--   0        0        0     9107 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/options_contract.rs
+-rw-r--r--   0        0        0     8852 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/options_spread.rs
+-rw-r--r--   0        0        0     3305 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/macros.rs
+-rw-r--r--   0        0        0     7317 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/mod.rs
+-rw-r--r--   0        0        0     6786 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/orderbook/book.rs
+-rw-r--r--   0        0        0     2104 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/orderbook/level.rs
+-rw-r--r--   0        0        0      913 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/orderbook/mod.rs
+-rw-r--r--   0        0        0    21337 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/orders/limit.rs
+-rw-r--r--   0        0        0     3478 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/orders/limit_if_touched.rs
+-rw-r--r--   0        0        0    17555 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/orders/market.rs
+-rw-r--r--   0        0        0     3392 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/orders/market_if_touched.rs
+-rw-r--r--   0        0        0     3120 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/orders/market_to_limit.rs
+-rw-r--r--   0        0        0     1093 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/orders/mod.rs
+-rw-r--r--   0        0        0    21258 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/orders/stop_limit.rs
+-rw-r--r--   0        0        0     3376 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/orders/stop_market.rs
+-rw-r--r--   0        0        0     3707 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/orders/trailing_stop_limit.rs
+-rw-r--r--   0        0        0     3566 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/orders/trailing_stop_market.rs
+-rw-r--r--   0        0        0    12742 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/position.rs
+-rw-r--r--   0        0        0     6913 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/types/balance.rs
+-rw-r--r--   0        0        0     5123 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/types/currency.rs
+-rw-r--r--   0        0        0      967 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/types/mod.rs
+-rw-r--r--   0        0        0    14400 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/types/money.rs
+-rw-r--r--   0        0        0    14717 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/types/price.rs
+-rw-r--r--   0        0        0    14627 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/python/types/quantity.rs
+-rw-r--r--   0        0        0     5373 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/stubs.rs
+-rw-r--r--   0        0        0     4765 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/types/balance.rs
+-rw-r--r--   0        0        0     6542 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/types/currency.rs
+-rw-r--r--   0        0        0     6622 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/types/fixed.rs
+-rw-r--r--   0        0        0     1023 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/types/mod.rs
+-rw-r--r--   0        0        0    11402 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/types/money.rs
+-rw-r--r--   0        0        0    14086 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/types/price.rs
+-rw-r--r--   0        0        0    14263 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/types/quantity.rs
+-rw-r--r--   0        0        0     1475 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/types/stubs.rs
+-rw-r--r--   0        0        0     3033 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/model/src/venues.rs
+-rw-r--r--   0        0        0     1036 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/Cargo.toml
+-rw-r--r--   0        0        0     1655 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/benches/test_client.rs
+-rw-r--r--   0        0        0     1374 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/benches/test_server.rs
+-rw-r--r--   0        0        0    12398 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/src/http.rs
+-rw-r--r--   0        0        0     1102 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/src/lib.rs
+-rw-r--r--   0        0        0     1441 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/src/python/mod.rs
+-rw-r--r--   0        0        0     6239 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/src/ratelimiter/clock.rs
+-rw-r--r--   0        0        0     5417 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/src/ratelimiter/gcra.rs
+-rw-r--r--   0        0        0     8865 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/src/ratelimiter/mod.rs
+-rw-r--r--   0        0        0     4079 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/src/ratelimiter/nanos.rs
+-rw-r--r--   0        0        0     9739 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/src/ratelimiter/quota.rs
+-rw-r--r--   0        0        0    23510 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/src/socket.rs
+-rw-r--r--   0        0        0    28849 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/src/websocket.rs
+-rw-r--r--   0        0        0       18 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/.gitignore
+-rw-r--r--   0        0        0     2862 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/CHANGELOG.md
+-rw-r--r--   0        0        0     2061 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/Cargo.toml
+-rw-r--r--   0        0        0     1093 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/LICENSE
+-rw-r--r--   0        0        0     2861 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/README.md
+-rw-r--r--   0        0        0      268 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/rustfmt.toml
+-rw-r--r--   0        0        0     6900 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/src/compat.rs
+-rw-r--r--   0        0        0     2747 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/src/connect.rs
+-rw-r--r--   0        0        0     5469 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/src/handshake.rs
+-rw-r--r--   0        0        0    14303 2024-04-20 03:38:23.414917 nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/src/lib.rs
+-rw-r--r--   0        0        0     2854 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/src/stream.rs
+-rw-r--r--   0        0        0     8755 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/src/tls.rs
+-rw-r--r--   0        0        0     1368 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/Cargo.toml
+-rw-r--r--   0        0        0     3658 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/benches/bench_persistence.rs
+-rw-r--r--   0        0        0    12962 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/arrow/bar.rs
+-rw-r--r--   0        0        0    15825 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/arrow/delta.rs
+-rw-r--r--   0        0        0    41495 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/arrow/depth.rs
+-rw-r--r--   0        0        0     4605 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/arrow/mod.rs
+-rw-r--r--   0        0        0    12628 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/arrow/quote.rs
+-rw-r--r--   0        0        0    12946 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/arrow/trade.rs
+-rw-r--r--   0        0        0    10542 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/backend/kmerge_batch.rs
+-rw-r--r--   0        0        0      923 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/backend/mod.rs
+-rw-r--r--   0        0        0     8048 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/backend/session.rs
+-rw-r--r--   0        0        0     7561 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/db/database.rs
+-rw-r--r--   0        0        0      931 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/db/mod.rs
+-rw-r--r--   0        0        0      980 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/db/schema.rs
+-rw-r--r--   0        0        0     3458 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/db/sql.rs
+-rw-r--r--   0        0        0      972 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/lib.rs
+-rw-r--r--   0        0        0      922 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/python/backend/mod.rs
+-rw-r--r--   0        0        0     4269 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/python/backend/session.rs
+-rw-r--r--   0        0        0    12804 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/python/backend/transformer.rs
+-rw-r--r--   0        0        0     1662 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/python/mod.rs
+-rw-r--r--   0        0        0     2824 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/python/wranglers/bar.rs
+-rw-r--r--   0        0        0     3031 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/python/wranglers/delta.rs
+-rw-r--r--   0        0        0      942 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/python/wranglers/mod.rs
+-rw-r--r--   0        0        0     2955 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/python/wranglers/quote.rs
+-rw-r--r--   0        0        0     2952 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/src/python/wranglers/trade.rs
+-rw-r--r--   0        0        0    10633 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/tests/test_catalog.rs
+-rw-r--r--   0        0        0     2159 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/persistence/tests/test_util.rs
+-rw-r--r--   0        0        0     1469 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/pyo3/Cargo.toml
+-rw-r--r--   0        0        0     4205 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/pyo3/src/lib.rs
+-rw-r--r--   0        0        0       50 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/rust-toolchain.toml
+-rw-r--r--   0        0        0      225 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_core/rustfmt.toml
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/__init__.pxd
+-rw-r--r--   0        0        0     2270 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/__init__.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/__init__.pxd
+-rw-r--r--   0        0        0     1414 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/__init__.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/__init__.pxd
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/__init__.py
+-rw-r--r--   0        0        0     4195 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/base.pxd
+-rw-r--r--   0        0        0    14679 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/base.pyx
+-rw-r--r--   0        0        0     1740 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/betting.pxd
+-rw-r--r--   0        0        0     4117 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/betting.pyx
+-rw-r--r--   0        0        0     2013 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/cash.pxd
+-rw-r--r--   0        0        0    13214 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/cash.pyx
+-rw-r--r--   0        0        0     3309 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/margin.pxd
+-rw-r--r--   0        0        0    22719 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/margin.pyx
+-rw-r--r--   0        0        0     1489 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/calculators.pxd
+-rw-r--r--   0        0        0    10740 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/calculators.pyx
+-rw-r--r--   0        0        0     2111 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/error.py
+-rw-r--r--   0        0        0     1089 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/factory.pxd
+-rw-r--r--   0        0        0     4065 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/factory.pyx
+-rw-r--r--   0        0        0     2653 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/manager.pxd
+-rw-r--r--   0        0        0    22638 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/accounting/manager.pyx
+-rw-r--r--   0        0        0     1153 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/adapters/__init__.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/adapters/_template/__init__.py
+-rw-r--r--   0        0        0     1013 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/adapters/_template/core.py
+-rw-r--r--   0        0        0    14665 2024-04-20 03:38:23.418917 nautilus_trader-1.191.0/nautilus_trader/adapters/_template/data.py
+-rw-r--r--   0        0        0     7371 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/_template/execution.py
+-rw-r--r--   0        0        0     2601 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/_template/providers.py
+-rw-r--r--   0        0        0      945 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/__init__.py
+-rw-r--r--   0        0        0    12517 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/client.py
+-rw-r--r--   0        0        0     3924 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/common.py
+-rw-r--r--   0        0        0     2529 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/config.py
+-rw-r--r--   0        0        0     2038 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/constants.py
+-rw-r--r--   0        0        0    12440 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/data.py
+-rw-r--r--   0        0        0    10941 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/data_types.py
+-rw-r--r--   0        0        0    41642 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/execution.py
+-rw-r--r--   0        0        0     7519 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/factories.py
+-rw-r--r--   0        0        0     1257 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/orderbook.pxd
+-rw-r--r--   0        0        0     1770 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/orderbook.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/parsing/__init__.py
+-rw-r--r--   0        0        0     3234 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/parsing/common.py
+-rw-r--r--   0        0        0     4607 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/parsing/core.py
+-rw-r--r--   0        0        0    19955 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/parsing/requests.py
+-rw-r--r--   0        0        0    19805 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/parsing/streaming.py
+-rw-r--r--   0        0        0    12917 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/providers.py
+-rw-r--r--   0        0        0     9450 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/sockets.py
+-rw-r--r--   0        0        0      938 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/__init__.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/__init__.py
+-rw-r--r--   0        0        0      997 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/constants.py
+-rw-r--r--   0        0        0     1871 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/credentials.py
+-rw-r--r--   0        0        0    39673 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/data.py
+-rw-r--r--   0        0        0    19212 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/enums.py
+-rw-r--r--   0        0        0    41882 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/execution.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/schemas/__init__.py
+-rw-r--r--   0        0        0    10932 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/schemas/account.py
+-rw-r--r--   0        0        0    22048 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/schemas/market.py
+-rw-r--r--   0        0        0     1209 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/schemas/user.py
+-rw-r--r--   0        0        0     2570 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/symbol.py
+-rw-r--r--   0        0        0    15632 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/types.py
+-rw-r--r--   0        0        0     3476 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/urls.py
+-rw-r--r--   0        0        0     5353 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/config.py
+-rw-r--r--   0        0        0    13709 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/factories.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/__init__.py
+-rw-r--r--   0        0        0     6564 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/data.py
+-rw-r--r--   0        0        0     6637 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/enums.py
+-rw-r--r--   0        0        0    13348 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/execution.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/http/__init__.py
+-rw-r--r--   0        0        0    16026 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/http/account.py
+-rw-r--r--   0        0        0     3629 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/http/market.py
+-rw-r--r--   0        0        0     1962 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/http/user.py
+-rw-r--r--   0        0        0     4834 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/http/wallet.py
+-rw-r--r--   0        0        0    17685 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/providers.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/schemas/__init__.py
+-rw-r--r--   0        0        0     6997 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/schemas/account.py
+-rw-r--r--   0        0        0     7646 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/schemas/market.py
+-rw-r--r--   0        0        0    15368 2024-04-20 03:38:23.422917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/schemas/user.py
+-rw-r--r--   0        0        0     1281 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/schemas/wallet.py
+-rw-r--r--   0        0        0     5070 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/types.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/__init__.py
+-rw-r--r--   0        0        0    27258 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/account.py
+-rw-r--r--   0        0        0     5511 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/client.py
+-rw-r--r--   0        0        0     3295 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/endpoint.py
+-rw-r--r--   0        0        0     1588 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/error.py
+-rw-r--r--   0        0        0    32496 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/market.py
+-rw-r--r--   0        0        0     7723 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/user.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/__init__.py
+-rw-r--r--   0        0        0     5582 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/data.py
+-rw-r--r--   0        0        0     5563 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/enums.py
+-rw-r--r--   0        0        0    10055 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/execution.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/http/__init__.py
+-rw-r--r--   0        0        0    26141 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/http/account.py
+-rw-r--r--   0        0        0     6645 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/http/market.py
+-rw-r--r--   0        0        0     1968 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/http/user.py
+-rw-r--r--   0        0        0     4590 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/http/wallet.py
+-rw-r--r--   0        0        0    13691 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/providers.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/schemas/__init__.py
+-rw-r--r--   0        0        0     3270 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/schemas/account.py
+-rw-r--r--   0        0        0     6832 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/schemas/market.py
+-rw-r--r--   0        0        0    11717 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/schemas/user.py
+-rw-r--r--   0        0        0     1262 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/schemas/wallet.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/websocket/__init__.py
+-rw-r--r--   0        0        0    16321 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/binance/websocket/client.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/__init__.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/common/__init__.py
+-rw-r--r--   0        0        0     1572 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/common/constants.py
+-rw-r--r--   0        0        0     1825 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/common/credentials.py
+-rw-r--r--   0        0        0    10724 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/common/enums.py
+-rw-r--r--   0        0        0     1502 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/common/error.py
+-rw-r--r--   0        0        0     4018 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/common/parsing.py
+-rw-r--r--   0        0        0     4250 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/common/symbol.py
+-rw-r--r--   0        0        0     2623 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/common/urls.py
+-rw-r--r--   0        0        0     3425 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/config.py
+-rw-r--r--   0        0        0    28863 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/data.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/__init__.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/account/__init__.py
+-rw-r--r--   0        0        0     2369 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/account/fee_rate.py
+-rw-r--r--   0        0        0     2381 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/account/position_info.py
+-rw-r--r--   0        0        0     2293 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/account/wallet_balance.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/asset/__init__.py
+-rw-r--r--   0        0        0     2225 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/asset/coin_info.py
+-rw-r--r--   0        0        0     2594 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/endpoint.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/market/__init__.py
+-rw-r--r--   0        0        0     3608 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/market/instruments_info.py
+-rw-r--r--   0        0        0     2222 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/market/klines.py
+-rw-r--r--   0        0        0     2060 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/market/server_time.py
+-rw-r--r--   0        0        0     3322 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/market/tickers.py
+-rw-r--r--   0        0        0     2132 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/market/trades.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/__init__.py
+-rw-r--r--   0        0        0     2866 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/amend_order.py
+-rw-r--r--   0        0        0     2879 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/batch_amend_order.py
+-rw-r--r--   0        0        0     2525 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/batch_cancel_order.py
+-rw-r--r--   0        0        0     3228 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/batch_place_order.py
+-rw-r--r--   0        0        0     2433 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/cancel_all_orders.py
+-rw-r--r--   0        0        0     2439 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/cancel_order.py
+-rw-r--r--   0        0        0     2466 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/open_orders.py
+-rw-r--r--   0        0        0     2756 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/order_history.py
+-rw-r--r--   0        0        0     2987 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/place_order.py
+-rw-r--r--   0        0        0     2679 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/trade_history.py
+-rw-r--r--   0        0        0    35884 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/execution.py
+-rw-r--r--   0        0        0     9039 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/factories.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/http/__init__.py
+-rw-r--r--   0        0        0    13207 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/http/account.py
+-rw-r--r--   0        0        0     1963 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/http/asset.py
+-rw-r--r--   0        0        0     6629 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/http/client.py
+-rw-r--r--   0        0        0     1083 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/http/errors.py
+-rw-r--r--   0        0        0     7979 2024-04-20 03:38:23.426917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/http/market.py
+-rw-r--r--   0        0        0     1180 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/http/user.py
+-rw-r--r--   0        0        0    11303 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/providers.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/__init__.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/account/__init__.py
+-rw-r--r--   0        0        0     3413 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/account/balance.py
+-rw-r--r--   0        0        0     1204 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/account/fee_rate.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/asset/__init__.py
+-rw-r--r--   0        0        0     1947 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/asset/coin_info.py
+-rw-r--r--   0        0        0     2114 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/common.py
+-rw-r--r--   0        0        0    15794 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/instrument.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/market/__init__.py
+-rw-r--r--   0        0        0     2184 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/market/kline.py
+-rw-r--r--   0        0        0     4540 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/market/orderbook.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/market/risk_limit.py
+-rw-r--r--   0        0        0     1088 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/market/server_time.py
+-rw-r--r--   0        0        0     4461 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/market/ticker.py
+-rw-r--r--   0        0        0     2476 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/market/trades.py
+-rw-r--r--   0        0        0     9705 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/order.py
+-rw-r--r--   0        0        0     2665 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/position.py
+-rw-r--r--   0        0        0     4044 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/trade.py
+-rw-r--r--   0        0        0    21528 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/ws.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/websocket/__init__.py
+-rw-r--r--   0        0        0    11105 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/websocket/client.py
+-rw-r--r--   0        0        0     1689 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/databento/__init__.py
+-rw-r--r--   0        0        0     2749 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/databento/common.py
+-rw-r--r--   0        0        0     2727 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/databento/config.py
+-rw-r--r--   0        0        0     1210 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/databento/constants.py
+-rw-r--r--   0        0        0    39036 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/databento/data.py
+-rw-r--r--   0        0        0     1315 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/databento/enums.py
+-rw-r--r--   0        0        0     6043 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/databento/factories.py
+-rw-r--r--   0        0        0    10712 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/databento/loaders.py
+-rw-r--r--   0        0        0    10149 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/databento/providers.py
+-rw-r--r--   0        0        0    10104 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/databento/publishers.json
+-rw-r--r--   0        0        0     1141 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/databento/types.py
+-rw-r--r--   0        0        0     1193 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/env.py
+-rw-r--r--   0        0        0      930 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/__init__.py
+-rw-r--r--   0        0        0     1014 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/__init__.py
+-rw-r--r--   0        0        0     6415 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/account.py
+-rw-r--r--   0        0        0    24959 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/client.py
+-rw-r--r--   0        0        0    15878 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/common.py
+-rw-r--r--   0        0        0     9097 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/connection.py
+-rw-r--r--   0        0        0     7167 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/contract.py
+-rw-r--r--   0        0        0     8724 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/error.py
+-rw-r--r--   0        0        0    32023 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/market_data.py
+-rw-r--r--   0        0        0    10352 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/order.py
+-rw-r--r--   0        0        0    43317 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/wrapper.py
+-rw-r--r--   0        0        0     6868 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/common.py
+-rw-r--r--   0        0        0     8127 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/config.py
+-rw-r--r--   0        0        0    17152 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/data.py
+-rw-r--r--   0        0        0    38640 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/execution.py
+-rw-r--r--   0        0        0     9005 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/factories.py
+-rw-r--r--   0        0        0     7876 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/gateway.py
+-rw-r--r--   0        0        0     1054 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/historic/__init__.py
+-rw-r--r--   0        0        0    20988 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/historic/client.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/parsing/__init__.py
+-rw-r--r--   0        0        0     3579 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/parsing/data.py
+-rw-r--r--   0        0        0     3839 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/parsing/execution.py
+-rw-r--r--   0        0        0    18270 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/parsing/instruments.py
+-rw-r--r--   0        0        0    12263 2024-04-20 03:38:23.430917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/providers.py
+-rw-r--r--   0        0        0     4904 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/web.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/adapters/sandbox/__init__.py
+-rw-r--r--   0        0        0     1360 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/adapters/sandbox/config.py
+-rw-r--r--   0        0        0     7889 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/adapters/sandbox/execution.py
+-rw-r--r--   0        0        0     2763 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/adapters/sandbox/factory.py
+-rw-r--r--   0        0        0      937 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/adapters/tardis/__init__.py
+-rw-r--r--   0        0        0     2909 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/adapters/tardis/loaders.py
+-rw-r--r--   0        0        0      978 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/__init__.py
+-rw-r--r--   0        0        0    15183 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/analyzer.py
+-rw-r--r--   0        0        0     5714 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/reporter.py
+-rw-r--r--   0        0        0     3940 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistic.py
+-rw-r--r--   0        0        0     2255 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/__init__.py
+-rw-r--r--   0        0        0     1997 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/expectancy.py
+-rw-r--r--   0        0        0     1705 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/long_ratio.py
+-rw-r--r--   0        0        0     1468 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/loser_avg.py
+-rw-r--r--   0        0        0     1514 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/loser_max.py
+-rw-r--r--   0        0        0     1512 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/loser_min.py
+-rw-r--r--   0        0        0     1563 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/profit_factor.py
+-rw-r--r--   0        0        0     1399 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/returns_avg.py
+-rw-r--r--   0        0        0     1414 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/returns_avg_loss.py
+-rw-r--r--   0        0        0     1413 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/returns_avg_win.py
+-rw-r--r--   0        0        0     1716 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/returns_volatility.py
+-rw-r--r--   0        0        0     1323 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/risk_return_ratio.py
+-rw-r--r--   0        0        0     1776 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/sharpe_ratio.py
+-rw-r--r--   0        0        0     1883 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/sortino_ratio.py
+-rw-r--r--   0        0        0     1498 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/win_rate.py
+-rw-r--r--   0        0        0     1489 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/winner_avg.py
+-rw-r--r--   0        0        0     1347 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/winner_max.py
+-rw-r--r--   0        0        0     1494 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/winner_min.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/__init__.pxd
+-rw-r--r--   0        0        0      946 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/__init__.py
+-rw-r--r--   0        0        0     1868 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/__main__.py
+-rw-r--r--   0        0        0     3840 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/auction.py
+-rw-r--r--   0        0        0     9257 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/config.py
+-rw-r--r--   0        0        0     1100 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/data_client.pxd
+-rw-r--r--   0        0        0    13931 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/data_client.pyx
+-rw-r--r--   0        0        0     2162 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/engine.pxd
+-rw-r--r--   0        0        0    51477 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/engine.pyx
+-rw-r--r--   0        0        0     7614 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/exchange.pxd
+-rw-r--r--   0        0        0    31318 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/exchange.pyx
+-rw-r--r--   0        0        0     1084 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/execution_client.pxd
+-rw-r--r--   0        0        0     5264 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/execution_client.pyx
+-rw-r--r--   0        0        0    12040 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/matching_engine.pxd
+-rw-r--r--   0        0        0    94450 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/matching_engine.pyx
+-rw-r--r--   0        0        0     2658 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/models.pxd
+-rw-r--r--   0        0        0     8785 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/models.pyx
+-rw-r--r--   0        0        0     1893 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/modules.pxd
+-rw-r--r--   0        0        0     8463 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/modules.pyx
+-rw-r--r--   0        0        0    15294 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/node.py
+-rw-r--r--   0        0        0     3072 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/backtest/results.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/cache/__init__.pxd
+-rw-r--r--   0        0        0     1220 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/cache/__init__.py
+-rw-r--r--   0        0        0    10536 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/cache/base.pxd
+-rw-r--r--   0        0        0    25831 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/cache/base.pyx
+-rw-r--r--   0        0        0     8478 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/cache/cache.pxd
+-rw-r--r--   0        0        0   132475 2024-04-20 03:38:23.434917 nautilus_trader-1.191.0/nautilus_trader/cache/cache.pyx
+-rw-r--r--   0        0        0     2884 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/cache/config.py
+-rw-r--r--   0        0        0     1104 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/cache/database.pxd
+-rw-r--r--   0        0        0    36287 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/cache/database.pyx
+-rw-r--r--   0        0        0     5051 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/cache/facade.pxd
+-rw-r--r--   0        0        0    11952 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/cache/facade.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/__init__.pxd
+-rw-r--r--   0        0        0     1571 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/__init__.py
+-rw-r--r--   0        0        0    11890 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/actor.pxd
+-rw-r--r--   0        0        0    92279 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/actor.pyx
+-rw-r--r--   0        0        0    11128 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/component.pxd
+-rw-r--r--   0        0        0    88403 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/component.pyx
+-rw-r--r--   0        0        0    16788 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/config.py
+-rw-r--r--   0        0        0     1849 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/enums.py
+-rw-r--r--   0        0        0    10752 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/executor.py
+-rw-r--r--   0        0        0     9445 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/factories.pxd
+-rw-r--r--   0        0        0    59588 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/factories.pyx
+-rw-r--r--   0        0        0     1320 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/functions.py
+-rw-r--r--   0        0        0     2143 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/generators.pxd
+-rw-r--r--   0        0        0     7841 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/generators.pyx
+-rw-r--r--   0        0        0     2723 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/messages.pxd
+-rw-r--r--   0        0        0    11741 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/messages.pyx
+-rw-r--r--   0        0        0    10413 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/common/providers.py
+-rw-r--r--   0        0        0     5512 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/config/__init__.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/__init__.pxd
+-rw-r--r--   0        0        0     1339 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/__init__.py
+-rw-r--r--   0        0        0     1230 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/asynchronous.py
+-rw-r--r--   0        0        0     3683 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/correctness.pxd
+-rw-r--r--   0        0        0    37316 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/correctness.pyx
+-rw-r--r--   0        0        0      897 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/data.pxd
+-rw-r--r--   0        0        0     1954 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/data.pyx
+-rw-r--r--   0        0        0     1363 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/datetime.pxd
+-rw-r--r--   0        0        0     7616 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/datetime.pyx
+-rw-r--r--   0        0        0     1230 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/fsm.pxd
+-rw-r--r--   0        0        0     4364 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/fsm.pyx
+-rw-r--r--   0        0        0     2511 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/includes/algorithms.h
+-rw-r--r--   0        0        0      907 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/includes/backtest.h
+-rw-r--r--   0        0        0    15576 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/includes/common.h
+-rw-r--r--   0        0        0     3055 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/includes/core.h
+-rw-r--r--   0        0        0    65728 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/includes/model.h
+-rw-r--r--   0        0        0     2529 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/inspect.py
+-rw-r--r--   0        0        0     2137 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/message.pxd
+-rw-r--r--   0        0        0     6509 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/message.pyx
+-rw-r--r--   0        0        0    83571 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/nautilus_pyo3.pyi
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/rust/__init__.pxd
+-rw-r--r--   0        0        0     2685 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/rust/algorithms.pxd
+-rw-r--r--   0        0        0     1050 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/rust/backtest.pxd
+-rw-r--r--   0        0        0    15271 2024-04-20 03:43:32.475410 nautilus_trader-1.191.0/nautilus_trader/core/rust/common.pxd
+-rw-r--r--   0        0        0     1222 2024-04-20 03:38:23.438917 nautilus_trader-1.191.0/nautilus_trader/core/rust/common.pyx
+-rw-r--r--   0        0        0     3107 2024-04-20 03:40:55.047157 nautilus_trader-1.191.0/nautilus_trader/core/rust/core.pxd
+-rw-r--r--   0        0        0    61774 2024-04-20 03:42:06.507272 nautilus_trader-1.191.0/nautilus_trader/core/rust/model.pxd
+-rw-r--r--   0        0        0     2702 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/core/rust/model.pyx
+-rw-r--r--   0        0        0     1359 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/core/stats.pxd
+-rw-r--r--   0        0        0     5710 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/core/stats.pyx
+-rw-r--r--   0        0        0     3870 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/core/string.pxd
+-rw-r--r--   0        0        0     1049 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/core/uuid.pxd
+-rw-r--r--   0        0        0     2755 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/core/uuid.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/data/__init__.pxd
+-rw-r--r--   0        0        0     1360 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/data/__init__.py
+-rw-r--r--   0        0        0     4191 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/data/aggregation.pxd
+-rw-r--r--   0        0        0    24607 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/data/aggregation.pyx
+-rw-r--r--   0        0        0     8072 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/data/client.pxd
+-rw-r--r--   0        0        0    39952 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/data/client.pyx
+-rw-r--r--   0        0        0     2142 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/data/config.py
+-rw-r--r--   0        0        0    10088 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/data/engine.pxd
+-rw-r--r--   0        0        0    65384 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/data/engine.pyx
+-rw-r--r--   0        0        0     2391 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/data/messages.pxd
+-rw-r--r--   0        0        0     8362 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/data/messages.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/__init__.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/algorithms/__init__.py
+-rw-r--r--   0        0        0     4226 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/algorithms/blank.py
+-rw-r--r--   0        0        0    11242 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/algorithms/twap.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/__init__.pxd
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/__init__.py
+-rw-r--r--   0        0        0     5593 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/blank.py
+-rw-r--r--   0        0        0    11711 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross.py
+-rw-r--r--   0        0        0    12008 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross_bracket.py
+-rw-r--r--   0        0        0    14632 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross_bracket_algo.py
+-rw-r--r--   0        0        0    10628 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross_cython.pyx
+-rw-r--r--   0        0        0    11523 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross_long_only.py
+-rw-r--r--   0        0        0    16338 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross_stop_entry.py
+-rw-r--r--   0        0        0    14463 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross_trailing_stop.py
+-rw-r--r--   0        0        0    12357 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross_twap.py
+-rw-r--r--   0        0        0     5286 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/market_maker.py
+-rw-r--r--   0        0        0     9274 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/orderbook_imbalance.py
+-rw-r--r--   0        0        0     9682 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/orderbook_imbalance_rust.py
+-rw-r--r--   0        0        0     2730 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/signal_strategy.py
+-rw-r--r--   0        0        0     4609 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/subscribe.py
+-rw-r--r--   0        0        0     7283 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/talib_strategy.py
+-rw-r--r--   0        0        0    14240 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/examples/strategies/volatility_market_maker.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/__init__.pxd
+-rw-r--r--   0        0        0     1353 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/__init__.py
+-rw-r--r--   0        0        0     8509 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/algorithm.pxd
+-rw-r--r--   0        0        0    52822 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/algorithm.pyx
+-rw-r--r--   0        0        0     7359 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/client.pxd
+-rw-r--r--   0        0        0    29170 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/client.pyx
+-rw-r--r--   0        0        0     3738 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/config.py
+-rw-r--r--   0        0        0     4001 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/emulator.pxd
+-rw-r--r--   0        0        0    35584 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/emulator.pyx
+-rw-r--r--   0        0        0     7089 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/engine.pxd
+-rw-r--r--   0        0        0    46733 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/engine.pyx
+-rw-r--r--   0        0        0     4593 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/manager.pxd
+-rw-r--r--   0        0        0    24284 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/manager.pyx
+-rw-r--r--   0        0        0     3590 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/matching_core.pxd
+-rw-r--r--   0        0        0    16178 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/matching_core.pyx
+-rw-r--r--   0        0        0     5598 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/messages.pxd
+-rw-r--r--   0        0        0    34392 2024-04-20 03:38:23.442917 nautilus_trader-1.191.0/nautilus_trader/execution/messages.pyx
+-rw-r--r--   0        0        0    22157 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/execution/reports.py
+-rw-r--r--   0        0        0     1726 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/execution/trailing.pxd
+-rw-r--r--   0        0        0    17089 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/execution/trailing.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/__init__.pxd
+-rw-r--r--   0        0        0     1188 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/__init__.py
+-rw-r--r--   0        0        0     1722 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/amat.pxd
+-rw-r--r--   0        0        0     4832 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/amat.pyx
+-rw-r--r--   0        0        0     1482 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/aroon.pxd
+-rw-r--r--   0        0        0     3470 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/aroon.pyx
+-rw-r--r--   0        0        0     1474 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/atr.pxd
+-rw-r--r--   0        0        0     4320 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/atr.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/__init__.pxd
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/__init__.py
+-rw-r--r--   0        0        0     1770 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/ama.pxd
+-rw-r--r--   0        0        0     5185 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/ama.pyx
+-rw-r--r--   0        0        0     1063 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/dema.pxd
+-rw-r--r--   0        0        0     3840 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/dema.pyx
+-rw-r--r--   0        0        0     1096 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/ema.pxd
+-rw-r--r--   0        0        0     3454 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/ema.pyx
+-rw-r--r--   0        0        0     1247 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/hma.pxd
+-rw-r--r--   0        0        0     4323 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/hma.pyx
+-rw-r--r--   0        0        0     3114 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/ma_factory.pyx
+-rw-r--r--   0        0        0     1568 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/moving_average.pxd
+-rw-r--r--   0        0        0     2960 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/moving_average.pyx
+-rw-r--r--   0        0        0     1080 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/rma.pxd
+-rw-r--r--   0        0        0     3466 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/rma.pyx
+-rw-r--r--   0        0        0     1020 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/sma.pxd
+-rw-r--r--   0        0        0     3530 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/sma.pyx
+-rw-r--r--   0        0        0     1283 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/vidya.pxd
+-rw-r--r--   0        0        0     4592 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/vidya.pyx
+-rw-r--r--   0        0        0     1174 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/wma.pxd
+-rw-r--r--   0        0        0     4700 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/average/wma.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/base/__init__.pxd
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/base/__init__.py
+-rw-r--r--   0        0        0     1701 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/base/indicator.pxd
+-rw-r--r--   0        0        0     3029 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/base/indicator.pyx
+-rw-r--r--   0        0        0     1315 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/bias.pxd
+-rw-r--r--   0        0        0     2868 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/bias.pyx
+-rw-r--r--   0        0        0     1579 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/bollinger_bands.pxd
+-rw-r--r--   0        0        0     5219 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/bollinger_bands.pyx
+-rw-r--r--   0        0        0     1635 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/cci.pxd
+-rw-r--r--   0        0        0     4056 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/cci.pyx
+-rw-r--r--   0        0        0     1375 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/cmo.pxd
+-rw-r--r--   0        0        0     3766 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/cmo.pyx
+-rw-r--r--   0        0        0     1658 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/dm.pxd
+-rw-r--r--   0        0        0     3732 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/dm.pyx
+-rw-r--r--   0        0        0     1490 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/donchian_channel.pxd
+-rw-r--r--   0        0        0     4374 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/donchian_channel.pyx
+-rw-r--r--   0        0        0     1231 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/efficiency_ratio.pxd
+-rw-r--r--   0        0        0     3119 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/efficiency_ratio.pyx
+-rw-r--r--   0        0        0     3168 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_candlesticks.pxd
+-rw-r--r--   0        0        0    12540 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_candlesticks.pyx
+-rw-r--r--   0        0        0     1347 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enum.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/__init__.pxd
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/__init__.py
+-rw-r--r--   0        0        0      976 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pxd
+-rw-r--r--   0        0        0      980 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pyx
+-rw-r--r--   0        0        0      947 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pxd
+-rw-r--r--   0        0        0      987 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pyx
+-rw-r--r--   0        0        0     1020 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pxd
+-rw-r--r--   0        0        0      972 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pyx
+-rw-r--r--   0        0        0      972 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pxd
+-rw-r--r--   0        0        0      980 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pyx
+-rw-r--r--   0        0        0     1805 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/keltner_channel.pxd
+-rw-r--r--   0        0        0     4675 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/keltner_channel.pyx
+-rw-r--r--   0        0        0     1395 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/keltner_position.pxd
+-rw-r--r--   0        0        0     4280 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/keltner_position.pyx
+-rw-r--r--   0        0        0     1713 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/kvo.pxd
+-rw-r--r--   0        0        0     4727 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/kvo.pyx
+-rw-r--r--   0        0        0     1636 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/linear_regression.pxd
+-rw-r--r--   0        0        0     3839 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/linear_regression.pyx
+-rw-r--r--   0        0        0     1664 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/macd.pxd
+-rw-r--r--   0        0        0     4809 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/macd.pyx
+-rw-r--r--   0        0        0     1232 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/obv.pxd
+-rw-r--r--   0        0        0     2958 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/obv.pyx
+-rw-r--r--   0        0        0     1514 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/pressure.pxd
+-rw-r--r--   0        0        0     4383 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/pressure.pyx
+-rw-r--r--   0        0        0     1476 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/psl.pxd
+-rw-r--r--   0        0        0     3311 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/psl.pyx
+-rw-r--r--   0        0        0     1227 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/roc.pxd
+-rw-r--r--   0        0        0     2726 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/roc.pyx
+-rw-r--r--   0        0        0     1393 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/rsi.pxd
+-rw-r--r--   0        0        0     3767 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/rsi.pyx
+-rw-r--r--   0        0        0     1763 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/rvi.pxd
+-rw-r--r--   0        0        0     4539 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/rvi.pyx
+-rw-r--r--   0        0        0     1444 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/spread_analyzer.pxd
+-rw-r--r--   0        0        0     3391 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/spread_analyzer.pyx
+-rw-r--r--   0        0        0     1485 2024-04-20 03:38:23.446917 nautilus_trader-1.191.0/nautilus_trader/indicators/stochastics.pxd
+-rw-r--r--   0        0        0     3884 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/indicators/stochastics.pyx
+-rw-r--r--   0        0        0     2271 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/indicators/swings.pxd
+-rw-r--r--   0        0        0     4678 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/indicators/swings.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/indicators/ta_lib/__init__.py
+-rw-r--r--   0        0        0     1993 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/indicators/ta_lib/common.py
+-rw-r--r--   0        0        0    29656 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/indicators/ta_lib/manager.py
+-rw-r--r--   0        0        0     1458 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/indicators/vhf.pxd
+-rw-r--r--   0        0        0     3513 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/indicators/vhf.pyx
+-rw-r--r--   0        0        0     1485 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/indicators/volatility_ratio.pxd
+-rw-r--r--   0        0        0     4482 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/indicators/volatility_ratio.pyx
+-rw-r--r--   0        0        0     1270 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/indicators/vwap.pxd
+-rw-r--r--   0        0        0     2938 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/indicators/vwap.pyx
+-rw-r--r--   0        0        0     1155 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/live/__init__.py
+-rw-r--r--   0        0        0     1861 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/live/__main__.py
+-rw-r--r--   0        0        0     8314 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/live/config.py
+-rw-r--r--   0        0        0    34311 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/live/data_client.py
+-rw-r--r--   0        0        0    16375 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/live/data_engine.py
+-rw-r--r--   0        0        0    18927 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/live/execution_client.py
+-rw-r--r--   0        0        0    41080 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/live/execution_engine.py
+-rw-r--r--   0        0        0     3395 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/live/factories.py
+-rw-r--r--   0        0        0    16758 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/live/node.py
+-rw-r--r--   0        0        0     9537 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/live/node_builder.py
+-rw-r--r--   0        0        0     9696 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/live/risk_engine.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/__init__.pxd
+-rw-r--r--   0        0        0     1652 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/__init__.py
+-rw-r--r--   0        0        0     3380 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/book.pxd
+-rw-r--r--   0        0        0    24328 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/book.pyx
+-rw-r--r--   0        0        0     5067 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/currencies.py
+-rw-r--r--   0        0        0    12720 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/data.pxd
+-rw-r--r--   0        0        0   124810 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/data.pyx
+-rw-r--r--   0        0        0     7811 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/enums.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/events/__init__.pxd
+-rw-r--r--   0        0        0     2829 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/events/__init__.py
+-rw-r--r--   0        0        0     2220 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/events/account.pxd
+-rw-r--r--   0        0        0     6660 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/events/account.pyx
+-rw-r--r--   0        0        0    12290 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/events/order.pxd
+-rw-r--r--   0        0        0   135685 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/events/order.pyx
+-rw-r--r--   0        0        0     5628 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/events/position.pxd
+-rw-r--r--   0        0        0    35329 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/events/position.pyx
+-rw-r--r--   0        0        0     5142 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/functions.pxd
+-rw-r--r--   0        0        0    10333 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/functions.pyx
+-rw-r--r--   0        0        0     4039 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/identifiers.pxd
+-rw-r--r--   0        0        0    27544 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/identifiers.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/__init__.pxd
+-rw-r--r--   0        0        0     2154 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/__init__.py
+-rw-r--r--   0        0        0     5465 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/base.pxd
+-rw-r--r--   0        0        0    20879 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/base.pyx
+-rw-r--r--   0        0        0     1778 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/betting.pxd
+-rw-r--r--   0        0        0     8622 2024-04-20 03:38:23.450917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/betting.pyx
+-rw-r--r--   0        0        0     1756 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/crypto_future.pxd
+-rw-r--r--   0        0        0    14488 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/crypto_future.pyx
+-rw-r--r--   0        0        0     1563 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/crypto_perpetual.pxd
+-rw-r--r--   0        0        0    13396 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/crypto_perpetual.pyx
+-rw-r--r--   0        0        0     1334 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/currency_pair.pxd
+-rw-r--r--   0        0        0    13464 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/currency_pair.pyx
+-rw-r--r--   0        0        0     1284 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/equity.pxd
+-rw-r--r--   0        0        0     9201 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/equity.pyx
+-rw-r--r--   0        0        0     1736 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/futures_contract.pxd
+-rw-r--r--   0        0        0    11356 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/futures_contract.pyx
+-rw-r--r--   0        0        0     1824 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/futures_spread.pxd
+-rw-r--r--   0        0        0    11963 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/futures_spread.pyx
+-rw-r--r--   0        0        0     2068 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/options_contract.pxd
+-rw-r--r--   0        0        0    12508 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/options_contract.pyx
+-rw-r--r--   0        0        0     1930 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/options_spread.pxd
+-rw-r--r--   0        0        0    12096 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/options_spread.pyx
+-rw-r--r--   0        0        0     1555 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/synthetic.pxd
+-rw-r--r--   0        0        0    12487 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/instruments/synthetic.pyx
+-rw-r--r--   0        0        0     5877 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/objects.pxd
+-rw-r--r--   0        0        0    51879 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/objects.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/__init__.pxd
+-rw-r--r--   0        0        0     2094 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/__init__.py
+-rw-r--r--   0        0        0     9424 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/base.pxd
+-rw-r--r--   0        0        0    37739 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/base.pyx
+-rw-r--r--   0        0        0     1768 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/limit.pxd
+-rw-r--r--   0        0        0    21355 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/limit.pyx
+-rw-r--r--   0        0        0     2173 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/limit_if_touched.pxd
+-rw-r--r--   0        0        0    17555 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/limit_if_touched.pyx
+-rw-r--r--   0        0        0     1842 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/list.pxd
+-rw-r--r--   0        0        0     2365 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/list.pyx
+-rw-r--r--   0        0        0     1270 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/market.pxd
+-rw-r--r--   0        0        0    15929 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/market.pyx
+-rw-r--r--   0        0        0     1610 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/market_if_touched.pxd
+-rw-r--r--   0        0        0    15782 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/market_if_touched.pyx
+-rw-r--r--   0        0        0     1644 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/market_to_limit.pxd
+-rw-r--r--   0        0        0    14225 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/market_to_limit.pyx
+-rw-r--r--   0        0        0     2230 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/stop_limit.pxd
+-rw-r--r--   0        0        0    20595 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/stop_limit.pyx
+-rw-r--r--   0        0        0     1600 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/stop_market.pxd
+-rw-r--r--   0        0        0    15947 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/stop_market.pyx
+-rw-r--r--   0        0        0     2645 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/trailing_stop_limit.pxd
+-rw-r--r--   0        0        0    19504 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/trailing_stop_limit.pyx
+-rw-r--r--   0        0        0     1951 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/trailing_stop_market.pxd
+-rw-r--r--   0        0        0    17169 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/trailing_stop_market.pyx
+-rw-r--r--   0        0        0     1141 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/unpacker.pxd
+-rw-r--r--   0        0        0     3908 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/orders/unpacker.pyx
+-rw-r--r--   0        0        0     6940 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/position.pxd
+-rw-r--r--   0        0        0    23891 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/position.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/__init__.pxd
+-rw-r--r--   0        0        0     1443 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/__init__.py
+-rw-r--r--   0        0        0     1581 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/base.pxd
+-rw-r--r--   0        0        0     3709 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/base.pyx
+-rw-r--r--   0        0        0     1147 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/implementations/__init__.py
+-rw-r--r--   0        0        0     1371 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/implementations/fixed.pxd
+-rw-r--r--   0        0        0     3921 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/implementations/fixed.pyx
+-rw-r--r--   0        0        0     1388 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/implementations/tiered.pxd
+-rw-r--r--   0        0        0     5436 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/implementations/tiered.pyx
+-rw-r--r--   0        0        0     1333 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/model/venues.py
+-rw-r--r--   0        0        0      973 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/persistence/__init__.py
+-rw-r--r--   0        0        0     1079 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/persistence/catalog/__init__.py
+-rw-r--r--   0        0        0     6321 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/persistence/catalog/base.py
+-rw-r--r--   0        0        0    27076 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/persistence/catalog/parquet.py
+-rw-r--r--   0        0        0     2073 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/persistence/catalog/singleton.py
+-rw-r--r--   0        0        0     1327 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/persistence/catalog/types.py
+-rw-r--r--   0        0        0     2886 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/persistence/config.py
+-rw-r--r--   0        0        0     3561 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/persistence/funcs.py
+-rw-r--r--   0        0        0     7025 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/persistence/loaders.py
+-rw-r--r--   0        0        0     3392 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/persistence/wranglers.pxd
+-rw-r--r--   0        0        0    30305 2024-04-20 03:38:23.454917 nautilus_trader-1.191.0/nautilus_trader/persistence/wranglers.pyx
+-rw-r--r--   0        0        0    16480 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/persistence/wranglers_v2.py
+-rw-r--r--   0        0        0    12974 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/persistence/writer.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/portfolio/__init__.pxd
+-rw-r--r--   0        0        0     1123 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/portfolio/__init__.py
+-rw-r--r--   0        0        0     2132 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/portfolio/base.pxd
+-rw-r--r--   0        0        0     4233 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/portfolio/base.pyx
+-rw-r--r--   0        0        0     3111 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/portfolio/portfolio.pxd
+-rw-r--r--   0        0        0    38505 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/portfolio/portfolio.pyx
+-rw-r--r--   0        0        0        0 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/py.typed
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/risk/__init__.pxd
+-rw-r--r--   0        0        0     1084 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/risk/__init__.py
+-rw-r--r--   0        0        0     1974 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/risk/config.py
+-rw-r--r--   0        0        0     5474 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/risk/engine.pxd
+-rw-r--r--   0        0        0    38066 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/risk/engine.pyx
+-rw-r--r--   0        0        0     1747 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/risk/sizing.pxd
+-rw-r--r--   0        0        0     7059 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/risk/sizing.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/__init__.pxd
+-rw-r--r--   0        0        0     1106 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/__init__.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/__init__.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/implementations/__init__.py
+-rw-r--r--   0        0        0     5360 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/implementations/account_state.py
+-rw-r--r--   0        0        0     1689 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/implementations/component_events.py
+-rw-r--r--   0        0        0    12316 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/implementations/instruments.py
+-rw-r--r--   0        0        0     2191 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/implementations/order_events.py
+-rw-r--r--   0        0        0     5923 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/implementations/position_events.py
+-rw-r--r--   0        0        0    15753 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/schema.py
+-rw-r--r--   0        0        0    13886 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/serializer.py
+-rw-r--r--   0        0        0     1096 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/base.pxd
+-rw-r--r--   0        0        0    12000 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/base.pyx
+-rw-r--r--   0        0        0     1303 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/serializer.pxd
+-rw-r--r--   0        0        0     5404 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/serialization/serializer.pyx
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/system/__init__.py
+-rw-r--r--   0        0        0     6506 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/system/config.py
+-rw-r--r--   0        0        0    40208 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/system/kernel.py
+-rw-r--r--   0        0        0     1034 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/__init__.py
+-rw-r--r--   0        0        0     2316 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/functions.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/__init__.py
+-rw-r--r--   0        0        0     6382 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/actors.py
+-rw-r--r--   0        0        0     5793 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/cache_database.py
+-rw-r--r--   0        0        0     1550 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/controller.py
+-rw-r--r--   0        0        0     3177 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/data.py
+-rw-r--r--   0        0        0     2976 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/engines.py
+-rw-r--r--   0        0        0    12678 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/exec_clients.py
+-rw-r--r--   0        0        0     7299 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/strategies.py
+-rw-r--r--   0        0        0    29811 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/providers.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/__init__.py
+-rw-r--r--   0        0        0     3697 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/accounting_pyo3.py
+-rw-r--r--   0        0        0     6642 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/data_pyo3.py
+-rw-r--r--   0        0        0    19949 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/events_pyo3.py
+-rw-r--r--   0        0        0     3912 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/identifiers_pyo3.py
+-rw-r--r--   0        0        0    15101 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/instruments_pyo3.py
+-rw-r--r--   0        0        0     5502 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/orders_pyo3.py
+-rw-r--r--   0        0        0     2451 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/types_pyo3.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/__init__.py
+-rw-r--r--   0        0        0     4828 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/commands.py
+-rw-r--r--   0        0        0     5842 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/component.py
+-rw-r--r--   0        0        0     6343 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/config.py
+-rw-r--r--   0        0        0    22352 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/data.py
+-rw-r--r--   0        0        0    14960 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/events.py
+-rw-r--r--   0        0        0     9471 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/execution.py
+-rw-r--r--   0        0        0     3991 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/identifiers.py
+-rw-r--r--   0        0        0     3415 2024-04-20 03:38:23.458917 nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/persistence.py
+-rw-r--r--   0        0        0      869 2024-04-20 03:38:23.462917 nautilus_trader-1.191.0/nautilus_trader/trading/__init__.pxd
+-rw-r--r--   0        0        0     1372 2024-04-20 03:38:23.462917 nautilus_trader-1.191.0/nautilus_trader/trading/__init__.py
+-rw-r--r--   0        0        0     4741 2024-04-20 03:38:23.462917 nautilus_trader-1.191.0/nautilus_trader/trading/config.py
+-rw-r--r--   0        0        0     5493 2024-04-20 03:38:23.462917 nautilus_trader-1.191.0/nautilus_trader/trading/controller.py
+-rw-r--r--   0        0        0    18226 2024-04-20 03:38:23.462917 nautilus_trader-1.191.0/nautilus_trader/trading/filters.py
+-rw-r--r--   0        0        0     8687 2024-04-20 03:38:23.462917 nautilus_trader-1.191.0/nautilus_trader/trading/strategy.pxd
+-rw-r--r--   0        0        0    59375 2024-04-20 03:38:23.462917 nautilus_trader-1.191.0/nautilus_trader/trading/strategy.pyx
+-rw-r--r--   0        0        0    25167 2024-04-20 03:38:23.462917 nautilus_trader-1.191.0/nautilus_trader/trading/trader.py
+-rw-r--r--   0        0        0     8000 2024-04-20 03:38:23.462917 nautilus_trader-1.191.0/pyproject.toml
+-rw-r--r--   0        0        0    28065 1970-01-01 00:00:00.000000 nautilus_trader-1.191.0/PKG-INFO
```

### Comparing `nautilus_trader-1.190.0/LICENSE` & `nautilus_trader-1.191.0/nautilus_core/LICENSE`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/README.md` & `nautilus_trader-1.191.0/README.md`

 * *Files 1% similar despite different names*

```diff
@@ -11,18 +11,18 @@
 | :-------- | :-------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
 | `master`  | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fmaster%2Fversion.json)  | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=master)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml)  |
 | `nightly` | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fnightly%2Fversion.json) | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=nightly)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml) |
 | `develop` | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fdevelop%2Fversion.json) | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=develop)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml) |
 
 | Platform           | Rust    | Python |
 | :----------------- | :------ | :----- |
-| `Linux (x86_64)`   | 1.77.0+ | 3.10+  |
-| `macOS (x86_64)`   | 1.77.0+ | 3.10+  |
-| `macOS (arm64)`    | 1.77.0+ | 3.10+  |
-| `Windows (x86_64)` | 1.77.0+ | 3.10+  |
+| `Linux (x86_64)`   | 1.77.1+ | 3.10+  |
+| `macOS (x86_64)`   | 1.77.1+ | 3.10+  |
+| `macOS (arm64)`    | 1.77.1+ | 3.10+  |
+| `Windows (x86_64)` | 1.77.1+ | 3.10+  |
 
 - **Website:** https://nautilustrader.io
 - **Docs:** https://docs.nautilustrader.io
 - **Support:** [support@nautilustrader.io](mailto:support@nautilustrader.io)
 
 ## Introduction
 
@@ -141,15 +141,15 @@
 
 | Name                                                      | ID                    | Type                    | Status                                                  | Docs                                                                |
 | :-------------------------------------------------------- | :-------------------- | :---------------------- | :------------------------------------------------------ | :------------------------------------------------------------------ |
 | [Betfair](https://betfair.com)                            | `BETFAIR`             | Sports Betting Exchange | ![status](https://img.shields.io/badge/stable-green)    | [Guide](https://docs.nautilustrader.io/integrations/betfair.html)   |
 | [Binance](https://binance.com)                            | `BINANCE`             | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/stable-green)    | [Guide](https://docs.nautilustrader.io/integrations/binance.html)   |
 | [Binance US](https://binance.us)                          | `BINANCE`             | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/stable-green)    | [Guide](https://docs.nautilustrader.io/integrations/binance.html)   |
 | [Binance Futures](https://www.binance.com/en/futures)     | `BINANCE`             | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/stable-green)    | [Guide](https://docs.nautilustrader.io/integrations/binance.html)   |
-| [Bybit](https://www.bybit.com)                            | `BYBIT`               | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/building-orange) |                                                                     |
+| [Bybit](https://www.bybit.com)                            | `BYBIT`               | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow)     | [Guide](https://docs.nautilustrader.io/integrations/bybit.html)     |
 | [Databento](https://databento.com)                        | `DATABENTO`           | Data Provider           | ![status](https://img.shields.io/badge/beta-yellow)     | [Guide](https://docs.nautilustrader.io/integrations/databento.html) |
 | [Interactive Brokers](https://www.interactivebrokers.com) | `INTERACTIVE_BROKERS` | Brokerage (multi-venue) | ![status](https://img.shields.io/badge/stable-green)    | [Guide](https://docs.nautilustrader.io/integrations/ib.html)        |
 
 - `ID:` The default client ID for the integrations adapter clients
 - `Type:` The type of integration (often the venue type)
 
 ### Status
```

### Comparing `nautilus_trader-1.190.0/build.py` & `nautilus_trader-1.191.0/build.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/.cargo/config.toml` & `nautilus_trader-1.191.0/nautilus_core/.cargo/config.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/Cargo.lock` & `nautilus_trader-1.191.0/nautilus_core/Cargo.lock`

 * *Files 2% similar despite different names*

```diff
@@ -64,17 +64,17 @@
 checksum = "94fb8275041c72129eb51b7d0322c29b8387a0386127718b096429201a5d6ece"
 dependencies = [
  "alloc-no-stdlib",
 ]
 
 [[package]]
 name = "allocator-api2"
-version = "0.2.16"
+version = "0.2.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0942ffc6dcaadf03badf6e6a2d0228460359d5e34b57ccdc720b7382dfbd5ec5"
+checksum = "5c6cb57a04249c6480766f7f7cef5467412af1490f8d1e243141daddada3264f"
 
 [[package]]
 name = "android-tzdata"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"
 
@@ -97,23 +97,23 @@
 name = "anstyle"
 version = "1.0.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8901269c6307e8d93993578286ac0edf7f195079ffff5ebdeea6a59ffb7e36bc"
 
 [[package]]
 name = "anyhow"
-version = "1.0.81"
+version = "1.0.82"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0952808a6c2afd1aa8947271f3a60f1a6763c7b912d210184c5149b5cf147247"
+checksum = "f538837af36e6f6a9be0faa67f9a314f8119e4e4b5867c6ab40ed60360142519"
 
 [[package]]
 name = "arc-swap"
-version = "1.7.0"
+version = "1.7.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7b3d0060af21e8d11a926981cc00c6c1541aa91dd64b9f881985c3da1094425f"
+checksum = "69f7f8c3906b62b754cd5326047894316021dcfe5a194c8ea52bdd94934a3457"
 
 [[package]]
 name = "arrayref"
 version = "0.3.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6b4930d2cb77ce62f89ee5d5289b4ac049559b1c45539271f5ed4fdc7db34545"
 
@@ -121,17 +121,17 @@
 name = "arrayvec"
 version = "0.7.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "96d30a06541fbafbc7f82ed10c06164cfbd2c401138f6addd8404629c4b16711"
 
 [[package]]
 name = "arrow"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "aa285343fba4d829d49985bdc541e3789cf6000ed0e84be7c039438df4a4e78c"
+checksum = "219d05930b81663fd3b32e3bde8ce5bff3c4d23052a99f11a8fa50a3b47b2658"
 dependencies = [
  "arrow-arith",
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-csv",
  "arrow-data",
@@ -143,79 +143,81 @@
  "arrow-select",
  "arrow-string",
  "pyo3",
 ]
 
 [[package]]
 name = "arrow-arith"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "753abd0a5290c1bcade7c6623a556f7d1659c5f4148b140b5b63ce7bd1a45705"
+checksum = "0272150200c07a86a390be651abdd320a2d12e84535f0837566ca87ecd8f95e0"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "chrono",
  "half",
  "num",
 ]
 
 [[package]]
 name = "arrow-array"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d390feeb7f21b78ec997a4081a025baef1e2e0d6069e181939b61864c9779609"
+checksum = "8010572cf8c745e242d1b632bd97bd6d4f40fefed5ed1290a8f433abaa686fea"
 dependencies = [
  "ahash 0.8.11",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "chrono",
  "chrono-tz",
  "half",
  "hashbrown 0.14.3",
  "num",
 ]
 
 [[package]]
 name = "arrow-buffer"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "69615b061701bcdffbc62756bc7e85c827d5290b472b580c972ebbbf690f5aa4"
+checksum = "0d0a2432f0cba5692bf4cb757469c66791394bac9ec7ce63c1afe74744c37b27"
 dependencies = [
  "bytes",
  "half",
  "num",
 ]
 
 [[package]]
 name = "arrow-cast"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e448e5dd2f4113bf5b74a1f26531708f5edcacc77335b7066f9398f4bcf4cdef"
+checksum = "9abc10cd7995e83505cc290df9384d6e5412b207b79ce6bdff89a10505ed2cba"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "arrow-select",
- "base64",
+ "atoi",
+ "base64 0.22.0",
  "chrono",
  "comfy-table",
  "half",
  "lexical-core",
  "num",
+ "ryu",
 ]
 
 [[package]]
 name = "arrow-csv"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "46af72211f0712612f5b18325530b9ad1bfbdc87290d5fbfd32a7da128983781"
+checksum = "95cbcba196b862270bf2a5edb75927380a7f3a163622c61d40cbba416a6305f2"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-data",
  "arrow-schema",
  "chrono",
@@ -224,133 +226,134 @@
  "lazy_static",
  "lexical-core",
  "regex",
 ]
 
 [[package]]
 name = "arrow-data"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "67d644b91a162f3ad3135ce1184d0a31c28b816a581e08f29e8e9277a574c64e"
+checksum = "2742ac1f6650696ab08c88f6dd3f0eb68ce10f8c253958a18c943a68cd04aec5"
 dependencies = [
  "arrow-buffer",
  "arrow-schema",
  "half",
  "num",
 ]
 
 [[package]]
 name = "arrow-ipc"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "03dea5e79b48de6c2e04f03f62b0afea7105be7b77d134f6c5414868feefb80d"
+checksum = "a42ea853130f7e78b9b9d178cb4cd01dee0f78e64d96c2949dc0a915d6d9e19d"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-data",
  "arrow-schema",
  "flatbuffers",
  "lz4_flex",
 ]
 
 [[package]]
 name = "arrow-json"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8950719280397a47d37ac01492e3506a8a724b3fb81001900b866637a829ee0f"
+checksum = "eaafb5714d4e59feae964714d724f880511500e3569cc2a94d02456b403a2a49"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-data",
  "arrow-schema",
  "chrono",
  "half",
- "indexmap 2.2.5",
+ "indexmap 2.2.6",
  "lexical-core",
  "num",
  "serde",
  "serde_json",
 ]
 
 [[package]]
 name = "arrow-ord"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1ed9630979034077982d8e74a942b7ac228f33dd93a93b615b4d02ad60c260be"
+checksum = "e3e6b61e3dc468f503181dccc2fc705bdcc5f2f146755fa5b56d0a6c5943f412"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "arrow-select",
  "half",
  "num",
 ]
 
 [[package]]
 name = "arrow-row"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "007035e17ae09c4e8993e4cb8b5b96edf0afb927cd38e2dff27189b274d83dcf"
+checksum = "848ee52bb92eb459b811fb471175ea3afcf620157674c8794f539838920f9228"
 dependencies = [
  "ahash 0.8.11",
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "half",
  "hashbrown 0.14.3",
 ]
 
 [[package]]
 name = "arrow-schema"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0ff3e9c01f7cd169379d269f926892d0e622a704960350d09d331be3ec9e0029"
+checksum = "02d9483aaabe910c4781153ae1b6ae0393f72d9ef757d38d09d450070cf2e528"
 dependencies = [
  "bitflags 2.5.0",
 ]
 
 [[package]]
 name = "arrow-select"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1ce20973c1912de6514348e064829e50947e35977bb9d7fb637dc99ea9ffd78c"
+checksum = "849524fa70e0e3c5ab58394c770cb8f514d0122d20de08475f7b472ed8075830"
 dependencies = [
  "ahash 0.8.11",
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "num",
 ]
 
 [[package]]
 name = "arrow-string"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "00f3b37f2aeece31a2636d1b037dabb69ef590e03bdc7eb68519b51ec86932a7"
+checksum = "9373cb5a021aee58863498c37eb484998ef13377f69989c6c5ccfbd258236cdb"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "arrow-select",
+ "memchr",
  "num",
  "regex",
- "regex-syntax 0.8.2",
+ "regex-syntax 0.8.3",
 ]
 
 [[package]]
 name = "async-compression"
-version = "0.4.6"
+version = "0.4.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a116f46a969224200a0a97f29cfd4c50e7534e4b4826bd23ea2c3c533039c82c"
+checksum = "07dbbf24db18d609b1462965249abdf49129ccad073ec257da372adc83259c60"
 dependencies = [
  "bzip2",
  "flate2",
  "futures-core",
  "futures-io",
  "memchr",
  "pin-project-lite",
@@ -358,21 +361,21 @@
  "xz2",
  "zstd",
  "zstd-safe",
 ]
 
 [[package]]
 name = "async-trait"
-version = "0.1.78"
+version = "0.1.80"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "461abc97219de0eaaf81fe3ef974a540158f3d079c2ab200f891f1a2ef201e85"
+checksum = "c6fa2087f2753a7da8cc1c0dbfcf89579dd57458e36769de5ac750b4671737ca"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "atoi"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f28d99ec8bfea296261ca1af174f24225171fea9664ba9003cbebee704810528"
@@ -389,45 +392,45 @@
  "hermit-abi 0.1.19",
  "libc",
  "winapi",
 ]
 
 [[package]]
 name = "autocfg"
-version = "1.1.0"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"
+checksum = "f1fdabc7756949593fe60f30ec81974b613357de856987752631dea1e3394c80"
 
 [[package]]
 name = "axum"
-version = "0.7.4"
+version = "0.7.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1236b4b292f6c4d6dc34604bb5120d85c3fe1d1aa596bd5cc52ca054d13e7b9e"
+checksum = "3a6c9af12842a67734c9a2e355436e5d03b22383ed60cf13cd0c18fbfe3dcbcf"
 dependencies = [
  "async-trait",
  "axum-core",
  "bytes",
  "futures-util",
  "http 1.1.0",
  "http-body 1.0.0",
  "http-body-util",
- "hyper 1.2.0",
+ "hyper 1.3.1",
  "hyper-util",
  "itoa",
  "matchit",
  "memchr",
  "mime",
  "percent-encoding",
  "pin-project-lite",
  "rustversion",
  "serde",
  "serde_json",
  "serde_path_to_error",
  "serde_urlencoded",
- "sync_wrapper",
+ "sync_wrapper 1.0.1",
  "tokio",
  "tower",
  "tower-layer",
  "tower-service",
  "tracing",
 ]
 
@@ -442,25 +445,25 @@
  "futures-util",
  "http 1.1.0",
  "http-body 1.0.0",
  "http-body-util",
  "mime",
  "pin-project-lite",
  "rustversion",
- "sync_wrapper",
+ "sync_wrapper 0.1.2",
  "tower-layer",
  "tower-service",
  "tracing",
 ]
 
 [[package]]
 name = "backtrace"
-version = "0.3.70"
+version = "0.3.71"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "95d8e92cac0961e91dbd517496b00f7e9b92363dbe6d42c3198268323798860c"
+checksum = "26b05800d2e817c8b3b4b54abd461726265fa9789ae34330622f2db9ee696f9d"
 dependencies = [
  "addr2line",
  "cc",
  "cfg-if",
  "libc",
  "miniz_oxide",
  "object",
@@ -470,14 +473,20 @@
 [[package]]
 name = "base64"
 version = "0.21.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"
 
 [[package]]
+name = "base64"
+version = "0.22.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9475866fec1451be56a3c2400fd081ff546538961565ccb5b7142cbd22bc7a51"
+
+[[package]]
 name = "base64ct"
 version = "1.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8c3c1a368f70d6cf7302d78f8f7093da241fb8e8807c05cc9e51a125895a6d5b"
 
 [[package]]
 name = "binary-heap-plus"
@@ -544,33 +553,33 @@
 checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
 dependencies = [
  "generic-array",
 ]
 
 [[package]]
 name = "borsh"
-version = "1.3.1"
+version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f58b559fd6448c6e2fd0adb5720cd98a2506594cafa4737ff98c396f3e82f667"
+checksum = "0901fc8eb0aca4c83be0106d6f2db17d86a08dfc2c25f0e84464bf381158add6"
 dependencies = [
  "borsh-derive",
  "cfg_aliases",
 ]
 
 [[package]]
 name = "borsh-derive"
-version = "1.3.1"
+version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7aadb5b6ccbd078890f6d7003694e33816e6b784358f18e15e7e6d9f065a57cd"
+checksum = "51670c3aa053938b0ee3bd67c3817e471e626151131b934038e83c5bf8de48f5"
 dependencies = [
  "once_cell",
  "proc-macro-crate",
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
  "syn_derive",
 ]
 
 [[package]]
 name = "brotli"
 version = "3.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -589,17 +598,17 @@
 dependencies = [
  "alloc-no-stdlib",
  "alloc-stdlib",
 ]
 
 [[package]]
 name = "bumpalo"
-version = "3.15.4"
+version = "3.16.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7ff69b9dd49fd426c69a0db9fc04dd934cdb6645ff000864d98f7e2af8830eaa"
+checksum = "79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c"
 
 [[package]]
 name = "bytecheck"
 version = "0.6.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "23cdc57ce23ac53c931e88a43d06d070a6fd142f2617be5855eb75efc9beb1c2"
 dependencies = [
@@ -617,29 +626,29 @@
  "proc-macro2",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
 name = "bytecount"
-version = "0.6.7"
+version = "0.6.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e1e5f035d16fc623ae5f74981db80a439803888314e3a555fd6f04acd51a3205"
+checksum = "5ce89b21cab1437276d2650d57e971f9d548a2d9037cc231abdc0562b97498ce"
 
 [[package]]
 name = "byteorder"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"
 
 [[package]]
 name = "bytes"
-version = "1.5.0"
+version = "1.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a2bd12c1caf447e69cd4528f47f94d203fd2582878ecb9e9465484c4148a8223"
+checksum = "514de17de45fdb8dc022b1a7975556c53c86f9f0aa5f534b98977b171857c2c9"
 
 [[package]]
 name = "bzip2"
 version = "0.4.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bdb116a6ef3f6c3698828873ad02c3014b3c85cadb88496095628e3ef1e347f8"
 dependencies = [
@@ -681,17 +690,17 @@
  "syn 1.0.109",
  "tempfile",
  "toml",
 ]
 
 [[package]]
 name = "cc"
-version = "1.0.90"
+version = "1.0.94"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8cd6604a82acf3039f1144f54b8eb34e91ffba622051189e71b781822d5ee1f5"
+checksum = "17f6e324229dc011159fcc089755d1e2e216a90d43a7dea6853ca740b84f35e7"
 dependencies = [
  "jobserver",
  "libc",
 ]
 
 [[package]]
 name = "cfg-if"
@@ -703,24 +712,24 @@
 name = "cfg_aliases"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "fd16c4719339c4530435d38e511904438d07cce7950afa3718a84ac36c10e89e"
 
 [[package]]
 name = "chrono"
-version = "0.4.35"
+version = "0.4.38"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8eaf5903dcbc0a39312feb77df2ff4c76387d591b9fc7b04a238dcf8bb62639a"
+checksum = "a21f936df1771bf62b77f047b726c4625ff2e8aa607c01ec06e5a05bd8463401"
 dependencies = [
  "android-tzdata",
  "iana-time-zone",
  "js-sys",
  "num-traits",
  "wasm-bindgen",
- "windows-targets 0.52.4",
+ "windows-targets 0.52.5",
 ]
 
 [[package]]
 name = "chrono-tz"
 version = "0.8.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d59ae0466b83e838b81a54256c39d5d7c20b9d7daa10510a242d9b75abd5936e"
@@ -781,17 +790,17 @@
  "strsim",
  "termcolor",
  "textwrap",
 ]
 
 [[package]]
 name = "clap"
-version = "4.5.3"
+version = "4.5.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "949626d00e063efc93b6dca932419ceb5432f99769911c0b995f7e884c778813"
+checksum = "90bc066a67923782aa8515dbaea16946c5bcc5addbd668bb80af688e53e548a0"
 dependencies = [
  "clap_builder",
 ]
 
 [[package]]
 name = "clap_builder"
 version = "4.5.2"
@@ -815,34 +824,34 @@
 name = "clap_lex"
 version = "0.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "98cc8fbded0c607b7ba9dd60cd98df59af97e84d24e49c8557331cfc26d301ce"
 
 [[package]]
 name = "combine"
-version = "4.6.6"
+version = "4.6.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "35ed6e9d84f0b51a7f52daf1c7d71dd136fd7a3f41a8462b8cdb8c78d920fad4"
+checksum = "ba5a308b75df32fe02788e748662718f03fde005016435c444eea572398219fd"
 dependencies = [
  "bytes",
  "futures-core",
  "memchr",
  "pin-project-lite",
  "tokio",
  "tokio-util",
 ]
 
 [[package]]
 name = "comfy-table"
-version = "7.1.0"
+version = "7.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7c64043d6c7b7a4c58e39e7efccfdea7b93d885a795d0c054a69dbbf4dd52686"
+checksum = "b34115915337defe99b2aff5c2ce6771e5fbc4079f4b506301f5cf394c8452f7"
 dependencies = [
- "strum 0.25.0",
- "strum_macros 0.25.3",
+ "strum",
+ "strum_macros",
  "unicode-width",
 ]
 
 [[package]]
 name = "compare"
 version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -903,17 +912,17 @@
 checksum = "53fe5e26ff1b7aef8bca9c6080520cfb8d9333c7568e1829cef191a9723e5504"
 dependencies = [
  "libc",
 ]
 
 [[package]]
 name = "crc"
-version = "3.0.1"
+version = "3.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "86ec7a15cbe22e59248fc7eadb1907dab5ba09372595da4d73dd805ed4417dfe"
+checksum = "69e6e4d7b33a94f0991c26729976b10ebde1d34c3ee82408fb536164fa10d636"
 dependencies = [
  "crc-catalog",
 ]
 
 [[package]]
 name = "crc-catalog"
 version = "2.4.0"
@@ -934,15 +943,15 @@
 version = "0.5.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f2b12d017a929603d80db1831cd3a24082f8137ce19c69e6447f54f5fc8d692f"
 dependencies = [
  "anes",
  "cast",
  "ciborium",
- "clap 4.5.3",
+ "clap 4.5.4",
  "criterion-plot",
  "is-terminal",
  "itertools 0.10.5",
  "num-traits",
  "once_cell",
  "oorandom",
  "plotters",
@@ -1053,26 +1062,26 @@
 checksum = "9c2cf1c23a687a1feeb728783b993c4e1ad83d99f351801977dd809b48d0a70f"
 dependencies = [
  "fnv",
  "ident_case",
  "proc-macro2",
  "quote",
  "strsim",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "darling_macro"
 version = "0.20.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a668eda54683121533a393014d8692171709ff57a7d61f187b6e782719f8933f"
 dependencies = [
  "darling_core",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "dashmap"
 version = "5.5.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "978747c1d849a7d2ee5e8adc0159961c48fb7e5db2f06af6723b80123bb53856"
@@ -1088,64 +1097,65 @@
 name = "data-encoding"
 version = "2.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7e962a19be5cfc3f3bf6dd8f61eb50107f356ad6270fbb3ed41476571db78be5"
 
 [[package]]
 name = "databento"
-version = "0.7.1"
+version = "0.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b87919b13848b6a615ae951e01a3c15465a9b5daffb21c425f87844d95ad4ea1"
+checksum = "a0429639ce27e07a088b53b9e89dea7519c6e1871df5508a7ae33fc2c61b6cdf"
 dependencies = [
  "dbn",
  "futures",
  "hex",
  "log",
- "reqwest",
+ "reqwest 0.11.27",
  "serde",
  "serde_json",
  "sha2",
  "thiserror",
  "time",
  "tokio",
  "tokio-util",
  "typed-builder",
 ]
 
 [[package]]
 name = "datafusion"
-version = "36.0.0"
+version = "37.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b2b360b692bf6c6d6e6b6dbaf41a3be0020daeceac0f406aed54c75331e50dbb"
+checksum = "812a53e154009ee2bd6b2f8a9ab8f30cbf2c693cb860e60f0aa3315ba3486e39"
 dependencies = [
  "ahash 0.8.11",
  "arrow",
  "arrow-array",
  "arrow-ipc",
  "arrow-schema",
  "async-compression",
  "async-trait",
  "bytes",
  "bzip2",
  "chrono",
  "dashmap",
  "datafusion-common",
+ "datafusion-common-runtime",
  "datafusion-execution",
  "datafusion-expr",
  "datafusion-functions",
  "datafusion-optimizer",
  "datafusion-physical-expr",
  "datafusion-physical-plan",
  "datafusion-sql",
  "flate2",
  "futures",
  "glob",
  "half",
  "hashbrown 0.14.3",
- "indexmap 2.2.5",
+ "indexmap 2.2.6",
  "itertools 0.12.1",
  "log",
  "num_cpus",
  "object_store",
  "parking_lot",
  "parquet",
  "pin-project-lite",
@@ -1158,38 +1168,48 @@
  "uuid",
  "xz2",
  "zstd",
 ]
 
 [[package]]
 name = "datafusion-common"
-version = "36.0.0"
+version = "37.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "37f343ccc298f440e25aa38ff82678291a7acc24061c7370ba6c0ff5cc811412"
+checksum = "b99d4d7ccdad4dffa8ff4569f45792d0678a0c7ee08e3fdf1b0a52ebb9cf201e"
 dependencies = [
  "ahash 0.8.11",
  "arrow",
  "arrow-array",
  "arrow-buffer",
  "arrow-schema",
  "chrono",
  "half",
+ "instant",
  "libc",
  "num_cpus",
  "object_store",
  "parquet",
  "pyo3",
  "sqlparser",
 ]
 
 [[package]]
+name = "datafusion-common-runtime"
+version = "37.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a5cf713ae1f5423b5625aeb3ddfb0d5c29e880cf6a0d2059d0724219c873a76c"
+dependencies = [
+ "tokio",
+]
+
+[[package]]
 name = "datafusion-execution"
-version = "36.0.0"
+version = "37.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3f9c93043081487e335399a21ebf8295626367a647ac5cb87d41d18afad7d0f7"
+checksum = "0f69d00325b77c3886b7080d96e3aa8e9a5ef16fe368a434c14b2f1b63b68803"
 dependencies = [
  "arrow",
  "chrono",
  "dashmap",
  "datafusion-common",
  "datafusion-expr",
  "futures",
@@ -1200,147 +1220,159 @@
  "rand",
  "tempfile",
  "url",
 ]
 
 [[package]]
 name = "datafusion-expr"
-version = "36.0.0"
+version = "37.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e204d89909e678846b6a95f156aafc1ee5b36cb6c9e37ec2e1449b078a38c818"
+checksum = "6fbe71343a95c2079fa443aa840dfdbd2034532cfc00449a57204c8a6fdcf928"
 dependencies = [
  "ahash 0.8.11",
  "arrow",
  "arrow-array",
+ "chrono",
  "datafusion-common",
  "paste",
  "sqlparser",
- "strum 0.26.2",
- "strum_macros 0.26.2",
+ "strum",
+ "strum_macros",
 ]
 
 [[package]]
 name = "datafusion-functions"
-version = "36.0.0"
+version = "37.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "98f1c73f7801b2b8ba2297b3ad78ffcf6c1fc6b8171f502987eb9ad5cb244ee7"
+checksum = "c046800d26d2267fab3bd5fc0b9bc0a7b1ae47e688b01c674ed39daa84cd3cc5"
 dependencies = [
  "arrow",
- "base64",
+ "base64 0.22.0",
+ "blake2",
+ "blake3",
+ "chrono",
  "datafusion-common",
  "datafusion-execution",
  "datafusion-expr",
+ "datafusion-physical-expr",
  "hex",
+ "itertools 0.12.1",
  "log",
+ "md-5",
+ "regex",
+ "sha2",
+ "unicode-segmentation",
+ "uuid",
 ]
 
 [[package]]
 name = "datafusion-optimizer"
-version = "36.0.0"
+version = "37.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5ae27e07bf1f04d327be5c2a293470879801ab5535204dc3b16b062fda195496"
+checksum = "e3d48972fffe5a4ee2af2b8b72a3db5cdbc800d5dd5af54f8df0ab508bb5545c"
 dependencies = [
  "arrow",
  "async-trait",
  "chrono",
  "datafusion-common",
  "datafusion-expr",
  "datafusion-physical-expr",
  "hashbrown 0.14.3",
  "itertools 0.12.1",
  "log",
- "regex-syntax 0.8.2",
+ "regex-syntax 0.8.3",
 ]
 
 [[package]]
 name = "datafusion-physical-expr"
-version = "36.0.0"
+version = "37.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dde620cd9ef76a3bca9c754fb68854bd2349c49f55baf97e08001f9e967f6d6b"
+checksum = "8e001baf1aaa95a418ee9fcb979f5fc18f16b81a8a5f6a260b05df9494344adb"
 dependencies = [
  "ahash 0.8.11",
  "arrow",
  "arrow-array",
  "arrow-buffer",
  "arrow-ord",
  "arrow-schema",
  "arrow-string",
- "base64",
+ "base64 0.22.0",
  "blake2",
  "blake3",
  "chrono",
  "datafusion-common",
  "datafusion-execution",
  "datafusion-expr",
  "half",
  "hashbrown 0.14.3",
  "hex",
- "indexmap 2.2.5",
+ "indexmap 2.2.6",
  "itertools 0.12.1",
  "log",
  "md-5",
  "paste",
  "petgraph",
  "rand",
  "regex",
  "sha2",
  "unicode-segmentation",
- "uuid",
 ]
 
 [[package]]
 name = "datafusion-physical-plan"
-version = "36.0.0"
+version = "37.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9a4c75fba9ea99d64b2246cbd2fcae2e6fc973e6616b1015237a616036506dd4"
+checksum = "3e5421ed2c5789bafc6d48231627d17c6836549a26c8162569354589202212ef"
 dependencies = [
  "ahash 0.8.11",
  "arrow",
  "arrow-array",
  "arrow-buffer",
  "arrow-schema",
  "async-trait",
  "chrono",
  "datafusion-common",
+ "datafusion-common-runtime",
  "datafusion-execution",
  "datafusion-expr",
  "datafusion-physical-expr",
  "futures",
  "half",
  "hashbrown 0.14.3",
- "indexmap 2.2.5",
+ "indexmap 2.2.6",
  "itertools 0.12.1",
  "log",
  "once_cell",
  "parking_lot",
  "pin-project-lite",
  "rand",
  "tokio",
- "uuid",
 ]
 
 [[package]]
 name = "datafusion-sql"
-version = "36.0.0"
+version = "37.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "21474a95c3a62d113599d21b439fa15091b538bac06bd20be0bb2e7d22903c09"
+checksum = "3f70d881337f733b7d0548e468073c0ae8b256557c33b299fd6afea0ea5d5162"
 dependencies = [
  "arrow",
+ "arrow-array",
  "arrow-schema",
  "datafusion-common",
  "datafusion-expr",
  "log",
  "sqlparser",
+ "strum",
 ]
 
 [[package]]
 name = "dbn"
-version = "0.16.0"
+version = "0.17.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "afd488d5a4c75b7ed5557c205f02c38db1bc0a6e85b6a7ff69e24cc354692143"
+checksum = "75c616347fc28872f993b5e9b80a5d25128db3557b852fc6642a0739b2f97003"
 dependencies = [
  "async-compression",
  "csv",
  "dbn-macros",
  "itoa",
  "json-writer",
  "num_enum",
@@ -1350,29 +1382,29 @@
  "time",
  "tokio",
  "zstd",
 ]
 
 [[package]]
 name = "dbn-macros"
-version = "0.16.0"
+version = "0.17.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d96ad08a698e3d5a61184e43d12d287b1198b447f641c4bfa268d89c7d7161f1"
+checksum = "405f6fb410dad990ea1e56ce02609ea103ffd5c153c489c770c909e3bb7b165c"
 dependencies = [
  "proc-macro-crate",
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "der"
-version = "0.7.8"
+version = "0.7.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fffa369a668c8af7dbf8b5e56c9f744fbd399949ed171606040001947de40b1c"
+checksum = "f55bf8e7b65898637379c1b74eb1551107c8294ed26d855ceb9fd1a09cfc9bc0"
 dependencies = [
  "const-oid",
  "pem-rfc7468",
  "zeroize",
 ]
 
 [[package]]
@@ -1399,25 +1431,25 @@
 version = "0.20.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d48cda787f839151732d396ac69e3473923d54312c070ee21e9effcaa8ca0b1d"
 dependencies = [
  "darling",
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "derive_builder_macro"
 version = "0.20.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "206868b8242f27cecce124c19fd88157fbd0dd334df2587f36417bafbc85097b"
 dependencies = [
  "derive_builder_core",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "digest"
 version = "0.10.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
@@ -1444,26 +1476,26 @@
 name = "dotenvy"
 version = "0.15.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1aaf95b3e5c8f23aa320147307562d361db0ae0d51242340f558153b4eb2439b"
 
 [[package]]
 name = "either"
-version = "1.10.0"
+version = "1.11.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "11157ac094ffbdde99aa67b23417ebdd801842852b500e395a45a9c0aac03e4a"
+checksum = "a47c1c47d2f5964e29c61246e81db715514cd532db6b5116a25ea3c03d6780a2"
 dependencies = [
  "serde",
 ]
 
 [[package]]
 name = "encoding_rs"
-version = "0.8.33"
+version = "0.8.34"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7268b386296a025e474d5140678f75d6de9493ae55a5d709eeb9dd08149945e1"
+checksum = "b45de904aa0b010bce2ab45264d0631681847fa7b6f2eaa7dab7619943bc4f59"
 dependencies = [
  "cfg-if",
 ]
 
 [[package]]
 name = "env_logger"
 version = "0.8.4"
@@ -1511,17 +1543,17 @@
 name = "event-listener"
 version = "2.5.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0206175f82b8d6bf6652ff7d71a1e27fd2e4efde587fd368662814d6ec1d9ce0"
 
 [[package]]
 name = "fastrand"
-version = "2.0.1"
+version = "2.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "25cbce373ec4653f1a01a31e8a5e5ec0c622dc27ff9c4e6606eefef5cbbed4a5"
+checksum = "658bd65b1cf4c852a3cc96f18a8ce7b5640f6b703f905c7d74532294c2a63984"
 
 [[package]]
 name = "finl_unicode"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8fcfdc7a0362c9f4444381a9e697c79d435fe65b52a37466fc2c1184cee9edc6"
 
@@ -1670,15 +1702,15 @@
 name = "futures-macro"
 version = "0.3.30"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "87750cf4b7a4c0625b1529e4c543c2182106e4dedc60a2a6455e00d212c489ac"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "futures-sink"
 version = "0.3.30"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9fb8e00e87438d937621c1c6269e53f536c14d3fbd6a042bb24879e57d474fb5"
@@ -1721,17 +1753,17 @@
 dependencies = [
  "typenum",
  "version_check",
 ]
 
 [[package]]
 name = "getrandom"
-version = "0.2.12"
+version = "0.2.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "190092ea657667030ac6a35e305e62fc4dd69fd98ac98631e5d3a2b1575a12b5"
+checksum = "94b22e06ecb0110981051723910cbf0b5f5e09a2062dd7663334ee79a9d1286c"
 dependencies = [
  "cfg-if",
  "libc",
  "wasi",
 ]
 
 [[package]]
@@ -1744,55 +1776,55 @@
 name = "glob"
 version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b"
 
 [[package]]
 name = "h2"
-version = "0.3.25"
+version = "0.3.26"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4fbd2820c5e49886948654ab546d0688ff24530286bdcf8fca3cefb16d4618eb"
+checksum = "81fe527a889e1532da5c525686d96d4c2e74cdd345badf8dfef9f6b39dd5f5e8"
 dependencies = [
  "bytes",
  "fnv",
  "futures-core",
  "futures-sink",
  "futures-util",
  "http 0.2.12",
- "indexmap 2.2.5",
+ "indexmap 2.2.6",
  "slab",
  "tokio",
  "tokio-util",
  "tracing",
 ]
 
 [[package]]
 name = "h2"
-version = "0.4.3"
+version = "0.4.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "51ee2dd2e4f378392eeff5d51618cd9a63166a2513846bbc55f21cfacd9199d4"
+checksum = "816ec7294445779408f36fe57bc5b7fc1cf59664059096c65f905c1c61f58069"
 dependencies = [
  "bytes",
  "fnv",
  "futures-core",
  "futures-sink",
  "futures-util",
  "http 1.1.0",
- "indexmap 2.2.5",
+ "indexmap 2.2.6",
  "slab",
  "tokio",
  "tokio-util",
  "tracing",
 ]
 
 [[package]]
 name = "half"
-version = "2.4.0"
+version = "2.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b5eceaaeec696539ddaf7b333340f1af35a5aa87ae3e4f3ead0532f72affab2e"
+checksum = "6dd08c532ae367adf81c312a4580bc67f1d0fe8bc9c460520283f4c0ff277888"
 dependencies = [
  "cfg-if",
  "crunchy",
  "num-traits",
 ]
 
 [[package]]
@@ -1966,15 +1998,15 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bf96e135eb83a2a8ddf766e426a841d8ddd7449d5f00d34ea02b41d2f19eef80"
 dependencies = [
  "bytes",
  "futures-channel",
  "futures-core",
  "futures-util",
- "h2 0.3.25",
+ "h2 0.3.26",
  "http 0.2.12",
  "http-body 0.4.6",
  "httparse",
  "httpdate",
  "itoa",
  "pin-project-lite",
  "socket2",
@@ -1982,30 +2014,31 @@
  "tower-service",
  "tracing",
  "want",
 ]
 
 [[package]]
 name = "hyper"
-version = "1.2.0"
+version = "1.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "186548d73ac615b32a73aafe38fb4f56c0d340e110e5a200bcadbaf2e199263a"
+checksum = "fe575dd17d0862a9a33781c8c4696a55c320909004a67a00fb286ba8b1bc496d"
 dependencies = [
  "bytes",
  "futures-channel",
  "futures-util",
- "h2 0.4.3",
+ "h2 0.4.4",
  "http 1.1.0",
  "http-body 1.0.0",
  "httparse",
  "httpdate",
  "itoa",
  "pin-project-lite",
  "smallvec",
  "tokio",
+ "want",
 ]
 
 [[package]]
 name = "hyper-tls"
 version = "0.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d6183ddfa99b85da61a140bea0efc93fdf56ceaa041b37d553518030827f9905"
@@ -2014,27 +2047,47 @@
  "hyper 0.14.28",
  "native-tls",
  "tokio",
  "tokio-native-tls",
 ]
 
 [[package]]
+name = "hyper-tls"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "70206fc6890eaca9fde8a0bf71caa2ddfc9fe045ac9e5c70df101a7dbde866e0"
+dependencies = [
+ "bytes",
+ "http-body-util",
+ "hyper 1.3.1",
+ "hyper-util",
+ "native-tls",
+ "tokio",
+ "tokio-native-tls",
+ "tower-service",
+]
+
+[[package]]
 name = "hyper-util"
 version = "0.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ca38ef113da30126bbff9cd1705f9273e15d45498615d138b0c20279ac7a76aa"
 dependencies = [
  "bytes",
+ "futures-channel",
  "futures-util",
  "http 1.1.0",
  "http-body 1.0.0",
- "hyper 1.2.0",
+ "hyper 1.3.1",
  "pin-project-lite",
  "socket2",
  "tokio",
+ "tower",
+ "tower-service",
+ "tracing",
 ]
 
 [[package]]
 name = "iai"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "71a816c97c42258aa5834d07590b718b4c9a598944cd39a52dc25b351185d678"
@@ -2086,28 +2139,40 @@
 dependencies = [
  "autocfg",
  "hashbrown 0.12.3",
 ]
 
 [[package]]
 name = "indexmap"
-version = "2.2.5"
+version = "2.2.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7b0b929d511467233429c45a44ac1dcaa21ba0f5ba11e4879e6ed28ddb4f9df4"
+checksum = "168fb715dda47215e360912c096649d23d58bf392ac62f73919e831745e40f26"
 dependencies = [
  "equivalent",
  "hashbrown 0.14.3",
  "serde",
 ]
 
 [[package]]
 name = "indoc"
-version = "2.0.4"
+version = "2.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b248f5224d1d606005e02c97f5aa4e88eeb230488bcc03bc9ca4d7991399f2b5"
+
+[[package]]
+name = "instant"
+version = "0.1.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1e186cfbae8084e513daff4240b4797e342f988cecda4fb6c939150f96315fd8"
+checksum = "7a5bbe824c507c5da5956355e86a746d82e0e1464f65d862cc5e71da70e94b2c"
+dependencies = [
+ "cfg-if",
+ "js-sys",
+ "wasm-bindgen",
+ "web-sys",
+]
 
 [[package]]
 name = "integer-encoding"
 version = "3.0.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8bb03732005da905c88227371639bf1ad885cc712789c011c31c5fb3ab3ccf02"
 
@@ -2144,23 +2209,23 @@
 checksum = "ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569"
 dependencies = [
  "either",
 ]
 
 [[package]]
 name = "itoa"
-version = "1.0.10"
+version = "1.0.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b1a46d1a171d865aa5f83f92695765caa047a9b4cbae2cbf37dbd613a793fd4c"
+checksum = "49f1f14873335454500d59611f1cf4a4b0f786f9ac11f4312a78e4cf2566695b"
 
 [[package]]
 name = "jobserver"
-version = "0.1.28"
+version = "0.1.30"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ab46a6e9526ddef3ae7f787c06f0f2600639ba80ea3eade3d8e670a2230f51d6"
+checksum = "685a7d121ee3f65ae4fddd72b25a04bb36b6af81bc0828f7d5434c0fe60fa3a2"
 dependencies = [
  "libc",
 ]
 
 [[package]]
 name = "js-sys"
 version = "0.3.69"
@@ -2300,17 +2365,17 @@
 dependencies = [
  "serde",
  "value-bag",
 ]
 
 [[package]]
 name = "lz4_flex"
-version = "0.11.2"
+version = "0.11.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "912b45c753ff5f7f5208307e8ace7d2a2e30d024e26d3509f3dce546c044ce15"
+checksum = "75761162ae2b0e580d7e7c390558127e5f01b4194debd6221fd8c207fc80e3f5"
 dependencies = [
  "twox-hash",
 ]
 
 [[package]]
 name = "lzma-sys"
 version = "0.1.20"
@@ -2345,23 +2410,23 @@
 dependencies = [
  "cfg-if",
  "digest",
 ]
 
 [[package]]
 name = "memchr"
-version = "2.7.1"
+version = "2.7.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "523dc4f511e55ab87b694dc30d0f820d60906ef06413f93d4d7a1385599cc149"
+checksum = "6c8640c5d730cb13ebd907d8d04b52f55ac9a2eec55b440c8892f40d56c76c1d"
 
 [[package]]
 name = "memoffset"
-version = "0.9.0"
+version = "0.9.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5a634b1c61a95585bd15607c6ab0c4e5b226e695ff2800ba0cdccddf208c406c"
+checksum = "488016bfae457b036d996092f6cb448677611ce4449e970ceaf42695203f218a"
 dependencies = [
  "autocfg",
 ]
 
 [[package]]
 name = "mime"
 version = "0.3.17"
@@ -2410,15 +2475,15 @@
  "security-framework",
  "security-framework-sys",
  "tempfile",
 ]
 
 [[package]]
 name = "nautilus-accounting"
-version = "0.20.0"
+version = "0.21.0"
 dependencies = [
  "anyhow",
  "cbindgen",
  "nautilus-common",
  "nautilus-core",
  "nautilus-model",
  "pyo3",
@@ -2426,87 +2491,91 @@
  "rust_decimal",
  "serde",
  "serde_json",
 ]
 
 [[package]]
 name = "nautilus-adapters"
-version = "0.20.0"
+version = "0.21.0"
 dependencies = [
  "anyhow",
  "chrono",
  "criterion",
  "databento",
- "indexmap 2.2.5",
+ "indexmap 2.2.6",
  "itoa",
  "log",
  "nautilus-common",
  "nautilus-core",
  "nautilus-model",
  "pyo3",
  "pyo3-asyncio",
  "rand",
  "rstest",
  "rust_decimal",
  "rust_decimal_macros",
  "serde",
  "serde_json",
  "streaming-iterator",
- "strum 0.26.2",
+ "strum",
  "thiserror",
  "time",
  "tokio",
  "tracing",
  "ustr",
 ]
 
 [[package]]
 name = "nautilus-backtest"
-version = "0.20.0"
+version = "0.21.0"
 dependencies = [
+ "anyhow",
  "cbindgen",
+ "log",
  "nautilus-common",
  "nautilus-core",
  "nautilus-execution",
  "nautilus-model",
  "pyo3",
  "rstest",
  "tempfile",
  "ustr",
 ]
 
 [[package]]
 name = "nautilus-common"
-version = "0.20.0"
+version = "0.21.0"
 dependencies = [
  "anyhow",
  "cbindgen",
  "chrono",
- "indexmap 2.2.5",
+ "indexmap 2.2.6",
+ "itertools 0.12.1",
  "log",
  "nautilus-core",
  "nautilus-model",
  "pyo3",
  "pyo3-asyncio",
- "redis",
  "rstest",
+ "rust_decimal",
+ "rust_decimal_macros",
  "serde",
  "serde_json",
- "strum 0.26.2",
+ "strum",
  "sysinfo",
  "tempfile",
  "tokio",
  "tracing",
  "tracing-subscriber",
  "ustr",
 ]
 
 [[package]]
 name = "nautilus-core"
-version = "0.20.0"
+version = "0.21.0"
 dependencies = [
  "anyhow",
  "cbindgen",
  "chrono",
  "criterion",
  "heck 0.5.0",
  "iai",
@@ -2517,51 +2586,52 @@
  "serde_json",
  "ustr",
  "uuid",
 ]
 
 [[package]]
 name = "nautilus-execution"
-version = "0.20.0"
+version = "0.21.0"
 dependencies = [
  "anyhow",
  "criterion",
- "indexmap 2.2.5",
+ "derive_builder",
+ "indexmap 2.2.6",
  "log",
  "nautilus-common",
  "nautilus-core",
  "nautilus-model",
  "pyo3",
  "pyo3-asyncio",
  "rstest",
  "rust_decimal",
  "rust_decimal_macros",
  "serde",
  "serde_json",
- "strum 0.26.2",
+ "strum",
  "thiserror",
  "tracing",
  "ustr",
 ]
 
 [[package]]
 name = "nautilus-indicators"
-version = "0.20.0"
+version = "0.21.0"
 dependencies = [
  "anyhow",
  "nautilus-core",
  "nautilus-model",
  "pyo3",
  "rstest",
- "strum 0.26.2",
+ "strum",
 ]
 
 [[package]]
 name = "nautilus-infrastructure"
-version = "0.20.0"
+version = "0.21.0"
 dependencies = [
  "anyhow",
  "nautilus-common",
  "nautilus-core",
  "nautilus-model",
  "pyo3",
  "redis",
@@ -2569,68 +2639,68 @@
  "rstest",
  "serde_json",
  "tracing",
 ]
 
 [[package]]
 name = "nautilus-model"
-version = "0.20.0"
+version = "0.21.0"
 dependencies = [
  "anyhow",
  "cbindgen",
  "chrono",
  "criterion",
  "derive_builder",
  "evalexpr",
  "float-cmp",
  "iai",
- "indexmap 2.2.5",
+ "indexmap 2.2.6",
  "nautilus-core",
  "once_cell",
  "pyo3",
  "rstest",
  "rust_decimal",
  "rust_decimal_macros",
  "serde",
  "serde_json",
- "strum 0.26.2",
+ "strum",
  "tabled",
  "thiserror",
  "thousands",
  "ustr",
 ]
 
 [[package]]
 name = "nautilus-network"
-version = "0.20.0"
+version = "0.21.0"
 dependencies = [
  "anyhow",
  "axum",
  "criterion",
  "dashmap",
  "futures",
  "futures-util",
  "http 1.1.0",
- "hyper 1.2.0",
+ "hyper 1.3.1",
  "nautilus-core",
  "nonzero_ext",
  "pyo3",
  "pyo3-asyncio",
- "reqwest",
+ "reqwest 0.12.4",
  "rstest",
  "serde_json",
  "tokio",
  "tokio-tungstenite",
  "tracing",
  "tracing-test",
 ]
 
 [[package]]
 name = "nautilus-persistence"
-version = "0.20.0"
+version = "0.21.0"
 dependencies = [
  "anyhow",
  "binary-heap-plus",
  "compare",
  "criterion",
  "datafusion",
  "dotenv",
@@ -2646,15 +2716,15 @@
  "sqlx",
  "thiserror",
  "tokio",
 ]
 
 [[package]]
 name = "nautilus-pyo3"
-version = "0.20.0"
+version = "0.21.0"
 dependencies = [
  "nautilus-accounting",
  "nautilus-adapters",
  "nautilus-common",
  "nautilus-core",
  "nautilus-indicators",
  "nautilus-infrastructure",
@@ -2697,17 +2767,17 @@
 dependencies = [
  "overload",
  "winapi",
 ]
 
 [[package]]
 name = "num"
-version = "0.4.1"
+version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b05180d69e3da0e530ba2a1dae5110317e49e3b7f3d41be227dc5f92e49ee7af"
+checksum = "3135b08af27d103b0a51f2ae0f8632117b7b185ccf931445affa8df530576a41"
 dependencies = [
  "num-bigint",
  "num-complex",
  "num-integer",
  "num-iter",
  "num-rational",
  "num-traits",
@@ -2822,15 +2892,15 @@
 version = "0.7.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "681030a937600a36906c185595136d26abfebb4aa9c65701cefcaf8578bb982b"
 dependencies = [
  "proc-macro-crate",
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "object"
 version = "0.32.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a6a622008b6e321afc04970976f62ee297fdbaa6f95318ca343e3eebb9648441"
@@ -2890,15 +2960,15 @@
 name = "openssl-macros"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "openssl-probe"
 version = "0.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf"
@@ -2910,17 +2980,17 @@
 checksum = "5cff92b6f71555b61bb9315f7c64da3ca43d87531622120fea0195fc761b4843"
 dependencies = [
  "cc",
 ]
 
 [[package]]
 name = "openssl-sys"
-version = "0.9.101"
+version = "0.9.102"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dda2b0f344e78efc2facf7d195d098df0dd72151b26ab98da807afc26c198dff"
+checksum = "c597637d56fbc83893a35eb0dd04b2b8e7a50c91e64e9493e398b5df4fb45fa2"
 dependencies = [
  "cc",
  "libc",
  "openssl-src",
  "pkg-config",
  "vcpkg",
 ]
@@ -2978,27 +3048,27 @@
  "redox_syscall",
  "smallvec",
  "windows-targets 0.48.5",
 ]
 
 [[package]]
 name = "parquet"
-version = "50.0.0"
+version = "51.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "547b92ebf0c1177e3892f44c8f79757ee62e678d564a9834189725f2c5b7a750"
+checksum = "096795d4f47f65fd3ee1ec5a98b77ab26d602f2cc785b0e4be5443add17ecc32"
 dependencies = [
  "ahash 0.8.11",
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-data",
  "arrow-ipc",
  "arrow-schema",
  "arrow-select",
- "base64",
+ "base64 0.22.0",
  "brotli",
  "bytes",
  "chrono",
  "flate2",
  "futures",
  "half",
  "hashbrown 0.14.3",
@@ -3048,15 +3118,15 @@
 [[package]]
 name = "petgraph"
 version = "0.6.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e1d3afd2628e69da2be385eb6f2fd57c8ac7977ceeff6dc166ff1657b0e386a9"
 dependencies = [
  "fixedbitset",
- "indexmap 2.2.5",
+ "indexmap 2.2.6",
 ]
 
 [[package]]
 name = "phf"
 version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ade2d8b8f33c7333b51bcf0428d37e217e9f32192ae4772156f65063b8ce03dc"
@@ -3106,22 +3176,22 @@
 name = "pin-project-internal"
 version = "1.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2f38a4412a78282e09a2cf38d195ea5420d15ba0602cb375210efbc877243965"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "pin-project-lite"
-version = "0.2.13"
+version = "0.2.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8afb450f006bf6385ca15ef45d71d2288452bc3683ce2e2cacc0d18e4be60b58"
+checksum = "bda66fc9667c18cb2758a2ac84d1167245054bcf85d5d1aaa6923f45801bdd02"
 
 [[package]]
 name = "pin-utils"
 version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"
 
@@ -3229,17 +3299,17 @@
  "proc-macro2",
  "quote",
  "version_check",
 ]
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.79"
+version = "1.0.81"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e835ff2298f5721608eb1a980ecaee1aef2c132bf95ecc026a11b7bf3c01c02e"
+checksum = "3d1597b0c024618f09a9c3b8655b7e430397a36d23fdafec26d6965e9eec3eba"
 dependencies = [
  "unicode-ident",
 ]
 
 [[package]]
 name = "procfs"
 version = "0.16.0"
@@ -3355,28 +3425,28 @@
 version = "0.20.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7305c720fa01b8055ec95e484a6eca7a83c841267f0dd5280f0c8b8551d2c158"
 dependencies = [
  "proc-macro2",
  "pyo3-macros-backend",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "pyo3-macros-backend"
 version = "0.20.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7c7e9b68bb9c3149c5b0cade5d07f953d6d125eb4337723c4ccdb665f1f96185"
 dependencies = [
  "heck 0.4.1",
  "proc-macro2",
  "pyo3-build-config",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "quickcheck"
 version = "1.0.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "588f6378e4dd99458b60ec275b4477add41ce4fa9f64dcba6f15adccb19b50d6"
@@ -3395,17 +3465,17 @@
  "proc-macro2",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
 name = "quote"
-version = "1.0.35"
+version = "1.0.36"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "291ec9ab5efd934aaf503a6466c5d5251535d108ee747472c3977cc5acc868ef"
+checksum = "0fa76aaf39101c457836aec0ce2316dbdc3ab723cdda1c6bd4e6ad4208acaca7"
 dependencies = [
  "proc-macro2",
 ]
 
 [[package]]
 name = "radium"
 version = "0.7.0"
@@ -3440,17 +3510,17 @@
 checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
 dependencies = [
  "getrandom",
 ]
 
 [[package]]
 name = "rayon"
-version = "1.9.0"
+version = "1.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e4963ed1bc86e4f3ee217022bd855b297cef07fb9eac5dfa1f788b220b49b3bd"
+checksum = "b418a60154510ca1a002a752ca9714984e21e4241e804d32555251faf8b78ffa"
 dependencies = [
  "either",
  "rayon-core",
 ]
 
 [[package]]
 name = "rayon-core"
@@ -3460,30 +3530,30 @@
 dependencies = [
  "crossbeam-deque",
  "crossbeam-utils",
 ]
 
 [[package]]
 name = "redis"
-version = "0.25.2"
+version = "0.25.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "71d64e978fd98a0e6b105d066ba4889a7301fca65aeac850a877d8797343feeb"
+checksum = "6472825949c09872e8f2c50bde59fcefc17748b6be5c90fd67cd8b4daca73bfd"
 dependencies = [
  "arc-swap",
  "async-trait",
  "bytes",
  "combine",
  "futures",
  "futures-util",
  "itoa",
  "percent-encoding",
  "pin-project-lite",
  "rustls",
  "rustls-native-certs",
- "rustls-pemfile 2.1.1",
+ "rustls-pemfile 2.1.2",
  "rustls-pki-types",
  "ryu",
  "sha1_smol",
  "socket2",
  "tokio",
  "tokio-retry",
  "tokio-rustls",
@@ -3499,22 +3569,22 @@
 checksum = "4722d768eff46b75989dd134e5c353f0d6296e5aaa3132e776cbdb56be7731aa"
 dependencies = [
  "bitflags 1.3.2",
 ]
 
 [[package]]
 name = "regex"
-version = "1.10.3"
+version = "1.10.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b62dbe01f0b06f9d8dc7d49e05a0785f153b00b2c227856282f671e0318c9b15"
+checksum = "c117dbdfde9c8308975b6a18d71f3f385c89461f7b3fb054288ecf2a2058ba4c"
 dependencies = [
  "aho-corasick",
  "memchr",
  "regex-automata 0.4.6",
- "regex-syntax 0.8.2",
+ "regex-syntax 0.8.3",
 ]
 
 [[package]]
 name = "regex-automata"
 version = "0.1.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
@@ -3526,28 +3596,28 @@
 name = "regex-automata"
 version = "0.4.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "86b83b8b9847f9bf95ef68afb0b8e6cdb80f498442f5179a29fad448fcc1eaea"
 dependencies = [
  "aho-corasick",
  "memchr",
- "regex-syntax 0.8.2",
+ "regex-syntax 0.8.3",
 ]
 
 [[package]]
 name = "regex-syntax"
 version = "0.6.29"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"
 
 [[package]]
 name = "regex-syntax"
-version = "0.8.2"
+version = "0.8.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c08c74e62047bb2de4ff487b251e4a92e24f48745648451635cec7d591162d9f"
+checksum = "adad44e29e4c806119491a7f06f03de4d1af22c3a680dd47f1e6e179439d1f56"
 
 [[package]]
 name = "relative-path"
 version = "1.9.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e898588f33fdd5b9420719948f9f2a32c922a246964576f71ba7f24f80610fbc"
 
@@ -3562,48 +3632,90 @@
 
 [[package]]
 name = "reqwest"
 version = "0.11.27"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "dd67538700a17451e7cba03ac727fb961abb7607553461627b97de0b89cf4a62"
 dependencies = [
- "base64",
+ "base64 0.21.7",
  "bytes",
  "encoding_rs",
  "futures-core",
  "futures-util",
- "h2 0.3.25",
+ "h2 0.3.26",
  "http 0.2.12",
  "http-body 0.4.6",
  "hyper 0.14.28",
- "hyper-tls",
+ "hyper-tls 0.5.0",
  "ipnet",
  "js-sys",
  "log",
  "mime",
  "native-tls",
  "once_cell",
  "percent-encoding",
  "pin-project-lite",
  "rustls-pemfile 1.0.4",
  "serde",
  "serde_json",
  "serde_urlencoded",
- "sync_wrapper",
+ "sync_wrapper 0.1.2",
  "system-configuration",
  "tokio",
  "tokio-native-tls",
  "tokio-util",
  "tower-service",
  "url",
  "wasm-bindgen",
  "wasm-bindgen-futures",
  "wasm-streams",
  "web-sys",
- "winreg",
+ "winreg 0.50.0",
+]
+
+[[package]]
+name = "reqwest"
+version = "0.12.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "566cafdd92868e0939d3fb961bd0dc25fcfaaed179291093b3d43e6b3150ea10"
+dependencies = [
+ "base64 0.22.0",
+ "bytes",
+ "encoding_rs",
+ "futures-core",
+ "futures-util",
+ "h2 0.4.4",
+ "http 1.1.0",
+ "http-body 1.0.0",
+ "http-body-util",
+ "hyper 1.3.1",
+ "hyper-tls 0.6.0",
+ "hyper-util",
+ "ipnet",
+ "js-sys",
+ "log",
+ "mime",
+ "native-tls",
+ "once_cell",
+ "percent-encoding",
+ "pin-project-lite",
+ "rustls-pemfile 2.1.2",
+ "serde",
+ "serde_json",
+ "serde_urlencoded",
+ "sync_wrapper 0.1.2",
+ "system-configuration",
+ "tokio",
+ "tokio-native-tls",
+ "tower-service",
+ "url",
+ "wasm-bindgen",
+ "wasm-bindgen-futures",
+ "web-sys",
+ "winreg 0.52.0",
 ]
 
 [[package]]
 name = "ring"
 version = "0.17.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c17fa4cb658e3583423e915b9f3acc01cceaee1860e33d59ebae66adc3a2dc0d"
@@ -3644,28 +3756,28 @@
  "proc-macro2",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
 name = "rmp"
-version = "0.8.12"
+version = "0.8.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7f9860a6cc38ed1da53456442089b4dfa35e7cedaa326df63017af88385e6b20"
+checksum = "228ed7c16fa39782c3b3468e974aec2795e9089153cd08ee2e9aefb3613334c4"
 dependencies = [
  "byteorder",
  "num-traits",
  "paste",
 ]
 
 [[package]]
 name = "rmp-serde"
-version = "1.1.2"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bffea85eea980d8a74453e5d02a8d93028f3c34725de143085a844ebe953258a"
+checksum = "938a142ab806f18b88a97b0dea523d39e0fd730a064b035726adcfc58a8a5188"
 dependencies = [
  "byteorder",
  "rmp",
  "serde",
 ]
 
 [[package]]
@@ -3709,23 +3821,23 @@
  "cfg-if",
  "glob",
  "proc-macro2",
  "quote",
  "regex",
  "relative-path",
  "rustc_version",
- "syn 2.0.53",
+ "syn 2.0.60",
  "unicode-ident",
 ]
 
 [[package]]
 name = "rust_decimal"
-version = "1.34.3"
+version = "1.35.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b39449a79f45e8da28c57c341891b69a183044b29518bb8f86dbac9df60bb7df"
+checksum = "1790d1c4c0ca81211399e0e0af16333276f375209e71a37b67698a373db5b47a"
 dependencies = [
  "arrayvec",
  "borsh",
  "bytes",
  "num-traits",
  "rand",
  "rkyv",
@@ -3769,17 +3881,17 @@
  "libc",
  "linux-raw-sys",
  "windows-sys 0.52.0",
 ]
 
 [[package]]
 name = "rustls"
-version = "0.22.2"
+version = "0.22.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e87c9956bd9807afa1f77e0f7594af32566e830e088a5576d27c5b6f30f49d41"
+checksum = "bf4ef73721ac7bcd79b2b315da7779d8fc09718c6b3d2d1b2d94850eb8c18432"
 dependencies = [
  "log",
  "ring",
  "rustls-pki-types",
  "rustls-webpki",
  "subtle",
  "zeroize",
@@ -3788,61 +3900,61 @@
 [[package]]
 name = "rustls-native-certs"
 version = "0.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8f1fb85efa936c42c6d5fc28d2629bb51e4b2f4b8a5211e297d599cc5a093792"
 dependencies = [
  "openssl-probe",
- "rustls-pemfile 2.1.1",
+ "rustls-pemfile 2.1.2",
  "rustls-pki-types",
  "schannel",
  "security-framework",
 ]
 
 [[package]]
 name = "rustls-pemfile"
 version = "1.0.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1c74cae0a4cf6ccbbf5f359f08efdf8ee7e1dc532573bf0db71968cb56b1448c"
 dependencies = [
- "base64",
+ "base64 0.21.7",
 ]
 
 [[package]]
 name = "rustls-pemfile"
-version = "2.1.1"
+version = "2.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f48172685e6ff52a556baa527774f61fcaa884f59daf3375c62a3f1cd2549dab"
+checksum = "29993a25686778eb88d4189742cd713c9bce943bc54251a33509dc63cbacf73d"
 dependencies = [
- "base64",
+ "base64 0.22.0",
  "rustls-pki-types",
 ]
 
 [[package]]
 name = "rustls-pki-types"
-version = "1.3.1"
+version = "1.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5ede67b28608b4c60685c7d54122d4400d90f62b40caee7700e700380a390fa8"
+checksum = "ecd36cc4259e3e4514335c4a138c6b43171a8d61d8f5c9348f9fc7529416f247"
 
 [[package]]
 name = "rustls-webpki"
 version = "0.102.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "faaa0a62740bedb9b2ef5afa303da42764c012f743917351dc9a237ea1663610"
 dependencies = [
  "ring",
  "rustls-pki-types",
  "untrusted",
 ]
 
 [[package]]
 name = "rustversion"
-version = "1.0.14"
+version = "1.0.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7ffc183a10b4478d04cbbbfc96d0873219d962dd5accaff2ffbd4ceb7df837f4"
+checksum = "80af6f9131f277a45a3fba6ce8e2258037bb0477a67e610d3c1fe046ab31de47"
 
 [[package]]
 name = "ryu"
 version = "1.0.17"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e86697c916019a8588c99b5fac3cead74ec0b4b819707a682fd4d23fa0ce1ba1"
 
@@ -3874,30 +3986,30 @@
 name = "seahash"
 version = "4.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1c107b6f4780854c8b126e228ea8869f4d7b71260f962fefb57b996b8959ba6b"
 
 [[package]]
 name = "security-framework"
-version = "2.9.2"
+version = "2.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "05b64fb303737d99b81884b2c63433e9ae28abebe5eb5045dcdd175dc2ecf4de"
+checksum = "770452e37cad93e0a50d5abc3990d2bc351c36d0328f86cefec2f2fb206eaef6"
 dependencies = [
  "bitflags 1.3.2",
  "core-foundation",
  "core-foundation-sys",
  "libc",
  "security-framework-sys",
 ]
 
 [[package]]
 name = "security-framework-sys"
-version = "2.9.1"
+version = "2.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e932934257d3b408ed8f30db49d85ea163bfe74961f017f405b025af298f0c7a"
+checksum = "41f3cc463c0ef97e11c3461a9d3787412d30e8e7eb907c79180c4a57bf7c04ef"
 dependencies = [
  "core-foundation-sys",
  "libc",
 ]
 
 [[package]]
 name = "semver"
@@ -3909,37 +4021,37 @@
 name = "seq-macro"
 version = "0.3.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a3f0bf26fd526d2a95683cd0f87bf103b8539e2ca1ef48ce002d67aad59aa0b4"
 
 [[package]]
 name = "serde"
-version = "1.0.197"
+version = "1.0.198"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3fb1c873e1b9b056a4dc4c0c198b24c3ffa059243875552b2bd0933b1aee4ce2"
+checksum = "9846a40c979031340571da2545a4e5b7c4163bdae79b301d5f86d03979451fcc"
 dependencies = [
  "serde_derive",
 ]
 
 [[package]]
 name = "serde_derive"
-version = "1.0.197"
+version = "1.0.198"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7eb0b34b42edc17f6b7cac84a52a1c5f0e1bb2227e997ca9011ea3dd34e8610b"
+checksum = "e88edab869b01783ba905e7d0153f9fc1a6505a96e4ad3018011eedb838566d9"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "serde_json"
-version = "1.0.114"
+version = "1.0.116"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c5f09b1bd632ef549eaa9f60a1f8de742bdbc698e6cee2095fc84dde5f549ae0"
+checksum = "3e17db7126d17feb94eb3fad46bf1a96b034e8aacbc2e775fe81505f8b0b2813"
 dependencies = [
  "itoa",
  "ryu",
  "serde",
 ]
 
 [[package]]
@@ -4119,31 +4231,31 @@
  "itertools 0.12.1",
  "nom",
  "unicode_categories",
 ]
 
 [[package]]
 name = "sqlparser"
-version = "0.43.1"
+version = "0.44.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f95c4bae5aba7cd30bd506f7140026ade63cff5afd778af8854026f9606bf5d4"
+checksum = "aaf9c7ff146298ffda83a200f8d5084f08dcee1edfc135fcc1d646a45d50ffd6"
 dependencies = [
  "log",
  "sqlparser_derive",
 ]
 
 [[package]]
 name = "sqlparser_derive"
 version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "01b2e185515564f15375f593fb966b5718bc624ba77fe49fa4616ad619690554"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "sqlx"
 version = "0.7.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c9a2ccff1a000a5a59cd33da541d9f2fdcd9e6e8229cc200565942bff36d0aaa"
@@ -4172,15 +4284,15 @@
  "futures-channel",
  "futures-core",
  "futures-intrusive",
  "futures-io",
  "futures-util",
  "hashlink",
  "hex",
- "indexmap 2.2.5",
+ "indexmap 2.2.6",
  "log",
  "memchr",
  "once_cell",
  "paste",
  "percent-encoding",
  "serde",
  "serde_json",
@@ -4236,15 +4348,15 @@
 [[package]]
 name = "sqlx-mysql"
 version = "0.7.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1ed31390216d20e538e447a7a9b959e06ed9fc51c37b514b46eb758016ecd418"
 dependencies = [
  "atoi",
- "base64",
+ "base64 0.21.7",
  "bitflags 2.5.0",
  "byteorder",
  "bytes",
  "crc",
  "digest",
  "dotenvy",
  "either",
@@ -4278,15 +4390,15 @@
 [[package]]
 name = "sqlx-postgres"
 version = "0.7.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7c824eb80b894f926f89a0b9da0c7f435d27cdd35b8c655b114e58223918577e"
 dependencies = [
  "atoi",
- "base64",
+ "base64 0.21.7",
  "bitflags 2.5.0",
  "byteorder",
  "crc",
  "dotenvy",
  "etcetera",
  "futures-channel",
  "futures-core",
@@ -4363,51 +4475,32 @@
 name = "strsim"
 version = "0.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623"
 
 [[package]]
 name = "strum"
-version = "0.25.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "290d54ea6f91c969195bdbcd7442c8c2a2ba87da8bf60a7ee86a235d4bc1e125"
-
-[[package]]
-name = "strum"
 version = "0.26.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5d8cec3501a5194c432b2b7976db6b7d10ec95c253208b45f83f7136aa985e29"
 dependencies = [
- "strum_macros 0.26.2",
-]
-
-[[package]]
-name = "strum_macros"
-version = "0.25.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "23dc1fa9ac9c169a78ba62f0b841814b7abae11bdd047b9c58f893439e309ea0"
-dependencies = [
- "heck 0.4.1",
- "proc-macro2",
- "quote",
- "rustversion",
- "syn 2.0.53",
+ "strum_macros",
 ]
 
 [[package]]
 name = "strum_macros"
 version = "0.26.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c6cf59daf282c0a494ba14fd21610a0325f9f90ec9d1231dea26bcb1d696c946"
 dependencies = [
  "heck 0.4.1",
  "proc-macro2",
  "quote",
  "rustversion",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "subtle"
 version = "2.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "81cdd64d312baedb58e21336b31bc043b77e01cc99033ce76ef539f78e965ebc"
@@ -4421,17 +4514,17 @@
  "proc-macro2",
  "quote",
  "unicode-ident",
 ]
 
 [[package]]
 name = "syn"
-version = "2.0.53"
+version = "2.0.60"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7383cd0e49fff4b6b90ca5670bfd3e9d6a733b3f90c686605aa7eec8c4996032"
+checksum = "909518bc7b1c9b779f1bbf07f2929d35af9f0f37e47c6e9ef7f9dddc1e1821f3"
 dependencies = [
  "proc-macro2",
  "quote",
  "unicode-ident",
 ]
 
 [[package]]
@@ -4439,28 +4532,34 @@
 version = "0.1.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1329189c02ff984e9736652b1631330da25eaa6bc639089ed4915d25446cbe7b"
 dependencies = [
  "proc-macro-error",
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "sync_wrapper"
 version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2047c6ded9c721764247e62cd3b03c09ffc529b2ba5b10ec482ae507a4a70160"
 
 [[package]]
+name = "sync_wrapper"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a7065abeca94b6a8a577f9bd45aa0867a2238b74e8eb67cf10d492bc39351394"
+
+[[package]]
 name = "sysinfo"
-version = "0.30.7"
+version = "0.30.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0c385888ef380a852a16209afc8cfad22795dd8873d69c9a14d2e2088f118d18"
+checksum = "87341a165d73787554941cd5ef55ad728011566fe714e987d1b976c15dbc3a83"
 dependencies = [
  "cfg-if",
  "core-foundation-sys",
  "libc",
  "ntapi",
  "once_cell",
  "rayon",
@@ -4564,15 +4663,15 @@
 name = "thiserror-impl"
 version = "1.0.58"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c61f3ba182994efc43764a46c018c347bc492c79f024e705f46567b418f6d4f7"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "thousands"
 version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3bf63baf9f5039dadc247375c29eb13706706cfde997d0330d05aa63a77d8820"
@@ -4596,17 +4695,17 @@
  "byteorder",
  "integer-encoding",
  "ordered-float",
 ]
 
 [[package]]
 name = "time"
-version = "0.3.34"
+version = "0.3.36"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c8248b6521bb14bc45b4067159b9b6ad792e2d6d754d6c41fb50e29fefe38749"
+checksum = "5dfd88e563464686c916c7e46e623e520ddc6d79fa6641390f2e3fa86e83e885"
 dependencies = [
  "deranged",
  "itoa",
  "num-conv",
  "powerfmt",
  "serde",
  "time-core",
@@ -4617,17 +4716,17 @@
 name = "time-core"
 version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ef927ca75afb808a4d64dd374f00a2adf8d0fcff8e7b184af886c3c87ec4a3f3"
 
 [[package]]
 name = "time-macros"
-version = "0.2.17"
+version = "0.2.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7ba3a3ef41e6672a2f0f001392bb5dcd3ff0a9992d618ca761a11c3121547774"
+checksum = "3f252a68540fde3a3877aeea552b832b40ab9a69e318efd078774a01ddee1ccf"
 dependencies = [
  "num-conv",
  "time-core",
 ]
 
 [[package]]
 name = "tiny-keccak"
@@ -4661,17 +4760,17 @@
 name = "tinyvec_macros"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
 
 [[package]]
 name = "tokio"
-version = "1.36.0"
+version = "1.37.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "61285f6515fa018fb2d1e46eb21223fff441ee8db5d0f1435e8ab4f5cdb80931"
+checksum = "1adbebffeca75fcfd058afa480fb6c0b81e165a0323f9c9d39c9697e37c46787"
 dependencies = [
  "backtrace",
  "bytes",
  "libc",
  "mio",
  "num_cpus",
  "parking_lot",
@@ -4686,15 +4785,15 @@
 name = "tokio-macros"
 version = "2.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5b8a1e28f2deaa14e508979454cb3a223b10b938b45af148bc0986de36f1923b"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "tokio-native-tls"
 version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
@@ -4784,15 +4883,15 @@
 
 [[package]]
 name = "toml_edit"
 version = "0.21.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6a8534fd7f78b5405e860340ad6575217ce99f38d4d5c8f2442cb5ecb50090e1"
 dependencies = [
- "indexmap 2.2.5",
+ "indexmap 2.2.6",
  "toml_datetime",
  "winnow",
 ]
 
 [[package]]
 name = "tower"
 version = "0.4.13"
@@ -4837,15 +4936,15 @@
 name = "tracing-attributes"
 version = "0.1.27"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "34704c8d6ebcbc939824180af020566b01a7c01f80641264eba0999f6c2b6be7"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "tracing-core"
 version = "0.1.32"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c06d3da6113f116aaee68e4d601191614c9053067f9ab7f6edbcb161237daa54"
@@ -4942,30 +5041,30 @@
 dependencies = [
  "cfg-if",
  "static_assertions",
 ]
 
 [[package]]
 name = "typed-builder"
-version = "0.18.1"
+version = "0.18.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "444d8748011b93cb168770e8092458cb0f8854f931ff82fdf6ddfbd72a9c933e"
+checksum = "77739c880e00693faef3d65ea3aad725f196da38b22fdc7ea6ded6e1ce4d3add"
 dependencies = [
  "typed-builder-macro",
 ]
 
 [[package]]
 name = "typed-builder-macro"
-version = "0.18.1"
+version = "0.18.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "563b3b88238ec95680aef36bdece66896eaa7ce3c0f1b4f39d38fb2435261352"
+checksum = "1f718dfaf347dcb5b983bfc87608144b0bad87970aebcbea5ce44d2a30c08e63"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "typenum"
 version = "1.17.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"
@@ -5138,15 +5237,15 @@
 checksum = "614d787b966d3989fa7bb98a654e369c762374fd3213d212cfc0251257e747da"
 dependencies = [
  "bumpalo",
  "log",
  "once_cell",
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-futures"
 version = "0.4.42"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -5172,15 +5271,15 @@
 name = "wasm-bindgen-macro-support"
 version = "0.2.92"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e94f17b526d0a461a191c78ea52bbce64071ed5c04c9ffe424dcb38f74171bb7"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
  "wasm-bindgen-backend",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-shared"
 version = "0.2.92"
@@ -5263,24 +5362,24 @@
 [[package]]
 name = "windows"
 version = "0.52.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e48a53791691ab099e5e2ad123536d0fff50652600abaf43bbf952894110d0be"
 dependencies = [
  "windows-core",
- "windows-targets 0.52.4",
+ "windows-targets 0.52.5",
 ]
 
 [[package]]
 name = "windows-core"
 version = "0.52.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
 dependencies = [
- "windows-targets 0.52.4",
+ "windows-targets 0.52.5",
 ]
 
 [[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
@@ -5290,15 +5389,15 @@
 
 [[package]]
 name = "windows-sys"
 version = "0.52.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
 dependencies = [
- "windows-targets 0.52.4",
+ "windows-targets 0.52.5",
 ]
 
 [[package]]
 name = "windows-targets"
 version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
@@ -5310,110 +5409,117 @@
  "windows_x86_64_gnu 0.48.5",
  "windows_x86_64_gnullvm 0.48.5",
  "windows_x86_64_msvc 0.48.5",
 ]
 
 [[package]]
 name = "windows-targets"
-version = "0.52.4"
+version = "0.52.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7dd37b7e5ab9018759f893a1952c9420d060016fc19a472b4bb20d1bdd694d1b"
+checksum = "6f0713a46559409d202e70e28227288446bf7841d3211583a4b53e3f6d96e7eb"
 dependencies = [
- "windows_aarch64_gnullvm 0.52.4",
- "windows_aarch64_msvc 0.52.4",
- "windows_i686_gnu 0.52.4",
- "windows_i686_msvc 0.52.4",
- "windows_x86_64_gnu 0.52.4",
- "windows_x86_64_gnullvm 0.52.4",
- "windows_x86_64_msvc 0.52.4",
+ "windows_aarch64_gnullvm 0.52.5",
+ "windows_aarch64_msvc 0.52.5",
+ "windows_i686_gnu 0.52.5",
+ "windows_i686_gnullvm",
+ "windows_i686_msvc 0.52.5",
+ "windows_x86_64_gnu 0.52.5",
+ "windows_x86_64_gnullvm 0.52.5",
+ "windows_x86_64_msvc 0.52.5",
 ]
 
 [[package]]
 name = "windows_aarch64_gnullvm"
 version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"
 
 [[package]]
 name = "windows_aarch64_gnullvm"
-version = "0.52.4"
+version = "0.52.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bcf46cf4c365c6f2d1cc93ce535f2c8b244591df96ceee75d8e83deb70a9cac9"
+checksum = "7088eed71e8b8dda258ecc8bac5fb1153c5cffaf2578fc8ff5d61e23578d3263"
 
 [[package]]
 name = "windows_aarch64_msvc"
 version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"
 
 [[package]]
 name = "windows_aarch64_msvc"
-version = "0.52.4"
+version = "0.52.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "da9f259dd3bcf6990b55bffd094c4f7235817ba4ceebde8e6d11cd0c5633b675"
+checksum = "9985fd1504e250c615ca5f281c3f7a6da76213ebd5ccc9561496568a2752afb6"
 
 [[package]]
 name = "windows_i686_gnu"
 version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"
 
 [[package]]
 name = "windows_i686_gnu"
-version = "0.52.4"
+version = "0.52.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "88ba073cf16d5372720ec942a8ccbf61626074c6d4dd2e745299726ce8b89670"
+
+[[package]]
+name = "windows_i686_gnullvm"
+version = "0.52.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b474d8268f99e0995f25b9f095bc7434632601028cf86590aea5c8a5cb7801d3"
+checksum = "87f4261229030a858f36b459e748ae97545d6f1ec60e5e0d6a3d32e0dc232ee9"
 
 [[package]]
 name = "windows_i686_msvc"
 version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"
 
 [[package]]
 name = "windows_i686_msvc"
-version = "0.52.4"
+version = "0.52.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1515e9a29e5bed743cb4415a9ecf5dfca648ce85ee42e15873c3cd8610ff8e02"
+checksum = "db3c2bf3d13d5b658be73463284eaf12830ac9a26a90c717b7f771dfe97487bf"
 
 [[package]]
 name = "windows_x86_64_gnu"
 version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"
 
 [[package]]
 name = "windows_x86_64_gnu"
-version = "0.52.4"
+version = "0.52.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5eee091590e89cc02ad514ffe3ead9eb6b660aedca2183455434b93546371a03"
+checksum = "4e4246f76bdeff09eb48875a0fd3e2af6aada79d409d33011886d3e1581517d9"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
 version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
-version = "0.52.4"
+version = "0.52.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "77ca79f2451b49fa9e2af39f0747fe999fcda4f5e241b2898624dca97a1f2177"
+checksum = "852298e482cd67c356ddd9570386e2862b5673c85bd5f88df9ab6802b334c596"
 
 [[package]]
 name = "windows_x86_64_msvc"
 version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"
 
 [[package]]
 name = "windows_x86_64_msvc"
-version = "0.52.4"
+version = "0.52.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "32b752e52a2da0ddfbdbcc6fceadfeede4c939ed16d13e648833a61dfb611ed8"
+checksum = "bec47e5bfd1bff0eeaf6d8b485cc1074891a197ab4225d504cb7a1ab88b02bf0"
 
 [[package]]
 name = "winnow"
 version = "0.5.40"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f593a95398737aeed53e489c785df13f3618e41dbcd6718c6addbf1395aa6876"
 dependencies = [
@@ -5427,14 +5533,24 @@
 checksum = "524e57b2c537c0f9b1e69f1965311ec12182b4122e45035b1508cd24d2adadb1"
 dependencies = [
  "cfg-if",
  "windows-sys 0.48.0",
 ]
 
 [[package]]
+name = "winreg"
+version = "0.52.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a277a57398d4bfa075df44f501a17cfdf8542d224f0d36095a2adc7aee4ef0a5"
+dependencies = [
+ "cfg-if",
+ "windows-sys 0.48.0",
+]
+
+[[package]]
 name = "wyz"
 version = "0.5.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "05f360fc0b24296329c78fda852a1e9ae82de9cf7b27dae4b7f62f118f77b9ed"
 dependencies = [
  "tap",
 ]
@@ -5461,43 +5577,43 @@
 name = "zerocopy-derive"
 version = "0.7.32"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9ce1b18ccd8e73a9321186f97e46f9f04b778851177567b1975109d26a08d2a6"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.53",
+ "syn 2.0.60",
 ]
 
 [[package]]
 name = "zeroize"
 version = "1.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "525b4ec142c6b68a2d10f01f7bbf6755599ca3f81ea53b8431b7dd348f5fdb2d"
 
 [[package]]
 name = "zstd"
-version = "0.13.0"
+version = "0.13.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bffb3309596d527cfcba7dfc6ed6052f1d39dfbd7c867aa2e865e4a449c10110"
+checksum = "2d789b1514203a1120ad2429eae43a7bd32b90976a7bb8a05f7ec02fa88cc23a"
 dependencies = [
  "zstd-safe",
 ]
 
 [[package]]
 name = "zstd-safe"
-version = "7.0.0"
+version = "7.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "43747c7422e2924c11144d5229878b98180ef8b06cca4ab5af37afc8a8d8ea3e"
+checksum = "1cd99b45c6bc03a018c8b8a86025678c87e55526064e38f9df301989dce7ec0a"
 dependencies = [
  "zstd-sys",
 ]
 
 [[package]]
 name = "zstd-sys"
-version = "2.0.9+zstd.1.5.5"
+version = "2.0.10+zstd.1.5.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9e16efa8a874a0481a574084d34cc26fdb3b99627480f785888deb6386506656"
+checksum = "c253a4914af5bafc8fa8c86ee400827e83cf6ec01195ec1f1ed8441bf00d65aa"
 dependencies = [
  "cc",
  "pkg-config",
 ]
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/Cargo.toml`

 * *Files 12% similar despite different names*

```diff
@@ -13,50 +13,52 @@
     "network",
     "network/tokio-tungstenite",
     "persistence",
     "pyo3",
 ]
 
 [workspace.package]
-rust-version = "1.77.0"
-version = "0.20.0"
+rust-version = "1.77.1"
+version = "0.21.0"
 edition = "2021"
 authors = ["Nautech Systems <info@nautechsystems.io>"]
 description = "A high-performance algorithmic trading platform and event-driven backtester"
 documentation = "https://docs.nautilustrader.io"
 
 [workspace.dependencies]
-anyhow = "1.0.81"
-chrono = "0.4.35"
+anyhow = "1.0.82"
+chrono = "0.4.38"
+derive_builder = "0.20.0"
 futures = "0.3.30"
-indexmap = { version = "2.2.5", features = ["serde"] }
-itoa = "1.0.10"
+indexmap = { version = "2.2.6", features = ["serde"] }
+itertools = "0.12.1"
+itoa = "1.0.11"
 once_cell = "1.19.0"
 log = { version = "0.4.21", features = ["std", "kv_unstable", "serde", "release_max_level_debug"] }
 pyo3 = { version = "0.20.3", features = ["rust_decimal"] }
 pyo3-asyncio = { version = "0.20.0", features = ["tokio-runtime", "tokio", "attributes"] }
 rand = "0.8.5"
-redis = { version = "0.25.2", features = [
+redis = { version = "0.25.3", features = [
     "connection-manager",
     "keep-alive",
     "tls-rustls",
     "tls-rustls-webpki-roots",
     "tokio-comp",
     "tokio-rustls-comp",
 ] }
-rmp-serde = "1.1.2"
-rust_decimal = "1.34.3"
+rmp-serde = "1.2.0"
+rust_decimal = "1.35.0"
 rust_decimal_macros = "1.34.2"
-serde = { version = "1.0.197", features = ["derive"] }
-serde_json = "1.0.114"
+serde = { version = "1.0.198", features = ["derive"] }
+serde_json = "1.0.116"
 strum = { version = "0.26.2", features = ["derive"] }
 thiserror = "1.0.58"
 thousands = "0.2.0"
 tracing = "0.1.40"
-tokio = { version = "1.36.0", features = ["full"] }
+tokio = { version = "1.37.0", features = ["full"] }
 ustr = { version = "1.0.0", features = ["serde"] }
 uuid = { version = "1.8.0", features = ["v4"] }
 
 # dev-dependencies
 criterion = "0.5.1"
 float-cmp = "0.9.0"
 iai = "0.1"
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/LICENSE` & `nautilus_trader-1.191.0/LICENSE`

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,14 @@
                    GNU LESSER GENERAL PUBLIC LICENSE
                        Version 3, 29 June 2007
 
  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
-
   This version of the GNU Lesser General Public License incorporates
 the terms and conditions of version 3 of the GNU General Public
 License, supplemented by the additional permissions listed below.
 
   0. Additional Definitions.
 
   As used herein, "this License" refers to version 3 of the GNU Lesser
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/README.md` & `nautilus_trader-1.191.0/nautilus_core/README.md`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/accounting/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/accounting/Cargo.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/accounting/src/account/base.rs` & `nautilus_trader-1.191.0/nautilus_core/accounting/src/account/base.rs`

 * *Files 2% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 
 use std::collections::HashMap;
 
 use nautilus_model::{
     enums::{AccountType, LiquiditySide, OrderSide},
     events::{account::state::AccountState, order::filled::OrderFilled},
     identifiers::account_id::AccountId,
-    instruments::Instrument,
+    instruments::InstrumentAny,
     position::Position,
     types::{
         balance::AccountBalance, currency::Currency, money::Money, price::Price, quantity::Quantity,
     },
 };
 use rust_decimal::prelude::ToPrimitive;
 
@@ -133,17 +133,17 @@
     }
 
     pub fn base_apply(&mut self, event: AccountState) {
         self.update_balances(event.balances.clone());
         self.events.push(event);
     }
 
-    pub fn base_calculate_balance_locked<T: Instrument>(
+    pub fn base_calculate_balance_locked(
         &mut self,
-        instrument: T,
+        instrument: InstrumentAny,
         side: OrderSide,
         quantity: Quantity,
         price: Price,
         use_quote_for_inverse: Option<bool>,
     ) -> anyhow::Result<Money> {
         let base_currency = instrument
             .base_currency()
@@ -168,17 +168,17 @@
         } else if side == OrderSide::Sell {
             Ok(Money::new(locked, base_currency).unwrap())
         } else {
             panic!("Invalid order side in `base_calculate_balance_locked`")
         }
     }
 
-    pub fn base_calculate_pnls<T: Instrument>(
+    pub fn base_calculate_pnls(
         &self,
-        instrument: T,
+        instrument: InstrumentAny,
         fill: OrderFilled,
         position: Option<Position>,
     ) -> anyhow::Result<Vec<Money>> {
         let mut pnls: HashMap<Currency, Money> = HashMap::new();
         let quote_currency = instrument.quote_currency();
         let base_currency = instrument.base_currency();
 
@@ -210,17 +210,17 @@
             );
         } else {
             panic!("Invalid order side in   base_calculate_pnls")
         }
         Ok(pnls.into_values().collect())
     }
 
-    pub fn base_calculate_commission<T: Instrument>(
+    pub fn base_calculate_commission(
         &self,
-        instrument: T,
+        instrument: InstrumentAny,
         last_qty: Quantity,
         last_px: Price,
         liquidity_side: LiquiditySide,
         use_quote_for_inverse: Option<bool>,
     ) -> anyhow::Result<Money> {
         assert!(
             liquidity_side != LiquiditySide::NoLiquiditySide,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/accounting/src/account/cash.rs` & `nautilus_trader-1.191.0/nautilus_core/accounting/src/account/cash.rs`

 * *Files 3% similar despite different names*

```diff
@@ -15,25 +15,27 @@
 
 use std::{
     collections::HashMap,
     fmt::Display,
     ops::{Deref, DerefMut},
 };
 
+use nautilus_common::interface::account::Account;
 use nautilus_model::{
     enums::{AccountType, LiquiditySide, OrderSide},
     events::{account::state::AccountState, order::filled::OrderFilled},
-    instruments::Instrument,
+    identifiers::account_id::AccountId,
+    instruments::InstrumentAny,
     position::Position,
     types::{
         balance::AccountBalance, currency::Currency, money::Money, price::Price, quantity::Quantity,
     },
 };
 
-use crate::account::{base::BaseAccount, Account};
+use crate::account::base::BaseAccount;
 
 #[derive(Debug)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.accounting")
 )]
 pub struct CashAccount {
@@ -59,77 +61,113 @@
     #[must_use]
     pub fn is_unleveraged(&self) -> bool {
         false
     }
 }
 
 impl Account for CashAccount {
+    fn id(&self) -> AccountId {
+        self.id
+    }
+
+    fn account_type(&self) -> AccountType {
+        self.account_type
+    }
+
+    fn base_currency(&self) -> Option<Currency> {
+        self.base_currency
+    }
+
+    fn is_cash_account(&self) -> bool {
+        self.account_type == AccountType::Cash
+    }
+
+    fn is_margin_account(&self) -> bool {
+        self.account_type == AccountType::Margin
+    }
+
+    fn calculated_account_state(&self) -> bool {
+        false // TODO (implement this logic)
+    }
+
     fn balance_total(&self, currency: Option<Currency>) -> Option<Money> {
         self.base_balance_total(currency)
     }
+
     fn balances_total(&self) -> HashMap<Currency, Money> {
         self.base_balances_total()
     }
 
     fn balance_free(&self, currency: Option<Currency>) -> Option<Money> {
         self.base_balance_free(currency)
     }
 
     fn balances_free(&self) -> HashMap<Currency, Money> {
         self.base_balances_free()
     }
+
     fn balance_locked(&self, currency: Option<Currency>) -> Option<Money> {
         self.base_balance_locked(currency)
     }
+
     fn balances_locked(&self) -> HashMap<Currency, Money> {
         self.base_balances_locked()
     }
+
     fn last_event(&self) -> Option<AccountState> {
         self.base_last_event()
     }
+
     fn events(&self) -> Vec<AccountState> {
         self.events.clone()
     }
+
     fn event_count(&self) -> usize {
         self.events.len()
     }
+
     fn currencies(&self) -> Vec<Currency> {
         self.balances.keys().copied().collect()
     }
+
     fn starting_balances(&self) -> HashMap<Currency, Money> {
         self.balances_starting.clone()
     }
+
     fn balances(&self) -> HashMap<Currency, AccountBalance> {
         self.balances.clone()
     }
+
     fn apply(&mut self, event: AccountState) {
         self.base_apply(event);
     }
 
-    fn calculate_balance_locked<T: Instrument>(
+    fn calculate_balance_locked(
         &mut self,
-        instrument: T,
+        instrument: InstrumentAny,
         side: OrderSide,
         quantity: Quantity,
         price: Price,
         use_quote_for_inverse: Option<bool>,
     ) -> anyhow::Result<Money> {
         self.base_calculate_balance_locked(instrument, side, quantity, price, use_quote_for_inverse)
     }
-    fn calculate_pnls<T: Instrument>(
+
+    fn calculate_pnls(
         &self,
-        instrument: T,
+        instrument: InstrumentAny,
         fill: OrderFilled,
         position: Option<Position>,
     ) -> anyhow::Result<Vec<Money>> {
         self.base_calculate_pnls(instrument, fill, position)
     }
-    fn calculate_commission<T: Instrument>(
+
+    fn calculate_commission(
         &self,
-        instrument: T,
+        instrument: InstrumentAny,
         last_qty: Quantity,
         last_px: Price,
         liquidity_side: LiquiditySide,
         use_quote_for_inverse: Option<bool>,
     ) -> anyhow::Result<Money> {
         self.base_calculate_commission(
             instrument,
@@ -181,30 +219,30 @@
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use std::collections::{HashMap, HashSet};
 
-    use nautilus_common::{factories::OrderFactory, stubs::*};
+    use nautilus_common::{factories::OrderFactory, interface::account::Account, stubs::*};
     use nautilus_model::{
         enums::{AccountType, LiquiditySide, OrderSide},
         events::account::{state::AccountState, stubs::*},
         identifiers::{account_id::AccountId, position_id::PositionId, strategy_id::StrategyId},
         instruments::{
             crypto_perpetual::CryptoPerpetual, currency_pair::CurrencyPair, equity::Equity,
-            stubs::*,
+            stubs::*, Instrument,
         },
         orders::{market::MarketOrder, stubs::TestOrderEventStubs},
         position::Position,
         types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
     };
     use rstest::rstest;
 
-    use crate::account::{cash::CashAccount, stubs::*, Account};
+    use crate::account::{cash::CashAccount, stubs::*};
 
     #[rstest]
     fn test_display(cash_account: CashAccount) {
         assert_eq!(
             format!("{cash_account}"),
             "CashAccount(id=SIM-001, type=CASH, base=USD)"
         );
@@ -348,15 +386,15 @@
     #[rstest]
     fn test_calculate_balance_locked_buy(
         mut cash_account_million_usd: CashAccount,
         audusd_sim: CurrencyPair,
     ) {
         let balance_locked = cash_account_million_usd
             .calculate_balance_locked(
-                audusd_sim,
+                audusd_sim.into_any(),
                 OrderSide::Buy,
                 Quantity::from("1000000"),
                 Price::from("0.8"),
                 None,
             )
             .unwrap();
         assert_eq!(balance_locked, Money::from("800032 USD"));
@@ -365,15 +403,15 @@
     #[rstest]
     fn test_calculate_balance_locked_sell(
         mut cash_account_million_usd: CashAccount,
         audusd_sim: CurrencyPair,
     ) {
         let balance_locked = cash_account_million_usd
             .calculate_balance_locked(
-                audusd_sim,
+                audusd_sim.into_any(),
                 OrderSide::Sell,
                 Quantity::from("1000000"),
                 Price::from("0.8"),
                 None,
             )
             .unwrap();
         assert_eq!(balance_locked, Money::from("1000040 AUD"));
@@ -382,15 +420,15 @@
     #[rstest]
     fn test_calculate_balance_locked_sell_no_base_currency(
         mut cash_account_million_usd: CashAccount,
         equity_aapl: Equity,
     ) {
         let balance_locked = cash_account_million_usd
             .calculate_balance_locked(
-                equity_aapl,
+                equity_aapl.into_any(),
                 OrderSide::Sell,
                 Quantity::from("100"),
                 Price::from("1500.0"),
                 None,
             )
             .unwrap();
         assert_eq!(balance_locked, Money::from("100 USD"));
@@ -422,15 +460,15 @@
             Some(Price::from("0.8")),
             None,
             None,
             None,
         );
         let position = Position::new(audusd_sim, fill).unwrap();
         let pnls = cash_account_million_usd
-            .calculate_pnls(audusd_sim, fill, Some(position))
+            .calculate_pnls(audusd_sim.into_any(), fill, Some(position))
             .unwrap();
         assert_eq!(pnls, vec![Money::from("-800000 USD")]);
     }
 
     #[rstest]
     fn test_calculate_pnls_for_multi_currency_cash_account_btcusdt(
         cash_account_multi: CashAccount,
@@ -457,15 +495,19 @@
             Some(Price::from("45500.00")),
             None,
             None,
             None,
         );
         let position = Position::new(currency_pair_btcusdt, fill1).unwrap();
         let result1 = cash_account_multi
-            .calculate_pnls(currency_pair_btcusdt, fill1, Some(position.clone()))
+            .calculate_pnls(
+                currency_pair_btcusdt.into_any(),
+                fill1,
+                Some(position.clone()),
+            )
             .unwrap();
         let order2 = order_factory.market(
             currency_pair_btcusdt.id,
             OrderSide::Buy,
             Quantity::from("0.5"),
             None,
             None,
@@ -482,15 +524,15 @@
             Some(PositionId::new("P-123456").unwrap()),
             Some(Price::from("45500.00")),
             None,
             None,
             None,
         );
         let result2 = cash_account_multi
-            .calculate_pnls(currency_pair_btcusdt, fill2, Some(position))
+            .calculate_pnls(currency_pair_btcusdt.into_any(), fill2, Some(position))
             .unwrap();
         // use hash set to ignore order of results
         let result1_set: HashSet<Money> = result1.into_iter().collect();
         let result1_expected: HashSet<Money> =
             vec![Money::from("22750 USDT"), Money::from("-0.5 BTC")]
                 .into_iter()
                 .collect();
@@ -510,15 +552,15 @@
         #[case] use_quote_for_inverse: bool,
         #[case] expected: Money,
         cash_account_million_usd: CashAccount,
         xbtusd_bitmex: CryptoPerpetual,
     ) {
         let result = cash_account_million_usd
             .calculate_commission(
-                xbtusd_bitmex,
+                xbtusd_bitmex.into_any(),
                 Quantity::from("100000"),
                 Price::from("11450.50"),
                 LiquiditySide::Maker,
                 Some(use_quote_for_inverse),
             )
             .unwrap();
         assert_eq!(result, expected);
@@ -527,15 +569,15 @@
     #[rstest]
     fn test_calculate_commission_for_taker_fx(
         cash_account_million_usd: CashAccount,
         audusd_sim: CurrencyPair,
     ) {
         let result = cash_account_million_usd
             .calculate_commission(
-                audusd_sim,
+                audusd_sim.into_any(),
                 Quantity::from("1500000"),
                 Price::from("0.8005"),
                 LiquiditySide::Taker,
                 None,
             )
             .unwrap();
         assert_eq!(result, Money::from("24.02 USD"));
@@ -544,30 +586,30 @@
     #[rstest]
     fn test_calculate_commission_crypto_taker(
         cash_account_million_usd: CashAccount,
         xbtusd_bitmex: CryptoPerpetual,
     ) {
         let result = cash_account_million_usd
             .calculate_commission(
-                xbtusd_bitmex,
+                xbtusd_bitmex.into_any(),
                 Quantity::from("100000"),
                 Price::from("11450.50"),
                 LiquiditySide::Taker,
                 None,
             )
             .unwrap();
         assert_eq!(result, Money::from("0.00654993 BTC"));
     }
 
     #[rstest]
     fn test_calculate_commission_fx_taker(cash_account_million_usd: CashAccount) {
         let instrument = usdjpy_idealpro();
         let result = cash_account_million_usd
             .calculate_commission(
-                instrument,
+                instrument.into_any(),
                 Quantity::from("2200000"),
                 Price::from("120.310"),
                 LiquiditySide::Taker,
                 None,
             )
             .unwrap();
         assert_eq!(result, Money::from("5294 JPY"));
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/accounting/src/account/margin.rs` & `nautilus_trader-1.191.0/nautilus_core/accounting/src/account/margin.rs`

 * *Files 2% similar despite different names*

```diff
@@ -18,31 +18,32 @@
 use std::{
     collections::HashMap,
     fmt::Display,
     hash::{Hash, Hasher},
     ops::{Deref, DerefMut},
 };
 
+use nautilus_common::interface::account::Account;
 use nautilus_model::{
     enums::{AccountType, LiquiditySide, OrderSide},
     events::{account::state::AccountState, order::filled::OrderFilled},
-    identifiers::instrument_id::InstrumentId,
-    instruments::Instrument,
+    identifiers::{account_id::AccountId, instrument_id::InstrumentId},
+    instruments::{Instrument, InstrumentAny},
     position::Position,
     types::{
         balance::{AccountBalance, MarginBalance},
         currency::Currency,
         money::Money,
         price::Price,
         quantity::Quantity,
     },
 };
 use rust_decimal::prelude::ToPrimitive;
 
-use crate::account::{base::BaseAccount, Account};
+use crate::account::base::BaseAccount;
 
 #[derive(Debug)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.accounting")
 )]
 pub struct MarginAccount {
@@ -269,14 +270,38 @@
 impl DerefMut for MarginAccount {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.base
     }
 }
 
 impl Account for MarginAccount {
+    fn id(&self) -> AccountId {
+        self.id
+    }
+
+    fn account_type(&self) -> AccountType {
+        self.account_type
+    }
+
+    fn base_currency(&self) -> Option<Currency> {
+        self.base_currency
+    }
+
+    fn is_cash_account(&self) -> bool {
+        self.account_type == AccountType::Cash
+    }
+
+    fn is_margin_account(&self) -> bool {
+        self.account_type == AccountType::Margin
+    }
+
+    fn calculated_account_state(&self) -> bool {
+        false // TODO (implement this logic)
+    }
+
     fn balance_total(&self, currency: Option<Currency>) -> Option<Money> {
         self.base_balance_total(currency)
     }
     fn balances_total(&self) -> HashMap<Currency, Money> {
         self.base_balances_total()
     }
 
@@ -310,35 +335,35 @@
     }
     fn balances(&self) -> HashMap<Currency, AccountBalance> {
         self.balances.clone()
     }
     fn apply(&mut self, event: AccountState) {
         self.base_apply(event);
     }
-    fn calculate_balance_locked<T: Instrument>(
+    fn calculate_balance_locked(
         &mut self,
-        instrument: T,
+        instrument: InstrumentAny,
         side: OrderSide,
         quantity: Quantity,
         price: Price,
         use_quote_for_inverse: Option<bool>,
     ) -> anyhow::Result<Money> {
         self.base_calculate_balance_locked(instrument, side, quantity, price, use_quote_for_inverse)
     }
-    fn calculate_pnls<T: Instrument>(
+    fn calculate_pnls(
         &self,
-        instrument: T,
+        instrument: InstrumentAny,
         fill: OrderFilled,
         position: Option<Position>,
     ) -> anyhow::Result<Vec<Money>> {
         self.base_calculate_pnls(instrument, fill, position)
     }
-    fn calculate_commission<T: Instrument>(
+    fn calculate_commission(
         &self,
-        instrument: T,
+        instrument: InstrumentAny,
         last_qty: Quantity,
         last_px: Price,
         liquidity_side: LiquiditySide,
         use_quote_for_inverse: Option<bool>,
     ) -> anyhow::Result<Money> {
         self.base_calculate_commission(
             instrument,
@@ -382,23 +407,24 @@
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use std::collections::HashMap;
 
+    use nautilus_common::interface::account::Account;
     use nautilus_model::{
         events::account::{state::AccountState, stubs::*},
         identifiers::{instrument_id::InstrumentId, stubs::*},
         instruments::{crypto_perpetual::CryptoPerpetual, currency_pair::CurrencyPair, stubs::*},
         types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
     };
     use rstest::rstest;
 
-    use crate::account::{margin::MarginAccount, stubs::*, Account};
+    use crate::account::{margin::MarginAccount, stubs::*};
 
     #[rstest]
     fn test_display(margin_account: MarginAccount) {
         assert_eq!(
             margin_account.to_string(),
             "MarginAccount(id=SIM-001, type=MARGIN, base=USD)"
         );
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/accounting/src/account/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/interface/account.rs`

 * *Files 12% similar despite different names*

```diff
@@ -12,63 +12,60 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::collections::HashMap;
 
 use nautilus_model::{
-    enums::{LiquiditySide, OrderSide},
+    enums::{AccountType, LiquiditySide, OrderSide},
     events::{account::state::AccountState, order::filled::OrderFilled},
-    instruments::Instrument,
+    identifiers::account_id::AccountId,
+    instruments::InstrumentAny,
     position::Position,
     types::{
         balance::AccountBalance, currency::Currency, money::Money, price::Price, quantity::Quantity,
     },
 };
 
 pub trait Account {
+    fn id(&self) -> AccountId;
+    fn account_type(&self) -> AccountType;
+    fn base_currency(&self) -> Option<Currency>;
+    fn is_cash_account(&self) -> bool;
+    fn is_margin_account(&self) -> bool;
+    fn calculated_account_state(&self) -> bool;
     fn balance_total(&self, currency: Option<Currency>) -> Option<Money>;
     fn balances_total(&self) -> HashMap<Currency, Money>;
     fn balance_free(&self, currency: Option<Currency>) -> Option<Money>;
     fn balances_free(&self) -> HashMap<Currency, Money>;
-
     fn balance_locked(&self, currency: Option<Currency>) -> Option<Money>;
     fn balances_locked(&self) -> HashMap<Currency, Money>;
     fn last_event(&self) -> Option<AccountState>;
     fn events(&self) -> Vec<AccountState>;
     fn event_count(&self) -> usize;
     fn currencies(&self) -> Vec<Currency>;
     fn starting_balances(&self) -> HashMap<Currency, Money>;
     fn balances(&self) -> HashMap<Currency, AccountBalance>;
     fn apply(&mut self, event: AccountState);
-    fn calculate_balance_locked<T: Instrument>(
+    fn calculate_balance_locked(
         &mut self,
-        instrument: T,
+        instrument: InstrumentAny,
         side: OrderSide,
         quantity: Quantity,
         price: Price,
         use_quote_for_inverse: Option<bool>,
     ) -> anyhow::Result<Money>;
-
-    fn calculate_pnls<T: Instrument>(
+    fn calculate_pnls(
         &self,
-        instrument: T,
+        instrument: InstrumentAny,
         fill: OrderFilled,
         position: Option<Position>,
     ) -> anyhow::Result<Vec<Money>>;
-
-    fn calculate_commission<T: Instrument>(
+    fn calculate_commission(
         &self,
-        instrument: T,
+        instrument: InstrumentAny,
         last_qty: Quantity,
         last_px: Price,
         liquidity_side: LiquiditySide,
         use_quote_for_inverse: Option<bool>,
     ) -> anyhow::Result<Money>;
 }
-
-pub mod base;
-pub mod cash;
-pub mod margin;
-
-#[cfg(test)]
-pub mod stubs;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/accounting/src/account/stubs.rs` & `nautilus_trader-1.191.0/nautilus_core/accounting/src/account/stubs.rs`

 * *Files 3% similar despite different names*

```diff
@@ -9,23 +9,24 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+use nautilus_common::interface::account::Account;
 use nautilus_model::{
     enums::LiquiditySide,
     events::account::{state::AccountState, stubs::*},
-    instruments::Instrument,
+    instruments::InstrumentAny,
     types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
 };
 use rstest::fixture;
 
-use crate::account::{cash::CashAccount, margin::MarginAccount, Account};
+use crate::account::{cash::CashAccount, margin::MarginAccount};
 
 #[fixture]
 pub fn margin_account(margin_account_state: AccountState) -> MarginAccount {
     MarginAccount::new(margin_account_state, true).unwrap()
 }
 
 #[fixture]
@@ -39,16 +40,17 @@
 }
 
 #[fixture]
 pub fn cash_account_multi(cash_account_state_multi: AccountState) -> CashAccount {
     CashAccount::new(cash_account_state_multi, true).unwrap()
 }
 
-pub fn calculate_commission<T: Instrument>(
-    instrument: T,
+#[must_use]
+pub fn calculate_commission(
+    instrument: InstrumentAny,
     quantity: Quantity,
     price: Price,
     currency: Option<Currency>,
 ) -> Money {
     let account_state = if Some(Currency::USDT()) == currency {
         cash_account_state_million_usdt()
     } else {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/accounting/src/lib.rs` & `nautilus_trader-1.191.0/nautilus_core/accounting/src/lib.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/accounting/src/python/margin.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/position.rs`

 * *Files 27% similar despite different names*

```diff
@@ -9,299 +9,415 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_core::python::to_pyvalue_err;
-use nautilus_model::{
-    events::account::state::AccountState,
-    identifiers::{account_id::AccountId, instrument_id::InstrumentId},
-    instruments::{
-        crypto_future::CryptoFuture, crypto_perpetual::CryptoPerpetual,
-        currency_pair::CurrencyPair, equity::Equity, futures_contract::FuturesContract,
-        options_contract::OptionsContract,
-    },
-    types::{money::Money, price::Price, quantity::Quantity},
+use nautilus_core::python::serialization::from_dict_pyo3;
+use pyo3::{
+    basic::CompareOp,
+    prelude::*,
+    types::{PyDict, PyList},
 };
-use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
+use rust_decimal::prelude::ToPrimitive;
 
-use crate::account::margin::MarginAccount;
+use crate::{
+    enums::{OrderSide, PositionSide},
+    events::order::filled::OrderFilled,
+    identifiers::{
+        client_order_id::ClientOrderId, instrument_id::InstrumentId, position_id::PositionId,
+        strategy_id::StrategyId, symbol::Symbol, trade_id::TradeId, trader_id::TraderId,
+        venue::Venue, venue_order_id::VenueOrderId,
+    },
+    instruments::InstrumentAny,
+    position::Position,
+    python::instruments::convert_pyobject_to_instrument_any,
+    types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
+};
 
 #[pymethods]
-impl MarginAccount {
+impl Position {
     #[new]
-    fn py_new(event: AccountState, calculate_account_state: bool) -> PyResult<Self> {
-        Self::new(event, calculate_account_state).map_err(to_pyvalue_err)
+    fn py_new(py: Python, instrument: PyObject, fill: OrderFilled) -> PyResult<Self> {
+        let instrument_type = convert_pyobject_to_instrument_any(py, instrument)?;
+        match instrument_type {
+            InstrumentAny::CryptoFuture(inst) => Ok(Self::new(inst, fill).unwrap()),
+            InstrumentAny::CryptoPerpetual(inst) => Ok(Self::new(inst, fill).unwrap()),
+            InstrumentAny::CurrencyPair(inst) => Ok(Self::new(inst, fill).unwrap()),
+            InstrumentAny::Equity(inst) => Ok(Self::new(inst, fill).unwrap()),
+            InstrumentAny::FuturesContract(inst) => Ok(Self::new(inst, fill).unwrap()),
+            InstrumentAny::FuturesSpread(inst) => Ok(Self::new(inst, fill).unwrap()),
+            InstrumentAny::OptionsContract(inst) => Ok(Self::new(inst, fill).unwrap()),
+            InstrumentAny::OptionsSpread(inst) => Ok(Self::new(inst, fill).unwrap()),
+        }
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
             CompareOp::Ne => self.ne(other).into_py(py),
             _ => py.NotImplemented(),
         }
     }
 
+    fn __str__(&self) -> String {
+        self.to_string()
+    }
+
+    fn __repr__(&self) -> String {
+        self.to_string()
+    }
+
+    #[getter]
+    #[pyo3(name = "trader_id")]
+    fn py_trader_id(&self) -> TraderId {
+        self.trader_id
+    }
+
+    #[getter]
+    #[pyo3(name = "strategy_id")]
+    fn py_strategy_id(&self) -> StrategyId {
+        self.strategy_id
+    }
+
+    #[getter]
+    #[pyo3(name = "instrument_id")]
+    fn py_instrument_id(&self) -> InstrumentId {
+        self.instrument_id
+    }
+
     #[getter]
-    fn id(&self) -> AccountId {
+    #[pyo3(name = "id")]
+    fn py_id(&self) -> PositionId {
         self.id
     }
 
     #[getter]
-    fn default_leverage(&self) -> f64 {
-        self.default_leverage
+    #[pyo3(name = "symbol")]
+    fn py_symbol(&self) -> Symbol {
+        self.symbol()
     }
 
-    fn __str__(&self) -> String {
-        format!(
-            "{}(id={}, type={}, base={})",
-            stringify!(MarginAccount),
-            self.id,
-            self.account_type,
-            self.base_currency.map_or_else(
-                || "None".to_string(),
-                |base_currency| format!("{}", base_currency.code)
-            )
-        )
+    #[getter]
+    #[pyo3(name = "venue")]
+    fn py_venue(&self) -> Venue {
+        self.venue()
     }
 
-    fn __repr__(&self) -> String {
-        format!(
-            "{}(id={}, type={}, base={})",
-            stringify!(MarginAccount),
-            self.id,
-            self.account_type,
-            self.base_currency.map_or_else(
-                || "None".to_string(),
-                |base_currency| format!("{}", base_currency.code)
-            ),
-        )
-    }
-
-    #[pyo3(name = "set_default_leverage")]
-    fn py_set_default_leverage(&mut self, default_leverage: f64) -> PyResult<()> {
-        self.set_default_leverage(default_leverage);
-        Ok(())
-    }
-
-    #[pyo3(name = "leverages")]
-    fn py_leverages(&self, py: Python) -> PyResult<PyObject> {
-        let leverages = PyDict::new(py);
-        for (key, &value) in &self.leverages {
-            leverages.set_item(key.to_object(py), value).unwrap();
-        }
-        Ok(leverages.to_object(py))
+    #[getter]
+    #[pyo3(name = "opening_order_id")]
+    fn py_opening_order_id(&self) -> ClientOrderId {
+        self.opening_order_id
     }
 
-    #[pyo3(name = "leverage")]
-    fn py_leverage(&self, instrument_id: &InstrumentId) -> PyResult<f64> {
-        Ok(self.get_leverage(instrument_id))
+    #[getter]
+    #[pyo3(name = "closing_order_id")]
+    fn py_closing_order_id(&self) -> Option<ClientOrderId> {
+        self.closing_order_id
     }
 
-    #[pyo3(name = "set_leverage")]
-    fn py_set_leverage(&mut self, instrument_id: InstrumentId, leverage: f64) -> PyResult<()> {
-        self.set_leverage(instrument_id, leverage);
-        Ok(())
+    #[getter]
+    #[pyo3(name = "entry")]
+    fn py_entry(&self) -> OrderSide {
+        self.entry
     }
 
-    #[pyo3(name = "is_unleveraged")]
-    fn py_is_unleveraged(&self, instrument_id: InstrumentId) -> PyResult<bool> {
-        Ok(self.is_unleveraged(instrument_id))
+    #[getter]
+    #[pyo3(name = "side")]
+    fn py_side(&self) -> PositionSide {
+        self.side
     }
 
-    #[pyo3(name = "initial_margins")]
-    fn py_initial_margins(&self, py: Python) -> PyResult<PyObject> {
-        let initial_margins = PyDict::new(py);
-        for (key, &value) in &self.initial_margins() {
-            initial_margins
-                .set_item(key.to_object(py), value.to_object(py))
-                .unwrap();
-        }
-        Ok(initial_margins.to_object(py))
+    #[getter]
+    #[pyo3(name = "signed_qty")]
+    fn py_signed_qty(&self) -> f64 {
+        self.signed_qty
     }
 
-    #[pyo3(name = "maintenance_margins")]
-    fn py_maintenance_margins(&self, py: Python) -> PyResult<PyObject> {
-        let maintenance_margins = PyDict::new(py);
-        for (key, &value) in &self.maintenance_margins() {
-            maintenance_margins
-                .set_item(key.to_object(py), value.to_object(py))
-                .unwrap();
-        }
-        Ok(maintenance_margins.to_object(py))
+    #[getter]
+    #[pyo3(name = "quantity")]
+    fn py_quantity(&self) -> Quantity {
+        self.quantity
     }
 
-    #[pyo3(name = "update_initial_margin")]
-    fn py_update_initial_margin(
-        &mut self,
-        instrument_id: InstrumentId,
-        initial_margin: Money,
-    ) -> PyResult<()> {
-        self.update_initial_margin(instrument_id, initial_margin);
-        Ok(())
-    }
-
-    #[pyo3(name = "initial_margin")]
-    fn py_initial_margin(&self, instrument_id: InstrumentId) -> PyResult<Money> {
-        Ok(self.initial_margin(instrument_id))
-    }
-
-    #[pyo3(name = "update_maintenance_margin")]
-    fn py_update_maintenance_margin(
-        &mut self,
-        instrument_id: InstrumentId,
-        maintenance_margin: Money,
-    ) -> PyResult<()> {
-        self.update_maintenance_margin(instrument_id, maintenance_margin);
-        Ok(())
-    }
-
-    #[pyo3(name = "maintenance_margin")]
-    fn py_maintenance_margin(&self, instrument_id: InstrumentId) -> PyResult<Money> {
-        Ok(self.maintenance_margin(instrument_id))
-    }
-
-    #[pyo3(name = "calculate_initial_margin")]
-    pub fn py_calculate_initial_margin(
-        &mut self,
-        instrument: PyObject,
-        quantity: Quantity,
-        price: Price,
-        use_quote_for_inverse: Option<bool>,
-        py: Python,
-    ) -> PyResult<Money> {
-        // extract instrument from PyObject
-        let instrument_type = instrument
-            .getattr(py, "instrument_type")?
-            .extract::<String>(py)?;
-        if instrument_type == "CryptoFuture" {
-            let instrument_rust = instrument.extract::<CryptoFuture>(py)?;
-            Ok(self.calculate_initial_margin(
-                instrument_rust,
-                quantity,
-                price,
-                use_quote_for_inverse,
-            ))
-        } else if instrument_type == "CryptoPerpetual" {
-            let instrument_rust = instrument.extract::<CryptoPerpetual>(py)?;
-            Ok(self.calculate_initial_margin(
-                instrument_rust,
-                quantity,
-                price,
-                use_quote_for_inverse,
-            ))
-        } else if instrument_type == "CurrencyPair" {
-            let instrument_rust = instrument.extract::<CurrencyPair>(py)?;
-            Ok(self.calculate_initial_margin(
-                instrument_rust,
-                quantity,
-                price,
-                use_quote_for_inverse,
-            ))
-        } else if instrument_type == "Equity" {
-            let instrument_rust = instrument.extract::<Equity>(py)?;
-            Ok(self.calculate_initial_margin(
-                instrument_rust,
-                quantity,
-                price,
-                use_quote_for_inverse,
-            ))
-        } else if instrument_type == "FuturesContract" {
-            let instrument_rust = instrument.extract::<FuturesContract>(py)?;
-            Ok(self.calculate_initial_margin(
-                instrument_rust,
-                quantity,
-                price,
-                use_quote_for_inverse,
-            ))
-        } else if instrument_type == "OptionsContract" {
-            let instrument_rust = instrument.extract::<OptionsContract>(py)?;
-            Ok(self.calculate_initial_margin(
-                instrument_rust,
-                quantity,
-                price,
-                use_quote_for_inverse,
-            ))
-        } else {
-            // throw error unsupported instrument
-            Err(to_pyvalue_err("Unsupported instrument type"))
-        }
+    #[getter]
+    #[pyo3(name = "peak_qty")]
+    fn py_peak_qty(&self) -> Quantity {
+        self.peak_qty
     }
 
-    #[pyo3(name = "calculate_maintenance_margin")]
-    pub fn py_calculate_maintenance_margin(
-        &mut self,
-        instrument: PyObject,
-        quantity: Quantity,
-        price: Price,
-        use_quote_for_inverse: Option<bool>,
-        py: Python,
-    ) -> PyResult<Money> {
-        // extract instrument from PyObject
-        let instrument_type = instrument
-            .getattr(py, "instrument_type")?
-            .extract::<String>(py)?;
-        if instrument_type == "CryptoFuture" {
-            let instrument_rust = instrument.extract::<CryptoFuture>(py)?;
-            Ok(self.calculate_maintenance_margin(
-                instrument_rust,
-                quantity,
-                price,
-                use_quote_for_inverse,
-            ))
-        } else if instrument_type == "CryptoPerpetual" {
-            let instrument_rust = instrument.extract::<CryptoPerpetual>(py)?;
-            Ok(self.calculate_maintenance_margin(
-                instrument_rust,
-                quantity,
-                price,
-                use_quote_for_inverse,
-            ))
-        } else if instrument_type == "CurrencyPair" {
-            let instrument_rust = instrument.extract::<CurrencyPair>(py)?;
-            Ok(self.calculate_maintenance_margin(
-                instrument_rust,
-                quantity,
-                price,
-                use_quote_for_inverse,
-            ))
-        } else if instrument_type == "Equity" {
-            let instrument_rust = instrument.extract::<Equity>(py)?;
-            Ok(self.calculate_maintenance_margin(
-                instrument_rust,
-                quantity,
-                price,
-                use_quote_for_inverse,
-            ))
-        } else if instrument_type == "FuturesContract" {
-            let instrument_rust = instrument.extract::<FuturesContract>(py)?;
-            Ok(self.calculate_maintenance_margin(
-                instrument_rust,
-                quantity,
-                price,
-                use_quote_for_inverse,
-            ))
-        } else if instrument_type == "OptionsContract" {
-            let instrument_rust = instrument.extract::<OptionsContract>(py)?;
-            Ok(self.calculate_maintenance_margin(
-                instrument_rust,
-                quantity,
-                price,
-                use_quote_for_inverse,
-            ))
-        } else {
-            // throw error unsupported instrument
-            Err(to_pyvalue_err("Unsupported instrument type"))
-        }
+    #[getter]
+    #[pyo3(name = "price_precision")]
+    fn py_price_precision(&self) -> u8 {
+        self.price_precision
     }
+
+    #[getter]
+    #[pyo3(name = "size_precision")]
+    fn py_size_precision(&self) -> u8 {
+        self.size_precision
+    }
+
+    #[getter]
+    #[pyo3(name = "multiplier")]
+    fn py_multiplier(&self) -> Quantity {
+        self.multiplier
+    }
+
+    #[getter]
+    #[pyo3(name = "is_inverse")]
+    fn py_is_inverse(&self) -> bool {
+        self.is_inverse
+    }
+
+    #[getter]
+    #[pyo3(name = "base_currency")]
+    fn py_base_currency(&self) -> Option<Currency> {
+        self.base_currency
+    }
+
+    #[getter]
+    #[pyo3(name = "quote_currency")]
+    fn py_quote_currency(&self) -> Currency {
+        self.quote_currency
+    }
+
+    #[getter]
+    #[pyo3(name = "settlement_currency")]
+    fn py_settlement_currency(&self) -> Currency {
+        self.settlement_currency
+    }
+
+    #[getter]
+    #[pyo3(name = "ts_init")]
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
+    }
+
+    #[getter]
+    #[pyo3(name = "ts_opened")]
+    fn py_ts_opened(&self) -> u64 {
+        self.ts_opened.as_u64()
+    }
+
+    #[getter]
+    #[pyo3(name = "ts_closed")]
+    fn py_ts_closed(&self) -> Option<u64> {
+        self.ts_closed.map(std::convert::Into::into)
+    }
+
+    #[getter]
+    #[pyo3(name = "duration_ns")]
+    fn py_duration_ns(&self) -> u64 {
+        self.duration_ns
+    }
+
+    #[getter]
+    #[pyo3(name = "avg_px_open")]
+    fn py_avg_px_open(&self) -> f64 {
+        self.avg_px_open
+    }
+
+    #[getter]
+    #[pyo3(name = "avg_px_close")]
+    fn py_avg_px_close(&self) -> Option<f64> {
+        self.avg_px_close
+    }
+
+    #[getter]
+    #[pyo3(name = "realized_return")]
+    fn py_realized_return(&self) -> f64 {
+        self.realized_return
+    }
+
+    #[getter]
+    #[pyo3(name = "realized_pnl")]
+    fn py_realized_pnl(&self) -> Option<Money> {
+        self.realized_pnl
+    }
+
+    #[getter]
+    #[pyo3(name = "events")]
+    fn py_events(&self) -> Vec<OrderFilled> {
+        self.events.clone()
+    }
+
+    #[getter]
+    #[pyo3(name = "client_order_ids")]
+    fn py_client_order_ids(&self) -> Vec<ClientOrderId> {
+        self.client_order_ids()
+    }
+
+    #[getter]
+    #[pyo3(name = "venue_order_ids")]
+    fn py_venue_order_ids(&self) -> Vec<VenueOrderId> {
+        self.venue_order_ids()
+    }
+
+    #[getter]
+    #[pyo3(name = "trade_ids")]
+    fn py_trade_ids(&self) -> Vec<TradeId> {
+        self.trade_ids()
+    }
+
+    #[getter]
+    #[pyo3(name = "last_event")]
+    fn py_last_event(&self) -> OrderFilled {
+        self.last_event()
+    }
+
+    #[getter]
+    #[pyo3(name = "last_trade_id")]
+    fn py_last_trade_id(&self) -> Option<TradeId> {
+        self.last_trade_id()
+    }
+
+    #[getter]
+    #[pyo3(name = "event_count")]
+    fn py_event_count(&self) -> usize {
+        self.events.len()
+    }
+
+    #[getter]
+    #[pyo3(name = "is_open")]
+    fn py_is_open(&self) -> bool {
+        self.is_open()
+    }
+
+    #[getter]
+    #[pyo3(name = "is_closed")]
+    fn py_is_closed(&self) -> bool {
+        self.is_closed()
+    }
+
+    #[getter]
+    #[pyo3(name = "is_long")]
+    fn py_is_long(&self) -> bool {
+        self.is_long()
+    }
+
+    #[getter]
+    #[pyo3(name = "is_short")]
+    fn py_is_short(&self) -> bool {
+        self.is_short()
+    }
+
+    #[pyo3(name = "unrealized_pnl")]
+    fn py_unrealized_pnl(&self, last: Price) -> Money {
+        self.unrealized_pnl(last)
+    }
+
+    #[pyo3(name = "total_pnl")]
+    fn py_total_pnl(&self, last: Price) -> Money {
+        self.total_pnl(last)
+    }
+
+    #[pyo3(name = "commissions")]
+    fn py_commissions(&self) -> Vec<Money> {
+        self.commissions()
+    }
+
+    #[pyo3(name = "apply")]
+    fn py_apply(&mut self, fill: &OrderFilled) {
+        self.apply(fill);
+    }
+
+    #[pyo3(name = "is_opposite_side")]
+    fn py_is_opposite_side(&self, side: OrderSide) -> bool {
+        self.is_opposite_side(side)
+    }
+
+    #[pyo3(name = "calculate_pnl")]
+    fn py_calculate_pnl(&self, avg_px_open: f64, avg_px_close: f64, quantity: Quantity) -> Money {
+        self.calculate_pnl(avg_px_open, avg_px_close, quantity)
+    }
+
+    #[pyo3(name = "notional_value")]
+    fn py_notional_value(&self, price: Price) -> Money {
+        self.notional_value(price)
+    }
+
+    #[staticmethod]
+    #[pyo3(name = "from_dict")]
+    pub fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
+        from_dict_pyo3(py, values)
+    }
+
     #[pyo3(name = "to_dict")]
     fn py_to_dict(&self, py: Python<'_>) -> PyResult<PyObject> {
         let dict = PyDict::new(py);
-        dict.set_item("calculate_account_state", self.calculate_account_state)?;
-        let events_list: PyResult<Vec<PyObject>> =
-            self.events.iter().map(|item| item.py_to_dict(py)).collect();
-        dict.set_item("events", events_list.unwrap())?;
+        dict.set_item("type", stringify!(Position))?;
+        let events_dict: PyResult<Vec<_>> = self.events.iter().map(|e| e.py_to_dict(py)).collect();
+        dict.set_item("events", events_dict?)?;
+        dict.set_item("trader_id", self.trader_id.to_string())?;
+        dict.set_item("strategy_id", self.strategy_id.to_string())?;
+        dict.set_item("instrument_id", self.instrument_id.to_string())?;
+        dict.set_item("id", self.id.to_string())?;
+        dict.set_item("account_id", self.account_id.to_string())?;
+        dict.set_item("opening_order_id", self.opening_order_id.to_string())?;
+        match self.closing_order_id {
+            Some(closing_order_id) => {
+                dict.set_item("closing_order_id", closing_order_id.to_string())?;
+            }
+            None => dict.set_item("closing_order_id", py.None())?,
+        }
+        dict.set_item("entry", self.entry.to_string())?;
+        dict.set_item("side", self.side.to_string())?;
+        dict.set_item("signed_qty", self.signed_qty.to_f64())?;
+        dict.set_item("quantity", self.quantity.to_string())?;
+        dict.set_item("peak_qty", self.peak_qty.to_string())?;
+        dict.set_item("price_precision", self.price_precision.to_u8())?;
+        dict.set_item("size_precision", self.size_precision.to_u8())?;
+        dict.set_item("multiplier", self.multiplier.to_string())?;
+        dict.set_item("is_inverse", self.is_inverse)?;
+        match self.base_currency {
+            Some(base_currency) => {
+                dict.set_item("base_currency", base_currency.code.to_string())?;
+            }
+            None => dict.set_item("base_currency", py.None())?,
+        }
+        dict.set_item("quote_currency", self.quote_currency.code.to_string())?;
+        dict.set_item(
+            "settlement_currency",
+            self.settlement_currency.code.to_string(),
+        )?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
+        dict.set_item("ts_opened", self.ts_opened.as_u64())?;
+        dict.set_item("ts_last", self.ts_last.as_u64())?;
+        match self.ts_closed {
+            Some(ts_closed) => dict.set_item("ts_closed", ts_closed.as_u64())?,
+            None => dict.set_item("ts_closed", py.None())?,
+        }
+        dict.set_item("duration_ns", self.duration_ns.to_u64())?;
+        dict.set_item("avg_px_open", self.avg_px_open.to_f64())?;
+        match self.avg_px_close {
+            Some(avg_px_close) => dict.set_item("avg_px_close", avg_px_close.to_u64())?,
+            None => dict.set_item("avg_px_close", py.None())?,
+        }
+        dict.set_item("realized_return", self.realized_return.to_f64())?;
+        match self.realized_pnl {
+            Some(realized_pnl) => dict.set_item("realized_pnl", realized_pnl.to_string())?,
+            None => dict.set_item("realized_pnl", py.None())?,
+        }
+        let venue_order_ids_list = PyList::new(
+            py,
+            self.venue_order_ids()
+                .iter()
+                .map(std::string::ToString::to_string),
+        );
+        dict.set_item("venue_order_ids", venue_order_ids_list)?;
+        let trade_ids_list = PyList::new(
+            py,
+            self.trade_ids.iter().map(std::string::ToString::to_string),
+        );
+        dict.set_item("trade_ids", trade_ids_list)?;
+        dict.set_item("buy_qty", self.buy_qty.to_string())?;
+        dict.set_item("sell_qty", self.sell_qty.to_string())?;
+        let commissions_dict = PyDict::new(py);
+        for (key, value) in &self.commissions {
+            commissions_dict.set_item(key.code.to_string(), value.to_string())?;
+        }
+        dict.set_item("commissions", commissions_dict)?;
         Ok(dict.into())
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/accounting/src/python/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/accounting/src/python/mod.rs`

 * *Files 11% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+#![allow(warnings)] // non-local `impl` definition, temporary allow until pyo3 upgrade
+
 use pyo3::{prelude::*, pymodule};
 
 pub mod cash;
 pub mod margin;
 pub mod transformer;
 
 #[pymodule]
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/accounting/src/python/transformer.rs` & `nautilus_trader-1.191.0/nautilus_core/accounting/src/python/transformer.rs`

 * *Files 4% similar despite different names*

```diff
@@ -9,19 +9,20 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+use nautilus_common::interface::account::Account;
 use nautilus_core::python::to_pyvalue_err;
 use nautilus_model::events::account::state::AccountState;
 use pyo3::{prelude::*, types::PyDict};
 
-use crate::account::{cash::CashAccount, margin::MarginAccount, Account};
+use crate::account::{cash::CashAccount, margin::MarginAccount};
 
 #[pyfunction]
 pub fn cash_account_from_account_events(
     py: Python<'_>,
     events: Vec<Py<PyDict>>,
     calculate_account_state: bool,
 ) -> PyResult<CashAccount> {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/accounting/src/stubs.rs` & `nautilus_trader-1.191.0/nautilus_core/accounting/src/stubs.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/adapters/Cargo.toml`

 * *Files 1% similar despite different names*

```diff
@@ -31,17 +31,17 @@
 tracing = { workspace = true }
 serde = { workspace = true }
 serde_json = { workspace = true }
 strum = { workspace = true }
 tokio = { workspace = true }
 thiserror = { workspace = true }
 ustr = { workspace = true }
-databento = { version = "0.7.1", optional = true }
+databento = { version = "0.8.0", optional = true }
 streaming-iterator = "0.1.9"
-time = "0.3.34"
+time = "0.3.35"
 
 [dev-dependencies]
 criterion = { workspace = true }
 rstest = { workspace = true }
 
 [features]
 default = ["ffi", "python"]
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/bin/sandbox.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/bin/sandbox.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/common.rs` & `nautilus_trader-1.191.0/nautilus_core/infrastructure/src/postgres/mod.rs`

 * *Files 24% similar despite different names*

```diff
@@ -8,21 +8,7 @@
 //
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
-
-use databento::historical::DateTimeRange;
-use nautilus_core::time::UnixNanos;
-use time::OffsetDateTime;
-
-pub const DATABENTO: &str = "DATABENTO";
-pub const ALL_SYMBOLS: &str = "ALL_SYMBOLS";
-
-pub fn get_date_time_range(start: UnixNanos, end: UnixNanos) -> anyhow::Result<DateTimeRange> {
-    Ok(DateTimeRange::from((
-        OffsetDateTime::from_unix_timestamp_nanos(i128::from(start))?,
-        OffsetDateTime::from_unix_timestamp_nanos(i128::from(end))?,
-    )))
-}
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/decode.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/decode.rs`

 * *Files 19% similar despite different names*

```diff
@@ -16,16 +16,16 @@
 use std::{
     cmp,
     ffi::{c_char, CStr},
     i64,
     str::FromStr,
 };
 
-use databento::dbn;
-use nautilus_core::{datetime::NANOSECONDS_IN_SECOND, time::UnixNanos};
+use databento::dbn::{self};
+use nautilus_core::{datetime::NANOSECONDS_IN_SECOND, nanos::UnixNanos};
 use nautilus_model::{
     data::{
         bar::{Bar, BarSpecification, BarType},
         delta::OrderBookDelta,
         depth::{OrderBookDepth10, DEPTH10_LEN},
         order::BookOrder,
         quote::QuoteTick,
@@ -35,15 +35,15 @@
     enums::{
         AggregationSource, AggressorSide, AssetClass, BarAggregation, BookAction, FromU8,
         InstrumentClass, OptionKind, OrderSide, PriceType,
     },
     identifiers::{instrument_id::InstrumentId, trade_id::TradeId},
     instruments::{
         equity::Equity, futures_contract::FuturesContract, futures_spread::FuturesSpread,
-        options_contract::OptionsContract, options_spread::OptionsSpread, InstrumentType,
+        options_contract::OptionsContract, options_spread::OptionsSpread, InstrumentAny,
     },
     types::{currency::Currency, fixed::FIXED_SCALAR, price::Price, quantity::Quantity},
 };
 use ustr::Ustr;
 
 use super::{
     enums::{DatabentoStatisticType, DatabentoStatisticUpdateAction},
@@ -201,19 +201,19 @@
         currency.precision,
         decode_price(msg.min_price_increment, currency.precision)?,
         None, // TBD
         None, // TBD
         None, // TBD
         None, // TBD
         Some(Quantity::new(msg.min_lot_size_round_lot.into(), 0)?),
-        None,        // TBD
-        None,        // TBD
-        None,        // TBD
-        None,        // TBD
-        msg.ts_recv, // More accurate and reliable timestamp
+        None,               // TBD
+        None,               // TBD
+        None,               // TBD
+        None,               // TBD
+        msg.ts_recv.into(), // More accurate and reliable timestamp
         ts_init,
     )
 }
 
 pub fn decode_futures_contract_v1(
     msg: &dbn::compat::InstrumentDefMsgV1,
     instrument_id: InstrumentId,
@@ -227,28 +227,28 @@
 
     FuturesContract::new(
         instrument_id,
         instrument_id.symbol,
         asset_class.unwrap_or(AssetClass::Commodity),
         Some(exchange),
         underlying,
-        msg.activation,
-        msg.expiration,
+        msg.activation.into(),
+        msg.expiration.into(),
         currency,
         currency.precision,
         decode_price(msg.min_price_increment, currency.precision)?,
         Quantity::new(1.0, 0)?, // TBD
         Quantity::new(1.0, 0)?, // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
-        msg.ts_recv,            // More accurate and reliable timestamp
+        msg.ts_recv.into(),     // More accurate and reliable timestamp
         ts_init,
     )
 }
 
 pub fn decode_futures_spread_v1(
     msg: &dbn::compat::InstrumentDefMsgV1,
     instrument_id: InstrumentId,
@@ -264,41 +264,41 @@
     FuturesSpread::new(
         instrument_id,
         instrument_id.symbol,
         asset_class.unwrap_or(AssetClass::Commodity),
         Some(exchange),
         underlying,
         strategy_type,
-        msg.activation,
-        msg.expiration,
+        msg.activation.into(),
+        msg.expiration.into(),
         currency,
         currency.precision,
         decode_price(msg.min_price_increment, currency.precision)?,
         Quantity::new(1.0, 0)?, // TBD
         Quantity::new(1.0, 0)?, // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
-        msg.ts_recv,            // More accurate and reliable timestamp
+        msg.ts_recv.into(),     // More accurate and reliable timestamp
         ts_init,
     )
 }
 
 pub fn decode_options_contract_v1(
     msg: &dbn::compat::InstrumentDefMsgV1,
     instrument_id: InstrumentId,
     ts_init: UnixNanos,
 ) -> anyhow::Result<OptionsContract> {
     let currency_str = unsafe { raw_ptr_to_string(msg.currency.as_ptr())? };
     let cfi_str = unsafe { raw_ptr_to_string(msg.cfi.as_ptr())? };
     let exchange = unsafe { raw_ptr_to_ustr(msg.exchange.as_ptr())? };
-    let asset_class_opt = match instrument_id.venue.value.as_str() {
+    let asset_class_opt = match instrument_id.venue.as_str() {
         "OPRA" => Some(AssetClass::Equity),
         _ => {
             let (asset_class, _) = parse_cfi_iso10926(&cfi_str)?;
             asset_class
         }
     };
     let underlying = unsafe { raw_ptr_to_ustr(msg.underlying.as_ptr())? };
@@ -307,42 +307,42 @@
     OptionsContract::new(
         instrument_id,
         instrument_id.symbol,
         asset_class_opt.unwrap_or(AssetClass::Commodity),
         Some(exchange),
         underlying,
         parse_option_kind(msg.instrument_class)?,
-        msg.activation,
-        msg.expiration,
+        msg.activation.into(),
+        msg.expiration.into(),
         Price::from_raw(msg.strike_price, currency.precision)?,
         currency,
         currency.precision,
         decode_price(msg.min_price_increment, currency.precision)?,
         Quantity::new(1.0, 0)?, // TBD
         Quantity::new(1.0, 0)?, // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,
         None,
-        msg.ts_recv, // More accurate and reliable timestamp
+        msg.ts_recv.into(), // More accurate and reliable timestamp
         ts_init,
     )
 }
 
 pub fn decode_options_spread_v1(
     msg: &dbn::compat::InstrumentDefMsgV1,
     instrument_id: InstrumentId,
     ts_init: UnixNanos,
 ) -> anyhow::Result<OptionsSpread> {
     let currency_str = unsafe { raw_ptr_to_string(msg.currency.as_ptr())? };
     let cfi_str = unsafe { raw_ptr_to_string(msg.cfi.as_ptr())? };
     let exchange = unsafe { raw_ptr_to_ustr(msg.exchange.as_ptr())? };
-    let asset_class_opt = match instrument_id.venue.value.as_str() {
+    let asset_class_opt = match instrument_id.venue.as_str() {
         "OPRA" => Some(AssetClass::Equity),
         _ => {
             let (asset_class, _) = parse_cfi_iso10926(&cfi_str)?;
             asset_class
         }
     };
     let underlying = unsafe { raw_ptr_to_ustr(msg.underlying.as_ptr())? };
@@ -352,28 +352,28 @@
     OptionsSpread::new(
         instrument_id,
         instrument_id.symbol,
         asset_class_opt.unwrap_or(AssetClass::Commodity),
         Some(exchange),
         underlying,
         strategy_type,
-        msg.activation,
-        msg.expiration,
+        msg.activation.into(),
+        msg.expiration.into(),
         currency,
         currency.precision,
         decode_price(msg.min_price_increment, currency.precision)?,
         Quantity::new(1.0, 0)?, // TBD
         Quantity::new(1.0, 0)?, // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
-        msg.ts_recv,            // More accurate and reliable timestamp
+        msg.ts_recv.into(),     // More accurate and reliable timestamp
         ts_init,
     )
 }
 
 #[must_use]
 fn is_trade_msg(order_side: OrderSide, action: c_char) -> bool {
     order_side == OrderSide::NoOrderSide || action as u8 as char == 'T'
@@ -391,15 +391,15 @@
         if include_trades {
             let trade = TradeTick::new(
                 instrument_id,
                 Price::from_raw(msg.price, price_precision)?,
                 Quantity::from_raw(u64::from(msg.size) * FIXED_SCALAR as u64, 0)?,
                 parse_aggressor_side(msg.side),
                 TradeId::new(itoa::Buffer::new().format(msg.sequence))?,
-                msg.ts_recv,
+                msg.ts_recv.into(),
                 ts_init,
             );
             return Ok((None, Some(trade)));
         }
 
         return Ok((None, None));
     };
@@ -413,15 +413,15 @@
 
     let delta = OrderBookDelta::new(
         instrument_id,
         parse_book_action(msg.action)?,
         order,
         msg.flags,
         msg.sequence.into(),
-        msg.ts_recv,
+        msg.ts_recv.into(),
         ts_init,
     );
 
     Ok((Some(delta), None))
 }
 
 pub fn decode_trade_msg(
@@ -432,47 +432,77 @@
 ) -> anyhow::Result<TradeTick> {
     let trade = TradeTick::new(
         instrument_id,
         Price::from_raw(msg.price, price_precision)?,
         Quantity::from_raw(u64::from(msg.size) * FIXED_SCALAR as u64, 0)?,
         parse_aggressor_side(msg.side),
         TradeId::new(itoa::Buffer::new().format(msg.sequence))?,
-        msg.ts_recv,
+        msg.ts_recv.into(),
         ts_init,
     );
 
     Ok(trade)
 }
 
+pub fn decode_tbbo_msg(
+    msg: &dbn::TbboMsg,
+    instrument_id: InstrumentId,
+    price_precision: u8,
+    ts_init: UnixNanos,
+) -> anyhow::Result<(QuoteTick, TradeTick)> {
+    let top_level = &msg.levels[0];
+    let quote = QuoteTick::new(
+        instrument_id,
+        Price::from_raw(top_level.bid_px, price_precision)?,
+        Price::from_raw(top_level.ask_px, price_precision)?,
+        Quantity::from_raw(u64::from(top_level.bid_sz) * FIXED_SCALAR as u64, 0)?,
+        Quantity::from_raw(u64::from(top_level.ask_sz) * FIXED_SCALAR as u64, 0)?,
+        msg.ts_recv.into(),
+        ts_init,
+    )?;
+
+    let trade = TradeTick::new(
+        instrument_id,
+        Price::from_raw(msg.price, price_precision)?,
+        Quantity::from_raw(u64::from(msg.size) * FIXED_SCALAR as u64, 0)?,
+        parse_aggressor_side(msg.side),
+        TradeId::new(itoa::Buffer::new().format(msg.sequence))?,
+        msg.ts_recv.into(),
+        ts_init,
+    );
+
+    Ok((quote, trade))
+}
+
 pub fn decode_mbp1_msg(
     msg: &dbn::Mbp1Msg,
     instrument_id: InstrumentId,
     price_precision: u8,
     ts_init: UnixNanos,
     include_trades: bool,
 ) -> anyhow::Result<(QuoteTick, Option<TradeTick>)> {
     let top_level = &msg.levels[0];
     let quote = QuoteTick::new(
         instrument_id,
         Price::from_raw(top_level.bid_px, price_precision)?,
         Price::from_raw(top_level.ask_px, price_precision)?,
         Quantity::from_raw(u64::from(top_level.bid_sz) * FIXED_SCALAR as u64, 0)?,
         Quantity::from_raw(u64::from(top_level.ask_sz) * FIXED_SCALAR as u64, 0)?,
-        msg.ts_recv,
+        msg.ts_recv.into(),
         ts_init,
     )?;
 
     let maybe_trade = if include_trades && msg.action as u8 as char == 'T' {
         Some(TradeTick::new(
             instrument_id,
             Price::from_raw(msg.price, price_precision)?,
             Quantity::from_raw(u64::from(msg.size) * FIXED_SCALAR as u64, 0)?,
             parse_aggressor_side(msg.side),
             TradeId::new(itoa::Buffer::new().format(msg.sequence))?,
-            msg.ts_recv,
+            msg.ts_recv.into(),
             ts_init,
         ))
     } else {
         None
     };
 
     Ok((quote, maybe_trade))
@@ -519,15 +549,15 @@
         instrument_id,
         bids,
         asks,
         bid_counts,
         ask_counts,
         msg.flags,
         msg.sequence.into(),
-        msg.ts_recv,
+        msg.ts_recv.into(),
         ts_init,
     );
 
     Ok(depth)
 }
 
 pub fn decode_bar_type(
@@ -580,77 +610,86 @@
         }
         _ => anyhow::bail!(
             "`rtype` is not a supported bar aggregation, was {}",
             msg.hd.rtype
         ),
     };
 
-    Ok(adjustment)
+    Ok(adjustment.into())
 }
 
 pub fn decode_ohlcv_msg(
     msg: &dbn::OhlcvMsg,
     instrument_id: InstrumentId,
     price_precision: u8,
     ts_init: UnixNanos,
 ) -> anyhow::Result<Bar> {
     let bar_type = decode_bar_type(msg, instrument_id)?;
     let ts_event_adjustment = decode_ts_event_adjustment(msg)?;
 
     // Adjust `ts_event` from open to close of bar
-    let ts_event = msg.hd.ts_event;
+    let ts_event = msg.hd.ts_event.into();
     let ts_init = cmp::max(ts_init, ts_event) + ts_event_adjustment;
 
+    // Adjust raw prices by a display factor
+    let mut display_factor = 1;
+    if instrument_id.venue.as_str() == "GLBX" {
+        display_factor = 100;
+    };
+
     let bar = Bar::new(
         bar_type,
-        Price::from_raw(msg.open / 100, price_precision)?, // TODO(adjust for display factor)
-        Price::from_raw(msg.high / 100, price_precision)?, // TODO(adjust for display factor)
-        Price::from_raw(msg.low / 100, price_precision)?,  // TODO(adjust for display factor)
-        Price::from_raw(msg.close / 100, price_precision)?, // TODO(adjust for display factor)
-        Quantity::from_raw(msg.volume * FIXED_SCALAR as u64, 0)?, // TODO(adjust for display factor)
+        Price::from_raw(msg.open / display_factor, price_precision)?,
+        Price::from_raw(msg.high / display_factor, price_precision)?,
+        Price::from_raw(msg.low / display_factor, price_precision)?,
+        Price::from_raw(msg.close / display_factor, price_precision)?,
+        Quantity::from_raw(msg.volume * FIXED_SCALAR as u64, 0)?,
         ts_event,
         ts_init,
     );
 
     Ok(bar)
 }
 
 pub fn decode_record(
     record: &dbn::RecordRef,
     instrument_id: InstrumentId,
     price_precision: u8,
     ts_init: Option<UnixNanos>,
     include_trades: bool,
 ) -> anyhow::Result<(Option<Data>, Option<Data>)> {
+    // We don't handle `TbboMsg` here as Nautilus separates this schema
+    // into quotes and trades when loading, and the live client will
+    // never subscribe to `tbbo`.
     let result = if let Some(msg) = record.get::<dbn::MboMsg>() {
-        let ts_init = determine_timestamp(ts_init, msg.ts_recv);
+        let ts_init = determine_timestamp(ts_init, msg.ts_recv.into());
         let result = decode_mbo_msg(msg, instrument_id, price_precision, ts_init, include_trades)?;
         match result {
             (Some(delta), None) => (Some(Data::Delta(delta)), None),
             (None, Some(trade)) => (Some(Data::Trade(trade)), None),
             (None, None) => (None, None),
             _ => anyhow::bail!("Invalid `MboMsg` parsing combination"),
         }
     } else if let Some(msg) = record.get::<dbn::TradeMsg>() {
-        let ts_init = determine_timestamp(ts_init, msg.ts_recv);
+        let ts_init = determine_timestamp(ts_init, msg.ts_recv.into());
         let trade = decode_trade_msg(msg, instrument_id, price_precision, ts_init)?;
         (Some(Data::Trade(trade)), None)
     } else if let Some(msg) = record.get::<dbn::Mbp1Msg>() {
-        let ts_init = determine_timestamp(ts_init, msg.ts_recv);
+        let ts_init = determine_timestamp(ts_init, msg.ts_recv.into());
         let result = decode_mbp1_msg(msg, instrument_id, price_precision, ts_init, include_trades)?;
         match result {
             (quote, None) => (Some(Data::Quote(quote)), None),
             (quote, Some(trade)) => (Some(Data::Quote(quote)), Some(Data::Trade(trade))),
         }
     } else if let Some(msg) = record.get::<dbn::Mbp10Msg>() {
-        let ts_init = determine_timestamp(ts_init, msg.ts_recv);
+        let ts_init = determine_timestamp(ts_init, msg.ts_recv.into());
         let depth = decode_mbp10_msg(msg, instrument_id, price_precision, ts_init)?;
         (Some(Data::Depth10(depth)), None)
     } else if let Some(msg) = record.get::<dbn::OhlcvMsg>() {
-        let ts_init = determine_timestamp(ts_init, msg.hd.ts_event);
+        let ts_init = determine_timestamp(ts_init, msg.hd.ts_event.into());
         let bar = decode_ohlcv_msg(msg, instrument_id, price_precision, ts_init)?;
         (Some(Data::Bar(bar)), None)
     } else {
         anyhow::bail!("DBN message type is not currently supported")
     };
 
     Ok(result)
@@ -663,37 +702,37 @@
     }
 }
 
 pub fn decode_instrument_def_msg_v1(
     msg: &dbn::compat::InstrumentDefMsgV1,
     instrument_id: InstrumentId,
     ts_init: UnixNanos,
-) -> anyhow::Result<InstrumentType> {
+) -> anyhow::Result<InstrumentAny> {
     match msg.instrument_class as u8 as char {
-        'K' => Ok(InstrumentType::Equity(decode_equity_v1(
+        'K' => Ok(InstrumentAny::Equity(decode_equity_v1(
             msg,
             instrument_id,
             ts_init,
         )?)),
-        'F' => Ok(InstrumentType::FuturesContract(decode_futures_contract_v1(
+        'F' => Ok(InstrumentAny::FuturesContract(decode_futures_contract_v1(
             msg,
             instrument_id,
             ts_init,
         )?)),
-        'S' => Ok(InstrumentType::FuturesSpread(decode_futures_spread_v1(
+        'S' => Ok(InstrumentAny::FuturesSpread(decode_futures_spread_v1(
             msg,
             instrument_id,
             ts_init,
         )?)),
-        'C' | 'P' => Ok(InstrumentType::OptionsContract(decode_options_contract_v1(
+        'C' | 'P' => Ok(InstrumentAny::OptionsContract(decode_options_contract_v1(
             msg,
             instrument_id,
             ts_init,
         )?)),
-        'T' | 'M' => Ok(InstrumentType::OptionsSpread(decode_options_spread_v1(
+        'T' | 'M' => Ok(InstrumentAny::OptionsSpread(decode_options_spread_v1(
             msg,
             instrument_id,
             ts_init,
         )?)),
         'B' => anyhow::bail!("Unsupported `instrument_class` 'B' (Bond)"),
         'X' => anyhow::bail!("Unsupported `instrument_class` 'X' (FX spot)"),
         _ => anyhow::bail!(
@@ -703,37 +742,37 @@
     }
 }
 
 pub fn decode_instrument_def_msg(
     msg: &dbn::InstrumentDefMsg,
     instrument_id: InstrumentId,
     ts_init: UnixNanos,
-) -> anyhow::Result<InstrumentType> {
+) -> anyhow::Result<InstrumentAny> {
     match msg.instrument_class as u8 as char {
-        'K' => Ok(InstrumentType::Equity(decode_equity(
+        'K' => Ok(InstrumentAny::Equity(decode_equity(
             msg,
             instrument_id,
             ts_init,
         )?)),
-        'F' => Ok(InstrumentType::FuturesContract(decode_futures_contract(
+        'F' => Ok(InstrumentAny::FuturesContract(decode_futures_contract(
             msg,
             instrument_id,
             ts_init,
         )?)),
-        'S' => Ok(InstrumentType::FuturesSpread(decode_futures_spread(
+        'S' => Ok(InstrumentAny::FuturesSpread(decode_futures_spread(
             msg,
             instrument_id,
             ts_init,
         )?)),
-        'C' | 'P' => Ok(InstrumentType::OptionsContract(decode_options_contract(
+        'C' | 'P' => Ok(InstrumentAny::OptionsContract(decode_options_contract(
             msg,
             instrument_id,
             ts_init,
         )?)),
-        'T' | 'M' => Ok(InstrumentType::OptionsSpread(decode_options_spread(
+        'T' | 'M' => Ok(InstrumentAny::OptionsSpread(decode_options_spread(
             msg,
             instrument_id,
             ts_init,
         )?)),
         'B' => anyhow::bail!("Unsupported `instrument_class` 'B' (Bond)"),
         'X' => anyhow::bail!("Unsupported `instrument_class` 'X' (FX spot)"),
         _ => anyhow::bail!(
@@ -758,19 +797,19 @@
         currency.precision,
         decode_price(msg.min_price_increment, currency.precision)?,
         None, // TBD
         None, // TBD
         None, // TBD
         None, // TBD
         Some(Quantity::new(msg.min_lot_size_round_lot.into(), 0)?),
-        None,        // TBD
-        None,        // TBD
-        None,        // TBD
-        None,        // TBD
-        msg.ts_recv, // More accurate and reliable timestamp
+        None,               // TBD
+        None,               // TBD
+        None,               // TBD
+        None,               // TBD
+        msg.ts_recv.into(), // More accurate and reliable timestamp
         ts_init,
     )
 }
 
 pub fn decode_futures_contract(
     msg: &dbn::InstrumentDefMsg,
     instrument_id: InstrumentId,
@@ -784,28 +823,28 @@
 
     FuturesContract::new(
         instrument_id,
         instrument_id.symbol,
         asset_class.unwrap_or(AssetClass::Commodity),
         Some(exchange),
         underlying,
-        msg.activation,
-        msg.expiration,
+        msg.activation.into(),
+        msg.expiration.into(),
         currency,
         currency.precision,
         decode_price(msg.min_price_increment, currency.precision)?,
         Quantity::new(1.0, 0)?, // TBD
         Quantity::new(1.0, 0)?, // TBD
         None,
-        None,        // TBD
-        None,        // TBD
-        None,        // TBD
-        None,        // TBD
-        None,        // TBD
-        msg.ts_recv, // More accurate and reliable timestamp
+        None,               // TBD
+        None,               // TBD
+        None,               // TBD
+        None,               // TBD
+        None,               // TBD
+        msg.ts_recv.into(), // More accurate and reliable timestamp
         ts_init,
     )
 }
 
 pub fn decode_futures_spread(
     msg: &dbn::InstrumentDefMsg,
     instrument_id: InstrumentId,
@@ -821,41 +860,41 @@
     FuturesSpread::new(
         instrument_id,
         instrument_id.symbol,
         asset_class.unwrap_or(AssetClass::Commodity),
         Some(exchange),
         underlying,
         strategy_type,
-        msg.activation,
-        msg.expiration,
+        msg.activation.into(),
+        msg.expiration.into(),
         currency,
         currency.precision,
         decode_price(msg.min_price_increment, currency.precision)?,
         Quantity::new(1.0, 0)?, // TBD
         Quantity::new(1.0, 0)?, // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
-        msg.ts_recv,            // More accurate and reliable timestamp
+        msg.ts_recv.into(),     // More accurate and reliable timestamp
         ts_init,
     )
 }
 
 pub fn decode_options_contract(
     msg: &dbn::InstrumentDefMsg,
     instrument_id: InstrumentId,
     ts_init: UnixNanos,
 ) -> anyhow::Result<OptionsContract> {
     let currency_str = unsafe { raw_ptr_to_string(msg.currency.as_ptr())? };
     let cfi_str = unsafe { raw_ptr_to_string(msg.cfi.as_ptr())? };
     let exchange = unsafe { raw_ptr_to_ustr(msg.exchange.as_ptr())? };
-    let asset_class_opt = match instrument_id.venue.value.as_str() {
+    let asset_class_opt = match instrument_id.venue.as_str() {
         "OPRA" => Some(AssetClass::Equity),
         _ => {
             let (asset_class, _) = parse_cfi_iso10926(&cfi_str)?;
             asset_class
         }
     };
     let underlying = unsafe { raw_ptr_to_ustr(msg.underlying.as_ptr())? };
@@ -864,41 +903,41 @@
     OptionsContract::new(
         instrument_id,
         instrument_id.symbol,
         asset_class_opt.unwrap_or(AssetClass::Commodity),
         Some(exchange),
         underlying,
         parse_option_kind(msg.instrument_class)?,
-        msg.activation,
-        msg.expiration,
+        msg.activation.into(),
+        msg.expiration.into(),
         Price::from_raw(msg.strike_price, currency.precision)?,
         currency,
         currency.precision,
         decode_price(msg.min_price_increment, currency.precision)?,
         Quantity::new(1.0, 0)?, // TBD
         Quantity::new(1.0, 0)?, // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
-        msg.ts_recv,            // More accurate and reliable timestamp
+        msg.ts_recv.into(),     // More accurate and reliable timestamp
         ts_init,
     )
 }
 
 pub fn decode_options_spread(
     msg: &dbn::InstrumentDefMsg,
     instrument_id: InstrumentId,
     ts_init: UnixNanos,
 ) -> anyhow::Result<OptionsSpread> {
     let currency_str = unsafe { raw_ptr_to_string(msg.currency.as_ptr())? };
     let cfi_str = unsafe { raw_ptr_to_string(msg.cfi.as_ptr())? };
-    let asset_class_opt = match instrument_id.venue.value.as_str() {
+    let asset_class_opt = match instrument_id.venue.as_str() {
         "OPRA" => Some(AssetClass::Equity),
         _ => {
             let (asset_class, _) = parse_cfi_iso10926(&cfi_str)?;
             asset_class
         }
     };
     let exchange = unsafe { raw_ptr_to_ustr(msg.exchange.as_ptr())? };
@@ -909,28 +948,28 @@
     OptionsSpread::new(
         instrument_id,
         instrument_id.symbol,
         asset_class_opt.unwrap_or(AssetClass::Commodity),
         Some(exchange),
         underlying,
         strategy_type,
-        msg.activation,
-        msg.expiration,
+        msg.activation.into(),
+        msg.expiration.into(),
         currency,
         currency.precision,
         decode_price(msg.min_price_increment, currency.precision)?,
         Quantity::new(1.0, 0)?, // TBD
         Quantity::new(1.0, 0)?, // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
         None,                   // TBD
-        msg.ts_recv,            // More accurate and reliable timestamp
+        msg.ts_recv.into(),     // More accurate and reliable timestamp
         ts_init,
     )
 }
 
 pub fn decode_imbalance_msg(
     msg: &dbn::ImbalanceMsg,
     instrument_id: InstrumentId,
@@ -942,16 +981,16 @@
         Price::from_raw(msg.ref_price, price_precision)?,
         Price::from_raw(msg.cont_book_clr_price, price_precision)?,
         Price::from_raw(msg.auct_interest_clr_price, price_precision)?,
         Quantity::new(f64::from(msg.paired_qty), 0)?,
         Quantity::new(f64::from(msg.total_imbalance_qty), 0)?,
         parse_order_side(msg.side),
         msg.significant_imbalance as c_char,
-        msg.hd.ts_event,
-        msg.ts_recv,
+        msg.hd.ts_event.into(),
+        msg.ts_recv.into(),
         ts_init,
     )
 }
 
 pub fn decode_statistics_msg(
     msg: &dbn::StatMsg,
     instrument_id: InstrumentId,
@@ -968,14 +1007,255 @@
         stat_type,
         update_action,
         decode_optional_price(msg.price, price_precision)?,
         decode_optional_quantity_i32(msg.quantity)?,
         msg.channel_id,
         msg.stat_flags,
         msg.sequence,
-        msg.ts_ref,
+        msg.ts_ref.into(),
         msg.ts_in_delta,
-        msg.hd.ts_event,
-        msg.ts_recv,
+        msg.hd.ts_event.into(),
+        msg.ts_recv.into(),
         ts_init,
     )
 }
+
+////////////////////////////////////////////////////////////////////////////////
+// Tests
+////////////////////////////////////////////////////////////////////////////////
+#[cfg(test)]
+mod tests {
+    use std::path::PathBuf;
+
+    use databento::dbn::decode::{dbn::Decoder, DecodeStream};
+    use rstest::*;
+    use streaming_iterator::StreamingIterator;
+
+    use super::*;
+
+    pub const TEST_DATA_PATH: &str =
+        concat!(env!("CARGO_MANIFEST_DIR"), "/src/databento/test_data");
+
+    #[rstest]
+    fn test_decode_mbo_msg() {
+        let path = PathBuf::from(format!("{TEST_DATA_PATH}/test_data.mbo.dbn.zst"));
+        let mut dbn_stream = Decoder::from_zstd_file(path)
+            .unwrap()
+            .decode_stream::<dbn::MboMsg>();
+        let msg = dbn_stream.next().unwrap();
+
+        let instrument_id = InstrumentId::from("ESM4.GLBX");
+        let (delta, _) = decode_mbo_msg(msg, instrument_id, 2, 0.into(), false).unwrap();
+        let delta = delta.unwrap();
+
+        assert_eq!(delta.instrument_id, instrument_id);
+        assert_eq!(delta.action, BookAction::Delete);
+        assert_eq!(delta.order.side, OrderSide::Sell);
+        assert_eq!(delta.order.price, Price::from("3722.75"));
+        assert_eq!(delta.order.size, Quantity::from("1"));
+        assert_eq!(delta.order.order_id, 647_784_973_705);
+        assert_eq!(delta.flags, 128);
+        assert_eq!(delta.sequence, 1_170_352);
+        assert_eq!(delta.ts_event, msg.ts_recv);
+        assert_eq!(delta.ts_event, 1_609_160_400_000_704_060);
+        assert_eq!(delta.ts_init, 0);
+    }
+
+    #[rstest]
+    fn test_decode_mbp1_msg() {
+        let path = PathBuf::from(format!("{TEST_DATA_PATH}/test_data.mbp-1.dbn.zst"));
+        let mut dbn_stream = Decoder::from_zstd_file(path)
+            .unwrap()
+            .decode_stream::<dbn::Mbp1Msg>();
+        let msg = dbn_stream.next().unwrap();
+
+        let instrument_id = InstrumentId::from("ESM4.GLBX");
+        let (quote, _) = decode_mbp1_msg(msg, instrument_id, 2, 0.into(), false).unwrap();
+
+        assert_eq!(quote.instrument_id, instrument_id);
+        assert_eq!(quote.bid_price, Price::from("3720.25"));
+        assert_eq!(quote.ask_price, Price::from("3720.50"));
+        assert_eq!(quote.bid_size, Quantity::from("24"));
+        assert_eq!(quote.ask_size, Quantity::from("11"));
+        assert_eq!(quote.ts_event, msg.ts_recv);
+        assert_eq!(quote.ts_event, 1_609_160_400_006_136_329);
+        assert_eq!(quote.ts_init, 0);
+    }
+
+    #[rstest]
+    fn test_decode_mbp10_msg() {
+        let path = PathBuf::from(format!("{TEST_DATA_PATH}/test_data.mbp-10.dbn.zst"));
+        let mut dbn_stream = Decoder::from_zstd_file(path)
+            .unwrap()
+            .decode_stream::<dbn::Mbp10Msg>();
+        let msg = dbn_stream.next().unwrap();
+
+        let instrument_id = InstrumentId::from("ESM4.GLBX");
+        let depth10 = decode_mbp10_msg(msg, instrument_id, 2, 0.into()).unwrap();
+
+        assert_eq!(depth10.instrument_id, instrument_id);
+        assert_eq!(depth10.bids.len(), 10);
+        assert_eq!(depth10.asks.len(), 10);
+        assert_eq!(depth10.bid_counts.len(), 10);
+        assert_eq!(depth10.ask_counts.len(), 10);
+        assert_eq!(depth10.flags, 128);
+        assert_eq!(depth10.sequence, 1_170_352);
+        assert_eq!(depth10.ts_event, msg.ts_recv);
+        assert_eq!(depth10.ts_event, 1_609_160_400_000_704_060);
+        assert_eq!(depth10.ts_init, 0);
+    }
+
+    #[rstest]
+    fn test_decode_trade_msg() {
+        let path = PathBuf::from(format!("{TEST_DATA_PATH}/test_data.trades.dbn.zst"));
+        let mut dbn_stream = Decoder::from_zstd_file(path)
+            .unwrap()
+            .decode_stream::<dbn::TradeMsg>();
+        let msg = dbn_stream.next().unwrap();
+
+        let instrument_id = InstrumentId::from("ESM4.GLBX");
+        let trade = decode_trade_msg(msg, instrument_id, 2, 0.into()).unwrap();
+
+        assert_eq!(trade.instrument_id, instrument_id);
+        assert_eq!(trade.price, Price::from("3720.25"));
+        assert_eq!(trade.size, Quantity::from("5"));
+        assert_eq!(trade.aggressor_side, AggressorSide::Seller);
+        assert_eq!(trade.trade_id.to_string(), "1170380");
+        assert_eq!(trade.ts_event, msg.ts_recv);
+        assert_eq!(trade.ts_event, 1_609_160_400_099_150_057);
+        assert_eq!(trade.ts_init, 0);
+    }
+
+    #[rstest]
+    fn test_decode_tbbo_msg() {
+        let path = PathBuf::from(format!("{TEST_DATA_PATH}/test_data.tbbo.dbn.zst"));
+        let mut dbn_stream = Decoder::from_zstd_file(path)
+            .unwrap()
+            .decode_stream::<dbn::Mbp1Msg>();
+        let msg = dbn_stream.next().unwrap();
+
+        let instrument_id = InstrumentId::from("ESM4.GLBX");
+        let (quote, trade) = decode_tbbo_msg(msg, instrument_id, 2, 0.into()).unwrap();
+
+        assert_eq!(quote.instrument_id, instrument_id);
+        assert_eq!(quote.bid_price, Price::from("3720.25"));
+        assert_eq!(quote.ask_price, Price::from("3720.50"));
+        assert_eq!(quote.bid_size, Quantity::from("26"));
+        assert_eq!(quote.ask_size, Quantity::from("7"));
+        assert_eq!(quote.ts_event, msg.ts_recv);
+        assert_eq!(quote.ts_event, 1_609_160_400_099_150_057);
+        assert_eq!(quote.ts_init, 0);
+
+        assert_eq!(trade.instrument_id, instrument_id);
+        assert_eq!(trade.price, Price::from("3720.25"));
+        assert_eq!(trade.size, Quantity::from("5"));
+        assert_eq!(trade.aggressor_side, AggressorSide::Seller);
+        assert_eq!(trade.trade_id.to_string(), "1170380");
+        assert_eq!(trade.ts_event, msg.ts_recv);
+        assert_eq!(trade.ts_event, 1_609_160_400_099_150_057);
+        assert_eq!(trade.ts_init, 0);
+    }
+
+    #[rstest]
+    fn test_decode_ohlcv_msg() {
+        let path = PathBuf::from(format!("{TEST_DATA_PATH}/test_data.ohlcv-1s.dbn.zst"));
+        let mut dbn_stream = Decoder::from_zstd_file(path)
+            .unwrap()
+            .decode_stream::<dbn::OhlcvMsg>();
+        let msg = dbn_stream.next().unwrap();
+
+        let instrument_id = InstrumentId::from("ESM4.GLBX");
+        let bar = decode_ohlcv_msg(msg, instrument_id, 2, 0.into()).unwrap();
+
+        assert_eq!(
+            bar.bar_type,
+            BarType::from("ESM4.GLBX-1-SECOND-LAST-EXTERNAL")
+        );
+        assert_eq!(bar.open, Price::from("3720.25"));
+        assert_eq!(bar.high, Price::from("3720.50"));
+        assert_eq!(bar.low, Price::from("3720.25"));
+        assert_eq!(bar.close, Price::from("3720.50"));
+        assert_eq!(bar.ts_event, 1_609_160_400_000_000_000);
+        assert_eq!(bar.ts_init, 1_609_160_401_000_000_000); // Adjusted to open + interval
+    }
+
+    #[rstest]
+    fn test_decode_definition_msg() {
+        let path = PathBuf::from(format!("{TEST_DATA_PATH}/test_data.definition.dbn.zst"));
+        let mut dbn_stream = Decoder::from_zstd_file(path)
+            .unwrap()
+            .decode_stream::<dbn::InstrumentDefMsg>();
+        let msg = dbn_stream.next().unwrap();
+
+        let instrument_id = InstrumentId::from("ESM4.GLBX");
+        let result = decode_instrument_def_msg(msg, instrument_id, 0.into());
+
+        assert!(result.is_ok());
+    }
+
+    #[rstest]
+    fn test_decode_definition_v1_msg() {
+        let path = PathBuf::from(format!("{TEST_DATA_PATH}/test_data.definition.v1.dbn.zst"));
+        let mut dbn_stream = Decoder::from_zstd_file(path)
+            .unwrap()
+            .decode_stream::<dbn::compat::InstrumentDefMsgV1>();
+        let msg = dbn_stream.next().unwrap();
+
+        let instrument_id = InstrumentId::from("ESM4.GLBX");
+        let result = decode_instrument_def_msg_v1(msg, instrument_id, 0.into());
+
+        assert!(result.is_ok());
+    }
+
+    #[rstest]
+    fn test_decode_imbalance_msg() {
+        let path = PathBuf::from(format!("{TEST_DATA_PATH}/test_data.imbalance.dbn.zst"));
+        let mut dbn_stream = Decoder::from_zstd_file(path)
+            .unwrap()
+            .decode_stream::<dbn::ImbalanceMsg>();
+        let msg = dbn_stream.next().unwrap();
+
+        let instrument_id = InstrumentId::from("ESM4.GLBX");
+        let imbalance = decode_imbalance_msg(msg, instrument_id, 2, 0.into()).unwrap();
+
+        assert_eq!(imbalance.instrument_id, instrument_id);
+        assert_eq!(imbalance.ref_price, Price::from("229.43"));
+        assert_eq!(imbalance.cont_book_clr_price, Price::from("0.00"));
+        assert_eq!(imbalance.auct_interest_clr_price, Price::from("0.00"));
+        assert_eq!(imbalance.paired_qty, Quantity::from("0"));
+        assert_eq!(imbalance.total_imbalance_qty, Quantity::from("2000"));
+        assert_eq!(imbalance.side, OrderSide::Buy);
+        assert_eq!(imbalance.significant_imbalance, 126);
+        assert_eq!(imbalance.ts_event, msg.hd.ts_event);
+        assert_eq!(imbalance.ts_recv, msg.ts_recv);
+        assert_eq!(imbalance.ts_init, 0);
+    }
+
+    #[rstest]
+    fn test_decode_statistics_msg() {
+        let path = PathBuf::from(format!("{TEST_DATA_PATH}/test_data.statistics.dbn.zst"));
+        let mut dbn_stream = Decoder::from_zstd_file(path)
+            .unwrap()
+            .decode_stream::<dbn::StatMsg>();
+        let msg = dbn_stream.next().unwrap();
+
+        let instrument_id = InstrumentId::from("ESM4.GLBX");
+        let statistics = decode_statistics_msg(msg, instrument_id, 2, 0.into()).unwrap();
+
+        assert_eq!(statistics.instrument_id, instrument_id);
+        assert_eq!(statistics.stat_type, DatabentoStatisticType::LowestOffer);
+        assert_eq!(
+            statistics.update_action,
+            DatabentoStatisticUpdateAction::Added
+        );
+        assert_eq!(statistics.price, Some(Price::from("100.00")));
+        assert_eq!(statistics.quantity, None);
+        assert_eq!(statistics.channel_id, 13);
+        assert_eq!(statistics.stat_flags, 255);
+        assert_eq!(statistics.sequence, 2);
+        assert_eq!(statistics.ts_ref, 18_446_744_073_709_551_615);
+        assert_eq!(statistics.ts_in_delta, 26961);
+        assert_eq!(statistics.ts_event, msg.hd.ts_event);
+        assert_eq!(statistics.ts_recv, msg.ts_recv);
+        assert_eq!(statistics.ts_init, 0);
+    }
+}
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/enums.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/enums.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/live.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/live.rs`

 * *Files 4% similar despite different names*

```diff
@@ -27,23 +27,23 @@
 };
 use nautilus_model::{
     data::{
         delta::OrderBookDelta,
         deltas::{OrderBookDeltas, OrderBookDeltas_API},
         Data,
     },
+    enums::RecordFlag,
     identifiers::{instrument_id::InstrumentId, symbol::Symbol, venue::Venue},
-    instruments::InstrumentType,
+    instruments::InstrumentAny,
 };
 use tokio::{
     sync::mpsc::{self, error::TryRecvError},
     time::{timeout, Duration},
 };
 use tracing::{debug, error, info, trace};
-use ustr::Ustr;
 
 use super::{
     decode::{decode_imbalance_msg, decode_statistics_msg},
     types::{DatabentoImbalance, DatabentoStatistics},
 };
 use crate::databento::{
     decode::{decode_instrument_def_msg, decode_record},
@@ -57,15 +57,15 @@
     Close,
 }
 
 #[derive(Debug)]
 #[allow(clippy::large_enum_variant)] // TODO: Optimize this (largest variant 1096 vs 80 bytes)
 pub enum LiveMessage {
     Data(Data),
-    Instrument(InstrumentType),
+    Instrument(InstrumentAny),
     Imbalance(DatabentoImbalance),
     Statistics(DatabentoStatistics),
     Error(anyhow::Error),
     Close,
 }
 
 /// Handles a raw TCP data feed from the Databento LSG for a single dataset.
@@ -263,20 +263,20 @@
                             deltas_count,
                             delta.ts_event,
                             buffering_start,
                             msg.flags,
                         );
 
                         // Check if last message in the packet
-                        if msg.flags & dbn::flags::LAST == 0 {
+                        if !RecordFlag::F_LAST.matches(msg.flags) {
                             continue; // NOT last message
                         }
 
                         // Check if snapshot
-                        if msg.flags & dbn::flags::SNAPSHOT != 0 {
+                        if RecordFlag::F_SNAPSHOT.matches(msg.flags) {
                             continue; // Buffer snapshot
                         }
 
                         // Check if buffering a replay
                         if let Some(start_ns) = buffering_start {
                             if delta.ts_event <= start_ns {
                                 continue; // Continue buffering replay
@@ -352,17 +352,15 @@
         return instrument_id;
     }
 
     let raw_symbol = symbol_map
         .get_for_rec(record)
         .expect("Cannot resolve `raw_symbol` from `symbol_map`");
 
-    let symbol = Symbol {
-        value: Ustr::from(raw_symbol),
-    };
+    let symbol = Symbol::from_str_unchecked(raw_symbol);
 
     let publisher_id = header.publisher_id;
     let venue = publisher_venue_map
         .get(&publisher_id)
         .unwrap_or_else(|| panic!("No venue found for `publisher_id` {publisher_id}"));
     let instrument_id = InstrumentId::new(symbol, *venue);
 
@@ -370,21 +368,18 @@
     instrument_id
 }
 
 fn handle_instrument_def_msg(
     msg: &dbn::InstrumentDefMsg,
     publisher_venue_map: &IndexMap<PublisherId, Venue>,
     clock: &AtomicTime,
-) -> anyhow::Result<InstrumentType> {
+) -> anyhow::Result<InstrumentAny> {
     let c_str: &CStr = unsafe { CStr::from_ptr(msg.raw_symbol.as_ptr()) };
     let raw_symbol: &str = c_str.to_str().map_err(to_pyvalue_err)?;
-
-    let symbol = Symbol {
-        value: Ustr::from(raw_symbol),
-    };
+    let symbol = Symbol::from(raw_symbol);
 
     let publisher_id = msg.header().publisher_id;
     let venue = publisher_venue_map
         .get(&publisher_id)
         .unwrap_or_else(|| panic!("No venue found for `publisher_id` {publisher_id}"));
     let instrument_id = InstrumentId::new(symbol, *venue);
     let ts_init = clock.get_time_ns();
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/loader.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/loader.rs`

 * *Files 2% similar despite different names*

```diff
@@ -20,15 +20,15 @@
     compat::InstrumentDefMsgV1,
     decode::{dbn::Decoder, DbnMetadata, DecodeStream},
 };
 use indexmap::IndexMap;
 use nautilus_model::{
     data::Data,
     identifiers::{instrument_id::InstrumentId, symbol::Symbol, venue::Venue},
-    instruments::InstrumentType,
+    instruments::InstrumentAny,
     types::currency::Currency,
 };
 use streaming_iterator::StreamingIterator;
 use ustr::Ustr;
 
 use super::{
     decode::{
@@ -39,17 +39,17 @@
     types::{DatabentoImbalance, DatabentoPublisher, DatabentoStatistics, Dataset, PublisherId},
 };
 
 /// Provides a Nautilus data loader for Databento Binary Encoding (DBN) format data.
 ///
 /// # Supported schemas:
 ///  - MBO -> `OrderBookDelta`
-///  - MBP_1 -> `QuoteTick` + `TradeTick`
+///  - MBP_1 -> `(QuoteTick, Option<TradeTick>)`
 ///  - MBP_10 -> `OrderBookDepth10`
-///  - TBBO -> `QuoteTick` + `TradeTick`
+///  - TBBO -> `(QuoteTick, TradeTick)`
 ///  - TRADES -> `TradeTick`
 ///  - OHLCV_1S -> `Bar`
 ///  - OHLCV_1M -> `Bar`
 ///  - OHLCV_1H -> `Bar`
 ///  - OHLCV_1D -> `Bar`
 ///  - DEFINITION -> `Instrument`
 ///  - IMBALANCE -> `DatabentoImbalance`
@@ -144,15 +144,15 @@
         let metadata = decoder.metadata();
         Ok(metadata.schema.map(|schema| schema.to_string()))
     }
 
     pub fn read_definition_records(
         &mut self,
         path: PathBuf,
-    ) -> anyhow::Result<impl Iterator<Item = anyhow::Result<InstrumentType>> + '_> {
+    ) -> anyhow::Result<impl Iterator<Item = anyhow::Result<InstrumentAny>> + '_> {
         let mut decoder = Decoder::from_zstd_file(path)?;
         decoder.set_upgrade_policy(dbn::VersionUpgradePolicy::Upgrade);
         let mut dbn_stream = decoder.decode_stream::<InstrumentDefMsgV1>();
 
         Ok(std::iter::from_fn(move || {
             dbn_stream.advance();
 
@@ -161,23 +161,23 @@
                     let record = dbn::RecordRef::from(rec);
                     let msg = record.get::<InstrumentDefMsgV1>().unwrap();
 
                     let raw_symbol = unsafe {
                         raw_ptr_to_ustr(rec.raw_symbol.as_ptr())
                             .expect("Error obtaining `raw_symbol` pointer")
                     };
-                    let symbol = Symbol { value: raw_symbol };
+                    let symbol = Symbol::from(raw_symbol);
 
                     let venue = self
                         .publisher_venue_map
                         .get(&msg.hd.publisher_id)
                         .expect("`Venue` not found `publisher_id`");
                     let instrument_id = InstrumentId::new(symbol, *venue);
 
-                    match decode_instrument_def_msg_v1(rec, instrument_id, msg.ts_recv) {
+                    match decode_instrument_def_msg_v1(rec, instrument_id, msg.ts_recv.into()) {
                         Ok(data) => Some(Ok(data)),
                         Err(e) => Some(Err(e)),
                     }
                 }
                 None => None,
             }
         }))
@@ -257,15 +257,20 @@
                         )
                         .unwrap(), // TODO: Panic on error for now
                     };
 
                     let msg = record
                         .get::<dbn::ImbalanceMsg>()
                         .expect("Invalid `ImbalanceMsg`");
-                    match decode_imbalance_msg(msg, instrument_id, price_precision, msg.ts_recv) {
+                    match decode_imbalance_msg(
+                        msg,
+                        instrument_id,
+                        price_precision,
+                        msg.ts_recv.into(),
+                    ) {
                         Ok(data) => Some(Ok(data)),
                         Err(e) => Some(Err(e)),
                     }
                 }
                 None => None,
             }
         }))
@@ -297,15 +302,20 @@
                             &metadata,
                             &self.publisher_venue_map,
                         )
                         .unwrap(), // TODO: Panic on error for now
                     };
 
                     let msg = record.get::<dbn::StatMsg>().expect("Invalid `StatMsg`");
-                    match decode_statistics_msg(msg, instrument_id, price_precision, msg.ts_recv) {
+                    match decode_statistics_msg(
+                        msg,
+                        instrument_id,
+                        price_precision,
+                        msg.ts_recv.into(),
+                    ) {
                         Ok(data) => Some(Ok(data)),
                         Err(e) => Some(Err(e)),
                     }
                 }
                 None => None,
             }
         }))
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/publishers.json` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/publishers.json`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/python/enums.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/python/enums.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/python/historical.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/python/historical.rs`

 * *Files 4% similar despite different names*

```diff
@@ -18,30 +18,31 @@
 use databento::{
     dbn::{self, SType},
     historical::timeseries::GetRangeParams,
 };
 use indexmap::IndexMap;
 use nautilus_core::{
     python::to_pyvalue_err,
-    time::{get_atomic_clock_realtime, AtomicTime, UnixNanos},
+    time::{get_atomic_clock_realtime, AtomicTime},
 };
 use nautilus_model::{
     data::{bar::Bar, quote::QuoteTick, trade::TradeTick, Data},
     enums::BarAggregation,
     identifiers::{instrument_id::InstrumentId, symbol::Symbol, venue::Venue},
+    python::instruments::convert_instrument_any_to_pyobject,
     types::currency::Currency,
 };
 use pyo3::{
     exceptions::PyException,
     prelude::*,
     types::{PyDict, PyList},
 };
 use tokio::sync::Mutex;
+use tracing::error;
 
-use super::loader::convert_instrument_to_pyobject;
 use crate::databento::{
     common::get_date_time_range,
     decode::{
         decode_imbalance_msg, decode_instrument_def_msg, decode_record, decode_statistics_msg,
         raw_ptr_to_ustr,
     },
     symbology::{check_consistent_symbology, decode_nautilus_instrument_id, infer_symbology_type},
@@ -110,24 +111,24 @@
 
     #[pyo3(name = "get_range_instruments")]
     fn py_get_range_instruments<'py>(
         &self,
         py: Python<'py>,
         dataset: String,
         symbols: Vec<&str>,
-        start: UnixNanos,
-        end: Option<UnixNanos>,
+        start: u64,
+        end: Option<u64>,
         limit: Option<u64>,
     ) -> PyResult<&'py PyAny> {
         let client = self.inner.clone();
 
         let stype_in = infer_symbology_type(symbols.first().unwrap());
         check_consistent_symbology(symbols.as_slice()).map_err(to_pyvalue_err)?;
-        let end = end.unwrap_or(self.clock.get_time_ns());
-        let time_range = get_date_time_range(start, end).map_err(to_pyvalue_err)?;
+        let end = end.unwrap_or(self.clock.get_time_ns().as_u64());
+        let time_range = get_date_time_range(start.into(), end.into()).map_err(to_pyvalue_err)?;
         let params = GetRangeParams::builder()
             .dataset(dataset)
             .date_time_range(time_range)
             .symbols(symbols)
             .stype_in(SType::from_str(&stype_in).map_err(to_pyvalue_err)?)
             .schema(dbn::Schema::Definition)
             .limit(limit.and_then(NonZeroU64::new))
@@ -146,56 +147,56 @@
 
             decoder.set_upgrade_policy(dbn::VersionUpgradePolicy::Upgrade);
 
             let mut instruments = Vec::new();
 
             while let Ok(Some(msg)) = decoder.decode_record::<dbn::InstrumentDefMsg>().await {
                 let raw_symbol = unsafe { raw_ptr_to_ustr(msg.raw_symbol.as_ptr()).unwrap() };
-                let symbol = Symbol { value: raw_symbol };
+                let symbol = Symbol::from(raw_symbol);
 
                 let publisher = msg.hd.publisher().expect("Invalid `publisher` for record");
                 let venue = publisher_venue_map
                     .get(&msg.hd.publisher_id)
                     .unwrap_or_else(|| panic!("`Venue` not found for `publisher` {publisher}"));
                 let instrument_id = InstrumentId::new(symbol, *venue);
 
                 let result = decode_instrument_def_msg(msg, instrument_id, ts_init);
                 match result {
                     Ok(instrument) => instruments.push(instrument),
-                    Err(e) => eprintln!("{e:?}"),
+                    Err(e) => error!("{e:?}"),
                 };
             }
 
             Python::with_gil(|py| {
                 let py_results: PyResult<Vec<PyObject>> = instruments
                     .into_iter()
-                    .map(|result| convert_instrument_to_pyobject(py, result))
+                    .map(|result| convert_instrument_any_to_pyobject(py, result))
                     .collect();
 
                 py_results.map(|objs| PyList::new(py, &objs).to_object(py))
             })
         })
     }
 
     #[pyo3(name = "get_range_quotes")]
     fn py_get_range_quotes<'py>(
         &self,
         py: Python<'py>,
         dataset: String,
         symbols: Vec<&str>,
-        start: UnixNanos,
-        end: Option<UnixNanos>,
+        start: u64,
+        end: Option<u64>,
         limit: Option<u64>,
     ) -> PyResult<&'py PyAny> {
         let client = self.inner.clone();
 
         let stype_in = infer_symbology_type(symbols.first().unwrap());
         check_consistent_symbology(symbols.as_slice()).map_err(to_pyvalue_err)?;
-        let end = end.unwrap_or(self.clock.get_time_ns());
-        let time_range = get_date_time_range(start, end).map_err(to_pyvalue_err)?;
+        let end = end.unwrap_or(self.clock.get_time_ns().as_u64());
+        let time_range = get_date_time_range(start.into(), end.into()).map_err(to_pyvalue_err)?;
         let params = GetRangeParams::builder()
             .dataset(dataset)
             .date_time_range(time_range)
             .symbols(symbols)
             .stype_in(SType::from_str(&stype_in).map_err(to_pyvalue_err)?)
             .schema(dbn::Schema::Mbp1)
             .limit(limit.and_then(NonZeroU64::new))
@@ -245,24 +246,24 @@
 
     #[pyo3(name = "get_range_trades")]
     fn py_get_range_trades<'py>(
         &self,
         py: Python<'py>,
         dataset: String,
         symbols: Vec<&str>,
-        start: UnixNanos,
-        end: Option<UnixNanos>,
+        start: u64,
+        end: Option<u64>,
         limit: Option<u64>,
     ) -> PyResult<&'py PyAny> {
         let client = self.inner.clone();
 
         let stype_in = infer_symbology_type(symbols.first().unwrap());
         check_consistent_symbology(symbols.as_slice()).map_err(to_pyvalue_err)?;
-        let end = end.unwrap_or(self.clock.get_time_ns());
-        let time_range = get_date_time_range(start, end).map_err(to_pyvalue_err)?;
+        let end = end.unwrap_or(self.clock.get_time_ns().as_u64());
+        let time_range = get_date_time_range(start.into(), end.into()).map_err(to_pyvalue_err)?;
         let params = GetRangeParams::builder()
             .dataset(dataset)
             .date_time_range(time_range)
             .symbols(symbols)
             .stype_in(SType::from_str(&stype_in).map_err(to_pyvalue_err)?)
             .schema(dbn::Schema::Trades)
             .limit(limit.and_then(NonZeroU64::new))
@@ -314,31 +315,31 @@
     #[allow(clippy::too_many_arguments)]
     fn py_get_range_bars<'py>(
         &self,
         py: Python<'py>,
         dataset: String,
         symbols: Vec<&str>,
         aggregation: BarAggregation,
-        start: UnixNanos,
-        end: Option<UnixNanos>,
+        start: u64,
+        end: Option<u64>,
         limit: Option<u64>,
     ) -> PyResult<&'py PyAny> {
         let client = self.inner.clone();
 
         let stype_in = infer_symbology_type(symbols.first().unwrap());
         check_consistent_symbology(symbols.as_slice()).map_err(to_pyvalue_err)?;
         let schema = match aggregation {
             BarAggregation::Second => dbn::Schema::Ohlcv1S,
             BarAggregation::Minute => dbn::Schema::Ohlcv1M,
             BarAggregation::Hour => dbn::Schema::Ohlcv1H,
             BarAggregation::Day => dbn::Schema::Ohlcv1D,
             _ => panic!("Invalid `BarAggregation` for request, was {aggregation}"),
         };
-        let end = end.unwrap_or(self.clock.get_time_ns());
-        let time_range = get_date_time_range(start, end).map_err(to_pyvalue_err)?;
+        let end = end.unwrap_or(self.clock.get_time_ns().as_u64());
+        let time_range = get_date_time_range(start.into(), end.into()).map_err(to_pyvalue_err)?;
         let params = GetRangeParams::builder()
             .dataset(dataset)
             .date_time_range(time_range)
             .symbols(symbols)
             .stype_in(SType::from_str(&stype_in).map_err(to_pyvalue_err)?)
             .schema(schema)
             .limit(limit.and_then(NonZeroU64::new))
@@ -389,24 +390,24 @@
     #[pyo3(name = "get_range_imbalance")]
     #[allow(clippy::too_many_arguments)]
     fn py_get_range_imbalance<'py>(
         &self,
         py: Python<'py>,
         dataset: String,
         symbols: Vec<&str>,
-        start: UnixNanos,
-        end: Option<UnixNanos>,
+        start: u64,
+        end: Option<u64>,
         limit: Option<u64>,
     ) -> PyResult<&'py PyAny> {
         let client = self.inner.clone();
 
         let stype_in = infer_symbology_type(symbols.first().unwrap());
         check_consistent_symbology(symbols.as_slice()).map_err(to_pyvalue_err)?;
-        let end = end.unwrap_or(self.clock.get_time_ns());
-        let time_range = get_date_time_range(start, end).map_err(to_pyvalue_err)?;
+        let end = end.unwrap_or(self.clock.get_time_ns().as_u64());
+        let time_range = get_date_time_range(start.into(), end.into()).map_err(to_pyvalue_err)?;
         let params = GetRangeParams::builder()
             .dataset(dataset)
             .date_time_range(time_range)
             .symbols(symbols)
             .stype_in(SType::from_str(&stype_in).map_err(to_pyvalue_err)?)
             .schema(dbn::Schema::Imbalance)
             .limit(limit.and_then(NonZeroU64::new))
@@ -446,24 +447,24 @@
     #[pyo3(name = "get_range_statistics")]
     #[allow(clippy::too_many_arguments)]
     fn py_get_range_statistics<'py>(
         &self,
         py: Python<'py>,
         dataset: String,
         symbols: Vec<&str>,
-        start: UnixNanos,
-        end: Option<UnixNanos>,
+        start: u64,
+        end: Option<u64>,
         limit: Option<u64>,
     ) -> PyResult<&'py PyAny> {
         let client = self.inner.clone();
 
         let stype_in = infer_symbology_type(symbols.first().unwrap());
         check_consistent_symbology(symbols.as_slice()).map_err(to_pyvalue_err)?;
-        let end = end.unwrap_or(self.clock.get_time_ns());
-        let time_range = get_date_time_range(start, end).map_err(to_pyvalue_err)?;
+        let end = end.unwrap_or(self.clock.get_time_ns().as_u64());
+        let time_range = get_date_time_range(start.into(), end.into()).map_err(to_pyvalue_err)?;
         let params = GetRangeParams::builder()
             .dataset(dataset)
             .date_time_range(time_range)
             .symbols(symbols)
             .stype_in(SType::from_str(&stype_in).map_err(to_pyvalue_err)?)
             .schema(dbn::Schema::Statistics)
             .limit(limit.and_then(NonZeroU64::new))
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/python/live.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/python/live.rs`

 * *Files 2% similar despite different names*

```diff
@@ -9,29 +9,28 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{fs, str::FromStr};
+use std::{fs, i128, str::FromStr};
 
 use databento::{dbn, live::Subscription};
 use indexmap::IndexMap;
-use nautilus_core::{
-    python::{to_pyruntime_err, to_pyvalue_err},
-    time::UnixNanos,
+use nautilus_core::python::{to_pyruntime_err, to_pyvalue_err};
+use nautilus_model::{
+    identifiers::venue::Venue,
+    python::{data::data_to_pycapsule, instruments::convert_instrument_any_to_pyobject},
 };
-use nautilus_model::{identifiers::venue::Venue, python::data::data_to_pycapsule};
 use pyo3::prelude::*;
 use time::OffsetDateTime;
 use tokio::sync::mpsc;
 use tracing::{debug, error, trace};
 
-use super::loader::convert_instrument_to_pyobject;
 use crate::databento::{
     live::{DatabentoFeedHandler, LiveCommand, LiveMessage},
     symbology::{check_consistent_symbology, infer_symbology_type},
     types::DatabentoPublisher,
 };
 
 #[cfg_attr(
@@ -70,15 +69,15 @@
             trace!("Received message: {:?}", msg);
             let result = match msg {
                 LiveMessage::Data(data) => Python::with_gil(|py| {
                     let py_obj = data_to_pycapsule(py, data);
                     call_python(py, &callback, py_obj)
                 }),
                 LiveMessage::Instrument(data) => Python::with_gil(|py| {
-                    let py_obj = convert_instrument_to_pyobject(py, data)
+                    let py_obj = convert_instrument_any_to_pyobject(py, data)
                         .expect("Error creating instrument");
                     call_python(py, &callback, py_obj)
                 }),
                 LiveMessage::Imbalance(data) => Python::with_gil(|py| {
                     let py_obj = data.into_py(py);
                     call_python(py, &callback_pyo3, py_obj)
                 }),
@@ -148,15 +147,15 @@
     }
 
     #[pyo3(name = "subscribe")]
     fn py_subscribe(
         &mut self,
         schema: String,
         symbols: Vec<&str>,
-        start: Option<UnixNanos>,
+        start: Option<u64>,
     ) -> PyResult<()> {
         let stype_in = infer_symbology_type(symbols.first().unwrap());
         check_consistent_symbology(symbols.as_slice()).map_err(to_pyvalue_err)?;
         let mut sub = Subscription::builder()
             .symbols(symbols)
             .schema(dbn::Schema::from_str(&schema).map_err(to_pyvalue_err)?)
             .stype_in(dbn::SType::from_str(&stype_in).map_err(to_pyvalue_err)?)
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/python/loader.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/python/loader.rs`

 * *Files 2% similar despite different names*

```diff
@@ -19,15 +19,15 @@
 use nautilus_core::{ffi::cvec::CVec, python::to_pyvalue_err};
 use nautilus_model::{
     data::{
         bar::Bar, delta::OrderBookDelta, depth::OrderBookDepth10, quote::QuoteTick,
         trade::TradeTick, Data,
     },
     identifiers::{instrument_id::InstrumentId, venue::Venue},
-    instruments::InstrumentType,
+    python::instruments::convert_instrument_any_to_pyobject,
 };
 use pyo3::{
     prelude::*,
     types::{PyCapsule, PyList},
 };
 
 use crate::databento::{
@@ -84,15 +84,15 @@
             .read_definition_records(path_buf)
             .map_err(to_pyvalue_err)?;
 
         let mut data = Vec::new();
         for result in iter {
             match result {
                 Ok(instrument) => {
-                    let py_object = convert_instrument_to_pyobject(py, instrument)?;
+                    let py_object = convert_instrument_any_to_pyobject(py, instrument)?;
                     data.push(py_object);
                 }
                 Err(e) => {
                     eprintln!("{e}");
                 }
             }
         }
@@ -396,28 +396,14 @@
             }
         }
 
         Ok(data)
     }
 }
 
-pub fn convert_instrument_to_pyobject(
-    py: Python,
-    instrument: InstrumentType,
-) -> PyResult<PyObject> {
-    match instrument {
-        InstrumentType::Equity(inst) => Ok(inst.into_py(py)),
-        InstrumentType::FuturesContract(inst) => Ok(inst.into_py(py)),
-        InstrumentType::FuturesSpread(inst) => Ok(inst.into_py(py)),
-        InstrumentType::OptionsContract(inst) => Ok(inst.into_py(py)),
-        InstrumentType::OptionsSpread(inst) => Ok(inst.into_py(py)),
-        _ => Err(to_pyvalue_err("Unsupported instrument type")),
-    }
-}
-
 fn exhaust_data_iter_to_pycapsule(
     py: Python,
     iter: impl Iterator<Item = anyhow::Result<(Option<Data>, Option<Data>)>>,
 ) -> anyhow::Result<PyObject> {
     let mut data = Vec::new();
     for result in iter {
         match result {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/python/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/python/mod.rs`

 * *Files 4% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+#![allow(warnings)] // non-local `impl` definition, temporary allow until pyo3 upgrade
+
 pub mod enums;
 pub mod historical;
 pub mod live;
 pub mod loader;
 pub mod types;
 
 use pyo3::prelude::*;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/python/types.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/python/types.rs`

 * *Files 3% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::hash_map::DefaultHasher,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::{python::serialization::from_dict_pyo3, time::UnixNanos};
+use nautilus_core::python::serialization::from_dict_pyo3;
 use nautilus_model::{
     enums::OrderSide,
     identifiers::instrument_id::InstrumentId,
     types::{price::Price, quantity::Quantity},
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
 
@@ -115,28 +115,28 @@
     #[pyo3(name = "significant_imbalance")]
     fn py_significant_imbalance(&self) -> String {
         self.significant_imbalance.to_string()
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_recv")]
-    fn py_ts_recv(&self) -> UnixNanos {
-        self.ts_recv
+    fn py_ts_recv(&self) -> u64 {
+        self.ts_recv.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
@@ -236,40 +236,40 @@
     #[pyo3(name = "sequence")]
     fn py_sequence(&self) -> u32 {
         self.sequence
     }
 
     #[getter]
     #[pyo3(name = "ts_ref")]
-    fn py_ts_ref(&self) -> UnixNanos {
-        self.ts_ref
+    fn py_ts_ref(&self) -> u64 {
+        self.ts_ref.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_in_delta")]
     fn py_ts_in_delta(&self) -> i32 {
         self.ts_in_delta
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[pyo3(name = "ts_recv")]
     #[getter]
-    fn py_ts_recv(&self) -> UnixNanos {
-        self.ts_recv
+    fn py_ts_recv(&self) -> u64 {
+        self.ts_recv.as_u64()
     }
 
     #[pyo3(name = "ts_init")]
     #[getter]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/symbology.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/symbology.rs`

 * *Files 4% similar despite different names*

```diff
@@ -12,14 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use databento::dbn;
 use dbn::Record;
 use indexmap::IndexMap;
+use nautilus_core::correctness::check_slice_not_empty;
 use nautilus_model::identifiers::{instrument_id::InstrumentId, symbol::Symbol, venue::Venue};
 
 use super::types::PublisherId;
 
 pub fn decode_nautilus_instrument_id(
     record: &dbn::RecordRef,
     metadata: &dbn::Metadata,
@@ -88,17 +89,15 @@
         return "instrument_id".to_string();
     }
 
     "raw_symbol".to_string()
 }
 
 pub fn check_consistent_symbology(symbols: &[&str]) -> anyhow::Result<()> {
-    if symbols.is_empty() {
-        return Err(anyhow::anyhow!("Symbols was empty"));
-    };
+    check_slice_not_empty(symbols, stringify!(symbols))?;
 
     // SAFETY: We checked len so know there must be at least one symbol
     let first_symbol = symbols.first().unwrap();
     let first_stype = infer_symbology_type(first_symbol);
 
     for symbol in symbols {
         let next_stype = infer_symbology_type(symbol);
@@ -145,15 +144,18 @@
     }
 
     #[rstest]
     fn test_check_consistent_symbology_when_empty_symbols() {
         let symbols: Vec<&str> = vec![];
         let result = check_consistent_symbology(&symbols);
         assert!(result.is_err());
-        assert_eq!(result.err().unwrap().to_string(), "Symbols was empty");
+        assert_eq!(
+            result.err().unwrap().to_string(),
+            "Condition failed: the 'symbols' slice `&[&str]` was empty"
+        );
     }
 
     #[rstest]
     fn test_check_consistent_symbology_when_inconsistent() {
         let symbols = vec!["ESM4", "ES.OPT"];
         let result = check_consistent_symbology(&symbols);
         assert!(result.is_err());
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/databento/types.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/databento/types.rs`

 * *Files 1% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::ffi::c_char;
 
 use databento::dbn;
-use nautilus_core::time::UnixNanos;
+use nautilus_core::nanos::UnixNanos;
 use nautilus_model::{
     enums::OrderSide,
     identifiers::instrument_id::InstrumentId,
     types::{price::Price, quantity::Quantity},
 };
 use serde::Deserialize;
 use ustr::Ustr;
@@ -49,15 +49,15 @@
     /// The publisher description.
     pub description: String,
 }
 
 /// Represents an auction imbalance.
 ///
 /// This data type includes the populated data fields provided by `Databento`,
-/// except for the `publisher_id` and `instrument_id` integers.
+/// excluding `publisher_id` and `instrument_id`.
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.databento")
 )]
 #[derive(Clone, Debug, PartialEq, Eq, Hash, Deserialize)]
 pub struct DatabentoImbalance {
     // The instrument ID for the imbalance data.
@@ -111,18 +111,18 @@
             ts_event,
             ts_recv,
             ts_init,
         })
     }
 }
 
-/// Represents a statistics.
+/// Represents a market statistics snapshot.
 ///
 /// This data type includes the populated data fields provided by `Databento`,
-/// except for the `publisher_id` and `instrument_id` integers.
+/// excluding `publisher_id` and `instrument_id`.
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.databento")
 )]
 #[derive(Clone, Debug, PartialEq, Eq, Hash, Deserialize)]
 pub struct DatabentoStatistics {
     // The instrument ID for the statistics message.
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/adapters/src/lib.rs` & `nautilus_trader-1.191.0/nautilus_core/adapters/src/lib.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/backtest/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/backtest/Cargo.toml`

 * *Files 12% similar despite different names*

```diff
@@ -11,14 +11,16 @@
 crate-type = ["rlib", "staticlib"]
 
 [dependencies]
 nautilus-common = { path = "../common" }
 nautilus-core = { path = "../core" }
 nautilus-execution = { path = "../execution" }
 nautilus-model = { path = "../model" }
+anyhow = { workspace = true }
+log = { workspace = true }
 pyo3 = { workspace = true, optional = true }
 ustr = { workspace = true }
 
 [dev-dependencies]
 tempfile = { workspace = true }
 rstest = { workspace = true}
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/backtest/build.rs` & `nautilus_trader-1.191.0/nautilus_core/backtest/build.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/backtest/cbindgen_cython.toml` & `nautilus_trader-1.191.0/nautilus_core/backtest/cbindgen_cython.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/backtest/src/engine.rs` & `nautilus_trader-1.191.0/nautilus_core/backtest/src/engine.rs`

 * *Files 4% similar despite different names*

```diff
@@ -14,24 +14,24 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::ops::{Deref, DerefMut};
 
 use nautilus_common::{clock::TestClock, ffi::clock::TestClock_API, timer::TimeEventHandler};
 use nautilus_core::{
     ffi::{cvec::CVec, parsing::u8_as_bool},
-    time::UnixNanos,
+    nanos::UnixNanos,
 };
 
 /// Provides a means of accumulating and draining time event handlers.
 pub struct TimeEventAccumulator {
     event_handlers: Vec<TimeEventHandler>,
 }
 
 impl TimeEventAccumulator {
-    /// Initializes a new `TimeEventAccumulator` instance.
+    /// Creates a new `TimeEventAccumulator` instance.
     #[must_use]
     pub fn new() -> Self {
         Self {
             event_handlers: Vec::new(),
         }
     }
 
@@ -124,17 +124,32 @@
 
         Python::with_gil(|py| {
             let py_list = PyList::empty(py);
             let py_append = Py::from(py_list.getattr("append").unwrap());
 
             let mut accumulator = TimeEventAccumulator::new();
 
-            let time_event1 = TimeEvent::new(Ustr::from("TEST_EVENT_1"), UUID4::new(), 100, 100);
-            let time_event2 = TimeEvent::new(Ustr::from("TEST_EVENT_2"), UUID4::new(), 300, 300);
-            let time_event3 = TimeEvent::new(Ustr::from("TEST_EVENT_3"), UUID4::new(), 200, 200);
+            let time_event1 = TimeEvent::new(
+                Ustr::from("TEST_EVENT_1"),
+                UUID4::new(),
+                100.into(),
+                100.into(),
+            );
+            let time_event2 = TimeEvent::new(
+                Ustr::from("TEST_EVENT_2"),
+                UUID4::new(),
+                300.into(),
+                300.into(),
+            );
+            let time_event3 = TimeEvent::new(
+                Ustr::from("TEST_EVENT_3"),
+                UUID4::new(),
+                200.into(),
+                200.into(),
+            );
 
             // Note: as_ptr returns a borrowed pointer. It is valid as long
             // as the object is in scope. In this case `callback_ptr` is valid
             // as long as `py_append` is in scope.
             let callback_ptr = py_append
                 .as_ptr()
                 .cast::<pyo3::ffi::PyObject>()
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/backtest/src/lib.rs` & `nautilus_trader-1.191.0/nautilus_core/backtest/src/lib.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/common/Cargo.toml`

 * *Files 7% similar despite different names*

```diff
@@ -12,28 +12,30 @@
 
 [dependencies]
 nautilus-core = { path = "../core" }
 nautilus-model = { path = "../model" }
 anyhow = { workspace = true }
 chrono = { workspace = true }
 indexmap = { workspace = true }
+itertools = { workspace = true }
 log = { workspace = true }
 pyo3 = { workspace = true, optional = true }
 pyo3-asyncio = { workspace = true, optional = true }
-redis = { workspace = true, optional = true }
+rstest = { workspace = true , optional = true}
+rust_decimal = { workspace = true }
+rust_decimal_macros = { workspace = true }
 serde = { workspace = true }
 serde_json = { workspace = true }
 strum = { workspace = true }
-ustr = { workspace = true }
-rstest = { workspace = true , optional = true}
+sysinfo = "0.30.11"
 tokio = { workspace = true }
-tracing = { workspace = true }
-sysinfo = "0.30.7"
 # Disable default feature "tracing-log" since it interferes with custom logging
 tracing-subscriber = { version = "0.3.18", default-features = false, features = ["smallvec", "fmt", "ansi", "std", "env-filter"] }
+tracing = { workspace = true }
+ustr = { workspace = true }
 
 [dev-dependencies]
 rstest = { workspace = true }
 tempfile = { workspace = true }
 
 [build-dependencies]
 cbindgen = { workspace = true, optional = true }
@@ -44,8 +46,7 @@
     "pyo3/extension-module",
     "nautilus-core/extension-module",
     "nautilus-model/extension-module",
 ]
 ffi = ["cbindgen", "nautilus-core/ffi", "nautilus-model/ffi"]
 python = ["pyo3", "pyo3-asyncio", "nautilus-core/python", "nautilus-model/python"]
 stubs = ["rstest", "nautilus-model/stubs"]
-redis = ["dep:redis"]
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/build.rs` & `nautilus_trader-1.191.0/nautilus_core/common/build.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/cbindgen.toml` & `nautilus_trader-1.191.0/nautilus_core/common/cbindgen.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/cbindgen_cython.toml` & `nautilus_trader-1.191.0/nautilus_core/common/cbindgen_cython.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/cache.rs` & `nautilus_trader-1.191.0/nautilus_core/execution/src/client.rs`

 * *Files 25% similar despite different names*

```diff
@@ -9,149 +9,233 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-#![allow(dead_code)] // Under development
+// Under development
+#![allow(dead_code)]
+#![allow(unused_variables)]
 
-use std::{
-    collections::{HashMap, HashSet, VecDeque},
-    sync::mpsc::Receiver,
-};
-
-use nautilus_core::uuid::UUID4;
+use nautilus_common::cache::Cache;
+use nautilus_core::nanos::UnixNanos;
 use nautilus_model::{
-    data::{
-        bar::{Bar, BarType},
-        quote::QuoteTick,
-        trade::TradeTick,
-    },
+    enums::{AccountType, LiquiditySide, OmsType, OrderSide, OrderType},
+    events::{account::state::AccountState, order::event::OrderEvent},
     identifiers::{
-        account_id::AccountId, client_id::ClientId, client_order_id::ClientOrderId,
-        component_id::ComponentId, exec_algorithm_id::ExecAlgorithmId, instrument_id::InstrumentId,
-        position_id::PositionId, strategy_id::StrategyId, symbol::Symbol, trader_id::TraderId,
-        venue::Venue, venue_order_id::VenueOrderId,
+        account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
+        position_id::PositionId, strategy_id::StrategyId, trade_id::TradeId, venue::Venue,
+        venue_order_id::VenueOrderId,
+    },
+    types::{
+        balance::{AccountBalance, MarginBalance},
+        currency::Currency,
+        money::Money,
+        price::Price,
+        quantity::Quantity,
     },
-    instruments::{synthetic::SyntheticInstrument, Instrument},
-    orders::base::Order,
-    position::Position,
-    types::currency::Currency,
 };
-use ustr::Ustr;
 
-/// A type of database operation.
-#[derive(Clone, Debug)]
-pub enum DatabaseOperation {
-    Insert,
-    Update,
-    Delete,
-}
+use crate::messages::{
+    cancel::CancelOrder, cancel_batch::BatchCancelOrders, modify::ModifyOrder, query::QueryOrder,
+    submit::SubmitOrder, submit_list::SubmitOrderList,
+};
 
-/// Represents a database command to be performed which may be executed 'remotely' across a thread.
-#[derive(Clone, Debug)]
-pub struct DatabaseCommand {
-    /// The database operation type.
-    pub op_type: DatabaseOperation,
-    /// The primary key for the operation.
-    pub key: String,
-    /// The data payload for the operation.
-    pub payload: Option<Vec<Vec<u8>>>,
-}
+pub struct ExecutionClient {
+    pub venue: Venue,
+    pub oms_type: OmsType,
+    pub account_id: AccountId,
+    pub account_type: AccountType,
+    pub base_currency: Option<Currency>,
+    pub is_connected: bool,
+    cache: &'static Cache,
+}
+
+impl ExecutionClient {
+    // TODO: Polymorphism for `Account` TBD?
+    // pub fn get_account(&self) -> Box<dyn Account> {
+    //     todo!();
+    // }
+
+    // -- COMMAND HANDLERS ----------------------------------------------------
 
-impl DatabaseCommand {
-    pub fn new(op_type: DatabaseOperation, key: String, payload: Option<Vec<Vec<u8>>>) -> Self {
-        Self {
-            op_type,
-            key,
-            payload,
-        }
+    pub fn submit_order(&self, command: SubmitOrder) -> anyhow::Result<()> {
+        todo!();
     }
-}
 
-/// Provides a generic cache database facade.
-///
-/// The main operations take a consistent `key` and `payload` which should provide enough
-/// information to implement the cache database in many different technologies.
-///
-/// Delete operations may need a `payload` to target specific values.
-pub trait CacheDatabase {
-    type DatabaseType;
-
-    fn new(
-        trader_id: TraderId,
-        instance_id: UUID4,
-        config: HashMap<String, serde_json::Value>,
-    ) -> anyhow::Result<Self::DatabaseType>;
-    fn flushdb(&mut self) -> anyhow::Result<()>;
-    fn keys(&mut self, pattern: &str) -> anyhow::Result<Vec<String>>;
-    fn read(&mut self, key: &str) -> anyhow::Result<Vec<Vec<u8>>>;
-    fn insert(&mut self, key: String, payload: Option<Vec<Vec<u8>>>) -> anyhow::Result<()>;
-    fn update(&mut self, key: String, payload: Option<Vec<Vec<u8>>>) -> anyhow::Result<()>;
-    fn delete(&mut self, key: String, payload: Option<Vec<Vec<u8>>>) -> anyhow::Result<()>;
-    fn handle_messages(
-        rx: Receiver<DatabaseCommand>,
-        trader_key: String,
-        config: HashMap<String, serde_json::Value>,
-    );
-}
+    pub fn submit_order_list(&self, command: SubmitOrderList) -> anyhow::Result<()> {
+        todo!();
+    }
 
-pub struct CacheConfig {
-    pub tick_capacity: usize,
-    pub bar_capacity: usize,
-    pub snapshot_orders: bool,
-    pub snapshot_positions: bool,
-}
+    pub fn modify_order(&self, command: ModifyOrder) -> anyhow::Result<()> {
+        todo!();
+    }
 
-pub struct CacheIndex {
-    venue_account: HashMap<Venue, AccountId>,
-    venue_orders: HashMap<Venue, HashSet<ClientOrderId>>,
-    venue_positions: HashMap<Venue, HashSet<PositionId>>,
-    order_ids: HashMap<VenueOrderId, ClientOrderId>,
-    order_position: HashMap<ClientOrderId, PositionId>,
-    order_strategy: HashMap<ClientOrderId, StrategyId>,
-    order_client: HashMap<ClientOrderId, ClientId>,
-    position_strategy: HashMap<PositionId, StrategyId>,
-    position_orders: HashMap<PositionId, HashSet<ClientOrderId>>,
-    instrument_orders: HashMap<InstrumentId, HashSet<ClientOrderId>>,
-    instrument_positions: HashMap<InstrumentId, HashSet<PositionId>>,
-    strategy_orders: HashMap<StrategyId, HashSet<ClientOrderId>>,
-    strategy_positions: HashMap<StrategyId, HashSet<PositionId>>,
-    exec_algorithm_orders: HashMap<ExecAlgorithmId, HashSet<ClientOrderId>>,
-    exec_spawn_orders: HashMap<ExecAlgorithmId, HashSet<ClientOrderId>>,
-    orders: HashSet<ClientOrderId>,
-    orders_open: HashSet<ClientOrderId>,
-    orders_closed: HashSet<ClientOrderId>,
-    orders_emulated: HashSet<ClientOrderId>,
-    orders_inflight: HashSet<ClientOrderId>,
-    orders_pending_cancel: HashSet<ClientOrderId>,
-    positions: HashSet<PositionId>,
-    positions_open: HashSet<PositionId>,
-    positions_closed: HashSet<PositionId>,
-    actors: HashSet<ComponentId>,
-    strategies: HashSet<StrategyId>,
-    exec_algorithms: HashSet<ExecAlgorithmId>,
-}
+    pub fn cancel_order(&self, command: CancelOrder) -> anyhow::Result<()> {
+        todo!();
+    }
+
+    pub fn batch_cancel_orders(&self, command: BatchCancelOrders) -> anyhow::Result<()> {
+        todo!();
+    }
+
+    pub fn query_order(&self, command: QueryOrder) -> anyhow::Result<()> {
+        todo!();
+    }
+
+    pub fn generate_account_state(
+        &self,
+        balances: Vec<AccountBalance>,
+        margins: Vec<MarginBalance>,
+        reported: bool,
+        ts_event: UnixNanos,
+        // info:  TODO: Need to double check the use case here
+    ) -> anyhow::Result<()> {
+        todo!();
+    }
+
+    pub fn generate_order_submitted(
+        &self,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        ts_event: UnixNanos,
+    ) {
+        todo!();
+    }
+
+    pub fn generate_order_rejected(
+        &self,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        reason: &str,
+        ts_event: UnixNanos,
+    ) {
+        todo!();
+    }
+
+    pub fn generate_order_accepted(
+        &self,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        venue_order_id: VenueOrderId,
+        reason: &str,
+        ts_event: UnixNanos,
+    ) {
+        todo!();
+    }
+
+    pub fn generate_order_modify_rejected(
+        &self,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        venue_order_id: VenueOrderId,
+        reason: &str,
+        ts_event: UnixNanos,
+    ) {
+        todo!();
+    }
+
+    pub fn generate_order_cancel_rejected(
+        &self,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        venue_order_id: VenueOrderId,
+        reason: &str,
+        ts_event: UnixNanos,
+    ) {
+        todo!();
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    pub fn generate_order_updated(
+        &self,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        venue_order_id: VenueOrderId,
+        quantity: Quantity,
+        price: Price,
+        trigger_price: Option<Price>,
+        reason: &str,
+        ts_event: UnixNanos,
+        venue_order_id_modified: bool,
+    ) {
+        todo!();
+    }
+
+    pub fn generate_order_canceled(
+        &self,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        venue_order_id: VenueOrderId,
+        ts_event: UnixNanos,
+    ) {
+        todo!();
+    }
+
+    pub fn generate_order_triggered(
+        &self,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        venue_order_id: VenueOrderId,
+        ts_event: UnixNanos,
+    ) {
+        todo!();
+    }
+
+    pub fn generate_order_expired(
+        &self,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        venue_order_id: VenueOrderId,
+        ts_event: UnixNanos,
+    ) {
+        todo!();
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    pub fn generate_order_filled(
+        &self,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        venue_order_id: VenueOrderId,
+        venue_position_id: PositionId,
+        trade_id: TradeId,
+        order_side: OrderSide,
+        order_type: OrderType,
+        last_qty: Quantity,
+        last_px: Price,
+        quote_currency: Currency,
+        commission: Money,
+        liquidity_side: LiquiditySide,
+        ts_event: UnixNanos,
+    ) {
+        todo!();
+    }
+
+    fn send_account_state(&self, account_state: AccountState) {
+        todo!()
+    }
+
+    fn send_order_event(&self, event: OrderEvent) {
+        todo!()
+    }
+
+    // TODO: Implement execution reports
+    // fn send_mass_status_report(&self, report)
+
+    // TODO: Implement execution reports
+    // fn send_order_status_report(&self, report)
 
-pub struct Cache {
-    config: CacheConfig,
-    index: CacheIndex,
-    // database: Option<Box<dyn CacheDatabase>>,  TODO
-    // xrate_calculator: ExchangeRateCalculator TODO
-    general: HashMap<Ustr, Vec<u8>>,
-    xrate_symbols: HashMap<InstrumentId, Symbol>,
-    quote_ticks: HashMap<InstrumentId, VecDeque<QuoteTick>>,
-    trade_ticks: HashMap<InstrumentId, VecDeque<TradeTick>>,
-    // order_books: HashMap<InstrumentId, OrderBook>>,  TODO: Needs single book
-    bars: HashMap<BarType, VecDeque<Bar>>,
-    bars_bid: HashMap<BarType, Bar>,
-    bars_ask: HashMap<BarType, Bar>,
-    currencies: HashMap<Ustr, Currency>,
-    instruments: HashMap<InstrumentId, Box<dyn Instrument>>,
-    synthetics: HashMap<InstrumentId, SyntheticInstrument>,
-    // accounts: HashMap<AccountId, Box<dyn Account>>,  TODO: Decide where trait should go
-    orders: HashMap<ClientOrderId, VecDeque<Box<dyn Order>>>, // TODO: Efficency (use enum)
-    // order_lists: HashMap<OrderListId, VecDeque<OrderList>>,  TODO: Need `OrderList`
-    positions: HashMap<PositionId, Position>,
-    position_snapshots: HashMap<PositionId, Vec<u8>>,
+    // TODO: Implement execution reports
+    // fn send_fill_report(&self, report)
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/clock.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/clock.rs`

 * *Files 6% similar despite different names*

```diff
@@ -12,17 +12,19 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::{collections::HashMap, ops::Deref};
 
 use nautilus_core::{
-    correctness::check_valid_string,
-    time::{get_atomic_clock_realtime, AtomicTime, UnixNanos},
+    correctness::{check_positive_u64, check_predicate_true, check_valid_string},
+    nanos::UnixNanos,
+    time::{get_atomic_clock_realtime, AtomicTime},
 };
+use tracing::error;
 use ustr::Ustr;
 
 use crate::{
     handlers::EventHandler,
     timer::{LiveTimer, TestTimer, TimeEvent, TimeEventHandler},
 };
 
@@ -44,27 +46,27 @@
     /// Set a `Timer` to alert at a particular time. Optional
     /// callback gets used to handle generated events.
     fn set_time_alert_ns(
         &mut self,
         name: &str,
         alert_time_ns: UnixNanos,
         callback: Option<EventHandler>,
-    );
+    ) -> anyhow::Result<()>;
 
     /// Set a `Timer` to start alerting at every interval
     /// between start and stop time. Optional callback gets
     /// used to handle generated event.
     fn set_timer_ns(
         &mut self,
         name: &str,
         interval_ns: u64,
         start_time_ns: UnixNanos,
         stop_time_ns: Option<UnixNanos>,
         callback: Option<EventHandler>,
-    );
+    ) -> anyhow::Result<()>;
 
     fn next_time_ns(&self, name: &str) -> UnixNanos;
     fn cancel_timer(&mut self, name: &str);
     fn cancel_timers(&mut self);
 }
 
 pub struct TestClock {
@@ -74,15 +76,15 @@
     callbacks: HashMap<Ustr, EventHandler>,
 }
 
 impl TestClock {
     #[must_use]
     pub fn new() -> Self {
         Self {
-            time: AtomicTime::new(false, 0),
+            time: AtomicTime::new(false, UnixNanos::default()),
             timers: HashMap::new(),
             default_callback: None,
             callbacks: HashMap::new(),
         }
     }
 
     #[must_use]
@@ -179,62 +181,68 @@
     }
 
     fn set_time_alert_ns(
         &mut self,
         name: &str,
         alert_time_ns: UnixNanos,
         callback: Option<EventHandler>,
-    ) {
-        check_valid_string(name, stringify!(name)).unwrap();
-        assert!(
+    ) -> anyhow::Result<()> {
+        check_valid_string(name, stringify!(name))?;
+        check_predicate_true(
             callback.is_some() | self.default_callback.is_some(),
-            "All Python callbacks were `None`"
-        );
+            "All Python callbacks were `None`",
+        )?;
 
         let name_ustr = Ustr::from(name);
         match callback {
             Some(callback_py) => self.callbacks.insert(name_ustr, callback_py),
             None => None,
         };
 
-        // TODO: should the atomic clock be shared
-        // currently share timestamp nanoseconds
         let time_ns = self.time.get_time_ns();
-        let timer = TestTimer::new(name, alert_time_ns - time_ns, time_ns, Some(alert_time_ns));
+        let timer = TestTimer::new(
+            name,
+            (alert_time_ns - time_ns).into(),
+            time_ns,
+            Some(alert_time_ns),
+        )?;
         self.timers.insert(name_ustr, timer);
+        Ok(())
     }
 
     fn set_timer_ns(
         &mut self,
         name: &str,
         interval_ns: u64,
         start_time_ns: UnixNanos,
         stop_time_ns: Option<UnixNanos>,
         callback: Option<EventHandler>,
-    ) {
-        check_valid_string(name, "name").unwrap();
-        assert!(
+    ) -> anyhow::Result<()> {
+        check_valid_string(name, "name")?;
+        check_positive_u64(interval_ns, stringify!(interval_ns))?;
+        check_predicate_true(
             callback.is_some() | self.default_callback.is_some(),
-            "All Python callbacks were `None`"
-        );
+            "All Python callbacks were `None`",
+        )?;
 
         let name_ustr = Ustr::from(name);
         match callback {
             Some(callback_py) => self.callbacks.insert(name_ustr, callback_py),
             None => None,
         };
 
-        let timer = TestTimer::new(name, interval_ns, start_time_ns, stop_time_ns);
+        let timer = TestTimer::new(name, interval_ns, start_time_ns, stop_time_ns)?;
         self.timers.insert(name_ustr, timer);
+        Ok(())
     }
 
     fn next_time_ns(&self, name: &str) -> UnixNanos {
         let timer = self.timers.get(&Ustr::from(name));
         match timer {
-            None => 0,
+            None => 0.into(),
             Some(timer) => timer.next_time_ns,
         }
     }
 
     fn cancel_timer(&mut self, name: &str) {
         let timer = self.timers.remove(&Ustr::from(name));
         match timer {
@@ -287,102 +295,107 @@
     }
 }
 
 impl Clock for LiveClock {
     fn timer_names(&self) -> Vec<&str> {
         self.timers
             .iter()
-            .filter(|(_, timer)| !timer.is_expired)
+            .filter(|(_, timer)| !timer.is_expired())
             .map(|(k, _)| k.as_str())
             .collect()
     }
 
     fn timer_count(&self) -> usize {
         self.timers
             .iter()
-            .filter(|(_, timer)| !timer.is_expired)
+            .filter(|(_, timer)| !timer.is_expired())
             .count()
     }
 
     fn register_default_handler(&mut self, handler: EventHandler) {
         self.default_callback = Some(handler);
     }
 
     fn set_time_alert_ns(
         &mut self,
         name: &str,
         mut alert_time_ns: UnixNanos,
         callback: Option<EventHandler>,
-    ) {
+    ) -> anyhow::Result<()> {
         check_valid_string(name, stringify!(name)).unwrap();
         assert!(
             callback.is_some() | self.default_callback.is_some(),
-            "All Python callbacks were `None`"
+            "No callbacks provided",
         );
 
         let callback = match callback {
             Some(callback) => callback,
             None => self.default_callback.clone().unwrap(),
         };
 
         let ts_now = self.get_time_ns();
         alert_time_ns = std::cmp::max(alert_time_ns, ts_now);
-        let mut timer = LiveTimer::new(
-            name,
-            alert_time_ns - ts_now,
-            ts_now,
-            Some(alert_time_ns),
-            callback,
-        );
+        let interval_ns = (alert_time_ns - ts_now).into();
+        let mut timer = LiveTimer::new(name, interval_ns, ts_now, Some(alert_time_ns), callback)?;
+
         timer.start();
         self.timers.insert(Ustr::from(name), timer);
+        Ok(())
     }
 
     fn set_timer_ns(
         &mut self,
         name: &str,
         interval_ns: u64,
         start_time_ns: UnixNanos,
         stop_time_ns: Option<UnixNanos>,
         callback: Option<EventHandler>,
-    ) {
-        check_valid_string(name, stringify!(name)).unwrap();
-        assert!(
+    ) -> anyhow::Result<()> {
+        check_valid_string(name, stringify!(name))?;
+        check_positive_u64(interval_ns, stringify!(interval_ns))?;
+        check_predicate_true(
             callback.is_some() | self.default_callback.is_some(),
-            "All Python callbacks were `None`"
-        );
+            "No callbacks provided",
+        )?;
 
         let callback = match callback {
             Some(callback) => callback,
             None => self.default_callback.clone().unwrap(),
         };
 
-        let mut timer = LiveTimer::new(name, interval_ns, start_time_ns, stop_time_ns, callback);
+        let mut timer = LiveTimer::new(name, interval_ns, start_time_ns, stop_time_ns, callback)?;
         timer.start();
         self.timers.insert(Ustr::from(name), timer);
+        Ok(())
     }
 
     fn next_time_ns(&self, name: &str) -> UnixNanos {
         let timer = self.timers.get(&Ustr::from(name));
         match timer {
-            None => 0,
+            None => 0.into(),
             Some(timer) => timer.next_time_ns,
         }
     }
 
     fn cancel_timer(&mut self, name: &str) {
         let timer = self.timers.remove(&Ustr::from(name));
         match timer {
             None => {}
-            Some(mut timer) => timer.cancel(),
+            Some(mut timer) => {
+                if let Err(e) = timer.cancel() {
+                    error!("Error on timer cancel: {:?}", e);
+                }
+            }
         }
     }
 
     fn cancel_timers(&mut self) {
         for timer in &mut self.timers.values_mut() {
-            timer.cancel();
+            if let Err(e) = timer.cancel() {
+                error!("Error on timer cancel: {:?}", e);
+            }
         }
-        self.timers = HashMap::new();
+        self.timers.clear();
     }
 }
 
 // TODO: Rust specific clock tests
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/enums.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/enums.rs`

 * *Files 6% similar despite different names*

```diff
@@ -278,7 +278,40 @@
     #[strum(serialize = "\x1b[1m")]
     Bold,
 
     /// Underline log format. This ANSI escape code is used to underline the text in the log output.
     #[strum(serialize = "\x1b[4m")]
     Underline,
 }
+
+/// The serialization encoding.
+#[repr(C)]
+#[derive(
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    FromRepr,
+    EnumIter,
+    EnumString,
+    Serialize,
+    Deserialize,
+)]
+#[strum(ascii_case_insensitive)]
+#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
+#[cfg_attr(
+    feature = "python",
+    pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.common.enums")
+)]
+pub enum SerializationEncoding {
+    /// The MessagePack encoding.
+    #[serde(rename = "msgpack")]
+    MsgPack = 0,
+    /// The JavaScript Object Notation (JSON) encoding.
+    #[serde(rename = "json")]
+    Json = 1,
+}
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/factories.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/factories.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/ffi/clock.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/ffi/clock.rs`

 * *Files 2% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 use std::{
     ffi::c_char,
     ops::{Deref, DerefMut},
 };
 
 use nautilus_core::{
     ffi::{cvec::CVec, parsing::u8_as_bool, string::cstr_to_str},
-    time::UnixNanos,
+    nanos::UnixNanos,
 };
 use pyo3::{
     ffi,
     prelude::*,
     types::{PyList, PyString},
 };
 
@@ -85,15 +85,15 @@
     let handler = EventHandler::new(callback);
 
     clock.register_default_handler(handler);
 }
 
 #[no_mangle]
 pub extern "C" fn test_clock_set_time(clock: &TestClock_API, to_time_ns: u64) {
-    clock.set_time(to_time_ns);
+    clock.set_time(to_time_ns.into());
 }
 
 #[no_mangle]
 pub extern "C" fn test_clock_timestamp(clock: &TestClock_API) -> f64 {
     clock.get_time()
 }
 
@@ -105,15 +105,15 @@
 #[no_mangle]
 pub extern "C" fn test_clock_timestamp_us(clock: &TestClock_API) -> u64 {
     clock.get_time_ms()
 }
 
 #[no_mangle]
 pub extern "C" fn test_clock_timestamp_ns(clock: &TestClock_API) -> u64 {
-    clock.get_time_ns()
+    clock.get_time_ns().as_u64()
 }
 
 #[no_mangle]
 pub extern "C" fn test_clock_timer_names(clock: &TestClock_API) -> *mut ffi::PyObject {
     Python::with_gil(|py| -> Py<PyList> {
         let names: Vec<Py<PyString>> = clock
             .get_timers()
@@ -148,15 +148,17 @@
         true => None,
         false => {
             let callback = Python::with_gil(|py| PyObject::from_borrowed_ptr(py, callback_ptr));
             Some(EventHandler::new(callback))
         }
     };
 
-    clock.set_time_alert_ns(name, alert_time_ns, handler);
+    clock
+        .set_time_alert_ns(name, alert_time_ns, handler)
+        .unwrap();
 }
 
 /// # Safety
 ///
 /// - Assumes `name_ptr` is a valid C string pointer.
 /// - Assumes `callback_ptr` is a valid `PyCallable` pointer.
 #[no_mangle]
@@ -167,39 +169,41 @@
     start_time_ns: UnixNanos,
     stop_time_ns: UnixNanos,
     callback_ptr: *mut ffi::PyObject,
 ) {
     assert!(!callback_ptr.is_null());
 
     let name = cstr_to_str(name_ptr);
-    let stop_time_ns = match stop_time_ns {
+    let stop_time_ns = match stop_time_ns.into() {
         0 => None,
         _ => Some(stop_time_ns),
     };
     let handler = match callback_ptr == ffi::Py_None() {
         true => None,
         false => {
             let callback = Python::with_gil(|py| PyObject::from_borrowed_ptr(py, callback_ptr));
             Some(EventHandler::new(callback))
         }
     };
 
-    clock.set_timer_ns(name, interval_ns, start_time_ns, stop_time_ns, handler);
+    clock
+        .set_timer_ns(name, interval_ns, start_time_ns, stop_time_ns, handler)
+        .unwrap();
 }
 
 /// # Safety
 ///
 /// - Assumes `set_time` is a correct `uint8_t` of either 0 or 1.
 #[no_mangle]
 pub unsafe extern "C" fn test_clock_advance_time(
     clock: &mut TestClock_API,
     to_time_ns: u64,
     set_time: u8,
 ) -> CVec {
-    let events: Vec<TimeEvent> = clock.advance_time(to_time_ns, u8_as_bool(set_time));
+    let events: Vec<TimeEvent> = clock.advance_time(to_time_ns.into(), u8_as_bool(set_time));
     clock.match_handlers(events).into()
 }
 
 // TODO: This struct implementation potentially leaks memory
 // TODO: Skip clippy check for now since it requires large modification
 #[allow(clippy::drop_non_drop)]
 #[no_mangle]
@@ -306,15 +310,15 @@
 #[no_mangle]
 pub extern "C" fn live_clock_timestamp_us(clock: &mut LiveClock_API) -> u64 {
     clock.get_time_ms()
 }
 
 #[no_mangle]
 pub extern "C" fn live_clock_timestamp_ns(clock: &mut LiveClock_API) -> u64 {
-    clock.get_time_ns()
+    clock.get_time_ns().as_u64()
 }
 
 #[no_mangle]
 pub extern "C" fn live_clock_timer_names(clock: &LiveClock_API) -> *mut ffi::PyObject {
     Python::with_gil(|py| -> Py<PyList> {
         let names: Vec<Py<PyString>> = clock
             .get_timers()
@@ -349,15 +353,17 @@
         true => None,
         false => {
             let callback = Python::with_gil(|py| PyObject::from_borrowed_ptr(py, callback_ptr));
             Some(EventHandler::new(callback))
         }
     };
 
-    clock.set_time_alert_ns(name, alert_time_ns, handler);
+    clock
+        .set_time_alert_ns(name, alert_time_ns, handler)
+        .unwrap();
 }
 
 /// # Safety
 ///
 /// - Assumes `name_ptr` is a valid C string pointer.
 /// - Assumes `callback_ptr` is a valid `PyCallable` pointer.
 #[no_mangle]
@@ -368,28 +374,30 @@
     start_time_ns: UnixNanos,
     stop_time_ns: UnixNanos,
     callback_ptr: *mut ffi::PyObject,
 ) {
     assert!(!callback_ptr.is_null());
 
     let name = cstr_to_str(name_ptr);
-    let stop_time_ns = match stop_time_ns {
+    let stop_time_ns = match stop_time_ns.into() {
         0 => None,
         _ => Some(stop_time_ns),
     };
 
     let handler = match callback_ptr == ffi::Py_None() {
         true => None,
         false => {
             let callback = Python::with_gil(|py| PyObject::from_borrowed_ptr(py, callback_ptr));
             Some(EventHandler::new(callback))
         }
     };
 
-    clock.set_timer_ns(name, interval_ns, start_time_ns, stop_time_ns, handler);
+    clock
+        .set_timer_ns(name, interval_ns, start_time_ns, stop_time_ns, handler)
+        .unwrap();
 }
 
 /// # Safety
 ///
 /// - Assumes `name_ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn live_clock_next_time(
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/ffi/enums.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/ffi/enums.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/ffi/logging.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/ffi/logging.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/ffi/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/momentum/mod.rs`

 * *Files 4% similar despite different names*

```diff
@@ -9,12 +9,11 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod clock;
-pub mod enums;
-pub mod logging;
-pub mod msgbus;
-pub mod timer;
+pub mod aroon;
+pub mod bias;
+pub mod cmo;
+pub mod rsi;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/ffi/timer.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/ffi/timer.rs`

 * *Files 6% similar despite different names*

```diff
@@ -28,15 +28,20 @@
 #[no_mangle]
 pub unsafe extern "C" fn time_event_new(
     name_ptr: *const c_char,
     event_id: UUID4,
     ts_event: u64,
     ts_init: u64,
 ) -> TimeEvent {
-    TimeEvent::new(cstr_to_ustr(name_ptr), event_id, ts_event, ts_init)
+    TimeEvent::new(
+        cstr_to_ustr(name_ptr),
+        event_id,
+        ts_event.into(),
+        ts_init.into(),
+    )
 }
 
 /// Returns a [`TimeEvent`] as a C string pointer.
 #[no_mangle]
 pub extern "C" fn time_event_to_cstr(event: &TimeEvent) -> *const c_char {
     str_to_cstr(&event.to_string())
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/generators/client_order_id.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/generators/client_order_id.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/generators/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/generators/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/generators/order_list_id.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/generators/order_list_id.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/generators/position_id.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/generators/position_id.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/handlers.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/handlers.rs`

 * *Files 1% similar despite different names*

```diff
@@ -33,15 +33,14 @@
     #[cfg(feature = "python")]
     callback: PyObject,
 }
 
 unsafe impl Send for SafeMessageCallback {}
 unsafe impl Sync for SafeMessageCallback {}
 
-#[allow(dead_code)]
 #[derive(Clone)]
 pub struct SafeTimeEventCallback {
     pub callback: Arc<dyn Fn(TimeEvent) + Send>,
 }
 
 unsafe impl Send for SafeTimeEventCallback {}
 unsafe impl Sync for SafeTimeEventCallback {}
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/lib.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/lib.rs`

 * *Files 4% similar despite different names*

```diff
@@ -15,24 +15,23 @@
 
 pub mod cache;
 pub mod clock;
 pub mod enums;
 pub mod factories;
 pub mod generators;
 pub mod handlers;
+pub mod interface;
 pub mod logging;
 pub mod msgbus;
 pub mod runtime;
 pub mod testing;
 pub mod timer;
+pub mod xrate;
 
 #[cfg(feature = "stubs")]
 pub mod stubs;
 
 #[cfg(feature = "ffi")]
 pub mod ffi;
 
 #[cfg(feature = "python")]
 pub mod python;
-
-#[cfg(feature = "redis")]
-pub mod redis;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/logging/headers.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/logging/headers.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/logging/logger.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/logging/logger.rs`

 * *Files 2% similar despite different names*

```diff
@@ -17,26 +17,26 @@
     collections::HashMap,
     env, fmt,
     str::FromStr,
     sync::{
         atomic::Ordering,
         mpsc::{channel, Receiver, SendError, Sender},
     },
-    thread,
+    thread::{self, JoinHandle},
 };
 
 use indexmap::IndexMap;
 use log::{
-    debug, error, info,
     kv::{ToValue, Value},
-    set_boxed_logger, set_max_level, warn, Level, LevelFilter, Log, STATIC_MAX_LEVEL,
+    set_boxed_logger, set_max_level, Level, LevelFilter, Log, STATIC_MAX_LEVEL,
 };
 use nautilus_core::{
     datetime::unix_nanos_to_iso8601,
-    time::{get_atomic_clock_realtime, get_atomic_clock_static, UnixNanos},
+    nanos::UnixNanos,
+    time::{get_atomic_clock_realtime, get_atomic_clock_static},
     uuid::UUID4,
 };
 use nautilus_model::identifiers::trader_id::TraderId;
 use serde::{Deserialize, Serialize, Serializer};
 use ustr::Ustr;
 
 use super::{LOGGING_BYPASSED, LOGGING_REALTIME};
@@ -205,29 +205,29 @@
         self.cache.get_or_insert_with(|| {
             format!(
                 "{} [{}] {}.{}: {}\n",
                 self.timestamp,
                 self.line.level,
                 self.trader_id,
                 &self.line.component,
-                &self.line.message
+                &self.line.message,
             )
         })
     }
 
     pub fn get_colored(&mut self) -> &str {
         self.colored.get_or_insert_with(|| {
             format!(
                 "\x1b[1m{}\x1b[0m {}[{}] {}.{}: {}\x1b[0m\n",
                 self.timestamp,
                 &self.line.color.as_ansi(),
                 self.line.level,
                 self.trader_id,
                 &self.line.component,
-                &self.line.message
+                &self.line.message,
             )
         })
     }
 
     pub fn get_json(&self) -> String {
         let json_string =
             serde_json::to_string(&self).expect("Error serializing log event to string");
@@ -317,41 +317,44 @@
 
         let print_config = config.print_config;
         if print_config {
             println!("STATIC_MAX_LEVEL={STATIC_MAX_LEVEL}");
             println!("Logger initialized with {:?} {:?}", config, file_config);
         }
 
+        let mut handle: Option<JoinHandle<()>> = None;
         match set_boxed_logger(Box::new(logger)) {
             Ok(_) => {
-                let _join_handle = thread::Builder::new()
-                    .name("logging".to_string())
-                    .spawn(move || {
-                        Self::handle_messages(
-                            trader_id.to_string(),
-                            instance_id.to_string(),
-                            config,
-                            file_config,
-                            rx,
-                        );
-                    })
-                    .expect("Error spawning `logging` thread");
+                handle = Some(
+                    thread::Builder::new()
+                        .name("logging".to_string())
+                        .spawn(move || {
+                            Self::handle_messages(
+                                trader_id.to_string(),
+                                instance_id.to_string(),
+                                config,
+                                file_config,
+                                rx,
+                            );
+                        })
+                        .expect("Error spawning `logging` thread"),
+                );
 
                 let max_level = log::LevelFilter::Debug;
                 set_max_level(max_level);
                 if print_config {
                     println!("Logger set as `log` implementation with max level {max_level}");
                 }
             }
             Err(e) => {
                 eprintln!("Cannot set logger because of error: {e}")
             }
         }
 
-        LogGuard::new()
+        LogGuard::new(handle)
     }
 
     fn handle_messages(
         trader_id: String,
         instance_id: String,
         config: LoggerConfig,
         file_config: FileWriterConfig,
@@ -443,50 +446,55 @@
 
 pub fn log(level: LogLevel, color: LogColor, component: Ustr, message: &str) {
     let color = Value::from(color as u8);
 
     match level {
         LogLevel::Off => {}
         LogLevel::Debug => {
-            debug!(component = component.to_value(), color = color; "{}", message);
+            log::debug!(component = component.to_value(), color = color; "{}", message);
         }
         LogLevel::Info => {
-            info!(component = component.to_value(), color = color; "{}", message);
+            log::info!(component = component.to_value(), color = color; "{}", message);
         }
         LogLevel::Warning => {
-            warn!(component = component.to_value(), color = color; "{}", message);
+            log::warn!(component = component.to_value(), color = color; "{}", message);
         }
         LogLevel::Error => {
-            error!(component = component.to_value(), color = color; "{}", message);
+            log::error!(component = component.to_value(), color = color; "{}", message);
         }
     }
 }
 
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.common")
 )]
 #[derive(Debug)]
-pub struct LogGuard {}
+pub struct LogGuard {
+    handle: Option<JoinHandle<()>>,
+}
 
 impl LogGuard {
-    pub fn new() -> Self {
-        LogGuard {}
+    pub fn new(handle: Option<JoinHandle<()>>) -> Self {
+        LogGuard { handle }
     }
 }
 
 impl Default for LogGuard {
     fn default() -> Self {
-        Self::new()
+        Self::new(None)
     }
 }
 
 impl Drop for LogGuard {
     fn drop(&mut self) {
         log::logger().flush();
+        if let Some(handle) = self.handle.take() {
+            handle.join().expect("Error joining logging handle")
+        }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/logging/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/logging/mod.rs`

 * *Files 1% similar despite different names*

```diff
@@ -19,14 +19,15 @@
     str::FromStr,
     sync::atomic::{AtomicBool, Ordering},
 };
 
 use log::LevelFilter;
 use nautilus_core::{time::get_atomic_clock_static, uuid::UUID4};
 use nautilus_model::identifiers::trader_id::TraderId;
+use tracing::error;
 use tracing_subscriber::EnvFilter;
 use ustr::Ustr;
 
 use self::{
     logger::{LogGuard, Logger, LoggerConfig},
     writer::FileWriterConfig,
 };
@@ -77,29 +78,29 @@
     LOGGING_REALTIME.store(false, Ordering::Relaxed);
 }
 
 /// Sets the global logging clock static time with the given UNIX time (nanoseconds).
 #[no_mangle]
 pub extern "C" fn logging_clock_set_static_time(time_ns: u64) {
     let clock = get_atomic_clock_static();
-    clock.set_time(time_ns);
+    clock.set_time(time_ns.into());
 }
 
 ///
 /// # Safety
 ///
 /// Should only be called once during an applications run, ideally at the
 /// beginning of the run.
 pub fn init_tracing() {
     // Skip tracing initialization if `RUST_LOG` is not set
     if let Ok(v) = env::var("RUST_LOG") {
         tracing_subscriber::fmt()
             .with_env_filter(EnvFilter::new(v.clone()))
             .try_init()
-            .unwrap_or_else(|e| eprintln!("Cannot set tracing subscriber because of error: {e}"));
+            .unwrap_or_else(|e| error!("Cannot set tracing subscriber because of error: {e}"));
         println!("Initialized tracing logs with RUST_LOG={v}");
     }
 }
 
 /// Initialize logging.
 ///
 /// Logging should be used for Python and sync Rust logic which is most of
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/logging/writer.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/logging/writer.rs`

 * *Files 2% similar despite different names*

```diff
@@ -17,14 +17,15 @@
     fs::{create_dir_all, File},
     io::{self, BufWriter, Stderr, Stdout, Write},
     path::PathBuf,
 };
 
 use chrono::{DateTime, Utc};
 use log::LevelFilter;
+use tracing::error;
 
 use crate::logging::logger::LogLine;
 
 pub trait LogWriter {
     /// Writes a log line.
     fn write(&mut self, line: &str);
     /// Flushes buffered logs.
@@ -150,15 +151,15 @@
         fileout_level: LevelFilter,
     ) -> Option<Self> {
         // Setup log file
         let json_format = match file_config.file_format.as_ref().map(|s| s.to_lowercase()) {
             Some(ref format) if format == "json" => true,
             None => false,
             Some(ref unrecognized) => {
-                eprintln!(
+                error!(
                     "Unrecognized log file format: {unrecognized}. Using plain text format as default."
                 );
                 false
             }
         };
 
         let file_path =
@@ -175,15 +176,15 @@
                 path: file_path,
                 file_config,
                 trader_id,
                 instance_id,
                 level: fileout_level,
             }),
             Err(e) => {
-                eprintln!("Error creating log file: {}", e);
+                error!("Error creating log file: {}", e);
                 None
             }
         }
     }
 
     fn create_log_file_path(
         file_config: &FileWriterConfig,
@@ -246,28 +247,28 @@
                 .append(true)
                 .open(file_path.clone())
             {
                 Ok(file) => {
                     self.buf = BufWriter::new(file);
                     self.path = file_path;
                 }
-                Err(e) => eprintln!("Error creating log file: {}", e),
+                Err(e) => error!("Error creating log file: {}", e),
             }
         }
 
         match self.buf.write_all(line.as_bytes()) {
             Ok(()) => {}
-            Err(e) => eprintln!("Error writing to file: {e:?}"),
+            Err(e) => error!("Error writing to file: {e:?}"),
         }
     }
 
     fn flush(&mut self) {
         match self.buf.flush() {
             Ok(()) => {}
-            Err(e) => eprintln!("Error flushing file: {e:?}"),
+            Err(e) => error!("Error flushing file: {e:?}"),
         }
     }
 
     fn enabled(&self, line: &LogLine) -> bool {
         line.level <= self.level
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/msgbus.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/msgbus/mod.rs`

 * *Files 10% similar despite different names*

```diff
@@ -9,32 +9,32 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+pub mod database;
+
 use std::{
     collections::HashMap,
     fmt,
     hash::{Hash, Hasher},
-    sync::mpsc::{channel, Receiver, SendError, Sender},
-    thread,
 };
 
 use indexmap::IndexMap;
+use log::error;
 use nautilus_core::uuid::UUID4;
 use nautilus_model::identifiers::trader_id::TraderId;
 use serde::{Deserialize, Serialize};
-use serde_json::Value;
 use ustr::Ustr;
 
 use crate::handlers::MessageHandler;
-#[cfg(feature = "redis")]
-use crate::redis::handle_messages_with_redis;
+
+pub const CLOSE_TOPIC: &str = "CLOSE";
 
 // Represents a subscription to a particular topic.
 //
 // This is an internal class intended to be used by the message bus to organize
 // topics and their subscribers.
 #[derive(Clone, Debug)]
 pub struct Subscription {
@@ -128,14 +128,15 @@
 /// example, `comp*` matches anything beginning with `comp` which means `comp`,
 /// `complete`, and `computer` are all matched.
 ///
 /// A question mark matches a single character once. For example, `c?mp` matches
 /// `camp` and `comp`. The question mark can also be used more than once.
 /// For example, `c??p` would match both of the above examples and `coop`.
 #[derive(Clone)]
+#[allow(clippy::type_complexity)] // Complexity will reduce when Cython eliminated
 pub struct MessageBus {
     /// The trader ID associated with the message bus.
     pub trader_id: TraderId,
     /// The instance ID associated with the message bus.
     pub instance_id: UUID4,
     /// The name for the message bus.
     pub name: String,
@@ -145,15 +146,14 @@
     pub req_count: u64,
     // The count of responses processed by the bus.
     pub res_count: u64,
     /// The count of messages published by the bus.
     pub pub_count: u64,
     /// If the message bus is backed by a database.
     pub has_backing: bool,
-    tx: Option<Sender<BusMessage>>,
     /// mapping from topic to the corresponding handler
     /// a topic can be a string with wildcards
     /// * '?' - any character
     /// * '*' - any number of any characters
     subscriptions: IndexMap<Subscription, Vec<Ustr>>,
     /// maps a pattern to all the handlers registered for it
     /// this is updated whenever a new subscription is created.
@@ -163,50 +163,34 @@
     /// Relates a request with a response
     /// a request maps it's id to a handler so that a response
     /// with the same id can later be handled.
     correlation_index: IndexMap<UUID4, MessageHandler>,
 }
 
 impl MessageBus {
-    /// Initializes a new instance of the [`MessageBus`].
+    /// Creates a new `MessageBus` instance.
     pub fn new(
         trader_id: TraderId,
         instance_id: UUID4,
         name: Option<String>,
-        config: Option<HashMap<String, serde_json::Value>>,
+        _config: Option<HashMap<String, serde_json::Value>>,
     ) -> anyhow::Result<Self> {
-        let config = config.unwrap_or_default();
-        let has_backing = config
-            .get("database")
-            .map_or(false, |v| v != &serde_json::Value::Null);
-        let tx = if has_backing {
-            let (tx, rx) = channel::<BusMessage>();
-            let _join_handler = thread::Builder::new()
-                .name("msgbus".to_string())
-                .spawn(move || Self::handle_messages(rx, trader_id, instance_id, config))
-                .expect("Error spawning `msgbus` thread");
-            Some(tx)
-        } else {
-            None
-        };
-
         Ok(Self {
-            tx,
             trader_id,
             instance_id,
-            name: name.unwrap_or_else(|| stringify!(MessageBus).to_owned()),
+            name: name.unwrap_or(stringify!(MessageBus).to_owned()),
             sent_count: 0,
             req_count: 0,
             res_count: 0,
             pub_count: 0,
             subscriptions: IndexMap::new(),
             patterns: IndexMap::new(),
             endpoints: IndexMap::new(),
             correlation_index: IndexMap::new(),
-            has_backing,
+            has_backing: false,
         })
     }
 
     /// Returns the registered endpoint addresses.
     #[must_use]
     pub fn endpoints(&self) -> Vec<&str> {
         self.endpoints.keys().map(Ustr::as_str).collect()
@@ -265,14 +249,20 @@
 
     /// Returns whether there is a pending request for the given `request_id`.
     #[must_use]
     pub fn is_pending_response(&self, request_id: &UUID4) -> bool {
         self.correlation_index.contains_key(request_id)
     }
 
+    /// Close the message bus which will close the sender channel and join the thread.
+    pub fn close(&self) -> anyhow::Result<()> {
+        // TODO: Integrate the backing database
+        Ok(())
+    }
+
     /// Registers the given `handler` for the `endpoint` address.
     pub fn register(&mut self, endpoint: &str, handler: MessageHandler) {
         // Updates value if key already exists
         self.endpoints.insert(Ustr::from(endpoint), handler);
     }
 
     /// Deregisters the given `handler` for the `endpoint` address.
@@ -283,16 +273,15 @@
 
     /// Subscribes the given `handler` to the `topic`.
     pub fn subscribe(&mut self, topic: &str, handler: MessageHandler, priority: Option<u8>) {
         let topic = Ustr::from(topic);
         let sub = Subscription::new(topic, handler, self.subscriptions.len(), priority);
 
         if self.subscriptions.contains_key(&sub) {
-            // TODO: Implement proper logging
-            println!("{sub:?} already exists.");
+            error!("{sub:?} already exists.");
             return;
         }
 
         // Find existing patterns which match this topic
         let mut matches = Vec::new();
         for (pattern, subs) in &mut self.patterns {
             if is_matching(&topic, pattern) {
@@ -388,68 +377,14 @@
             if is_matching(&sub.topic, pattern) {
                 Some(&sub.handler)
             } else {
                 None
             }
         })
     }
-
-    pub fn publish_external(&self, topic: String, payload: Vec<u8>) {
-        if let Some(tx) = &self.tx {
-            let msg = BusMessage { topic, payload };
-            if let Err(SendError(e)) = tx.send(msg) {
-                eprintln!("Error publishing external message: {e}");
-            }
-        } else {
-            eprintln!("Error publishing external message: no tx channel");
-        }
-    }
-
-    fn handle_messages(
-        rx: Receiver<BusMessage>,
-        trader_id: TraderId,
-        instance_id: UUID4,
-        config: HashMap<String, serde_json::Value>,
-    ) -> anyhow::Result<()> {
-        let database_config = config
-            .get("database")
-            .expect("No `MessageBusConfig` `database` config specified");
-        let backing_type = database_config
-            .get("type")
-            .expect("No `MessageBusConfig` database config `type` specified")
-            .as_str()
-            .expect("`MessageBusConfig` database `type` must be a valid string");
-
-        match backing_type {
-            "redis" => handle_messages_with_redis_if_enabled(rx, trader_id, instance_id, config),
-            other => panic!("Unsupported message bus backing database type '{other}'"),
-        }
-    }
-}
-
-/// Handles messages using Redis if the `redis` feature is enabled.
-#[cfg(feature = "redis")]
-fn handle_messages_with_redis_if_enabled(
-    rx: Receiver<BusMessage>,
-    trader_id: TraderId,
-    instance_id: UUID4,
-    config: HashMap<String, Value>,
-) -> anyhow::Result<()> {
-    handle_messages_with_redis(rx, trader_id, instance_id, config)
-}
-
-/// Handles messages using a default method if the "redis" feature is not enabled.
-#[cfg(not(feature = "redis"))]
-fn handle_messages_with_redis_if_enabled(
-    _rx: Receiver<BusMessage>,
-    _trader_id: TraderId,
-    _instance_id: UUID4,
-    _config: HashMap<String, Value>,
-) {
-    panic!("`redis` feature is not enabled");
 }
 
 /// Match a topic and a string pattern
 /// pattern can contains -
 /// '*' - match 0 or more characters after this
 /// '?' - match any character once
 /// 'a-z' - match the specific character
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/python/clock.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/python/clock.rs`

 * *Files 5% similar despite different names*

```diff
@@ -29,14 +29,15 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
+    use nautilus_core::nanos::UnixNanos;
     use pyo3::{prelude::*, types::PyList};
     use rstest::*;
     use stubs::*;
 
     use super::*;
     use crate::{
         clock::{Clock, TestClock},
@@ -50,15 +51,17 @@
         Python::with_gil(|py| {
             let py_list = PyList::empty(py);
             let py_append = Py::from(py_list.getattr("append").unwrap());
             let handler = EventHandler::new(py_append);
             test_clock.register_default_handler(handler);
 
             let timer_name = "TEST_TIME1";
-            test_clock.set_timer_ns(timer_name, 10, 0, None, None);
+            test_clock
+                .set_timer_ns(timer_name, 10, 0.into(), None, None)
+                .unwrap();
 
             assert_eq!(test_clock.timer_names(), [timer_name]);
             assert_eq!(test_clock.timer_count(), 1);
         });
     }
 
     #[rstest]
@@ -68,15 +71,17 @@
         Python::with_gil(|py| {
             let py_list = PyList::empty(py);
             let py_append = Py::from(py_list.getattr("append").unwrap());
             let handler = EventHandler::new(py_append);
             test_clock.register_default_handler(handler);
 
             let timer_name = "TEST_TIME1";
-            test_clock.set_timer_ns(timer_name, 10, 0, None, None);
+            test_clock
+                .set_timer_ns(timer_name, 10, 0.into(), None, None)
+                .unwrap();
             test_clock.cancel_timer(timer_name);
 
             assert!(test_clock.timer_names().is_empty());
             assert_eq!(test_clock.timer_count(), 0);
         });
     }
 
@@ -87,15 +92,17 @@
         Python::with_gil(|py| {
             let py_list = PyList::empty(py);
             let py_append = Py::from(py_list.getattr("append").unwrap());
             let handler = EventHandler::new(py_append);
             test_clock.register_default_handler(handler);
 
             let timer_name = "TEST_TIME1";
-            test_clock.set_timer_ns(timer_name, 10, 0, None, None);
+            test_clock
+                .set_timer_ns(timer_name, 10, 0.into(), None, None)
+                .unwrap();
             test_clock.cancel_timers();
 
             assert!(test_clock.timer_names().is_empty());
             assert_eq!(test_clock.timer_count(), 0);
         });
     }
 
@@ -106,16 +113,18 @@
         Python::with_gil(|py| {
             let py_list = PyList::empty(py);
             let py_append = Py::from(py_list.getattr("append").unwrap());
             let handler = EventHandler::new(py_append);
             test_clock.register_default_handler(handler);
 
             let timer_name = "TEST_TIME1";
-            test_clock.set_timer_ns(timer_name, 1, 1, Some(3), None);
-            test_clock.advance_time(2, true);
+            test_clock
+                .set_timer_ns(timer_name, 1, 1.into(), Some(UnixNanos::from(3)), None)
+                .unwrap();
+            test_clock.advance_time(2.into(), true);
 
             assert_eq!(test_clock.timer_names(), [timer_name]);
             assert_eq!(test_clock.timer_count(), 1);
         });
     }
 
     #[rstest]
@@ -124,16 +133,18 @@
 
         Python::with_gil(|py| {
             let py_list = PyList::empty(py);
             let py_append = Py::from(py_list.getattr("append").unwrap());
             let handler = EventHandler::new(py_append);
             test_clock.register_default_handler(handler);
 
-            test_clock.set_timer_ns("TEST_TIME1", 2, 0, Some(3), None);
-            test_clock.advance_time(3, true);
+            test_clock
+                .set_timer_ns("TEST_TIME1", 2, 0.into(), Some(UnixNanos::from(3)), None)
+                .unwrap();
+            test_clock.advance_time(3.into(), true);
 
             assert_eq!(test_clock.timer_names().len(), 1);
             assert_eq!(test_clock.timer_count(), 1);
             assert_eq!(test_clock.get_time_ns(), 3);
         });
     }
 
@@ -143,16 +154,18 @@
 
         Python::with_gil(|py| {
             let py_list = PyList::empty(py);
             let py_append = Py::from(py_list.getattr("append").unwrap());
             let handler = EventHandler::new(py_append);
             test_clock.register_default_handler(handler);
 
-            test_clock.set_timer_ns("TEST_TIME1", 2, 0, Some(3), None);
-            test_clock.advance_time(3, false);
+            test_clock
+                .set_timer_ns("TEST_TIME1", 2, 0.into(), Some(UnixNanos::from(3)), None)
+                .unwrap();
+            test_clock.advance_time(3.into(), false);
 
             assert_eq!(test_clock.timer_names().len(), 1);
             assert_eq!(test_clock.timer_count(), 1);
             assert_eq!(test_clock.get_time_ns(), 0);
         });
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/python/enums.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/python/enums.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/python/logging.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/python/logging.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/python/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/python/mod.rs`

 * *Files 4% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+#![allow(warnings)] // non-local `impl` definition, temporary allow until pyo3 upgrade
+
 pub mod clock;
 pub mod enums;
 pub mod logging;
 pub mod timer;
 pub mod versioning;
 
 use pyo3::prelude::*;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/python/timer.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/python/timer.rs`

 * *Files 8% similar despite different names*

```diff
@@ -11,61 +11,68 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::str::FromStr;
 
-use nautilus_core::{python::to_pyvalue_err, time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, python::to_pyvalue_err, uuid::UUID4};
 use pyo3::{
     basic::CompareOp,
     prelude::*,
     types::{PyLong, PyString, PyTuple},
 };
 use ustr::Ustr;
 
 use crate::timer::TimeEvent;
 
 #[pymethods]
 impl TimeEvent {
     #[new]
-    fn py_new(name: &str, event_id: UUID4, ts_event: UnixNanos, ts_init: UnixNanos) -> Self {
-        Self::new(Ustr::from(name), event_id, ts_event, ts_init)
+    fn py_new(name: &str, event_id: UUID4, ts_event: u64, ts_init: u64) -> Self {
+        Self::new(Ustr::from(name), event_id, ts_event.into(), ts_init.into())
     }
 
     fn __setstate__(&mut self, py: Python, state: PyObject) -> PyResult<()> {
         let tuple: (&PyString, &PyString, &PyLong, &PyLong) = state.extract(py)?;
+        let ts_event: u64 = tuple.2.extract()?;
+        let ts_init: u64 = tuple.3.extract()?;
 
         self.name = Ustr::from(tuple.0.extract()?);
         self.event_id = UUID4::from_str(tuple.1.extract()?).map_err(to_pyvalue_err)?;
-        self.ts_event = tuple.2.extract()?;
-        self.ts_init = tuple.3.extract()?;
+        self.ts_event = ts_event.into();
+        self.ts_init = ts_init.into();
 
         Ok(())
     }
 
     fn __getstate__(&self, py: Python) -> PyResult<PyObject> {
         Ok((
             self.name.to_string(),
             self.event_id.to_string(),
-            self.ts_event,
-            self.ts_init,
+            self.ts_event.as_u64(),
+            self.ts_init.as_u64(),
         )
             .to_object(py))
     }
 
     fn __reduce__(&self, py: Python) -> PyResult<PyObject> {
         let safe_constructor = py.get_type::<Self>().getattr("_safe_constructor")?;
         let state = self.__getstate__(py)?;
         Ok((safe_constructor, PyTuple::empty(py), state).to_object(py))
     }
 
     #[staticmethod]
     fn _safe_constructor() -> Self {
-        Self::new(Ustr::from("NULL"), UUID4::new(), 0, 0)
+        Self::new(
+            Ustr::from("NULL"),
+            UUID4::new(),
+            UnixNanos::default(),
+            UnixNanos::default(),
+        )
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
             CompareOp::Ne => self.ne(other).into_py(py),
             _ => py.NotImplemented(),
@@ -90,17 +97,17 @@
     #[pyo3(name = "event_id")]
     fn py_event_id(&self) -> UUID4 {
         self.event_id
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/python/versioning.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/python/versioning.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/redis.rs` & `nautilus_trader-1.191.0/nautilus_core/infrastructure/src/redis/mod.rs`

 * *Files 16% similar despite different names*

```diff
@@ -9,142 +9,26 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{
-    collections::{HashMap, VecDeque},
-    sync::mpsc::{Receiver, TryRecvError},
-    thread,
-    time::{Duration, Instant},
-};
+pub mod cache;
+pub mod msgbus;
 
-use nautilus_core::{time::duration_since_unix_epoch, uuid::UUID4};
+use std::{collections::HashMap, time::Duration};
+
+use nautilus_core::uuid::UUID4;
 use nautilus_model::identifiers::trader_id::TraderId;
 use redis::*;
 use serde_json::{json, Value};
 use tracing::debug;
 
-use crate::msgbus::BusMessage;
-
 const DELIMITER: char = ':';
-const XTRIM: &str = "XTRIM";
-const MINID: &str = "MINID";
-
-pub fn handle_messages_with_redis(
-    rx: Receiver<BusMessage>,
-    trader_id: TraderId,
-    instance_id: UUID4,
-    config: HashMap<String, Value>,
-) -> anyhow::Result<()> {
-    let database_config = config
-        .get("database")
-        .ok_or(anyhow::anyhow!("No database config"))?;
-    debug!("Creating msgbus redis connection");
-    let mut conn = create_redis_connection(&database_config.clone())?;
-
-    let stream_name = get_stream_name(trader_id, instance_id, &config);
-
-    // Autotrimming
-    let autotrim_mins = config
-        .get("autotrim_mins")
-        .and_then(|v| v.as_u64())
-        .unwrap_or(0) as usize;
-    let autotrim_duration = if autotrim_mins > 0 {
-        Some(Duration::from_secs(autotrim_mins as u64 * 60))
-    } else {
-        None
-    };
-    let mut last_trim_index: HashMap<String, usize> = HashMap::new();
-
-    // Buffering
-    let mut buffer: VecDeque<BusMessage> = VecDeque::new();
-    let mut last_drain = Instant::now();
-    let recv_interval = Duration::from_millis(1);
-    let buffer_interval = get_buffer_interval(&config);
-
-    loop {
-        if last_drain.elapsed() >= buffer_interval && !buffer.is_empty() {
-            drain_buffer(
-                &mut conn,
-                &stream_name,
-                autotrim_duration,
-                &mut last_trim_index,
-                &mut buffer,
-            )?;
-            last_drain = Instant::now();
-        } else {
-            // Continue to receive and handle messages until channel is hung up
-            match rx.try_recv() {
-                Ok(msg) => buffer.push_back(msg),
-                Err(TryRecvError::Empty) => thread::sleep(recv_interval),
-                Err(TryRecvError::Disconnected) => break, // Channel hung up
-            }
-        }
-    }
-
-    // Drain any remaining messages
-    if !buffer.is_empty() {
-        drain_buffer(
-            &mut conn,
-            &stream_name,
-            autotrim_duration,
-            &mut last_trim_index,
-            &mut buffer,
-        )?;
-    }
-
-    Ok(())
-}
-
-fn drain_buffer(
-    conn: &mut Connection,
-    stream_name: &str,
-    autotrim_duration: Option<Duration>,
-    last_trim_index: &mut HashMap<String, usize>,
-    buffer: &mut VecDeque<BusMessage>,
-) -> anyhow::Result<()> {
-    let mut pipe = redis::pipe();
-    pipe.atomic();
-
-    for msg in buffer.drain(..) {
-        let key = format!("{stream_name}{}", &msg.topic);
-        let items: Vec<(&str, &Vec<u8>)> = vec![("payload", &msg.payload)];
-        pipe.xadd(&key, "*", &items);
-
-        if autotrim_duration.is_none() {
-            continue; // Nothing else to do
-        }
-
-        // Autotrim stream
-        let last_trim_ms = last_trim_index.entry(key.clone()).or_insert(0); // Remove clone
-        let unix_duration_now = duration_since_unix_epoch();
-
-        // Improve efficiency of this by batching
-        if *last_trim_ms < (unix_duration_now - Duration::from_secs(60)).as_millis() as usize {
-            let min_timestamp_ms =
-                (unix_duration_now - autotrim_duration.unwrap()).as_millis() as usize;
-            let result: Result<(), redis::RedisError> = redis::cmd(XTRIM)
-                .arg(&key)
-                .arg(MINID)
-                .arg(min_timestamp_ms)
-                .query(conn);
-
-            if let Err(e) = result {
-                eprintln!("Error trimming stream '{key}': {e}");
-            } else {
-                last_trim_index.insert(key, unix_duration_now.as_millis() as usize);
-            }
-        }
-    }
-
-    pipe.query::<()>(conn).map_err(anyhow::Error::from)
-}
 
 pub fn get_redis_url(database_config: &serde_json::Value) -> (String, String) {
     let host = database_config
         .get("host")
         .and_then(|v| v.as_str())
         .unwrap_or("127.0.0.1");
     let port = database_config
@@ -238,15 +122,15 @@
     let mut stream_name = String::new();
 
     if let Some(json!(true)) = config.get("use_trader_prefix") {
         stream_name.push_str("trader-");
     }
 
     if let Some(json!(true)) = config.get("use_trader_id") {
-        stream_name.push_str(trader_id.value.as_str());
+        stream_name.push_str(trader_id.as_str());
         stream_name.push(DELIMITER);
     }
 
     if let Some(json!(true)) = config.get("use_instance_id") {
         stream_name.push_str(&format!("{instance_id}"));
         stream_name.push(DELIMITER);
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/runtime.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/ratio/mod.rs`

 * *Files 18% similar despite different names*

```diff
@@ -9,17 +9,8 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::sync::OnceLock;
-
-use tokio::runtime::Runtime;
-
-static RUNTIME: OnceLock<tokio::runtime::Runtime> = OnceLock::new();
-
-pub fn get_runtime() -> &'static tokio::runtime::Runtime {
-    // Using default configuration values for now
-    RUNTIME.get_or_init(|| Runtime::new().expect("Failed to create tokio runtime"))
-}
+pub mod efficiency_ratio;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/stubs.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/stubs.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/common/src/testing.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/testing.rs`

 * *Files 0% similar despite different names*

```diff
@@ -16,16 +16,14 @@
 use std::{
     thread,
     time::{Duration, Instant},
 };
 
 /// Repeatedly evaluates a condition with a delay until it becomes true or a timeout occurs.
 ///
-/// # Arguments
-///
 /// * `condition` - A closure that represents the condition to be met. This closure should return `true`
 ///                 when the condition is met and `false` otherwise.
 /// * `timeout` - The maximum amount of time to wait for the condition to be met. If this duration is
 ///               exceeded, the function will panic.
 ///
 /// # Panics
 ///
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/core/Cargo.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/build.rs` & `nautilus_trader-1.191.0/nautilus_core/core/build.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/cbindgen.toml` & `nautilus_trader-1.191.0/nautilus_core/core/cbindgen.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/cbindgen_cython.toml` & `nautilus_trader-1.191.0/nautilus_core/core/cbindgen_cython.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/datetime.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/datetime.rs`

 * *Files 2% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 use std::time::{Duration, UNIX_EPOCH};
 
 use chrono::{
     prelude::{DateTime, Utc},
     Datelike, NaiveDate, SecondsFormat, TimeDelta, Weekday,
 };
 
-use crate::time::UnixNanos;
+use crate::nanos::UnixNanos;
 
 pub const MILLISECONDS_IN_SECOND: u64 = 1_000;
 pub const NANOSECONDS_IN_SECOND: u64 = 1_000_000_000;
 pub const NANOSECONDS_IN_MILLISECOND: u64 = 1_000_000;
 pub const NANOSECONDS_IN_MICROSECOND: u64 = 1_000;
 
 pub const WEEKDAYS: [Weekday; 5] = [
@@ -83,19 +83,24 @@
 pub extern "C" fn nanos_to_micros(nanos: u64) -> u64 {
     nanos / NANOSECONDS_IN_MICROSECOND
 }
 
 /// Converts a UNIX nanoseconds timestamp to an ISO 8601 formatted string.
 #[inline]
 #[must_use]
-pub fn unix_nanos_to_iso8601(timestamp_ns: u64) -> String {
-    let dt = DateTime::<Utc>::from(UNIX_EPOCH + Duration::from_nanos(timestamp_ns));
+pub fn unix_nanos_to_iso8601(unix_nanos: UnixNanos) -> String {
+    let dt = DateTime::<Utc>::from(UNIX_EPOCH + Duration::from_nanos(unix_nanos.as_u64()));
     dt.to_rfc3339_opts(SecondsFormat::Nanos, true)
 }
 
+/// Floor the given UNIX nanoseconds to the nearest microsecond.
+pub fn floor_to_nearest_microsecond(unix_nanos: u64) -> u64 {
+    (unix_nanos / NANOSECONDS_IN_MICROSECOND) * NANOSECONDS_IN_MICROSECOND
+}
+
 pub fn last_weekday_nanos(year: i32, month: u32, day: u32) -> anyhow::Result<UnixNanos> {
     let date =
         NaiveDate::from_ymd_opt(year, month, day).ok_or_else(|| anyhow::anyhow!("Invalid date"))?;
     let current_weekday = date.weekday().number_from_monday();
 
     // Calculate the offset in days for closest weekday (Mon-Fri)
     let offset = i64::from(match current_weekday {
@@ -108,21 +113,24 @@
     let last_closest = date - TimeDelta::try_days(offset).expect("Invalid offset");
 
     // Convert to UNIX nanoseconds
     let unix_timestamp_ns = last_closest
         .and_hms_nano_opt(0, 0, 0, 0)
         .ok_or_else(|| anyhow::anyhow!("Failed `and_hms_nano_opt`"))?;
 
-    Ok(unix_timestamp_ns
-        .and_utc()
-        .timestamp_nanos_opt()
-        .ok_or_else(|| anyhow::anyhow!("Failed `timestamp_nanos_opt`"))? as UnixNanos)
+    Ok(UnixNanos::from(
+        unix_timestamp_ns
+            .and_utc()
+            .timestamp_nanos_opt()
+            .ok_or_else(|| anyhow::anyhow!("Failed `timestamp_nanos_opt`"))? as u64,
+    ))
 }
 
 pub fn is_within_last_24_hours(timestamp_ns: UnixNanos) -> anyhow::Result<bool> {
+    let timestamp_ns = timestamp_ns.as_u64();
     let seconds = timestamp_ns / NANOSECONDS_IN_SECOND;
     let nanoseconds = (timestamp_ns % NANOSECONDS_IN_SECOND) as u32;
     let timestamp = DateTime::from_timestamp(seconds as i64, nanoseconds)
         .ok_or_else(|| anyhow::anyhow!("Invalid timestamp {timestamp_ns}"))?;
     let now = Utc::now();
 
     Ok(now.signed_duration_since(timestamp) <= TimeDelta::try_days(1).unwrap())
@@ -228,15 +236,15 @@
     #[case(2023, 12, 18, 1_702_857_600_000_000_000)] // Mon
     fn test_last_closest_weekday_nanos_with_valid_date(
         #[case] year: i32,
         #[case] month: u32,
         #[case] day: u32,
         #[case] expected: u64,
     ) {
-        let result = last_weekday_nanos(year, month, day).unwrap();
+        let result = last_weekday_nanos(year, month, day).unwrap().as_u64();
         assert_eq!(result, expected);
     }
 
     #[rstest]
     fn test_last_closest_weekday_nanos_with_invalid_date() {
         let result = last_weekday_nanos(2023, 4, 31);
         assert!(result.is_err());
@@ -253,18 +261,18 @@
         let result = last_weekday_nanos(9999, 12, 31);
         assert!(result.is_err());
     }
 
     #[rstest]
     fn test_is_within_last_24_hours_when_now() {
         let now_ns = Utc::now().timestamp_nanos_opt().unwrap();
-        assert!(is_within_last_24_hours(now_ns as UnixNanos).unwrap());
+        assert!(is_within_last_24_hours(UnixNanos::from(now_ns as u64)).unwrap());
     }
 
     #[rstest]
     fn test_is_within_last_24_hours_when_two_days_ago() {
         let past_ns = (Utc::now() - TimeDelta::try_days(2).unwrap())
             .timestamp_nanos_opt()
             .unwrap();
-        assert!(!is_within_last_24_hours(past_ns as UnixNanos).unwrap());
+        assert!(!is_within_last_24_hours(UnixNanos::from(past_ns as u64)).unwrap());
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/ffi/cvec.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/ffi/cvec.rs`

 * *Files 1% similar despite different names*

```diff
@@ -143,15 +143,15 @@
         }
     }
 
     /// After deallocating the vector the block of memory may not
     /// contain the same values.
     /// NOTE: This test maybe flaky depending on the platform
     #[rstest]
-    #[ignore] // TODO(cs): Flaky one some platforms
+    #[ignore] // TODO: Flaky one some platforms
     fn drop_test() {
         let test_data = vec![1, 2, 3];
         let cvec: CVec = {
             let data = test_data.clone();
             data.into()
         };
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/ffi/datetime.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/ffi/datetime.rs`

 * *Files 12% similar despite different names*

```diff
@@ -17,9 +17,9 @@
 
 use crate::{datetime::unix_nanos_to_iso8601, ffi::string::str_to_cstr};
 
 /// Converts a UNIX nanoseconds timestamp to an ISO 8601 formatted C string pointer.
 #[cfg(feature = "ffi")]
 #[no_mangle]
 pub extern "C" fn unix_nanos_to_iso8601_cstr(timestamp_ns: u64) -> *const c_char {
-    str_to_cstr(&unix_nanos_to_iso8601(timestamp_ns))
+    str_to_cstr(&unix_nanos_to_iso8601(timestamp_ns.into()))
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/ffi/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/ffi/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/ffi/parsing.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/ffi/parsing.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/ffi/string.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/ffi/string.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/ffi/uuid.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/ffi/uuid.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/lib.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orderbook/mod.rs`

 * *Files 14% similar despite different names*

```diff
@@ -9,19 +9,14 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod correctness;
-pub mod datetime;
-pub mod message;
-pub mod parsing;
-pub mod serialization;
-pub mod time;
-pub mod uuid;
-
-#[cfg(feature = "ffi")]
-pub mod ffi;
-#[cfg(feature = "python")]
-pub mod python;
+pub mod aggregation;
+pub mod analysis;
+pub mod book;
+pub mod display;
+pub mod error;
+pub mod ladder;
+pub mod level;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/message.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/message.rs`

 * *Files 14% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use crate::{time::UnixNanos, uuid::UUID4};
+use crate::{nanos::UnixNanos, uuid::UUID4};
 
 #[derive(Debug, Clone)]
 pub enum Message {
     Command {
         id: UUID4,
         ts_init: UnixNanos,
     },
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/parsing.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/parsing.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/python/casing.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/python/casing.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/python/datetime.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/python/datetime.rs`

 * *Files 13% similar despite different names*

```diff
@@ -12,17 +12,21 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use pyo3::prelude::*;
 
 use super::to_pyvalue_err;
-use crate::datetime::{
-    is_within_last_24_hours, last_weekday_nanos, micros_to_nanos, millis_to_nanos, nanos_to_micros,
-    nanos_to_millis, nanos_to_secs, secs_to_millis, secs_to_nanos, unix_nanos_to_iso8601,
+use crate::{
+    datetime::{
+        is_within_last_24_hours, last_weekday_nanos, micros_to_nanos, millis_to_nanos,
+        nanos_to_micros, nanos_to_millis, nanos_to_secs, secs_to_millis, secs_to_nanos,
+        unix_nanos_to_iso8601,
+    },
+    nanos::UnixNanos,
 };
 
 #[must_use]
 #[pyfunction(name = "secs_to_nanos")]
 pub fn py_secs_to_nanos(secs: f64) -> u64 {
     secs_to_nanos(secs)
 }
@@ -62,19 +66,21 @@
 pub fn py_nanos_to_micros(nanos: u64) -> u64 {
     nanos_to_micros(nanos)
 }
 
 #[must_use]
 #[pyfunction(name = "unix_nanos_to_iso8601")]
 pub fn py_unix_nanos_to_iso8601(timestamp_ns: u64) -> String {
-    unix_nanos_to_iso8601(timestamp_ns)
+    unix_nanos_to_iso8601(timestamp_ns.into())
 }
 
 #[pyfunction(name = "last_weekday_nanos")]
 pub fn py_last_weekday_nanos(year: i32, month: u32, day: u32) -> PyResult<u64> {
-    last_weekday_nanos(year, month, day).map_err(to_pyvalue_err)
+    Ok(last_weekday_nanos(year, month, day)
+        .map_err(to_pyvalue_err)?
+        .as_u64())
 }
 
 #[pyfunction(name = "is_within_last_24_hours")]
 pub fn py_is_within_last_24_hours(timestamp_ns: u64) -> PyResult<bool> {
-    is_within_last_24_hours(timestamp_ns).map_err(to_pyvalue_err)
+    is_within_last_24_hours(UnixNanos::from(timestamp_ns)).map_err(to_pyvalue_err)
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/python/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/python/mod.rs`

 * *Files 5% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+#![allow(warnings)] // non-local `impl` definition, temporary allow until pyo3 upgrade
+
 use std::fmt;
 
 use pyo3::{
     exceptions::{PyRuntimeError, PyTypeError, PyValueError},
     prelude::*,
     wrap_pyfunction,
 };
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/python/serialization.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/python/serialization.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/python/uuid.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/python/uuid.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/serialization.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/serialization.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/time.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/time.rs`

 * *Files 9% similar despite different names*

```diff
@@ -18,38 +18,33 @@
     sync::{
         atomic::{AtomicBool, AtomicU64, Ordering},
         OnceLock,
     },
     time::{Duration, SystemTime, UNIX_EPOCH},
 };
 
-use crate::datetime::{
-    NANOSECONDS_IN_MICROSECOND, NANOSECONDS_IN_MILLISECOND, NANOSECONDS_IN_SECOND,
+use crate::{
+    datetime::{NANOSECONDS_IN_MICROSECOND, NANOSECONDS_IN_MILLISECOND, NANOSECONDS_IN_SECOND},
+    nanos::UnixNanos,
 };
 
-/// Represents a timestamp in nanoseconds since UNIX epoch.
-pub type UnixNanos = u64;
-
-/// Represents a timedelta in nanoseconds.
-pub type TimedeltaNanos = i64;
-
 /// Provides a global atomic time in real-time mode for use across the system.
 pub static ATOMIC_CLOCK_REALTIME: OnceLock<AtomicTime> = OnceLock::new();
 
 /// Provides a global atomic time in static mode for use across the system.
 pub static ATOMIC_CLOCK_STATIC: OnceLock<AtomicTime> = OnceLock::new();
 
 /// Returns a static reference to the global atomic clock in real-time mode.
 pub fn get_atomic_clock_realtime() -> &'static AtomicTime {
     ATOMIC_CLOCK_REALTIME.get_or_init(AtomicTime::default)
 }
 
 /// Returns a static reference to the global atomic clock in static mode.
 pub fn get_atomic_clock_static() -> &'static AtomicTime {
-    ATOMIC_CLOCK_STATIC.get_or_init(|| AtomicTime::new(false, 0))
+    ATOMIC_CLOCK_STATIC.get_or_init(|| AtomicTime::new(false, UnixNanos::default()))
 }
 
 #[must_use]
 pub fn duration_since_unix_epoch() -> Duration {
     SystemTime::now()
         .duration_since(UNIX_EPOCH)
         .expect("Error calling `SystemTime::now.duration_since`")
@@ -85,76 +80,76 @@
     fn deref(&self) -> &Self::Target {
         &self.timestamp_ns
     }
 }
 
 impl Default for AtomicTime {
     fn default() -> Self {
-        Self::new(true, 0)
+        Self::new(true, UnixNanos::default())
     }
 }
 
 impl AtomicTime {
     /// New atomic clock set with the given UNIX time (nanoseconds).
     #[must_use]
     pub fn new(realtime: bool, time: UnixNanos) -> Self {
         Self {
             realtime: AtomicBool::new(realtime),
-            timestamp_ns: AtomicU64::new(time),
+            timestamp_ns: AtomicU64::new(time.into()),
         }
     }
 
     /// Get time in nanoseconds.
     ///
     /// - Real-time mode returns current wall clock time since UNIX epoch (unique and monotonic).
     /// - Static mode returns currently stored time.
     #[must_use]
     pub fn get_time_ns(&self) -> UnixNanos {
         match self.realtime.load(Ordering::Relaxed) {
             true => self.time_since_epoch(),
-            false => self.timestamp_ns.load(Ordering::Relaxed),
+            false => UnixNanos::from(self.timestamp_ns.load(Ordering::Relaxed)),
         }
     }
 
     /// Get time as microseconds.
     #[must_use]
     pub fn get_time_us(&self) -> u64 {
-        self.get_time_ns() / NANOSECONDS_IN_MICROSECOND
+        self.get_time_ns().as_u64() / NANOSECONDS_IN_MICROSECOND
     }
 
     /// Get time as milliseconds.
     #[must_use]
     pub fn get_time_ms(&self) -> u64 {
-        self.get_time_ns() / NANOSECONDS_IN_MILLISECOND
+        self.get_time_ns().as_u64() / NANOSECONDS_IN_MILLISECOND
     }
 
     /// Get time as seconds.
     #[must_use]
     pub fn get_time(&self) -> f64 {
-        self.get_time_ns() as f64 / (NANOSECONDS_IN_SECOND as f64)
+        self.get_time_ns().as_f64() / (NANOSECONDS_IN_SECOND as f64)
     }
 
     /// Sets new time for the clock.
     pub fn set_time(&self, time: UnixNanos) {
-        self.store(time, Ordering::Relaxed);
+        self.store(time.into(), Ordering::Relaxed);
     }
 
     /// Increments current time with a delta and returns the updated time.
     pub fn increment_time(&self, delta: u64) -> UnixNanos {
-        self.fetch_add(delta, Ordering::Relaxed) + delta
+        UnixNanos::from(self.fetch_add(delta, Ordering::Relaxed) + delta)
     }
 
     /// Stores and returns current time.
     pub fn time_since_epoch(&self) -> UnixNanos {
         // Increment by 1 nanosecond to keep increasing time
         let now = duration_since_unix_epoch().as_nanos() as u64 + 1;
         let last = self.load(Ordering::SeqCst) + 1;
         let time = now.max(last);
         self.store(time, Ordering::SeqCst);
-        time
+        UnixNanos::from(time)
     }
 
     pub fn make_realtime(&self) {
         self.realtime.store(true, Ordering::Relaxed);
     }
 
     pub fn make_static(&self) {
@@ -171,16 +166,16 @@
 
     use rstest::*;
 
     use super::*;
 
     #[rstest]
     fn test_duration_since_unix_epoch() {
-        let time = AtomicTime::new(true, 0);
-        let duration = Duration::from_nanos(time.get_time_ns());
+        let time = AtomicTime::new(true, UnixNanos::default());
+        let duration = Duration::from_nanos(time.get_time_ns().into());
         let now = SystemTime::now();
 
         // Check if the duration is close to the actual difference between now and UNIX_EPOCH
         let delta = now
             .duration_since(UNIX_EPOCH)
             .unwrap()
             .checked_sub(duration);
@@ -188,15 +183,15 @@
 
         // Check if the duration is greater than a certain value (assuming the test is run after that point)
         assert!(duration > Duration::from_secs(1_650_000_000));
     }
 
     #[rstest]
     fn test_unix_timestamp_is_monotonic_increasing() {
-        let time = AtomicTime::new(true, 0);
+        let time = AtomicTime::new(true, UnixNanos::default());
         let result1 = time.get_time();
         let result2 = time.get_time();
         let result3 = time.get_time();
         let result4 = time.get_time();
         let result5 = time.get_time();
 
         assert!(result2 >= result1);
@@ -204,15 +199,15 @@
         assert!(result4 >= result3);
         assert!(result5 >= result4);
         assert!(result1 > 1_650_000_000.0);
     }
 
     #[rstest]
     fn test_unix_timestamp_ms_is_monotonic_increasing() {
-        let time = AtomicTime::new(true, 0);
+        let time = AtomicTime::new(true, UnixNanos::default());
         let result1 = time.get_time_ms();
         let result2 = time.get_time_ms();
         let result3 = time.get_time_ms();
         let result4 = time.get_time_ms();
         let result5 = time.get_time_ms();
 
         assert!(result2 >= result1);
@@ -220,15 +215,15 @@
         assert!(result4 >= result3);
         assert!(result5 >= result4);
         assert!(result1 >= 1_650_000_000_000);
     }
 
     #[rstest]
     fn test_unix_timestamp_us_is_monotonic_increasing() {
-        let time = AtomicTime::new(true, 0);
+        let time = AtomicTime::new(true, UnixNanos::default());
         let result1 = time.get_time_us();
         let result2 = time.get_time_us();
         let result3 = time.get_time_us();
         let result4 = time.get_time_us();
         let result5 = time.get_time_us();
 
         assert!(result2 >= result1);
@@ -236,21 +231,21 @@
         assert!(result4 >= result3);
         assert!(result5 >= result4);
         assert!(result1 > 1_650_000_000_000_000);
     }
 
     #[rstest]
     fn test_unix_timestamp_ns_is_monotonic_increasing() {
-        let time = AtomicTime::new(true, 0);
+        let time = AtomicTime::new(true, UnixNanos::default());
         let result1 = time.get_time_ns();
         let result2 = time.get_time_ns();
         let result3 = time.get_time_ns();
         let result4 = time.get_time_ns();
         let result5 = time.get_time_ns();
 
         assert!(result2 >= result1);
         assert!(result3 >= result2);
         assert!(result4 >= result3);
         assert!(result5 >= result4);
-        assert!(result1 > 1_650_000_000_000_000_000);
+        assert!(result1.as_u64() > 1_650_000_000_000_000_000);
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/core/src/uuid.rs` & `nautilus_trader-1.191.0/nautilus_core/core/src/uuid.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/execution/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/execution/Cargo.toml`

 * *Files 7% similar despite different names*

```diff
@@ -11,14 +11,15 @@
 crate-type = ["rlib", "cdylib"]
 
 [dependencies]
 nautilus-common = { path = "../common" }
 nautilus-core = { path = "../core" }
 nautilus-model = { path = "../model", features = ["stubs"] }
 anyhow = { workspace = true }
+derive_builder = { workspace = true }
 indexmap = { workspace = true }
 log = { workspace = true }
 pyo3 = { workspace = true, optional = true }
 pyo3-asyncio = { workspace = true, optional = true }
 rust_decimal = { workspace = true }
 rust_decimal_macros = { workspace = true }
 tracing = { workspace = true }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/execution/src/lib.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/mod.rs`

 * *Files 3% similar despite different names*

```diff
@@ -9,8 +9,9 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod matching_core;
+pub mod account;
+pub mod order;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/execution/src/matching_core.rs` & `nautilus_trader-1.191.0/nautilus_core/execution/src/matching_core.rs`

 * *Files 8% similar despite different names*

```diff
@@ -9,25 +9,26 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-#![allow(dead_code)] // Under development
+// Under development
+#![allow(dead_code)]
+#![allow(unused_variables)]
 
 use nautilus_model::{
-    identifiers::instrument_id::InstrumentId,
+    enums::OrderSideSpecified,
+    identifiers::{client_order_id::ClientOrderId, instrument_id::InstrumentId},
     orders::{
-        base::{
-            GetClientOrderId, GetLimitPrice, GetOrderSide, GetStopPrice, LimitOrderType,
-            OrderError, OrderSideFixed, PassiveOrderType, StopOrderType,
-        },
+        base::{LimitOrderAny, OrderError, PassiveOrderAny, StopOrderAny},
         market::MarketOrder,
     },
+    polymorphism::{GetClientOrderId, GetLimitPrice, GetOrderSideSpecified, GetStopPrice},
     types::price::Price,
 };
 
 /// Provides a generic order matching core.
 pub struct OrderMatchingCore {
     /// The instrument ID for the matching core.
     pub instrument_id: InstrumentId,
@@ -35,29 +36,29 @@
     pub price_increment: Price,
     /// The current bid price for the matching core.
     pub bid: Option<Price>,
     /// The current ask price for the matching core.
     pub ask: Option<Price>,
     /// The last price for the matching core.
     pub last: Option<Price>,
-    orders_bid: Vec<PassiveOrderType>,
-    orders_ask: Vec<PassiveOrderType>,
-    trigger_stop_order: Option<fn(StopOrderType)>,
+    orders_bid: Vec<PassiveOrderAny>,
+    orders_ask: Vec<PassiveOrderAny>,
+    trigger_stop_order: Option<fn(StopOrderAny)>,
     fill_market_order: Option<fn(MarketOrder)>,
-    fill_limit_order: Option<fn(LimitOrderType)>,
+    fill_limit_order: Option<fn(LimitOrderAny)>,
 }
 
 impl OrderMatchingCore {
     #[must_use]
     pub fn new(
         instrument_id: InstrumentId,
         price_increment: Price,
-        trigger_stop_order: Option<fn(StopOrderType)>,
+        trigger_stop_order: Option<fn(StopOrderAny)>,
         fill_market_order: Option<fn(MarketOrder)>,
-        fill_limit_order: Option<fn(LimitOrderType)>,
+        fill_limit_order: Option<fn(LimitOrderAny)>,
     ) -> Self {
         Self {
             instrument_id,
             price_increment,
             bid: None,
             ask: None,
             last: None,
@@ -73,63 +74,74 @@
 
     #[must_use]
     pub fn price_precision(&self) -> u8 {
         self.price_increment.precision
     }
 
     #[must_use]
-    pub fn get_orders_bid(&self) -> &[PassiveOrderType] {
+    pub fn get_orders_bid(&self) -> &[PassiveOrderAny] {
         self.orders_bid.as_slice()
     }
 
     #[must_use]
-    pub fn get_orders_ask(&self) -> &[PassiveOrderType] {
+    pub fn get_orders_ask(&self) -> &[PassiveOrderAny] {
         self.orders_ask.as_slice()
     }
 
+    #[must_use]
+    pub fn order_exists(&self, client_order_id: ClientOrderId) -> bool {
+        self.orders_bid
+            .iter()
+            .any(|o| o.client_order_id() == client_order_id)
+            || self
+                .orders_ask
+                .iter()
+                .any(|o| o.client_order_id() == client_order_id)
+    }
+
     // -- COMMANDS --------------------------------------------------------------------------------
 
     pub fn reset(&mut self) {
         self.bid = None;
         self.ask = None;
         self.last = None;
         self.orders_bid.clear();
         self.orders_ask.clear();
     }
 
-    pub fn add_order(&mut self, order: PassiveOrderType) -> Result<(), OrderError> {
-        match order.get_order_side() {
-            OrderSideFixed::Buy => {
+    pub fn add_order(&mut self, order: PassiveOrderAny) -> Result<(), OrderError> {
+        match order.order_side_specified() {
+            OrderSideSpecified::Buy => {
                 self.orders_bid.push(order);
                 Ok(())
             }
-            OrderSideFixed::Sell => {
+            OrderSideSpecified::Sell => {
                 self.orders_ask.push(order);
                 Ok(())
             }
         }
     }
 
-    pub fn delete_order(&mut self, order: &PassiveOrderType) -> Result<(), OrderError> {
-        match order.get_order_side() {
-            OrderSideFixed::Buy => {
+    pub fn delete_order(&mut self, order: &PassiveOrderAny) -> Result<(), OrderError> {
+        match order.order_side_specified() {
+            OrderSideSpecified::Buy => {
                 let index = self
                     .orders_bid
                     .iter()
                     .position(|o| o == order)
-                    .ok_or(OrderError::NotFound(order.get_client_order_id()))?;
+                    .ok_or(OrderError::NotFound(order.client_order_id()))?;
                 self.orders_bid.remove(index);
                 Ok(())
             }
-            OrderSideFixed::Sell => {
+            OrderSideSpecified::Sell => {
                 let index = self
                     .orders_ask
                     .iter()
                     .position(|o| o == order)
-                    .ok_or(OrderError::NotFound(order.get_client_order_id()))?;
+                    .ok_or(OrderError::NotFound(order.client_order_id()))?;
                 self.orders_ask.remove(index);
                 Ok(())
             }
         }
     }
 
     pub fn iterate(&self) {
@@ -141,58 +153,58 @@
         self.iterate_orders(&self.orders_bid);
     }
 
     pub fn iterate_asks(&self) {
         self.iterate_orders(&self.orders_ask);
     }
 
-    fn iterate_orders(&self, orders: &[PassiveOrderType]) {
+    fn iterate_orders(&self, orders: &[PassiveOrderAny]) {
         for order in orders {
             self.match_order(order, false);
         }
     }
 
     // -- MATCHING --------------------------------------------------------------------------------
 
-    fn match_order(&self, order: &PassiveOrderType, _initial: bool) {
+    fn match_order(&self, order: &PassiveOrderAny, _initial: bool) {
         match order {
-            PassiveOrderType::Limit(o) => self.match_limit_order(o),
-            PassiveOrderType::Stop(o) => self.match_stop_order(o),
+            PassiveOrderAny::Limit(o) => self.match_limit_order(o),
+            PassiveOrderAny::Stop(o) => self.match_stop_order(o),
         }
     }
 
-    pub fn match_limit_order(&self, order: &LimitOrderType) {
+    pub fn match_limit_order(&self, order: &LimitOrderAny) {
         if self.is_limit_matched(order) {
             if let Some(func) = self.fill_limit_order {
                 func(order.clone()); // TODO: Remove this clone (will need a lifetime)
             }
         }
     }
 
-    pub fn match_stop_order(&self, order: &StopOrderType) {
+    pub fn match_stop_order(&self, order: &StopOrderAny) {
         if self.is_stop_matched(order) {
             if let Some(func) = self.trigger_stop_order {
                 func(order.clone()); // TODO: Remove this clone (will need a lifetime)
             }
         }
     }
 
     #[must_use]
-    pub fn is_limit_matched(&self, order: &LimitOrderType) -> bool {
-        match order.get_order_side() {
-            OrderSideFixed::Buy => self.ask.map_or(false, |a| a <= order.get_limit_px()),
-            OrderSideFixed::Sell => self.bid.map_or(false, |b| b >= order.get_limit_px()),
+    pub fn is_limit_matched(&self, order: &LimitOrderAny) -> bool {
+        match order.order_side_specified() {
+            OrderSideSpecified::Buy => self.ask.map_or(false, |a| a <= order.limit_px()),
+            OrderSideSpecified::Sell => self.bid.map_or(false, |b| b >= order.limit_px()),
         }
     }
 
     #[must_use]
-    pub fn is_stop_matched(&self, order: &StopOrderType) -> bool {
-        match order.get_order_side() {
-            OrderSideFixed::Buy => self.ask.map_or(false, |a| a >= order.get_stop_px()),
-            OrderSideFixed::Sell => self.bid.map_or(false, |b| b <= order.get_stop_px()),
+    pub fn is_stop_matched(&self, order: &StopOrderAny) -> bool {
+        match order.order_side_specified() {
+            OrderSideSpecified::Buy => self.ask.map_or(false, |a| a >= order.stop_px()),
+            OrderSideSpecified::Sell => self.bid.map_or(false, |b| b <= order.stop_px()),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
@@ -203,16 +215,16 @@
     use nautilus_model::{
         enums::OrderSide, orders::stubs::TestOrderStubs, types::quantity::Quantity,
     };
     use rstest::rstest;
 
     use super::*;
 
-    static TRIGGERED_STOPS: Mutex<Vec<StopOrderType>> = Mutex::new(Vec::new());
-    static FILLED_LIMITS: Mutex<Vec<LimitOrderType>> = Mutex::new(Vec::new());
+    static TRIGGERED_STOPS: Mutex<Vec<StopOrderAny>> = Mutex::new(Vec::new());
+    static FILLED_LIMITS: Mutex<Vec<LimitOrderAny>> = Mutex::new(Vec::new());
 
     fn create_matching_core(
         instrument_id: InstrumentId,
         price_increment: Price,
     ) -> OrderMatchingCore {
         OrderMatchingCore::new(instrument_id, price_increment, None, None, None)
     }
@@ -226,22 +238,24 @@
             instrument_id,
             OrderSide::Buy,
             Price::from("100.00"),
             Quantity::from("100"),
             None,
             None,
         );
+        let client_order_id = order.client_order_id;
 
-        let passive_order = PassiveOrderType::Limit(LimitOrderType::Limit(order));
+        let passive_order = PassiveOrderAny::Limit(LimitOrderAny::Limit(order));
         matching_core.add_order(passive_order.clone()).unwrap();
 
         assert!(matching_core.get_orders_bid().contains(&passive_order));
         assert!(!matching_core.get_orders_ask().contains(&passive_order));
         assert_eq!(matching_core.get_orders_bid().len(), 1);
         assert!(matching_core.get_orders_ask().is_empty());
+        assert!(matching_core.order_exists(client_order_id));
     }
 
     #[rstest]
     fn test_add_order_ask_side() {
         let instrument_id = InstrumentId::from("AAPL.XNAS");
         let mut matching_core = create_matching_core(instrument_id, Price::from("0.01"));
 
@@ -249,22 +263,24 @@
             instrument_id,
             OrderSide::Sell,
             Price::from("100.00"),
             Quantity::from("100"),
             None,
             None,
         );
+        let client_order_id = order.client_order_id;
 
-        let passive_order = PassiveOrderType::Limit(LimitOrderType::Limit(order));
+        let passive_order = PassiveOrderAny::Limit(LimitOrderAny::Limit(order));
         matching_core.add_order(passive_order.clone()).unwrap();
 
         assert!(matching_core.get_orders_ask().contains(&passive_order));
         assert!(!matching_core.get_orders_bid().contains(&passive_order));
         assert_eq!(matching_core.get_orders_ask().len(), 1);
         assert!(matching_core.get_orders_bid().is_empty());
+        assert!(matching_core.order_exists(client_order_id));
     }
 
     #[rstest]
     fn test_reset() {
         let instrument_id = InstrumentId::from("AAPL.XNAS");
         let mut matching_core = create_matching_core(instrument_id, Price::from("0.01"));
 
@@ -272,28 +288,30 @@
             instrument_id,
             OrderSide::Sell,
             Price::from("100.00"),
             Quantity::from("100"),
             None,
             None,
         );
+        let client_order_id = order.client_order_id;
 
-        let passive_order = PassiveOrderType::Limit(LimitOrderType::Limit(order));
+        let passive_order = PassiveOrderAny::Limit(LimitOrderAny::Limit(order));
         matching_core.add_order(passive_order).unwrap();
         matching_core.bid = Some(Price::from("100.00"));
         matching_core.ask = Some(Price::from("100.00"));
         matching_core.last = Some(Price::from("100.00"));
 
         matching_core.reset();
 
         assert!(matching_core.bid.is_none());
         assert!(matching_core.ask.is_none());
         assert!(matching_core.last.is_none());
         assert!(matching_core.get_orders_bid().is_empty());
         assert!(matching_core.get_orders_ask().is_empty());
+        assert!(!matching_core.order_exists(client_order_id));
     }
 
     #[rstest]
     fn test_delete_order_when_not_exists() {
         let instrument_id = InstrumentId::from("AAPL.XNAS");
         let mut matching_core = create_matching_core(instrument_id, Price::from("0.01"));
 
@@ -302,15 +320,15 @@
             OrderSide::Buy,
             Price::from("100.00"),
             Quantity::from("100"),
             None,
             None,
         );
 
-        let passive_order = PassiveOrderType::Limit(LimitOrderType::Limit(order));
+        let passive_order = PassiveOrderAny::Limit(LimitOrderAny::Limit(order));
         let result = matching_core.delete_order(&passive_order);
 
         assert!(result.is_err());
     }
 
     #[rstest]
     #[case(OrderSide::Buy)]
@@ -324,15 +342,15 @@
             order_side,
             Price::from("100.00"),
             Quantity::from("100"),
             None,
             None,
         );
 
-        let passive_order = PassiveOrderType::Limit(LimitOrderType::Limit(order));
+        let passive_order = PassiveOrderAny::Limit(LimitOrderAny::Limit(order));
         matching_core.add_order(passive_order.clone()).unwrap();
         matching_core.delete_order(&passive_order).unwrap();
 
         assert!(matching_core.get_orders_ask().is_empty());
         assert!(matching_core.get_orders_bid().is_empty());
     }
 
@@ -398,15 +416,15 @@
             order_side,
             price,
             Quantity::from("100"),
             None,
             None,
         );
 
-        let result = matching_core.is_limit_matched(&LimitOrderType::Limit(order));
+        let result = matching_core.is_limit_matched(&LimitOrderAny::Limit(order));
 
         assert_eq!(result, expected);
     }
 
     #[rstest]
     #[case(None, None, Price::from("100.00"), OrderSide::Buy, false)]
     #[case(None, None, Price::from("100.00"), OrderSide::Sell, false)]
@@ -470,27 +488,27 @@
             trigger_price,
             Quantity::from("100"),
             None,
             None,
             None,
         );
 
-        let result = matching_core.is_stop_matched(&StopOrderType::StopMarket(order));
+        let result = matching_core.is_stop_matched(&StopOrderAny::StopMarket(order));
 
         assert_eq!(result, expected);
     }
 
     #[rstest]
     #[case(OrderSide::Buy)]
     #[case(OrderSide::Sell)]
     fn test_match_stop_order_when_triggered(#[case] order_side: OrderSide) {
         let instrument_id = InstrumentId::from("AAPL.XNAS");
         let trigger_price = Price::from("100.00");
 
-        fn trigger_stop_order_handler(order: StopOrderType) {
+        fn trigger_stop_order_handler(order: StopOrderAny) {
             let order = order;
             TRIGGERED_STOPS.lock().unwrap().push(order);
         }
 
         let mut matching_core = OrderMatchingCore::new(
             instrument_id,
             Price::from("0.01"),
@@ -508,29 +526,29 @@
             trigger_price,
             Quantity::from("100"),
             None,
             None,
             None,
         );
 
-        matching_core.match_stop_order(&StopOrderType::StopMarket(order.clone()));
+        matching_core.match_stop_order(&StopOrderAny::StopMarket(order.clone()));
 
         let triggered_stops = TRIGGERED_STOPS.lock().unwrap();
         assert_eq!(triggered_stops.len(), 1);
-        assert_eq!(triggered_stops[0], StopOrderType::StopMarket(order));
+        assert_eq!(triggered_stops[0], StopOrderAny::StopMarket(order));
     }
 
     #[rstest]
     #[case(OrderSide::Buy)]
     #[case(OrderSide::Sell)]
     fn test_match_limit_order_when_triggered(#[case] order_side: OrderSide) {
         let instrument_id = InstrumentId::from("AAPL.XNAS");
         let price = Price::from("100.00");
 
-        fn fill_limit_order_handler(order: LimitOrderType) {
+        fn fill_limit_order_handler(order: LimitOrderAny) {
             FILLED_LIMITS.lock().unwrap().push(order);
         }
 
         let mut matching_core = OrderMatchingCore::new(
             instrument_id,
             Price::from("0.01"),
             None,
@@ -546,14 +564,14 @@
             order_side,
             price,
             Quantity::from("100.00"),
             None,
             None,
         );
 
-        matching_core.match_limit_order(&LimitOrderType::Limit(order.clone()));
+        matching_core.match_limit_order(&LimitOrderAny::Limit(order.clone()));
 
         let filled_limits = FILLED_LIMITS.lock().unwrap();
         assert_eq!(filled_limits.len(), 1);
-        assert_eq!(filled_limits[0], LimitOrderType::Limit(order));
+        assert_eq!(filled_limits[0], LimitOrderAny::Limit(order));
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/indicators/Cargo.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/average/ama.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/average/ama.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/average/dema.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/average/dema.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/average/ema.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/average/ema.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/average/hma.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/average/hma.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/average/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/average/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/average/rma.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/average/rma.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/average/sma.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/average/sma.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/average/vidya.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/average/vidya.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/average/wma.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/average/wma.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/book/imbalance.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/book/imbalance.rs`

 * *Files 7% similar despite different names*

```diff
@@ -11,18 +11,15 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::Display;
 
-use nautilus_model::{
-    orderbook::{book_mbo::OrderBookMbo, book_mbp::OrderBookMbp},
-    types::quantity::Quantity,
-};
+use nautilus_model::{orderbook::book::OrderBook, types::quantity::Quantity};
 
 use crate::indicator::Indicator;
 
 #[repr(C)]
 #[derive(Debug)]
 #[cfg_attr(
     feature = "python",
@@ -50,19 +47,15 @@
         self.has_inputs
     }
 
     fn initialized(&self) -> bool {
         self.initialized
     }
 
-    fn handle_book_mbo(&mut self, book: &OrderBookMbo) {
-        self.update(book.best_bid_size(), book.best_ask_size());
-    }
-
-    fn handle_book_mbp(&mut self, book: &OrderBookMbp) {
+    fn handle_book(&mut self, book: &OrderBook) {
         self.update(book.best_bid_size(), book.best_ask_size());
     }
 
     fn reset(&mut self) {
         self.value = 0.0;
         self.count = 0;
         self.has_inputs = false;
@@ -108,16 +101,14 @@
         identifiers::instrument_id::InstrumentId,
         stubs::{stub_order_book_mbp, stub_order_book_mbp_appl_xnas},
     };
     use rstest::rstest;
 
     use super::*;
 
-    // TODO: Test `OrderBookMbo`: needs a good stub function
-
     #[rstest]
     fn test_initialized() {
         let imbalance = BookImbalanceRatio::new().unwrap();
         let display_str = format!("{imbalance}");
         assert_eq!(display_str, "BookImbalanceRatio()");
         assert_eq!(imbalance.value, 0.0);
         assert_eq!(imbalance.count, 0);
@@ -125,27 +116,27 @@
         assert!(!imbalance.initialized);
     }
 
     #[rstest]
     fn test_one_value_input_balanced() {
         let mut imbalance = BookImbalanceRatio::new().unwrap();
         let book = stub_order_book_mbp_appl_xnas();
-        imbalance.handle_book_mbp(&book);
+        imbalance.handle_book(&book);
 
         assert_eq!(imbalance.count, 1);
         assert_eq!(imbalance.value, 1.0);
         assert!(imbalance.initialized);
         assert!(imbalance.has_inputs);
     }
 
     #[rstest]
     fn test_reset() {
         let mut imbalance = BookImbalanceRatio::new().unwrap();
         let book = stub_order_book_mbp_appl_xnas();
-        imbalance.handle_book_mbp(&book);
+        imbalance.handle_book(&book);
         imbalance.reset();
 
         assert_eq!(imbalance.count, 0);
         assert_eq!(imbalance.value, 0.0);
         assert!(!imbalance.initialized);
         assert!(!imbalance.has_inputs);
     }
@@ -161,15 +152,15 @@
             100.0,
             2,
             0.01,
             0,
             100.0,
             10,
         );
-        imbalance.handle_book_mbp(&book);
+        imbalance.handle_book(&book);
 
         assert_eq!(imbalance.count, 1);
         assert_eq!(imbalance.value, 0.5);
         assert!(imbalance.initialized);
         assert!(imbalance.has_inputs);
     }
 
@@ -184,15 +175,15 @@
             200.0, // <-- Larger ask side
             2,
             0.01,
             0,
             100.0,
             10,
         );
-        imbalance.handle_book_mbp(&book);
+        imbalance.handle_book(&book);
 
         assert_eq!(imbalance.count, 1);
         assert_eq!(imbalance.value, 0.5);
         assert!(imbalance.initialized);
         assert!(imbalance.has_inputs);
     }
 
@@ -207,17 +198,17 @@
             100.0,
             2,
             0.01,
             0,
             100.0,
             10,
         );
-        imbalance.handle_book_mbp(&book);
-        imbalance.handle_book_mbp(&book);
-        imbalance.handle_book_mbp(&book);
+        imbalance.handle_book(&book);
+        imbalance.handle_book(&book);
+        imbalance.handle_book(&book);
 
         assert_eq!(imbalance.count, 3);
         assert_eq!(imbalance.value, 0.5);
         assert!(imbalance.initialized);
         assert!(imbalance.has_inputs);
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/book/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/book/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/indicator.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/indicator.rs`

 * *Files 3% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 use std::{fmt, fmt::Debug};
 
 use nautilus_model::{
     data::{
         bar::Bar, delta::OrderBookDelta, deltas::OrderBookDeltas, depth::OrderBookDepth10,
         quote::QuoteTick, trade::TradeTick,
     },
-    orderbook::{book_mbo::OrderBookMbo, book_mbp::OrderBookMbp},
+    orderbook::book::OrderBook,
 };
 
 const IMPL_ERR: &str = "is not implemented for";
 
 #[allow(unused_variables)]
 pub trait Indicator {
     fn name(&self) -> String;
@@ -38,22 +38,18 @@
         // Eventually change this to log an error
         panic!("`handle_deltas` {} `{}`", IMPL_ERR, self.name());
     }
     fn handle_depth(&mut self, depth: &OrderBookDepth10) {
         // Eventually change this to log an error
         panic!("`handle_depth` {} `{}`", IMPL_ERR, self.name());
     }
-    fn handle_book_mbo(&mut self, book: &OrderBookMbo) {
+    fn handle_book(&mut self, book: &OrderBook) {
         // Eventually change this to log an error
         panic!("`handle_book_mbo` {} `{}`", IMPL_ERR, self.name());
     }
-    fn handle_book_mbp(&mut self, book: &OrderBookMbp) {
-        // Eventually change this to log an error
-        panic!("`handle_book_mbp` {} `{}`", IMPL_ERR, self.name());
-    }
     fn handle_quote_tick(&mut self, quote: &QuoteTick) {
         // Eventually change this to log an error
         panic!("`handle_quote_tick` {} `{}`", IMPL_ERR, self.name());
     }
     fn handle_trade_tick(&mut self, trade: &TradeTick) {
         // Eventually change this to log an error
         panic!("`handle_trade_tick` {} `{}`", IMPL_ERR, self.name());
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/lib.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/lib.rs`

 * *Files 2% similar despite different names*

```diff
@@ -14,14 +14,15 @@
 // -------------------------------------------------------------------------------------------------
 
 pub mod average;
 pub mod book;
 pub mod indicator;
 pub mod momentum;
 pub mod ratio;
+pub mod testing;
 pub mod volatility;
 
 #[cfg(test)]
 mod stubs;
 
 #[cfg(feature = "python")]
 pub mod python;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/momentum/cmo.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/momentum/cmo.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/momentum/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/momentum/mod.rs`

 * *Files 1% similar despite different names*

```diff
@@ -10,9 +10,10 @@
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 pub mod aroon;
+pub mod bias;
 pub mod cmo;
 pub mod rsi;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/momentum/rsi.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/momentum/rsi.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/ama.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/ama.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/dema.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/dema.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/ema.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/ema.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/hma.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/hma.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/rma.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/rma.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/sma.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/sma.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/vidya.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/vidya.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/average/wma.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/average/wma.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/book/imbalance.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/book/imbalance.rs`

 * *Files 6% similar despite different names*

```diff
@@ -10,18 +10,15 @@
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use nautilus_core::python::to_pyvalue_err;
-use nautilus_model::{
-    orderbook::{book_mbo::OrderBookMbo, book_mbp::OrderBookMbp},
-    types::quantity::Quantity,
-};
+use nautilus_model::{orderbook::book::OrderBook, types::quantity::Quantity};
 use pyo3::prelude::*;
 
 use crate::{book::imbalance::BookImbalanceRatio, indicator::Indicator};
 
 #[pymethods]
 impl BookImbalanceRatio {
     #[new]
@@ -59,22 +56,17 @@
 
     #[getter]
     #[pyo3(name = "initialized")]
     fn py_initialized(&self) -> bool {
         self.initialized
     }
 
-    #[pyo3(name = "handle_book_mbo")]
-    fn py_handle_book_mbo(&mut self, book: &OrderBookMbo) {
-        self.handle_book_mbo(book);
-    }
-
-    #[pyo3(name = "handle_book_mbp")]
-    fn py_handle_book_mbp(&mut self, book: &OrderBookMbp) {
-        self.handle_book_mbp(book);
+    #[pyo3(name = "handle_book")]
+    fn py_handle_book(&mut self, book: &OrderBook) {
+        self.handle_book(book);
     }
 
     #[pyo3(name = "update")]
     fn py_update(&mut self, best_bid: Option<Quantity>, best_ask: Option<Quantity>) {
         self.update(best_bid, best_ask);
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/book/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/book/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/mod.rs`

 * *Files 5% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+#![allow(warnings)] // non-local `impl` definition, temporary allow until pyo3 upgrade
+
 use pyo3::{prelude::*, pymodule};
 
 pub mod average;
 pub mod book;
 pub mod momentum;
 pub mod ratio;
 pub mod volatility;
@@ -34,12 +36,13 @@
     // book
     m.add_class::<crate::book::imbalance::BookImbalanceRatio>()?;
     // ratio
     m.add_class::<crate::ratio::efficiency_ratio::EfficiencyRatio>()?;
     // momentum
     m.add_class::<crate::momentum::rsi::RelativeStrengthIndex>()?;
     m.add_class::<crate::momentum::aroon::AroonOscillator>()?;
+    m.add_class::<crate::momentum::bias::Bias>()?;
     m.add_class::<crate::momentum::cmo::ChandeMomentumOscillator>()?;
     // volatility
     m.add_class::<crate::volatility::atr::AverageTrueRange>()?;
     Ok(())
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/momentum/aroon.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/momentum/aroon.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/momentum/cmo.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/momentum/cmo.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/momentum/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/backend/mod.rs`

 * *Files 4% similar despite different names*

```diff
@@ -9,10 +9,9 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod aroon;
-pub mod cmo;
-pub mod rsi;
+pub mod kmerge_batch;
+pub mod session;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/momentum/rsi.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/momentum/rsi.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/ratio/efficiency_ratio.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/ratio/efficiency_ratio.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/ratio/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/ratio/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/volatility/atr.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/volatility/atr.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/python/volatility/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/python/volatility/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/ratio/efficiency_ratio.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/ratio/efficiency_ratio.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/ratio/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/common/src/interface/mod.rs`

 * *Files 14% similar despite different names*

```diff
@@ -9,8 +9,8 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod efficiency_ratio;
+pub mod account;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/stubs.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/stubs.rs`

 * *Files 4% similar despite different names*

```diff
@@ -28,15 +28,15 @@
 use crate::{
     average::{
         ama::AdaptiveMovingAverage, dema::DoubleExponentialMovingAverage,
         ema::ExponentialMovingAverage, hma::HullMovingAverage, rma::WilderMovingAverage,
         sma::SimpleMovingAverage, vidya::VariableIndexDynamicAverage, wma::WeightedMovingAverage,
         MovingAverageType,
     },
-    momentum::{cmo::ChandeMomentumOscillator, rsi::RelativeStrengthIndex},
+    momentum::{bias::Bias, cmo::ChandeMomentumOscillator, rsi::RelativeStrengthIndex},
     ratio::efficiency_ratio::EfficiencyRatio,
 };
 
 ////////////////////////////////////////////////////////////////////////////////
 // Common
 ////////////////////////////////////////////////////////////////////////////////
 #[fixture]
@@ -46,29 +46,29 @@
 ) -> QuoteTick {
     QuoteTick {
         instrument_id: InstrumentId::from("ETHUSDT-PERP.BINANCE"),
         bid_price: Price::from(bid_price),
         ask_price: Price::from(ask_price),
         bid_size: Quantity::from("1.00000000"),
         ask_size: Quantity::from("1.00000000"),
-        ts_event: 1,
-        ts_init: 0,
+        ts_event: 1.into(),
+        ts_init: 0.into(),
     }
 }
 
 #[fixture]
 pub fn trade_tick() -> TradeTick {
     TradeTick {
         instrument_id: InstrumentId::from("ETHUSDT-PERP.BINANCE"),
         price: Price::from("1500.0000"),
         size: Quantity::from("1.00000000"),
         aggressor_side: AggressorSide::Buyer,
         trade_id: TradeId::from("123456789"),
-        ts_event: 1,
-        ts_init: 0,
+        ts_event: 1.into(),
+        ts_init: 0.into(),
     }
 }
 
 #[fixture]
 pub fn bar_ethusdt_binance_minute_bid(#[default("1522")] close_price: &str) -> Bar {
     let instrument_id = InstrumentId {
         symbol: Symbol::new("ETHUSDT-PERP.BINANCE").unwrap(),
@@ -87,16 +87,16 @@
     Bar {
         bar_type,
         open: Price::from("1500.0"),
         high: Price::from("1550.0"),
         low: Price::from("1495.0"),
         close: Price::from(close_price),
         volume: Quantity::from("100000"),
-        ts_event: 0,
-        ts_init: 1,
+        ts_event: 0.into(),
+        ts_init: 1.into(),
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Average
 ////////////////////////////////////////////////////////////////////////////////
 #[fixture]
@@ -157,7 +157,12 @@
     RelativeStrengthIndex::new(10, Some(MovingAverageType::Exponential)).unwrap()
 }
 
 #[fixture]
 pub fn cmo_10() -> ChandeMomentumOscillator {
     ChandeMomentumOscillator::new(10, Some(MovingAverageType::Wilder)).unwrap()
 }
+
+#[fixture]
+pub fn bias_10() -> Bias {
+    Bias::new(10, Some(MovingAverageType::Wilder)).unwrap()
+}
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/volatility/atr.rs` & `nautilus_trader-1.191.0/nautilus_trader/indicators/keltner_position.pyx`

 * *Files 24% similar despite different names*

```diff
@@ -1,142 +1,137 @@
-// -------------------------------------------------------------------------------------------------
-//  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
-//  https://nautechsystems.io
-//
-//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-//  You may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-// -------------------------------------------------------------------------------------------------
-
-use std::fmt::{Debug, Display};
-
-use nautilus_model::data::bar::Bar;
-
-use crate::{
-    average::{MovingAverageFactory, MovingAverageType},
-    indicator::{Indicator, MovingAverage},
-};
-
-/// An indicator which calculates a Average True Range (ATR) across a rolling window.
-#[repr(C)]
-#[derive(Debug)]
-#[cfg_attr(
-    feature = "python",
-    pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.indicators")
-)]
-pub struct AverageTrueRange {
-    pub period: usize,
-    pub ma_type: MovingAverageType,
-    pub use_previous: bool,
-    pub value_floor: f64,
-    pub value: f64,
-    pub count: usize,
-    pub initialized: bool,
-    ma: Box<dyn MovingAverage + Send + 'static>,
-    has_inputs: bool,
-    previous_close: f64,
-}
-
-impl Display for AverageTrueRange {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        write!(
-            f,
-            "{}({},{},{},{})",
-            self.name(),
-            self.period,
-            self.ma_type,
-            self.use_previous,
-            self.value_floor,
-        )
-    }
-}
+# -------------------------------------------------------------------------------------------------
+#  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
+#  https://nautechsystems.io
+#
+#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+#  You may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+# -------------------------------------------------------------------------------------------------
+
+from nautilus_trader.indicators.average.moving_average import MovingAverageType
+
+from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.indicators.base.indicator cimport Indicator
+from nautilus_trader.indicators.keltner_channel cimport KeltnerChannel
+from nautilus_trader.model.data cimport Bar
+
+
+cdef class KeltnerPosition(Indicator):
+    """
+    An indicator which calculates the relative position of the given price
+    within a defined Keltner channel. This provides a measure of the relative
+    'extension' of a market from the mean, as a multiple of volatility.
+
+    Parameters
+    ----------
+    period : int
+        The rolling window period for the indicator (> 0).
+    k_multiplier : double
+        The multiplier for the ATR (> 0).
+    ma_type : MovingAverageType
+        The moving average type for the middle band (cannot be None).
+    ma_type_atr : MovingAverageType
+        The moving average type for the internal ATR (cannot be None).
+    use_previous : bool
+        The boolean flag indicating whether previous price values should be used.
+    atr_floor : double
+        The ATR floor (minimum) output value for the indicator (>= 0).
+    """
+
+    def __init__(
+        self,
+        int period,
+        double k_multiplier,
+        ma_type not None: MovingAverageType=MovingAverageType.EXPONENTIAL,
+        ma_type_atr not None: MovingAverageType=MovingAverageType.SIMPLE,
+        bint use_previous=True,
+        double atr_floor=0,
+    ):
+        Condition.positive_int(period, "period")
+        Condition.positive(k_multiplier, "k_multiplier")
+        Condition.not_negative(atr_floor, "atr_floor")
 
-impl Indicator for AverageTrueRange {
-    fn name(&self) -> String {
-        stringify!(AverageTrueRange).to_string()
-    }
-
-    fn has_inputs(&self) -> bool {
-        self.has_inputs
-    }
-
-    fn initialized(&self) -> bool {
-        self.initialized
-    }
-
-    fn handle_bar(&mut self, bar: &Bar) {
-        self.update_raw((&bar.high).into(), (&bar.low).into(), (&bar.close).into());
-    }
-
-    fn reset(&mut self) {
-        self.previous_close = 0.0;
-        self.value = 0.0;
-        self.count = 0;
-        self.has_inputs = false;
-        self.initialized = false;
-    }
-}
-
-impl AverageTrueRange {
-    pub fn new(
-        period: usize,
-        ma_type: Option<MovingAverageType>,
-        use_previous: Option<bool>,
-        value_floor: Option<f64>,
-    ) -> anyhow::Result<Self> {
-        Ok(Self {
+        params = [
             period,
-            ma_type: ma_type.unwrap_or(MovingAverageType::Simple),
-            use_previous: use_previous.unwrap_or(true),
-            value_floor: value_floor.unwrap_or(0.0),
-            value: 0.0,
-            count: 0,
-            previous_close: 0.0,
-            ma: MovingAverageFactory::create(MovingAverageType::Simple, period),
-            has_inputs: false,
-            initialized: false,
-        })
-    }
-
-    pub fn update_raw(&mut self, high: f64, low: f64, close: f64) {
-        if self.use_previous {
-            if !self.has_inputs {
-                self.previous_close = close;
-            }
-            self.ma.update_raw(
-                f64::max(self.previous_close, high) - f64::min(low, self.previous_close),
-            );
-            self.previous_close = close;
-        } else {
-            self.ma.update_raw(high - low);
-        }
-
-        self._floor_value();
-        self.increment_count();
-    }
-
-    fn _floor_value(&mut self) {
-        if self.value_floor == 0.0 || self.value_floor < self.ma.value() {
-            self.value = self.ma.value();
-        } else {
-            // Floor the value
-            self.value = self.value_floor;
-        }
-    }
-
-    fn increment_count(&mut self) {
-        self.count += 1;
-
-        if !self.initialized {
-            self.has_inputs = true;
-            if self.count >= self.period {
-                self.initialized = true;
-            }
-        }
-    }
-}
+            k_multiplier,
+            ma_type.name,
+            ma_type_atr.name,
+            use_previous,
+            atr_floor,
+        ]
+        super().__init__(params=params)
+
+        self.period = period
+        self.k_multiplier = k_multiplier
+
+        self._kc = KeltnerChannel(
+            period,
+            k_multiplier,
+            ma_type,
+            ma_type_atr,
+            use_previous,
+            atr_floor,
+        )
+
+        self.value = 0
+
+    cpdef void handle_bar(self, Bar bar):
+        """
+        Update the indicator with the given bar.
+
+        Parameters
+        ----------
+        bar : Bar
+            The update bar.
+
+        """
+        Condition.not_none(bar, "bar")
+
+        self.update_raw(
+            bar.high.as_double(),
+            bar.low.as_double(),
+            bar.close.as_double(),
+        )
+
+    cpdef void update_raw(
+        self,
+        double high,
+        double low,
+        double close,
+    ):
+        """
+        Update the indicator with the given raw value.
+
+        Parameters
+        ----------
+        high : double
+            The high price.
+        low : double
+            The low price.
+        close : double
+            The close price.
+
+        """
+        self._kc.update_raw(high, low, close)
+
+        # Initialization logic
+        if not self.initialized:
+            self._set_has_inputs(True)
+            if self._kc.initialized:
+                self._set_initialized(True)
+
+        cdef double k_width = (self._kc.upper - self._kc.lower) / 2
+
+        if k_width > 0:
+            self.value = (close - self._kc.middle) / k_width
+        else:
+            self.value = 0
+
+    cpdef void _reset(self):
+        self._kc.reset()
+        self.value = 0
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/indicators/src/volatility/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/volatility/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/infrastructure/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/infrastructure/Cargo.toml`

 * *Files 8% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 documentation.workspace = true
 
 [lib]
 name = "nautilus_infrastructure"
 crate-type = ["rlib", "cdylib"]
 
 [dependencies]
-nautilus-common = { path = "../common", features = ["redis"] }
+nautilus-common = { path = "../common", features = ["python"] }
 nautilus-core = { path = "../core" , features = ["python"] }
 nautilus-model = { path = "../model" , features = ["python"] }
 anyhow = { workspace = true }
 pyo3 = { workspace = true, optional = true }
 redis = { workspace = true, optional = true }
 rmp-serde = { workspace = true }
 serde_json = { workspace = true }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/infrastructure/src/lib.rs` & `nautilus_trader-1.191.0/nautilus_core/infrastructure/src/lib.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/infrastructure/src/python/cache.rs` & `nautilus_trader-1.191.0/nautilus_core/infrastructure/src/python/redis/cache.rs`

 * *Files 5% similar despite different names*

```diff
@@ -11,37 +11,42 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::collections::HashMap;
 
-use nautilus_common::cache::CacheDatabase;
+use nautilus_common::cache::database::CacheDatabase;
 use nautilus_core::{
     python::{to_pyruntime_err, to_pyvalue_err},
     uuid::UUID4,
 };
 use nautilus_model::identifiers::trader_id::TraderId;
 use pyo3::{prelude::*, types::PyBytes};
 
-use crate::redis::RedisCacheDatabase;
+use crate::redis::cache::RedisCacheDatabase;
 
 #[pymethods]
 impl RedisCacheDatabase {
     #[new]
     fn py_new(trader_id: TraderId, instance_id: UUID4, config_json: Vec<u8>) -> PyResult<Self> {
         let config: HashMap<String, serde_json::Value> =
             serde_json::from_slice(&config_json).map_err(to_pyvalue_err)?;
 
         match Self::new(trader_id, instance_id, config) {
             Ok(cache) => Ok(cache),
             Err(e) => Err(to_pyruntime_err(e.to_string())),
         }
     }
 
+    #[pyo3(name = "close")]
+    fn py_close(&mut self) -> PyResult<()> {
+        self.close().map_err(to_pyruntime_err)
+    }
+
     #[pyo3(name = "flushdb")]
     fn py_flushdb(&mut self) -> PyResult<()> {
         match self.flushdb() {
             Ok(_) => Ok(()),
             Err(e) => Err(to_pyruntime_err(e)),
         }
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/infrastructure/src/python/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/infrastructure/src/python/mod.rs`

 * *Files 10% similar despite different names*

```diff
@@ -9,16 +9,20 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+#![allow(warnings)] // non-local `impl` definition, temporary allow until pyo3 upgrade
+
 use pyo3::{prelude::*, pymodule};
 
-pub mod cache;
+#[cfg(feature = "redis")]
+pub mod redis;
 
 #[pymodule]
 pub fn infrastructure(_: Python<'_>, m: &PyModule) -> PyResult<()> {
-    m.add_class::<crate::redis::RedisCacheDatabase>()?;
+    m.add_class::<crate::redis::cache::RedisCacheDatabase>()?;
+    m.add_class::<crate::redis::msgbus::RedisMessageBusDatabase>()?;
     Ok(())
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/infrastructure/src/redis.rs` & `nautilus_trader-1.191.0/nautilus_core/infrastructure/src/redis/cache.rs`

 * *Files 1% similar despite different names*

```diff
@@ -12,30 +12,29 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::{HashMap, VecDeque},
     sync::mpsc::{channel, Receiver, Sender, TryRecvError},
-    thread,
+    thread::{self, JoinHandle},
     time::{Duration, Instant},
 };
 
-use nautilus_common::{
-    cache::{CacheDatabase, DatabaseCommand, DatabaseOperation},
-    redis::{create_redis_connection, get_buffer_interval},
-};
-use nautilus_core::uuid::UUID4;
+use nautilus_common::cache::database::{CacheDatabase, DatabaseCommand, DatabaseOperation};
+use nautilus_core::{correctness::check_slice_not_empty, uuid::UUID4};
 use nautilus_model::identifiers::trader_id::TraderId;
 use redis::{Commands, Connection, Pipeline};
 use serde_json::{json, Value};
-use tracing::debug;
+use tracing::{debug, error};
+
+use crate::redis::{create_redis_connection, get_buffer_interval};
 
 // Error constants
-const CHANNEL_TX_FAILED: &str = "Failed to send to channel";
+const FAILED_TX_CHANNEL: &str = "Failed to send to channel";
 
 // Redis constants
 const FLUSHDB: &str = "FLUSHDB";
 const DELIMITER: char = ':';
 
 // Collection keys
 const INDEX: &str = "index";
@@ -69,14 +68,15 @@
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.infrastructure")
 )]
 pub struct RedisCacheDatabase {
     pub trader_id: TraderId,
     trader_key: String,
     conn: Connection,
     tx: Sender<DatabaseCommand>,
+    handle: Option<JoinHandle<()>>,
 }
 
 impl CacheDatabase for RedisCacheDatabase {
     type DatabaseType = RedisCacheDatabase;
 
     fn new(
         trader_id: TraderId,
@@ -89,29 +89,44 @@
         debug!("Creating cache-read redis connection");
         let conn = create_redis_connection(&database_config.clone())?;
 
         let (tx, rx) = channel::<DatabaseCommand>();
         let trader_key = get_trader_key(trader_id, instance_id, &config);
         let trader_key_clone = trader_key.clone();
 
-        let _join_handle = thread::Builder::new()
+        let handle = thread::Builder::new()
             .name("cache".to_string())
             .spawn(move || {
                 Self::handle_messages(rx, trader_key_clone, config);
             })
             .expect("Error spawning `cache` thread");
 
         Ok(RedisCacheDatabase {
             trader_id,
             trader_key,
             conn,
             tx,
+            handle: Some(handle),
         })
     }
 
+    fn close(&mut self) -> anyhow::Result<()> {
+        debug!("Closing cache database adapter");
+        self.tx
+            .send(DatabaseCommand::close())
+            .map_err(anyhow::Error::new)?;
+
+        if let Some(handle) = self.handle.take() {
+            debug!("Joining `cache` thread");
+            handle.join().map_err(|e| anyhow::anyhow!("{:?}", e))
+        } else {
+            Err(anyhow::anyhow!("Cache database already shutdown"))
+        }
+    }
+
     fn flushdb(&mut self) -> anyhow::Result<()> {
         match redis::cmd(FLUSHDB).query::<()>(&mut self.conn) {
             Ok(_) => Ok(()),
             Err(e) => Err(e.into()),
         }
     }
 
@@ -143,31 +158,31 @@
         }
     }
 
     fn insert(&mut self, key: String, payload: Option<Vec<Vec<u8>>>) -> anyhow::Result<()> {
         let op = DatabaseCommand::new(DatabaseOperation::Insert, key, payload);
         match self.tx.send(op) {
             Ok(_) => Ok(()),
-            Err(e) => anyhow::bail!("{CHANNEL_TX_FAILED}: {e}"),
+            Err(e) => anyhow::bail!("{FAILED_TX_CHANNEL}: {e}"),
         }
     }
 
     fn update(&mut self, key: String, payload: Option<Vec<Vec<u8>>>) -> anyhow::Result<()> {
         let op = DatabaseCommand::new(DatabaseOperation::Update, key, payload);
         match self.tx.send(op) {
             Ok(_) => Ok(()),
-            Err(e) => anyhow::bail!("{CHANNEL_TX_FAILED}: {e}"),
+            Err(e) => anyhow::bail!("{FAILED_TX_CHANNEL}: {e}"),
         }
     }
 
     fn delete(&mut self, key: String, payload: Option<Vec<Vec<u8>>>) -> anyhow::Result<()> {
         let op = DatabaseCommand::new(DatabaseOperation::Delete, key, payload);
         match self.tx.send(op) {
             Ok(_) => Ok(()),
-            Err(e) => anyhow::bail!("{CHANNEL_TX_FAILED}: {e}"),
+            Err(e) => anyhow::bail!("{FAILED_TX_CHANNEL}: {e}"),
         }
     }
 
     fn handle_messages(
         rx: Receiver<DatabaseCommand>,
         trader_key: String,
         config: HashMap<String, serde_json::Value>,
@@ -186,15 +201,22 @@
         loop {
             if last_drain.elapsed() >= buffer_interval && !buffer.is_empty() {
                 drain_buffer(&mut conn, &trader_key, &mut buffer);
                 last_drain = Instant::now();
             } else {
                 // Continue to receive and handle messages until channel is hung up
                 match rx.try_recv() {
-                    Ok(msg) => buffer.push_back(msg),
+                    Ok(msg) => {
+                        if let DatabaseOperation::Close = msg.op_type {
+                            // Close receiver end of the channel
+                            drop(rx);
+                            break;
+                        }
+                        buffer.push_back(msg)
+                    }
                     Err(TryRecvError::Empty) => thread::sleep(recv_interval),
                     Err(TryRecvError::Disconnected) => break, // Channel hung up
                 }
             }
         }
 
         // Drain any remaining messages
@@ -205,77 +227,79 @@
 }
 
 fn drain_buffer(conn: &mut Connection, trader_key: &str, buffer: &mut VecDeque<DatabaseCommand>) {
     let mut pipe = redis::pipe();
     pipe.atomic();
 
     for msg in buffer.drain(..) {
-        let collection = match get_collection_key(&msg.key) {
+        let key = msg.key.expect("Null command `key`");
+        let collection = match get_collection_key(&key) {
             Ok(collection) => collection,
             Err(e) => {
-                eprintln!("{e}");
+                error!("{e}");
                 continue; // Continue to next message
             }
         };
 
-        let key = format!("{trader_key}{DELIMITER}{}", msg.key);
+        let key = format!("{trader_key}{DELIMITER}{}", &key);
 
         match msg.op_type {
             DatabaseOperation::Insert => {
                 if msg.payload.is_none() {
-                    eprintln!("Null `payload` for `insert`");
+                    error!("Null `payload` for `insert`");
                     continue; // Continue to next message
                 };
 
                 let payload = msg
                     .payload
                     .as_ref()
                     .unwrap()
                     .iter()
                     .map(|v| v.as_slice())
                     .collect::<Vec<&[u8]>>();
 
                 if let Err(e) = insert(&mut pipe, collection, &key, payload) {
-                    eprintln!("{e}");
+                    error!("{e}");
                 }
             }
             DatabaseOperation::Update => {
                 if msg.payload.is_none() {
-                    eprintln!("Null `payload` for `update`");
+                    error!("Null `payload` for `update`");
                     continue; // Continue to next message
                 };
 
                 let payload = msg
                     .payload
                     .as_ref()
                     .unwrap()
                     .iter()
                     .map(|v| v.as_slice())
                     .collect::<Vec<&[u8]>>();
 
                 if let Err(e) = update(&mut pipe, collection, &key, payload) {
-                    eprintln!("{e}");
+                    error!("{e}");
                 }
             }
             DatabaseOperation::Delete => {
                 // `payload` can be `None` for a delete operation
                 let payload = msg
                     .payload
                     .as_ref()
                     .map(|v| v.iter().map(|v| v.as_slice()).collect::<Vec<&[u8]>>());
 
                 if let Err(e) = delete(&mut pipe, collection, &key, payload) {
-                    eprintln!("{e}");
+                    error!("{e}");
                 }
             }
+            DatabaseOperation::Close => panic!("Close command should not be drained"),
         }
     }
 
     if let Err(e) = pipe.query::<()>(conn) {
-        eprintln!("{e}");
+        error!("{e}");
     }
 }
 
 fn read_index(conn: &mut Connection, key: &str) -> anyhow::Result<Vec<Vec<u8>>> {
     let index_key = get_index_key(key)?;
     match index_key {
         INDEX_ORDER_IDS => read_set(conn, key),
@@ -321,17 +345,15 @@
 
 fn insert(
     pipe: &mut Pipeline,
     collection: &str,
     key: &str,
     value: Vec<&[u8]>,
 ) -> anyhow::Result<()> {
-    if value.is_empty() {
-        anyhow::bail!("Empty `payload` for `insert`")
-    }
+    check_slice_not_empty(value.as_slice(), stringify!(value))?;
 
     match collection {
         INDEX => insert_index(pipe, key, &value),
         GENERAL => {
             insert_string(pipe, key, value[0]);
             Ok(())
         }
@@ -448,17 +470,15 @@
 
 fn update(
     pipe: &mut Pipeline,
     collection: &str,
     key: &str,
     value: Vec<&[u8]>,
 ) -> anyhow::Result<()> {
-    if value.is_empty() {
-        anyhow::bail!("Empty `payload` for `update`")
-    }
+    check_slice_not_empty(value.as_slice(), stringify!(value))?;
 
     match collection {
         ACCOUNTS => {
             update_list(pipe, key, value[0]);
             Ok(())
         }
         ORDERS => {
@@ -545,15 +565,15 @@
 ) -> String {
     let mut key = String::new();
 
     if let Some(json!(true)) = config.get("use_trader_prefix") {
         key.push_str("trader-");
     }
 
-    key.push_str(trader_id.value.as_str());
+    key.push_str(trader_id.as_str());
 
     if let Some(json!(true)) = config.get("use_instance_id") {
         key.push(DELIMITER);
         key.push_str(&format!("{instance_id}"));
     }
 
     key
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/model/Cargo.toml`

 * *Files 4% similar despite different names*

```diff
@@ -9,28 +9,28 @@
 [lib]
 name = "nautilus_model"
 crate-type = ["rlib", "staticlib"]
 
 [dependencies]
 nautilus-core = { path = "../core" }
 anyhow = { workspace = true }
+derive_builder = { workspace = true }
 indexmap = { workspace = true }
 once_cell = { workspace = true }
 pyo3 = { workspace = true, optional = true }
 rstest = { workspace = true, optional = true }
 rust_decimal = { workspace = true }
 rust_decimal_macros = { workspace = true }
 serde = { workspace = true }
 serde_json = { workspace = true }
 strum = { workspace = true }
 thiserror = { workspace = true }
 thousands = { workspace = true }
 ustr = { workspace = true }
 chrono = { workspace = true }
-derive_builder = "0.20.0"
 evalexpr = "11.3.0"
 tabled = "0.15.0"
 
 [dev-dependencies]
 criterion = { workspace = true }
 float-cmp = { workspace = true }
 iai = { workspace = true }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/build.rs` & `nautilus_trader-1.191.0/nautilus_core/model/build.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/cbindgen.toml` & `nautilus_trader-1.191.0/nautilus_core/model/cbindgen.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/cbindgen_cython.toml` & `nautilus_trader-1.191.0/nautilus_core/model/cbindgen_cython.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/currencies.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/currencies.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/data/bar.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/data/bar.rs`

 * *Files 8% similar despite different names*

```diff
@@ -17,17 +17,15 @@
     collections::HashMap,
     fmt::{Debug, Display, Formatter},
     hash::Hash,
     str::FromStr,
 };
 
 use indexmap::IndexMap;
-use nautilus_core::{serialization::Serializable, time::UnixNanos};
-#[cfg(feature = "python")]
-use pyo3::{PyAny, PyResult};
+use nautilus_core::{nanos::UnixNanos, serialization::Serializable};
 use serde::{Deserialize, Deserializer, Serialize, Serializer};
 
 use crate::{
     enums::{AggregationSource, BarAggregation, PriceType},
     identifiers::instrument_id::InstrumentId,
     types::{price::Price, quantity::Quantity},
 };
@@ -219,15 +217,15 @@
     pub low: Price,
     /// The bars close price.
     pub close: Price,
     /// The bars volume.
     pub volume: Quantity,
     /// The UNIX timestamp (nanoseconds) when the data event occurred.
     pub ts_event: UnixNanos,
-    /// The UNIX timestamp (nanoseconds) when the data object was initialized.
+    /// The UNIX timestamp (nanoseconds) when the struct was initialized.
     pub ts_init: UnixNanos,
 }
 
 impl Bar {
     #[must_use]
     #[allow(clippy::too_many_arguments)]
     pub fn new(
@@ -277,55 +275,14 @@
         metadata.insert("low".to_string(), "Int64".to_string());
         metadata.insert("close".to_string(), "Int64".to_string());
         metadata.insert("volume".to_string(), "UInt64".to_string());
         metadata.insert("ts_event".to_string(), "UInt64".to_string());
         metadata.insert("ts_init".to_string(), "UInt64".to_string());
         metadata
     }
-
-    /// Create a new [`Bar`] extracted from the given [`PyAny`].
-    #[cfg(feature = "python")]
-    pub fn from_pyobject(obj: &PyAny) -> PyResult<Self> {
-        use nautilus_core::python::to_pyvalue_err;
-
-        let bar_type_obj: &PyAny = obj.getattr("bar_type")?.extract()?;
-        let bar_type_str = bar_type_obj.call_method0("__str__")?.extract()?;
-        let bar_type = BarType::from_str(bar_type_str)
-            .map_err(to_pyvalue_err)
-            .unwrap();
-
-        let open_py: &PyAny = obj.getattr("open")?;
-        let price_prec: u8 = open_py.getattr("precision")?.extract()?;
-        let open_raw: i64 = open_py.getattr("raw")?.extract()?;
-        let open = Price::from_raw(open_raw, price_prec).map_err(to_pyvalue_err)?;
-
-        let high_py: &PyAny = obj.getattr("high")?;
-        let high_raw: i64 = high_py.getattr("raw")?.extract()?;
-        let high = Price::from_raw(high_raw, price_prec).map_err(to_pyvalue_err)?;
-
-        let low_py: &PyAny = obj.getattr("low")?;
-        let low_raw: i64 = low_py.getattr("raw")?.extract()?;
-        let low = Price::from_raw(low_raw, price_prec).map_err(to_pyvalue_err)?;
-
-        let close_py: &PyAny = obj.getattr("close")?;
-        let close_raw: i64 = close_py.getattr("raw")?.extract()?;
-        let close = Price::from_raw(close_raw, price_prec).map_err(to_pyvalue_err)?;
-
-        let volume_py: &PyAny = obj.getattr("volume")?;
-        let volume_raw: u64 = volume_py.getattr("raw")?.extract()?;
-        let volume_prec: u8 = volume_py.getattr("precision")?.extract()?;
-        let volume = Quantity::from_raw(volume_raw, volume_prec).map_err(to_pyvalue_err)?;
-
-        let ts_event: UnixNanos = obj.getattr("ts_event")?.extract()?;
-        let ts_init: UnixNanos = obj.getattr("ts_init")?.extract()?;
-
-        Ok(Self::new(
-            bar_type, open, high, low, close, volume, ts_event, ts_init,
-        ))
-    }
 }
 
 impl Serializable for Bar {}
 
 impl Display for Bar {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(
@@ -337,14 +294,15 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Stubs
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(feature = "stubs")]
 pub mod stubs {
+    use nautilus_core::nanos::UnixNanos;
     use rstest::fixture;
 
     use crate::{
         data::bar::{Bar, BarSpecification, BarType},
         enums::{AggregationSource, BarAggregation, PriceType},
         identifiers::{instrument_id::InstrumentId, symbol::Symbol, venue::Venue},
         types::{price::Price, quantity::Quantity},
@@ -369,16 +327,16 @@
         Bar {
             bar_type,
             open: Price::from("1.00001"),
             high: Price::from("1.00004"),
             low: Price::from("1.00002"),
             close: Price::from("1.00003"),
             volume: Quantity::from("100000"),
-            ts_event: 0,
-            ts_init: 1,
+            ts_event: UnixNanos::from(0),
+            ts_init: UnixNanos::from(1),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
@@ -580,27 +538,27 @@
         let bar1 = Bar {
             bar_type,
             open: Price::from("1.00001"),
             high: Price::from("1.00004"),
             low: Price::from("1.00002"),
             close: Price::from("1.00003"),
             volume: Quantity::from("100000"),
-            ts_event: 0,
-            ts_init: 0,
+            ts_event: UnixNanos::from(0),
+            ts_init: UnixNanos::from(0),
         };
 
         let bar2 = Bar {
             bar_type,
             open: Price::from("1.00000"),
             high: Price::from("1.00004"),
             low: Price::from("1.00002"),
             close: Price::from("1.00003"),
             volume: Quantity::from("100000"),
-            ts_event: 0,
-            ts_init: 0,
+            ts_event: UnixNanos::from(0),
+            ts_init: UnixNanos::from(0),
         };
         assert_eq!(bar1, bar1);
         assert_ne!(bar1, bar2);
     }
 
     #[rstest]
     fn test_json_serialization(stub_bar: Bar) {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/data/delta.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/data/delta.rs`

 * *Files 12% similar despite different names*

```diff
@@ -16,19 +16,22 @@
 use std::{
     collections::HashMap,
     fmt::{Display, Formatter},
     hash::Hash,
 };
 
 use indexmap::IndexMap;
-use nautilus_core::{serialization::Serializable, time::UnixNanos};
+use nautilus_core::{nanos::UnixNanos, serialization::Serializable};
 use serde::{Deserialize, Serialize};
 
 use super::order::{BookOrder, NULL_ORDER};
-use crate::{enums::BookAction, identifiers::instrument_id::InstrumentId};
+use crate::{
+    enums::{BookAction, RecordFlag},
+    identifiers::instrument_id::InstrumentId,
+};
 
 /// Represents a single change/delta in an order book.
 #[repr(C)]
 #[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
 #[serde(tag = "type")]
 #[cfg_attr(
     feature = "python",
@@ -38,21 +41,21 @@
 pub struct OrderBookDelta {
     /// The instrument ID for the book.
     pub instrument_id: InstrumentId,
     /// The order book delta action.
     pub action: BookAction,
     /// The order to apply.
     pub order: BookOrder,
-    /// A combination of packet end with matching engine status.
+    /// The record flags bit field, indicating packet end and data information.
     pub flags: u8,
     /// The message sequence number assigned at the venue.
     pub sequence: u64,
-    /// The UNIX timestamp (nanoseconds) when the data event occurred.
+    /// The UNIX timestamp (nanoseconds) when the book event occurred.
     pub ts_event: UnixNanos,
-    /// The UNIX timestamp (nanoseconds) when the data object was initialized.
+    /// The UNIX timestamp (nanoseconds) when the struct was initialized.
     pub ts_init: UnixNanos,
 }
 
 impl OrderBookDelta {
     #[allow(clippy::too_many_arguments)]
     #[must_use]
     pub fn new(
@@ -82,15 +85,15 @@
         ts_event: UnixNanos,
         ts_init: UnixNanos,
     ) -> Self {
         Self {
             instrument_id,
             action: BookAction::Clear,
             order: NULL_ORDER,
-            flags: 32, // TODO: Flags constants
+            flags: RecordFlag::F_SNAPSHOT as u8,
             sequence,
             ts_event,
             ts_init,
         }
     }
 
     /// Returns the metadata for the type, for use with serialization formats.
@@ -172,16 +175,16 @@
         let order = BookOrder::new(side, price, size, order_id);
         OrderBookDelta::new(
             instrument_id,
             action,
             order,
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
@@ -214,16 +217,16 @@
 
         let delta = OrderBookDelta::new(
             instrument_id,
             action,
             order,
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         );
 
         assert_eq!(delta.instrument_id, instrument_id);
         assert_eq!(delta.action, action);
         assert_eq!(delta.order.price, price);
         assert_eq!(delta.order.size, size);
         assert_eq!(delta.order.side, side);
@@ -237,15 +240,15 @@
     #[rstest]
     fn test_clear() {
         let instrument_id = InstrumentId::from("AAPL.XNAS");
         let sequence = 1;
         let ts_event = 2;
         let ts_init = 3;
 
-        let delta = OrderBookDelta::clear(instrument_id, sequence, ts_event, ts_init);
+        let delta = OrderBookDelta::clear(instrument_id, sequence, ts_event.into(), ts_init.into());
 
         assert_eq!(delta.instrument_id, instrument_id);
         assert_eq!(delta.action, BookAction::Clear);
         assert!(delta.order.price.is_zero());
         assert!(delta.order.size.is_zero());
         assert_eq!(delta.order.side, OrderSide::NoOrderSide);
         assert_eq!(delta.order.order_id, 0);
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/data/deltas.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/data/deltas.rs`

 * *Files 10% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 
 use std::{
     fmt::{Display, Formatter},
     hash::{Hash, Hasher},
     ops::{Deref, DerefMut},
 };
 
-use nautilus_core::time::UnixNanos;
+use nautilus_core::nanos::UnixNanos;
 
 use super::delta::OrderBookDelta;
 use crate::identifiers::instrument_id::InstrumentId;
 
 /// Represents a grouped batch of `OrderBookDelta` updates for an `OrderBook`.
 ///
 /// This type cannot be `repr(C)` due to the `deltas` vec.
@@ -33,21 +33,21 @@
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
 pub struct OrderBookDeltas {
     /// The instrument ID for the book.
     pub instrument_id: InstrumentId,
     /// The order book deltas.
     pub deltas: Vec<OrderBookDelta>,
-    /// A combination of packet end with matching engine status.
+    /// The record flags bit field, indicating packet end and data information.
     pub flags: u8,
     /// The message sequence number assigned at the venue.
     pub sequence: u64,
-    /// The UNIX timestamp (nanoseconds) when the data event occurred.
+    /// The UNIX timestamp (nanoseconds) when the book event occurred.
     pub ts_event: UnixNanos,
-    /// The UNIX timestamp (nanoseconds) when the data object was initialized.
+    /// The UNIX timestamp (nanoseconds) when the struct was initialized.
     pub ts_init: UnixNanos,
 }
 
 impl OrderBookDeltas {
     #[allow(clippy::too_many_arguments)]
     #[must_use]
     pub fn new(instrument_id: InstrumentId, deltas: Vec<OrderBookDelta>) -> Self {
@@ -156,98 +156,99 @@
     pub fn stub_deltas() -> OrderBookDeltas {
         let instrument_id = InstrumentId::from("AAPL.XNAS");
         let flags = 32; // Snapshot flag
         let sequence = 0;
         let ts_event = 1;
         let ts_init = 2;
 
-        let delta0 = OrderBookDelta::clear(instrument_id, sequence, ts_event, ts_init);
+        let delta0 =
+            OrderBookDelta::clear(instrument_id, sequence, ts_event.into(), ts_init.into());
         let delta1 = OrderBookDelta::new(
             instrument_id,
             BookAction::Add,
             BookOrder::new(
                 OrderSide::Sell,
                 Price::from("102.00"),
                 Quantity::from("300"),
                 1,
             ),
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         );
         let delta2 = OrderBookDelta::new(
             instrument_id,
             BookAction::Add,
             BookOrder::new(
                 OrderSide::Sell,
                 Price::from("101.00"),
                 Quantity::from("200"),
                 2,
             ),
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         );
         let delta3 = OrderBookDelta::new(
             instrument_id,
             BookAction::Add,
             BookOrder::new(
                 OrderSide::Sell,
                 Price::from("100.00"),
                 Quantity::from("100"),
                 3,
             ),
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         );
         let delta4 = OrderBookDelta::new(
             instrument_id,
             BookAction::Add,
             BookOrder::new(
                 OrderSide::Buy,
                 Price::from("99.00"),
                 Quantity::from("100"),
                 4,
             ),
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         );
         let delta5 = OrderBookDelta::new(
             instrument_id,
             BookAction::Add,
             BookOrder::new(
                 OrderSide::Buy,
                 Price::from("98.00"),
                 Quantity::from("200"),
                 5,
             ),
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         );
         let delta6 = OrderBookDelta::new(
             instrument_id,
             BookAction::Add,
             BookOrder::new(
                 OrderSide::Buy,
                 Price::from("97.00"),
                 Quantity::from("300"),
                 6,
             ),
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         );
 
         let deltas = vec![delta0, delta1, delta2, delta3, delta4, delta5, delta6];
 
         OrderBookDeltas::new(instrument_id, deltas)
     }
 }
@@ -270,98 +271,99 @@
     fn test_new() {
         let instrument_id = InstrumentId::from("AAPL.XNAS");
         let flags = 32; // Snapshot flag
         let sequence = 0;
         let ts_event = 1;
         let ts_init = 2;
 
-        let delta0 = OrderBookDelta::clear(instrument_id, sequence, ts_event, ts_init);
+        let delta0 =
+            OrderBookDelta::clear(instrument_id, sequence, ts_event.into(), ts_init.into());
         let delta1 = OrderBookDelta::new(
             instrument_id,
             BookAction::Add,
             BookOrder::new(
                 OrderSide::Sell,
                 Price::from("102.00"),
                 Quantity::from("300"),
                 1,
             ),
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         );
         let delta2 = OrderBookDelta::new(
             instrument_id,
             BookAction::Add,
             BookOrder::new(
                 OrderSide::Sell,
                 Price::from("101.00"),
                 Quantity::from("200"),
                 2,
             ),
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         );
         let delta3 = OrderBookDelta::new(
             instrument_id,
             BookAction::Add,
             BookOrder::new(
                 OrderSide::Sell,
                 Price::from("100.00"),
                 Quantity::from("100"),
                 3,
             ),
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         );
         let delta4 = OrderBookDelta::new(
             instrument_id,
             BookAction::Add,
             BookOrder::new(
                 OrderSide::Buy,
                 Price::from("99.00"),
                 Quantity::from("100"),
                 4,
             ),
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         );
         let delta5 = OrderBookDelta::new(
             instrument_id,
             BookAction::Add,
             BookOrder::new(
                 OrderSide::Buy,
                 Price::from("98.00"),
                 Quantity::from("200"),
                 5,
             ),
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         );
         let delta6 = OrderBookDelta::new(
             instrument_id,
             BookAction::Add,
             BookOrder::new(
                 OrderSide::Buy,
                 Price::from("97.00"),
                 Quantity::from("300"),
                 6,
             ),
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         );
 
         let deltas = OrderBookDeltas::new(
             instrument_id,
             vec![delta0, delta1, delta2, delta3, delta4, delta5, delta6],
         );
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/data/depth.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/data/depth.rs`

 * *Files 2% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 
 use std::{
     collections::HashMap,
     fmt::{Display, Formatter},
 };
 
 use indexmap::IndexMap;
-use nautilus_core::{serialization::Serializable, time::UnixNanos};
+use nautilus_core::{nanos::UnixNanos, serialization::Serializable};
 use serde::{Deserialize, Serialize};
 
 use super::order::BookOrder;
 use crate::identifiers::instrument_id::InstrumentId;
 
 pub const DEPTH10_LEN: usize = 10;
 
@@ -50,21 +50,21 @@
     pub bids: [BookOrder; DEPTH10_LEN],
     /// The ask orders for the depth update.
     pub asks: [BookOrder; DEPTH10_LEN],
     /// The count of bid orders per level for the depth update.
     pub bid_counts: [u32; DEPTH10_LEN],
     /// The count of ask orders per level for the depth update.
     pub ask_counts: [u32; DEPTH10_LEN],
-    /// A combination of packet end with matching engine status.
+    /// The record flags bit field, indicating packet end and data information.
     pub flags: u8,
     /// The message sequence number assigned at the venue.
     pub sequence: u64,
-    /// The UNIX timestamp (nanoseconds) when the data event occurred.
+    /// The UNIX timestamp (nanoseconds) when the book event occurred.
     pub ts_event: UnixNanos,
-    /// The UNIX timestamp (nanoseconds) when the data object was initialized.
+    /// The UNIX timestamp (nanoseconds) when the struct was initialized.
     pub ts_init: UnixNanos,
 }
 
 impl OrderBookDepth10 {
     #[allow(clippy::too_many_arguments)]
     #[must_use]
     pub fn new(
@@ -264,16 +264,16 @@
             instrument_id,
             bids,
             asks,
             bid_counts,
             ask_counts,
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/data/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/data/mod.rs`

 * *Files 10% similar despite different names*

```diff
@@ -19,93 +19,90 @@
 pub mod depth;
 pub mod order;
 pub mod quote;
 #[cfg(feature = "stubs")]
 pub mod stubs;
 pub mod trade;
 
-use nautilus_core::time::UnixNanos;
+use nautilus_core::nanos::UnixNanos;
 
 use self::{
     bar::Bar,
     delta::OrderBookDelta,
     deltas::{OrderBookDeltas, OrderBookDeltas_API},
     depth::OrderBookDepth10,
     quote::QuoteTick,
     trade::TradeTick,
 };
+use crate::polymorphism::GetTsInit;
 
 #[repr(C)]
 #[derive(Clone, Debug)]
 #[allow(clippy::large_enum_variant)] // TODO: Optimize this (largest variant 1008 vs 136 bytes)
 pub enum Data {
     Delta(OrderBookDelta),
     Deltas(OrderBookDeltas_API),
     Depth10(OrderBookDepth10),
     Quote(QuoteTick),
     Trade(TradeTick),
     Bar(Bar),
 }
 
-pub trait HasTsInit {
-    fn get_ts_init(&self) -> UnixNanos;
-}
-
-impl HasTsInit for Data {
-    fn get_ts_init(&self) -> UnixNanos {
+impl GetTsInit for Data {
+    fn ts_init(&self) -> UnixNanos {
         match self {
             Self::Delta(d) => d.ts_init,
             Self::Deltas(d) => d.ts_init,
             Self::Depth10(d) => d.ts_init,
             Self::Quote(q) => q.ts_init,
             Self::Trade(t) => t.ts_init,
             Self::Bar(b) => b.ts_init,
         }
     }
 }
 
-impl HasTsInit for OrderBookDelta {
-    fn get_ts_init(&self) -> UnixNanos {
+impl GetTsInit for OrderBookDelta {
+    fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
 }
 
-impl HasTsInit for OrderBookDeltas {
-    fn get_ts_init(&self) -> UnixNanos {
+impl GetTsInit for OrderBookDeltas {
+    fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
 }
 
-impl HasTsInit for OrderBookDepth10 {
-    fn get_ts_init(&self) -> UnixNanos {
+impl GetTsInit for OrderBookDepth10 {
+    fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
 }
 
-impl HasTsInit for QuoteTick {
-    fn get_ts_init(&self) -> UnixNanos {
+impl GetTsInit for QuoteTick {
+    fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
 }
 
-impl HasTsInit for TradeTick {
-    fn get_ts_init(&self) -> UnixNanos {
+impl GetTsInit for TradeTick {
+    fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
 }
 
-impl HasTsInit for Bar {
-    fn get_ts_init(&self) -> UnixNanos {
+impl GetTsInit for Bar {
+    fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
 }
 
-pub fn is_monotonically_increasing_by_init<T: HasTsInit>(data: &[T]) -> bool {
+pub fn is_monotonically_increasing_by_init<T: GetTsInit>(data: &[T]) -> bool {
     data.windows(2)
-        .all(|window| window[0].get_ts_init() <= window[1].get_ts_init())
+        .all(|window| window[0].ts_init() <= window[1].ts_init())
 }
 
 impl From<OrderBookDelta> for Data {
     fn from(value: OrderBookDelta) -> Self {
         Self::Delta(value)
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/data/order.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orders/limit_if_touched.rs`

 * *Files 24% similar despite different names*

```diff
@@ -10,338 +10,409 @@
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::{
-    fmt::{Display, Formatter},
-    hash::{Hash, Hasher},
+    collections::HashMap,
+    ops::{Deref, DerefMut},
 };
 
-use nautilus_core::serialization::Serializable;
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
+use ustr::Ustr;
 
-use super::{quote::QuoteTick, trade::TradeTick};
+use super::base::{Order, OrderAny, OrderCore, OrderError};
 use crate::{
-    enums::OrderSide,
-    orderbook::{book::BookIntegrityError, ladder::BookPrice},
-    types::{price::Price, quantity::Quantity},
-};
-
-pub type OrderId = u64;
-
-pub const NULL_ORDER: BookOrder = BookOrder {
-    side: OrderSide::NoOrderSide,
-    price: Price {
-        raw: 0,
-        precision: 0,
+    enums::{
+        ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, TimeInForce,
+        TrailingOffsetType, TriggerType,
     },
-    size: Quantity {
-        raw: 0,
-        precision: 0,
+    events::order::{event::OrderEvent, initialized::OrderInitialized, updated::OrderUpdated},
+    identifiers::{
+        account_id::AccountId, client_order_id::ClientOrderId, exec_algorithm_id::ExecAlgorithmId,
+        instrument_id::InstrumentId, order_list_id::OrderListId, position_id::PositionId,
+        strategy_id::StrategyId, symbol::Symbol, trade_id::TradeId, trader_id::TraderId,
+        venue::Venue, venue_order_id::VenueOrderId,
     },
-    order_id: 0,
+    types::{price::Price, quantity::Quantity},
 };
 
-/// Represents an order in a book.
-#[repr(C)]
-#[derive(Clone, Eq, Debug, Serialize, Deserialize)]
+#[derive(Clone, Debug, Serialize, Deserialize)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-#[cfg_attr(feature = "trivial_copy", derive(Copy))]
-pub struct BookOrder {
-    /// The order side.
-    pub side: OrderSide,
-    /// The order price.
+pub struct LimitIfTouchedOrder {
     pub price: Price,
-    /// The order size.
-    pub size: Quantity,
-    /// The order ID.
-    pub order_id: OrderId,
+    pub trigger_price: Price,
+    pub trigger_type: TriggerType,
+    pub expire_time: Option<UnixNanos>,
+    pub is_post_only: bool,
+    pub display_qty: Option<Quantity>,
+    pub trigger_instrument_id: Option<InstrumentId>,
+    pub is_triggered: bool,
+    pub ts_triggered: Option<UnixNanos>,
+    core: OrderCore,
 }
 
-impl BookOrder {
-    #[must_use]
-    pub fn new(side: OrderSide, price: Price, size: Quantity, order_id: u64) -> Self {
-        Self {
-            side,
+impl LimitIfTouchedOrder {
+    #[allow(clippy::too_many_arguments)]
+    pub fn new(
+        trader_id: TraderId,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        order_side: OrderSide,
+        quantity: Quantity,
+        price: Price,
+        trigger_price: Price,
+        trigger_type: TriggerType,
+        time_in_force: TimeInForce,
+        expire_time: Option<UnixNanos>,
+        post_only: bool,
+        reduce_only: bool,
+        quote_quantity: bool,
+        display_qty: Option<Quantity>,
+        emulation_trigger: Option<TriggerType>,
+        trigger_instrument_id: Option<InstrumentId>,
+        contingency_type: Option<ContingencyType>,
+        order_list_id: Option<OrderListId>,
+        linked_order_ids: Option<Vec<ClientOrderId>>,
+        parent_order_id: Option<ClientOrderId>,
+        exec_algorithm_id: Option<ExecAlgorithmId>,
+        exec_algorithm_params: Option<HashMap<Ustr, Ustr>>,
+        exec_spawn_id: Option<ClientOrderId>,
+        tags: Option<Ustr>,
+        init_id: UUID4,
+        ts_init: UnixNanos,
+    ) -> anyhow::Result<Self> {
+        let init_order = OrderInitialized::new(
+            trader_id,
+            strategy_id,
+            instrument_id,
+            client_order_id,
+            order_side,
+            OrderType::LimitIfTouched,
+            quantity,
+            time_in_force,
+            post_only,
+            reduce_only,
+            quote_quantity,
+            false,
+            init_id,
+            ts_init,
+            ts_init,
+            Some(price),
+            Some(trigger_price),
+            Some(trigger_type),
+            None,
+            None,
+            None,
+            expire_time,
+            display_qty,
+            emulation_trigger,
+            trigger_instrument_id,
+            contingency_type,
+            order_list_id,
+            linked_order_ids,
+            parent_order_id,
+            exec_algorithm_id,
+            exec_algorithm_params,
+            exec_spawn_id,
+            tags,
+        )
+        .unwrap();
+        Ok(Self {
+            core: OrderCore::new(init_order).unwrap(),
             price,
-            size,
-            order_id,
-        }
+            trigger_price,
+            trigger_type,
+            expire_time,
+            is_post_only: post_only,
+            display_qty,
+            trigger_instrument_id,
+            is_triggered: false,
+            ts_triggered: None,
+        })
     }
+}
 
-    #[must_use]
-    pub fn to_book_price(&self) -> BookPrice {
-        BookPrice::new(self.price, self.side)
-    }
-
-    #[must_use]
-    pub fn exposure(&self) -> f64 {
-        self.price.as_f64() * self.size.as_f64()
-    }
-
-    #[must_use]
-    pub fn signed_size(&self) -> f64 {
-        match self.side {
-            OrderSide::Buy => self.size.as_f64(),
-            OrderSide::Sell => -(self.size.as_f64()),
-            _ => panic!("{}", BookIntegrityError::NoOrderSide),
-        }
-    }
+impl Deref for LimitIfTouchedOrder {
+    type Target = OrderCore;
 
-    #[must_use]
-    pub fn from_quote_tick(tick: &QuoteTick, side: OrderSide) -> Self {
-        match side {
-            OrderSide::Buy => Self::new(
-                OrderSide::Buy,
-                tick.bid_price,
-                tick.bid_size,
-                tick.bid_price.raw as u64,
-            ),
-            OrderSide::Sell => Self::new(
-                OrderSide::Sell,
-                tick.ask_price,
-                tick.ask_size,
-                tick.ask_price.raw as u64,
-            ),
-            _ => panic!("{}", BookIntegrityError::NoOrderSide),
-        }
+    fn deref(&self) -> &Self::Target {
+        &self.core
     }
+}
 
-    #[must_use]
-    pub fn from_trade_tick(tick: &TradeTick, side: OrderSide) -> Self {
-        match side {
-            OrderSide::Buy => {
-                Self::new(OrderSide::Buy, tick.price, tick.size, tick.price.raw as u64)
-            }
-            OrderSide::Sell => Self::new(
-                OrderSide::Sell,
-                tick.price,
-                tick.size,
-                tick.price.raw as u64,
-            ),
-            _ => panic!("{}", BookIntegrityError::NoOrderSide),
-        }
+impl DerefMut for LimitIfTouchedOrder {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.core
     }
 }
 
-impl Default for BookOrder {
-    fn default() -> Self {
-        NULL_ORDER
+impl Order for LimitIfTouchedOrder {
+    fn into_any(self) -> OrderAny {
+        OrderAny::LimitIfTouched(self)
     }
-}
 
-impl PartialEq for BookOrder {
-    fn eq(&self, other: &Self) -> bool {
-        self.order_id == other.order_id
+    fn status(&self) -> OrderStatus {
+        self.status
     }
-}
 
-impl Hash for BookOrder {
-    fn hash<H: Hasher>(&self, state: &mut H) {
-        self.order_id.hash(state);
+    fn trader_id(&self) -> TraderId {
+        self.trader_id
     }
-}
 
-impl Display for BookOrder {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(
-            f,
-            "{},{},{},{}",
-            self.price, self.size, self.side, self.order_id,
-        )
+    fn strategy_id(&self) -> StrategyId {
+        self.strategy_id
     }
-}
 
-impl Serializable for BookOrder {}
+    fn instrument_id(&self) -> InstrumentId {
+        self.instrument_id
+    }
 
-////////////////////////////////////////////////////////////////////////////////
-// Stubs
-////////////////////////////////////////////////////////////////////////////////
-#[cfg(feature = "stubs")]
-pub mod stubs {
-    use rstest::fixture;
-
-    use super::{BookOrder, OrderSide};
-    use crate::types::{price::Price, quantity::Quantity};
-
-    #[fixture]
-    pub fn stub_book_order() -> BookOrder {
-        let price = Price::from("100.00");
-        let size = Quantity::from("10");
-        let side = OrderSide::Buy;
-        let order_id = 123_456;
+    fn symbol(&self) -> Symbol {
+        self.instrument_id.symbol
+    }
 
-        BookOrder::new(side, price, size, order_id)
+    fn venue(&self) -> Venue {
+        self.instrument_id.venue
     }
-}
 
-////////////////////////////////////////////////////////////////////////////////
-// Tests
-////////////////////////////////////////////////////////////////////////////////
-#[cfg(test)]
-mod tests {
-    use rstest::rstest;
-
-    use super::{stubs::*, *};
-    use crate::{
-        enums::AggressorSide,
-        identifiers::{instrument_id::InstrumentId, trade_id::TradeId},
-    };
-
-    #[rstest]
-    fn test_new() {
-        let price = Price::from("100.00");
-        let size = Quantity::from("10");
-        let side = OrderSide::Buy;
-        let order_id = 123_456;
-
-        let order = BookOrder::new(side, price, size, order_id);
-
-        assert_eq!(order.price, price);
-        assert_eq!(order.size, size);
-        assert_eq!(order.side, side);
-        assert_eq!(order.order_id, order_id);
-    }
-
-    #[rstest]
-    fn test_to_book_price() {
-        let price = Price::from("100.00");
-        let size = Quantity::from("10");
-        let side = OrderSide::Buy;
-        let order_id = 123_456;
-
-        let order = BookOrder::new(side, price, size, order_id);
-        let book_price = order.to_book_price();
-
-        assert_eq!(book_price.value, price);
-        assert_eq!(book_price.side, side);
-    }
-
-    #[rstest]
-    fn test_exposure() {
-        let price = Price::from("100.00");
-        let size = Quantity::from("10");
-        let side = OrderSide::Buy;
-        let order_id = 123_456;
-
-        let order = BookOrder::new(side, price, size, order_id);
-        let exposure = order.exposure();
-
-        assert_eq!(exposure, price.as_f64() * size.as_f64());
-    }
-
-    #[rstest]
-    fn test_signed_size() {
-        let price = Price::from("100.00");
-        let size = Quantity::from("10");
-        let order_id = 123_456;
-
-        let order_buy = BookOrder::new(OrderSide::Buy, price, size, order_id);
-        let signed_size_buy = order_buy.signed_size();
-        assert_eq!(signed_size_buy, size.as_f64());
-
-        let order_sell = BookOrder::new(OrderSide::Sell, price, size, order_id);
-        let signed_size_sell = order_sell.signed_size();
-        assert_eq!(signed_size_sell, -(size.as_f64()));
-    }
-
-    #[rstest]
-    fn test_display() {
-        let price = Price::from("100.00");
-        let size = Quantity::from(10);
-        let side = OrderSide::Buy;
-        let order_id = 123_456;
-
-        let order = BookOrder::new(side, price, size, order_id);
-        let display = format!("{order}");
-
-        let expected = format!("{price},{size},{side},{order_id}");
-        assert_eq!(display, expected);
-    }
-
-    #[rstest]
-    #[case(OrderSide::Buy)]
-    #[case(OrderSide::Sell)]
-    fn test_from_quote_tick(#[case] side: OrderSide) {
-        let tick = QuoteTick::new(
-            InstrumentId::from("ETHUSDT-PERP.BINANCE"),
-            Price::from("5000.00"),
-            Price::from("5001.00"),
-            Quantity::from("100.000"),
-            Quantity::from("99.000"),
-            0,
-            0,
-        )
-        .unwrap();
+    fn client_order_id(&self) -> ClientOrderId {
+        self.client_order_id
+    }
+
+    fn venue_order_id(&self) -> Option<VenueOrderId> {
+        self.venue_order_id
+    }
 
-        let book_order = BookOrder::from_quote_tick(&tick, side);
+    fn position_id(&self) -> Option<PositionId> {
+        self.position_id
+    }
+
+    fn account_id(&self) -> Option<AccountId> {
+        self.account_id
+    }
 
-        assert_eq!(book_order.side, side);
-        assert_eq!(
-            book_order.price,
-            match side {
-                OrderSide::Buy => tick.bid_price,
-                OrderSide::Sell => tick.ask_price,
-                _ => panic!("Invalid test"),
-            }
-        );
-        assert_eq!(
-            book_order.size,
-            match side {
-                OrderSide::Buy => tick.bid_size,
-                OrderSide::Sell => tick.ask_size,
-                _ => panic!("Invalid test"),
-            }
-        );
-        assert_eq!(
-            book_order.order_id,
-            match side {
-                OrderSide::Buy => tick.bid_price.raw as u64,
-                OrderSide::Sell => tick.ask_price.raw as u64,
-                _ => panic!("Invalid test"),
-            }
-        );
-    }
-
-    #[rstest]
-    #[case(OrderSide::Buy)]
-    #[case(OrderSide::Sell)]
-    fn test_from_trade_tick(#[case] side: OrderSide) {
-        let tick = TradeTick::new(
-            InstrumentId::from("ETHUSDT-PERP.BINANCE"),
-            Price::from("5000.00"),
-            Quantity::from("100.00"),
-            AggressorSide::Buyer,
-            TradeId::new("1").unwrap(),
-            0,
-            0,
-        );
-
-        let book_order = BookOrder::from_trade_tick(&tick, side);
-
-        assert_eq!(book_order.side, side);
-        assert_eq!(book_order.price, tick.price);
-        assert_eq!(book_order.size, tick.size);
-        assert_eq!(book_order.order_id, tick.price.raw as u64);
-    }
-
-    #[rstest]
-    fn test_json_serialization(stub_book_order: BookOrder) {
-        let order = stub_book_order;
-        let serialized = order.as_json_bytes().unwrap();
-        let deserialized = BookOrder::from_json_bytes(serialized).unwrap();
-        assert_eq!(deserialized, order);
-    }
-
-    #[rstest]
-    fn test_msgpack_serialization(stub_book_order: BookOrder) {
-        let order = stub_book_order;
-        let serialized = order.as_msgpack_bytes().unwrap();
-        let deserialized = BookOrder::from_msgpack_bytes(serialized).unwrap();
-        assert_eq!(deserialized, order);
+    fn last_trade_id(&self) -> Option<TradeId> {
+        self.last_trade_id
+    }
+
+    fn side(&self) -> OrderSide {
+        self.side
+    }
+
+    fn order_type(&self) -> OrderType {
+        self.order_type
+    }
+
+    fn quantity(&self) -> Quantity {
+        self.quantity
+    }
+
+    fn time_in_force(&self) -> TimeInForce {
+        self.time_in_force
+    }
+
+    fn expire_time(&self) -> Option<UnixNanos> {
+        self.expire_time
+    }
+
+    fn price(&self) -> Option<Price> {
+        Some(self.price)
+    }
+
+    fn trigger_price(&self) -> Option<Price> {
+        Some(self.trigger_price)
+    }
+
+    fn trigger_type(&self) -> Option<TriggerType> {
+        Some(self.trigger_type)
+    }
+
+    fn liquidity_side(&self) -> Option<LiquiditySide> {
+        self.liquidity_side
+    }
+
+    fn is_post_only(&self) -> bool {
+        self.is_post_only
+    }
+
+    fn is_reduce_only(&self) -> bool {
+        self.is_reduce_only
+    }
+
+    fn is_quote_quantity(&self) -> bool {
+        self.is_quote_quantity
+    }
+
+    fn display_qty(&self) -> Option<Quantity> {
+        self.display_qty
+    }
+
+    fn limit_offset(&self) -> Option<Price> {
+        None
+    }
+
+    fn trailing_offset(&self) -> Option<Price> {
+        None
+    }
+
+    fn trailing_offset_type(&self) -> Option<TrailingOffsetType> {
+        None
+    }
+
+    fn emulation_trigger(&self) -> Option<TriggerType> {
+        self.emulation_trigger
+    }
+
+    fn trigger_instrument_id(&self) -> Option<InstrumentId> {
+        self.trigger_instrument_id
+    }
+
+    fn contingency_type(&self) -> Option<ContingencyType> {
+        self.contingency_type
+    }
+
+    fn order_list_id(&self) -> Option<OrderListId> {
+        self.order_list_id
+    }
+
+    fn linked_order_ids(&self) -> Option<Vec<ClientOrderId>> {
+        self.linked_order_ids.clone()
+    }
+
+    fn parent_order_id(&self) -> Option<ClientOrderId> {
+        self.parent_order_id
+    }
+
+    fn exec_algorithm_id(&self) -> Option<ExecAlgorithmId> {
+        self.exec_algorithm_id
+    }
+
+    fn exec_algorithm_params(&self) -> Option<HashMap<Ustr, Ustr>> {
+        self.exec_algorithm_params.clone()
+    }
+
+    fn exec_spawn_id(&self) -> Option<ClientOrderId> {
+        self.exec_spawn_id
+    }
+
+    fn tags(&self) -> Option<Ustr> {
+        self.tags
+    }
+
+    fn filled_qty(&self) -> Quantity {
+        self.filled_qty
+    }
+
+    fn leaves_qty(&self) -> Quantity {
+        self.leaves_qty
+    }
+
+    fn avg_px(&self) -> Option<f64> {
+        self.avg_px
+    }
+
+    fn slippage(&self) -> Option<f64> {
+        self.slippage
+    }
+
+    fn init_id(&self) -> UUID4 {
+        self.init_id
+    }
+
+    fn ts_init(&self) -> UnixNanos {
+        self.ts_init
+    }
+
+    fn ts_last(&self) -> UnixNanos {
+        self.ts_last
+    }
+
+    fn events(&self) -> Vec<&OrderEvent> {
+        self.events.iter().collect()
+    }
+
+    fn venue_order_ids(&self) -> Vec<&VenueOrderId> {
+        self.venue_order_ids.iter().collect()
+    }
+
+    fn trade_ids(&self) -> Vec<&TradeId> {
+        self.trade_ids.iter().collect()
+    }
+
+    fn apply(&mut self, event: OrderEvent) -> Result<(), OrderError> {
+        if let OrderEvent::OrderUpdated(ref event) = event {
+            self.update(event);
+        };
+        let is_order_filled = matches!(event, OrderEvent::OrderFilled(_));
+
+        self.core.apply(event)?;
+
+        if is_order_filled {
+            self.core.set_slippage(self.price);
+        };
+
+        Ok(())
+    }
+
+    fn update(&mut self, event: &OrderUpdated) {
+        if let Some(price) = event.price {
+            self.price = price;
+        }
+
+        if let Some(trigger_price) = event.trigger_price {
+            self.trigger_price = trigger_price;
+        }
+
+        self.quantity = event.quantity;
+        self.leaves_qty = self.quantity - self.filled_qty;
+    }
+}
+
+impl From<OrderInitialized> for LimitIfTouchedOrder {
+    fn from(event: OrderInitialized) -> Self {
+        Self::new(
+            event.trader_id,
+            event.strategy_id,
+            event.instrument_id,
+            event.client_order_id,
+            event.order_side,
+            event.quantity,
+            event
+                .price // TODO: Improve this error, model order domain errors
+                .expect("Error initializing order: `price` was `None` for `LimitIfTouchedOrder"),
+            event
+                .trigger_price // TODO: Improve this error, model order domain errors
+                .expect(
+                    "Error initializing order: `trigger_price` was `None` for `LimitIfTouchedOrder",
+                ),
+            event
+                .trigger_type
+                .expect("Error initializing order: `trigger_type` was `None`"),
+            event.time_in_force,
+            event.expire_time,
+            event.post_only,
+            event.reduce_only,
+            event.quote_quantity,
+            event.display_qty,
+            event.emulation_trigger,
+            event.trigger_instrument_id,
+            event.contingency_type,
+            event.order_list_id,
+            event.linked_order_ids,
+            event.parent_order_id,
+            event.exec_algorithm_id,
+            event.exec_algorithm_params,
+            event.exec_spawn_id,
+            event.tags,
+            event.event_id,
+            event.ts_event,
+        )
+        .unwrap() // SAFETY: From can panic
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/data/quote.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/data/quote.rs`

 * *Files 3% similar despite different names*

```diff
@@ -17,24 +17,24 @@
     cmp,
     collections::HashMap,
     fmt::{Display, Formatter},
     hash::Hash,
 };
 
 use indexmap::IndexMap;
-use nautilus_core::{correctness::check_equal_u8, serialization::Serializable, time::UnixNanos};
+use nautilus_core::{correctness::check_equal_u8, nanos::UnixNanos, serialization::Serializable};
 use serde::{Deserialize, Serialize};
 
 use crate::{
     enums::PriceType,
     identifiers::instrument_id::InstrumentId,
     types::{fixed::FIXED_PRECISION, price::Price, quantity::Quantity},
 };
 
-/// Represents a single quote tick in a financial market.
+/// Represents a single quote tick in market.
 #[repr(C)]
 #[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
 #[serde(tag = "type")]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
@@ -46,17 +46,17 @@
     pub bid_price: Price,
     /// The top of book ask price.
     pub ask_price: Price,
     /// The top of book bid size.
     pub bid_size: Quantity,
     /// The top of book ask size.
     pub ask_size: Quantity,
-    /// The UNIX timestamp (nanoseconds) when the tick event occurred.
+    /// The UNIX timestamp (nanoseconds) when the quote event occurred.
     pub ts_event: UnixNanos,
-    /// The UNIX timestamp (nanoseconds) when the data object was initialized.
+    /// The UNIX timestamp (nanoseconds) when the struct was initialized.
     pub ts_init: UnixNanos,
 }
 
 impl QuoteTick {
     pub fn new(
         instrument_id: InstrumentId,
         bid_price: Price,
@@ -163,14 +163,15 @@
 impl Serializable for QuoteTick {}
 
 ////////////////////////////////////////////////////////////////////////////////
 // Stubs
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(feature = "stubs")]
 pub mod stubs {
+    use nautilus_core::nanos::UnixNanos;
     use rstest::fixture;
 
     use crate::{
         data::quote::QuoteTick,
         identifiers::instrument_id::InstrumentId,
         types::{price::Price, quantity::Quantity},
     };
@@ -179,16 +180,16 @@
     pub fn quote_tick_ethusdt_binance() -> QuoteTick {
         QuoteTick {
             instrument_id: InstrumentId::from("ETHUSDT-PERP.BINANCE"),
             bid_price: Price::from("10000.0000"),
             ask_price: Price::from("10001.0000"),
             bid_size: Quantity::from("1.00000000"),
             ask_size: Quantity::from("1.00000000"),
-            ts_event: 0,
-            ts_init: 1,
+            ts_event: UnixNanos::from(0),
+            ts_init: UnixNanos::from(1),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/data/stubs.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/data/stubs.rs`

 * *Files 8% similar despite different names*

```diff
@@ -39,11 +39,11 @@
     let order = BookOrder::new(side, price, size, order_id);
     OrderBookDelta::new(
         instrument_id,
         action,
         order,
         flags,
         sequence,
-        ts_event,
-        ts_init,
+        ts_event.into(),
+        ts_init.into(),
     )
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/data/trade.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/data/trade.rs`

 * *Files 2% similar despite different names*

```diff
@@ -16,24 +16,24 @@
 use std::{
     collections::HashMap,
     fmt::{Display, Formatter},
     hash::Hash,
 };
 
 use indexmap::IndexMap;
-use nautilus_core::{serialization::Serializable, time::UnixNanos};
+use nautilus_core::{nanos::UnixNanos, serialization::Serializable};
 use serde::{Deserialize, Serialize};
 
 use crate::{
     enums::AggressorSide,
     identifiers::{instrument_id::InstrumentId, trade_id::TradeId},
     types::{price::Price, quantity::Quantity},
 };
 
-/// Represents a single trade tick in a financial market.
+/// Represents a single trade tick in a market.
 #[repr(C)]
 #[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
 #[serde(tag = "type")]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
@@ -45,17 +45,17 @@
     pub price: Price,
     /// The traded size.
     pub size: Quantity,
     /// The trade aggressor side.
     pub aggressor_side: AggressorSide,
     /// The trade match ID (assigned by the venue).
     pub trade_id: TradeId,
-    /// The UNIX timestamp (nanoseconds) when the tick event occurred.
+    /// The UNIX timestamp (nanoseconds) when the trade event occurred.
     pub ts_event: UnixNanos,
-    ///  The UNIX timestamp (nanoseconds) when the data object was initialized.
+    /// The UNIX timestamp (nanoseconds) when the struct was initialized.
     pub ts_init: UnixNanos,
 }
 
 impl TradeTick {
     #[must_use]
     pub fn new(
         instrument_id: InstrumentId,
@@ -123,14 +123,15 @@
 impl Serializable for TradeTick {}
 
 ////////////////////////////////////////////////////////////////////////////////
 // Stubs
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(feature = "stubs")]
 pub mod stubs {
+    use nautilus_core::nanos::UnixNanos;
     use rstest::fixture;
 
     use crate::{
         data::trade::TradeTick,
         enums::AggressorSide,
         identifiers::{instrument_id::InstrumentId, trade_id::TradeId},
         types::{price::Price, quantity::Quantity},
@@ -140,16 +141,16 @@
     pub fn stub_trade_tick_ethusdt_buyer() -> TradeTick {
         TradeTick {
             instrument_id: InstrumentId::from("ETHUSDT-PERP.BINANCE"),
             price: Price::from("10000.0000"),
             size: Quantity::from("1.00000000"),
             aggressor_side: AggressorSide::Buyer,
             trade_id: TradeId::new("123456789").unwrap(),
-            ts_event: 0,
-            ts_init: 1,
+            ts_event: UnixNanos::from(0),
+            ts_init: UnixNanos::from(1),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/enums.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/enums.rs`

 * *Files 3% similar despite different names*

```diff
@@ -92,14 +92,15 @@
 
 /// The side for the aggressing order of a trade in a market.
 #[repr(C)]
 #[derive(
     Copy,
     Clone,
     Debug,
+    Default,
     Display,
     Hash,
     PartialEq,
     Eq,
     PartialOrd,
     Ord,
     AsRefStr,
@@ -111,14 +112,15 @@
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model.enums")
 )]
 pub enum AggressorSide {
     /// There was no specific aggressor for the trade.
+    #[default]
     NoAggressor = 0,
     /// The BUY order was the aggressor for the trade.
     Buyer = 1,
     /// The SELL order was the aggressor for the trade.
     Seller = 2,
 }
 
@@ -170,15 +172,15 @@
     Index = 5,
     /// Cryptocurrency or crypto token assets.
     Cryptocurrency = 6,
     /// Alternative assets.
     Alternative = 7,
 }
 
-/// The asset type for a financial market product.
+/// The instrument class.
 #[repr(C)]
 #[derive(
     Copy,
     Clone,
     Debug,
     Display,
     Hash,
@@ -374,14 +376,15 @@
 ///
 /// [FIX 5.0 SP2 : ContingencyType <1385> field](https://www.onixs.biz/fix-dictionary/5.0.sp2/tagnum_1385.html).
 #[repr(C)]
 #[derive(
     Copy,
     Clone,
     Debug,
+    Default,
     Display,
     Hash,
     PartialEq,
     Eq,
     PartialOrd,
     Ord,
     AsRefStr,
@@ -393,15 +396,16 @@
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model.enums")
 )]
 pub enum ContingencyType {
     /// Not a contingent order.
-    NoContingency = 0, // Will be replaced by `Option`
+    #[default]
+    NoContingency = 0,
     /// One-Cancels-the-Other.
     Oco = 1,
     /// One-Triggers-the-Other.
     Oto = 2,
     /// One-Updates-the-Other (by proportional quantity).
     Ouo = 3,
 }
@@ -464,15 +468,15 @@
 pub enum InstrumentCloseType {
     /// When the market session ended.
     EndOfSession = 1,
     /// When the instrument expiration was reached.
     ContractExpired = 2,
 }
 
-/// The liqudity side for a trade in a financial market.
+/// The liqudity side for a trade.
 #[repr(C)]
 #[derive(
     Copy,
     Clone,
     Debug,
     Display,
     Hash,
@@ -575,14 +579,15 @@
 
 /// The order management system (OMS) type for a trading venue or trading strategy.
 #[repr(C)]
 #[derive(
     Copy,
     Clone,
     Debug,
+    Default,
     Display,
     Hash,
     PartialEq,
     Eq,
     PartialOrd,
     Ord,
     AsRefStr,
@@ -593,16 +598,17 @@
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model.enums")
 )]
 pub enum OmsType {
-    /// There is no specific type of order management specified (will defer to the venue).
-    Unspecified = 0, // Will be replaced by `Option`
+    /// There is no specific type of order management specified (will defer to the venue OMS).
+    #[default]
+    Unspecified = 0,
     /// The netting type where there is one position per instrument.
     Netting = 1,
     /// The hedging type where there can be multiple positions per instrument.
     /// This can be in LONG/SHORT directions, by position/ticket ID, or tracked virtually by
     /// Nautilus.
     Hedging = 2,
 }
@@ -639,14 +645,15 @@
 
 /// The order side for a specific order, or action related to orders.
 #[repr(C)]
 #[derive(
     Copy,
     Clone,
     Debug,
+    Default,
     Display,
     Hash,
     PartialEq,
     Eq,
     PartialOrd,
     Ord,
     AsRefStr,
@@ -659,33 +666,63 @@
 #[allow(clippy::enum_variant_names)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model.enums")
 )]
 pub enum OrderSide {
     /// No order side is specified.
+    #[default]
     NoOrderSide = 0,
     /// The order is a BUY.
     Buy = 1,
     /// The order is a SELL.
     Sell = 2,
 }
 
+impl OrderSide {
+    #[must_use]
+    pub fn as_specified(&self) -> OrderSideSpecified {
+        match &self {
+            Self::Buy => OrderSideSpecified::Buy,
+            Self::Sell => OrderSideSpecified::Sell,
+            _ => panic!("Order invariant failed: side must be 'Buy' or 'Sell'"),
+        }
+    }
+}
+
 /// Convert the given `value` to an [`OrderSide`].
 impl FromU8 for OrderSide {
     fn from_u8(value: u8) -> Option<Self> {
         match value {
             0 => Some(Self::NoOrderSide),
             1 => Some(Self::Buy),
             2 => Some(Self::Sell),
             _ => None,
         }
     }
 }
 
+/// The specified order side (BUY or SELL).
+pub enum OrderSideSpecified {
+    /// The order is a BUY.
+    Buy = 1,
+    /// The order is a SELL.
+    Sell = 2,
+}
+
+impl OrderSideSpecified {
+    #[must_use]
+    pub fn as_order_side(&self) -> OrderSide {
+        match &self {
+            Self::Buy => OrderSide::Buy,
+            Self::Sell => OrderSide::Sell,
+        }
+    }
+}
+
 /// The status for a specific order.
 ///
 /// An order is considered _open_ for the following status:
 ///  - `ACCEPTED`
 ///  - `TRIGGERED`
 ///  - `PENDING_UPDATE`
 ///  - `PENDING_CANCEL`
@@ -801,14 +838,15 @@
 
 /// The market side for a specific position, or action related to positions.
 #[repr(C)]
 #[derive(
     Copy,
     Clone,
     Debug,
+    Default,
     Display,
     Hash,
     PartialEq,
     Eq,
     PartialOrd,
     Ord,
     AsRefStr,
@@ -821,24 +859,25 @@
 #[allow(clippy::enum_variant_names)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model.enums")
 )]
 pub enum PositionSide {
     /// No position side is specified (only valid in the context of a filter for actions involving positions).
-    NoPositionSide = 0, // Will be replaced by `Option`
+    #[default]
+    NoPositionSide = 0,
     /// A neural/flat position, where no position is currently held in the market.
     Flat = 1,
     /// A long position in the market, typically acquired through one or many BUY orders.
     Long = 2,
     /// A short position in the market, typically acquired through one or many SELL orders.
     Short = 3,
 }
 
-/// The type of price for an instrument in a financial market.
+/// The type of price for an instrument in market.
 #[repr(C)]
 #[derive(
     Copy,
     Clone,
     Debug,
     Display,
     Hash,
@@ -864,15 +903,62 @@
     Ask = 2,
     /// The midpoint between the bid and ask prices.
     Mid = 3,
     /// The last price at which a trade was made for an instrument.
     Last = 4,
 }
 
-/// The 'Time in Force' instruction for an order in the financial market.
+/// A record flag bit field, indicating packet end and data information.
+#[repr(C)]
+#[derive(
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumIter,
+    EnumString,
+)]
+#[strum(ascii_case_insensitive)]
+#[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
+#[cfg_attr(
+    feature = "python",
+    pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model.enums")
+)]
+#[allow(non_camel_case_types)]
+pub enum RecordFlag {
+    /// Last message in the packet from the venue for a given `instrument_id`.
+    F_LAST = 1 << 7, // 128
+    /// Top-of-book message, not an individual order.
+    F_TOB = 1 << 6, // 64
+    /// Message sourced from a replay, such as a snapshot server.
+    F_SNAPSHOT = 1 << 5, // 32
+    /// Aggregated price level message, not an individual order.
+    F_MBP = 1 << 4, // 16
+    /// Reserved for future use.
+    RESERVED_2 = 1 << 3, // 8
+    /// Reserved for future use.
+    RESERVED_1 = 1 << 2, // 4
+}
+
+impl RecordFlag {
+    /// Checks if the flag matches a given value.
+    #[must_use]
+    pub fn matches(self, value: u8) -> bool {
+        (self as u8) & value != 0
+    }
+}
+
+/// The 'Time in Force' instruction for an order.
 #[repr(C)]
 #[derive(
     Copy,
     Clone,
     Debug,
     Display,
     Hash,
@@ -961,15 +1047,15 @@
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model.enums")
 )]
 pub enum TrailingOffsetType {
     /// No trailing offset type is specified (invalid for trailing type orders).
-    NoTrailingOffset = 0, // Will be replaced by `Option`
+    NoTrailingOffset = 0,
     /// The trailing offset is based on a market price.
     Price = 1,
     /// The trailing offset is based on a percentage represented in basis points, of a market price.
     BasisPoints = 2,
     /// The trailing offset is based on the number of ticks from a market price.
     Ticks = 3,
     /// The trailing offset is based on a price tier set by a specific trading venue.
@@ -978,14 +1064,15 @@
 
 /// The trigger type for the stop/trigger price of an order.
 #[repr(C)]
 #[derive(
     Copy,
     Clone,
     Debug,
+    Default,
     Display,
     Hash,
     PartialEq,
     Eq,
     PartialOrd,
     Ord,
     AsRefStr,
@@ -997,15 +1084,16 @@
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model.enums")
 )]
 pub enum TriggerType {
     /// No trigger type is specified (invalid for orders with a trigger).
-    NoTrigger = 0, // Will be replaced by `Option`
+    #[default]
+    NoTrigger = 0,
     /// The default trigger type set by the trading venue.
     Default = 1,
     /// Based on the top-of-book quoted prices for the instrument.
     BidAsk = 2,
     /// Based on the last traded price for the instrument.
     LastTrade = 3,
     /// Based on a 'double match' of the last traded price for the instrument
@@ -1038,11 +1126,12 @@
 enum_strum_serde!(OmsType);
 enum_strum_serde!(OptionKind);
 enum_strum_serde!(OrderSide);
 enum_strum_serde!(OrderStatus);
 enum_strum_serde!(OrderType);
 enum_strum_serde!(PositionSide);
 enum_strum_serde!(PriceType);
+enum_strum_serde!(RecordFlag);
 enum_strum_serde!(TimeInForce);
 enum_strum_serde!(TradingState);
 enum_strum_serde!(TrailingOffsetType);
 enum_strum_serde!(TriggerType);
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/account/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/account/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/account/state.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/account/state.rs`

 * *Files 1% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::{Display, Formatter};
 
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 
 use crate::{
     enums::AccountType,
     identifiers::account_id::AccountId,
     types::{
         balance::{AccountBalance, MarginBalance},
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/account/stubs.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/account/stubs.rs`

 * *Files 5% similar despite different names*

```diff
@@ -32,16 +32,16 @@
     AccountState::new(
         account_id(),
         AccountType::Cash,
         vec![account_balance_test()],
         vec![],
         true,
         uuid4(),
-        0,
-        0,
+        0.into(),
+        0.into(),
         Some(Currency::USD()),
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn cash_account_state_million_usd() -> AccountState {
@@ -53,16 +53,16 @@
             Money::from("0 USD"),
             Money::from("1000000 USD"),
         )
         .unwrap()],
         vec![],
         true,
         uuid4(),
-        0,
-        0,
+        0.into(),
+        0.into(),
         Some(Currency::USD()),
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn cash_account_state_million_usdt() -> AccountState {
@@ -74,16 +74,16 @@
             Money::from("0 USD"),
             Money::from("1000000 USD"),
         )
         .unwrap()],
         vec![],
         true,
         uuid4(),
-        0,
-        0,
+        0.into(),
+        0.into(),
         Some(Currency::USD()),
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn cash_account_state_multi() -> AccountState {
@@ -102,16 +102,16 @@
     AccountState::new(
         account_id(),
         AccountType::Cash,
         vec![btc_account_balance, eth_account_balance],
         vec![],
         true,
         uuid4(),
-        0,
-        0,
+        0.into(),
+        0.into(),
         None, // multi cash account
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn cash_account_state_multi_changed_btc() -> AccountState {
@@ -130,29 +130,29 @@
     AccountState::new(
         account_id(),
         AccountType::Cash,
         vec![btc_account_balance, eth_account_balance],
         vec![],
         true,
         uuid4(),
-        0,
-        0,
+        0.into(),
+        0.into(),
         None, // multi cash account
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn margin_account_state() -> AccountState {
     AccountState::new(
         account_id(),
         AccountType::Margin,
         vec![account_balance_test()],
         vec![margin_balance_test()],
         true,
         uuid4(),
-        0,
-        0,
+        0.into(),
+        0.into(),
         Some(Currency::USD()),
     )
     .unwrap()
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/accepted.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/accepted.rs`

 * *Files 2% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::Display;
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 
 use crate::identifiers::{
     account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
     strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
 };
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/cancel_rejected.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/cancel_rejected.rs`

 * *Files 3% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::Display;
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
 use crate::identifiers::{
     account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
     strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
 };
@@ -81,16 +81,16 @@
 impl Display for OrderCancelRejected {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         write!(
             f,
             "OrderCancelRejected(instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, reason={}, ts_event={})",
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
-            self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
+            self.venue_order_id.map_or("None".to_string(), |venue_order_id| format!("{venue_order_id}")),
+            self.account_id.map_or("None".to_string(), |account_id| format!("{account_id}")),
             self.reason,
             self.ts_event
         )
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/canceled.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/canceled.rs`

 * *Files 5% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::Display;
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 
 use crate::identifiers::{
     account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
     strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
 };
 
@@ -77,16 +77,16 @@
 impl Display for OrderCanceled {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         write!(
             f,
             "OrderCanceled(instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, ts_event={})",
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
-            self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
+            self.venue_order_id.map_or("None".to_string(), |venue_order_id| format!("{venue_order_id}")),
+            self.account_id.map_or("None".to_string(), |account_id| format!("{account_id}")),
             self.ts_event
         )
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/denied.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/denied.rs`

 * *Files 1% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::{Display, Formatter};
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
 use crate::identifiers::{
     client_order_id::ClientOrderId, instrument_id::InstrumentId, strategy_id::StrategyId,
     trader_id::TraderId,
 };
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/emulated.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/emulated.rs`

 * *Files 1% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::{Display, Formatter};
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 
 use crate::identifiers::{
     client_order_id::ClientOrderId, instrument_id::InstrumentId, strategy_id::StrategyId,
     trader_id::TraderId,
 };
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/event.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/event.rs`

 * *Files 1% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_core::time::UnixNanos;
+use nautilus_core::nanos::UnixNanos;
 use serde::{Deserialize, Serialize};
 use strum::Display;
 
 use crate::{
     events::order::{
         accepted::OrderAccepted, cancel_rejected::OrderCancelRejected, canceled::OrderCanceled,
         denied::OrderDenied, emulated::OrderEmulated, expired::OrderExpired, filled::OrderFilled,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/expired.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/expired.rs`

 * *Files 1% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::Display;
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 
 use crate::identifiers::{
     account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
     strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
 };
 
@@ -77,16 +77,16 @@
 impl Display for OrderExpired {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         write!(
             f,
             "OrderExpired(instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, ts_event={})",
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
-            self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
+            self.venue_order_id.map_or("None".to_string(), |venue_order_id| format!("{venue_order_id}")),
+            self.account_id.map_or("None".to_string(), |account_id| format!("{account_id}")),
             self.ts_event
         )
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/filled.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/filled.rs`

 * *Files 0% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::Display;
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 
 use crate::{
     enums::{LiquiditySide, OrderSide, OrderType},
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         position_id::PositionId, strategy_id::StrategyId, trade_id::TradeId, trader_id::TraderId,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/initialized.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/initialized.rs`

 * *Files 0% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 
 use std::{
     collections::HashMap,
     fmt::{Display, Formatter},
 };
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
 use crate::{
     enums::{ContingencyType, OrderSide, OrderType, TimeInForce, TrailingOffsetType, TriggerType},
     identifiers::{
         client_order_id::ClientOrderId, exec_algorithm_id::ExecAlgorithmId,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/modify_rejected.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/modify_rejected.rs`

 * *Files 8% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::{Display, Formatter};
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
 use crate::identifiers::{
     account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
     strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
 };
@@ -81,16 +81,16 @@
 impl Display for OrderModifyRejected {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(
             f,
             "OrderModifyRejected(instrument_id={}, client_order_id={}, venue_order_id={}, account_id={},reason={}, ts_event={})",
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
-            self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
+            self.venue_order_id.map_or("None".to_string(), |venue_order_id| format!("{venue_order_id}")),
+            self.account_id.map_or("None".to_string(), |account_id| format!("{account_id}")),
             self.reason,
             self.ts_event
         )
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/pending_cancel.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/pending_cancel.rs`

 * *Files 5% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::{Display, Formatter};
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 
 use crate::identifiers::{
     account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
     strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
 };
 
@@ -77,15 +77,15 @@
 impl Display for OrderPendingCancel {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(
             f,
             "OrderPendingCancel(instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, ts_event={})",
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
+            self.venue_order_id.map_or("None".to_string(), |venue_order_id| format!("{venue_order_id}")),
             self.account_id,
             self.ts_event
         )
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/pending_update.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/pending_update.rs`

 * *Files 7% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::{Display, Formatter};
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 
 use crate::identifiers::{
     account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
     strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
 };
 
@@ -77,15 +77,15 @@
 impl Display for OrderPendingUpdate {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(
             f,
             "OrderPendingUpdate(instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, ts_event={})",
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
+            self.venue_order_id.map_or("None".to_string(), |venue_order_id| format!("{venue_order_id}")),
             self.account_id,
             self.ts_event
         )
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/rejected.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/rejected.rs`

 * *Files 2% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::{Display, Formatter};
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
 use crate::identifiers::{
     account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
     strategy_id::StrategyId, trader_id::TraderId,
 };
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/released.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/released.rs`

 * *Files 2% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::Display;
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 
 use crate::{
     identifiers::{
         client_order_id::ClientOrderId, instrument_id::InstrumentId, strategy_id::StrategyId,
         trader_id::TraderId,
     },
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/stubs.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/stubs.rs`

 * *Files 8% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::str::FromStr;
 
-use nautilus_core::uuid::UUID4;
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use rstest::fixture;
 use ustr::Ustr;
 
 use crate::{
     enums::{ContingencyType, LiquiditySide, OrderSide, OrderType, TimeInForce, TriggerType},
     events::order::{
         accepted::OrderAccepted, cancel_rejected::OrderCancelRejected, denied::OrderDenied,
@@ -65,16 +65,16 @@
         OrderSide::Buy,
         OrderType::Limit,
         Quantity::from_str("0.561").unwrap(),
         Price::from_str("22000").unwrap(),
         Currency::from_str("USDT").unwrap(),
         LiquiditySide::Taker,
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
         false,
         None,
         Some(Money::from_str("12.2 USDT").unwrap()),
     )
     .unwrap()
 }
 
@@ -89,16 +89,16 @@
     OrderDenied::new(
         trader_id,
         strategy_id_ema_cross,
         instrument_id_btc_usdt,
         client_order_id,
         Ustr::from("Exceeded MAX_ORDER_SUBMIT_RATE"),
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn order_rejected_insufficient_margin(
     trader_id: TraderId,
@@ -112,16 +112,16 @@
         trader_id,
         strategy_id_ema_cross,
         instrument_id_btc_usdt,
         client_order_id,
         account_id,
         Ustr::from("INSUFFICIENT_MARGIN"),
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
         false,
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn order_initialized_buy_limit(
@@ -143,16 +143,16 @@
         Quantity::from_str("0.561").unwrap(),
         TimeInForce::Day,
         true,
         true,
         false,
         false,
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
         Some(Price::from_str("22000").unwrap()),
         None,
         None,
         None,
         None,
         None,
         None,
@@ -183,16 +183,16 @@
     OrderSubmitted::new(
         trader_id,
         strategy_id_ema_cross,
         instrument_id_btc_usdt,
         client_order_id,
         account_id,
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn order_triggered(
     trader_id: TraderId,
@@ -205,16 +205,16 @@
 ) -> OrderTriggered {
     OrderTriggered::new(
         trader_id,
         strategy_id_ema_cross,
         instrument_id_btc_usdt,
         client_order_id,
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
         false,
         Some(venue_order_id),
         Some(account_id),
     )
     .unwrap()
 }
 
@@ -228,16 +228,16 @@
 ) -> OrderEmulated {
     OrderEmulated::new(
         trader_id,
         strategy_id_ema_cross,
         instrument_id_btc_usdt,
         client_order_id,
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn order_released(
     trader_id: TraderId,
@@ -249,16 +249,16 @@
     OrderReleased::new(
         trader_id,
         strategy_id_ema_cross,
         instrument_id_btc_usdt,
         client_order_id,
         Price::from_str("22000").unwrap(),
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn order_updated(
     trader_id: TraderId,
@@ -272,16 +272,16 @@
     OrderUpdated::new(
         trader_id,
         strategy_id_ema_cross,
         instrument_id_btc_usdt,
         client_order_id,
         Quantity::from(100),
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
         false,
         Some(venue_order_id),
         Some(account_id),
         Some(Price::from("22000")),
         None,
     )
     .unwrap()
@@ -300,16 +300,16 @@
     OrderPendingUpdate::new(
         trader_id,
         strategy_id_ema_cross,
         instrument_id_btc_usdt,
         client_order_id,
         account_id,
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
         false,
         Some(venue_order_id),
     )
     .unwrap()
 }
 
 #[fixture]
@@ -325,16 +325,16 @@
     OrderPendingCancel::new(
         trader_id,
         strategy_id_ema_cross,
         instrument_id_btc_usdt,
         client_order_id,
         account_id,
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
         false,
         Some(venue_order_id),
     )
     .unwrap()
 }
 
 #[fixture]
@@ -350,16 +350,16 @@
     OrderModifyRejected::new(
         trader_id,
         strategy_id_ema_cross,
         instrument_id_btc_usdt,
         client_order_id,
         Ustr::from("ORDER_DOES_NOT_EXIST"),
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
         false,
         Some(venue_order_id),
         Some(account_id),
     )
     .unwrap()
 }
 
@@ -377,16 +377,16 @@
         trader_id,
         strategy_id_ema_cross,
         instrument_id_btc_usdt,
         client_order_id,
         venue_order_id,
         account_id,
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
         false,
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn order_cancel_rejected(
@@ -401,16 +401,16 @@
     OrderCancelRejected::new(
         trader_id,
         strategy_id_ema_cross,
         instrument_id_btc_usdt,
         client_order_id,
         Ustr::from("ORDER_DOES_NOT_EXISTS"),
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
         false,
         Some(venue_order_id),
         Some(account_id),
     )
     .unwrap()
 }
 
@@ -426,15 +426,15 @@
 ) -> OrderExpired {
     OrderExpired::new(
         trader_id,
         strategy_id_ema_cross,
         instrument_id_btc_usdt,
         client_order_id,
         uuid4,
-        0,
-        0,
+        UnixNanos::default(),
+        UnixNanos::default(),
         false,
         Some(venue_order_id),
         Some(account_id),
     )
     .unwrap()
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/submitted.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/submitted.rs`

 * *Files 0% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::{Display, Formatter};
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 
 use crate::identifiers::{
     account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
     strategy_id::StrategyId, trader_id::TraderId,
 };
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/triggered.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/triggered.rs`

 * *Files 2% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::Display;
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 
 use crate::identifiers::{
     account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
     strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
 };
 
@@ -78,20 +78,20 @@
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         write!(
             f,
             "{}(instrument_id={}, client_order_id={}, venue_order_id={}, account_id={})",
             stringify!(OrderTriggered),
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(
-                || "None".to_string(),
-                |venue_order_id| format!("{venue_order_id}")
-            ),
+            self.venue_order_id
+                .map_or("None".to_string(), |venue_order_id| format!(
+                    "{venue_order_id}"
+                )),
             self.account_id
-                .map_or_else(|| "None".to_string(), |account_id| format!("{account_id}"))
+                .map_or("None".to_string(), |account_id| format!("{account_id}"))
         )
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/order/updated.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/order/updated.rs`

 * *Files 16% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::{Display, Formatter};
 
 use derive_builder::Builder;
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 
 use crate::{
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
     },
@@ -89,19 +89,19 @@
 impl Display for OrderUpdated {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(
             f,
             "OrderUpdated(instrument_id={}, client_order_id={}, venue_order_id={}, account_id={},quantity={}, price={}, trigger_price={}, ts_event={})",
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
-            self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
+            self.venue_order_id.map_or("None".to_string(), |venue_order_id| format!("{venue_order_id}")),
+            self.account_id.map_or("None".to_string(), |account_id| format!("{account_id}")),
             self.quantity,
-            self.price.map_or_else(|| "None".to_string(), |price| format!("{price}")),
-            self.trigger_price.map_or_else(|| "None".to_string(), |trigger_price| format!("{trigger_price}")),
+            self.price.map_or("None".to_string(), |price| format!("{price}")),
+            self.trigger_price.map_or("None".to_string(), |trigger_price| format!("{trigger_price}")),
             self.ts_event
         )
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/position/changed.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/position/changed.rs`

 * *Files 1% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_core::time::UnixNanos;
+use nautilus_core::nanos::UnixNanos;
 
 use crate::{
     enums::{OrderSide, PositionSide},
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         position_id::PositionId, strategy_id::StrategyId, trader_id::TraderId,
     },
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/position/closed.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/position/closed.rs`

 * *Files 8% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_core::time::{TimedeltaNanos, UnixNanos};
+use nautilus_core::nanos::{TimedeltaNanos, UnixNanos};
 
 use crate::{
     enums::{OrderSide, PositionSide},
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         position_id::PositionId, strategy_id::StrategyId, trader_id::TraderId,
     },
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/position/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/position/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/position/opened.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/position/opened.rs`

 * *Files 1% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_core::time::UnixNanos;
+use nautilus_core::nanos::UnixNanos;
 
 use crate::{
     enums::{OrderSide, PositionSide},
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         position_id::PositionId, strategy_id::StrategyId, trader_id::TraderId,
     },
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/events/position/state.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/events/position/state.rs`

 * *Files 1% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_core::time::UnixNanos;
+use nautilus_core::nanos::UnixNanos;
 
 use crate::{
     enums::{OrderSide, PositionSide},
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         position_id::PositionId, strategy_id::StrategyId, trader_id::TraderId,
     },
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/bar.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/bar.rs`

 * *Files 0% similar despite different names*

```diff
@@ -18,15 +18,15 @@
     ffi::c_char,
     hash::{Hash, Hasher},
     str::FromStr,
 };
 
 use nautilus_core::{
     ffi::string::{cstr_to_str, str_to_cstr},
-    time::UnixNanos,
+    nanos::UnixNanos,
 };
 
 use crate::{
     data::bar::{Bar, BarSpecification, BarType},
     enums::{AggregationSource, BarAggregation, PriceType},
     identifiers::instrument_id::InstrumentId,
     types::{price::Price, quantity::Quantity},
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/delta.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/delta.rs`

 * *Files 8% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::hash_map::DefaultHasher,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::time::UnixNanos;
+use nautilus_core::nanos::UnixNanos;
 
 use crate::{
     data::{delta::OrderBookDelta, order::BookOrder},
     enums::BookAction,
     identifiers::instrument_id::InstrumentId,
 };
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/deltas.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/deltas.rs`

 * *Files 1% similar despite different names*

```diff
@@ -9,26 +9,26 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_core::{ffi::cvec::CVec, time::UnixNanos};
+use nautilus_core::{ffi::cvec::CVec, nanos::UnixNanos};
 
 use crate::{
     data::{
         delta::OrderBookDelta,
         deltas::{OrderBookDeltas, OrderBookDeltas_API},
     },
     enums::BookAction,
     identifiers::instrument_id::InstrumentId,
 };
 
-/// Creates a new `OrderBookDeltas` object from a `CVec` of `OrderBookDelta`.
+/// Creates a new `OrderBookDeltas` instance from a `CVec` of `OrderBookDelta`.
 ///
 /// # Safety
 /// - The `deltas` must be a valid pointer to a `CVec` containing `OrderBookDelta` objects
 /// - This function clones the data pointed to by `deltas` into Rust-managed memory, then forgets the original `Vec` to prevent Rust from auto-deallocating it
 /// - The caller is responsible for managing the memory of `deltas` (including its deallocation) to avoid memory leaks
 #[no_mangle]
 pub extern "C" fn orderbook_deltas_new(
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/depth.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/depth.rs`

 * *Files 0% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::hash_map::DefaultHasher,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::time::UnixNanos;
+use nautilus_core::nanos::UnixNanos;
 
 use crate::{
     data::{
         depth::{OrderBookDepth10, DEPTH10_LEN},
         order::BookOrder,
     },
     identifiers::instrument_id::InstrumentId,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/order.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/order.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/quote.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/quote.rs`

 * *Files 5% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 
 use std::{
     collections::hash_map::DefaultHasher,
     ffi::c_char,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::{ffi::string::str_to_cstr, time::UnixNanos};
+use nautilus_core::{ffi::string::str_to_cstr, nanos::UnixNanos};
 
 use crate::{
     data::quote::QuoteTick,
     identifiers::instrument_id::InstrumentId,
     types::{price::Price, quantity::Quantity},
 };
 
@@ -57,19 +57,16 @@
 pub extern "C" fn quote_tick_eq(lhs: &QuoteTick, rhs: &QuoteTick) -> u8 {
     assert_eq!(lhs.ask_price, rhs.ask_price);
     assert_eq!(lhs.ask_size, rhs.ask_size);
     assert_eq!(lhs.bid_price, rhs.bid_price);
     assert_eq!(lhs.bid_size, rhs.bid_size);
     assert_eq!(lhs.ts_event, rhs.ts_event);
     assert_eq!(lhs.ts_init, rhs.ts_init);
-    assert_eq!(
-        lhs.instrument_id.symbol.value,
-        rhs.instrument_id.symbol.value
-    );
-    assert_eq!(lhs.instrument_id.venue.value, rhs.instrument_id.venue.value);
+    assert_eq!(lhs.instrument_id.symbol, rhs.instrument_id.symbol);
+    assert_eq!(lhs.instrument_id.venue, rhs.instrument_id.venue);
     u8::from(lhs == rhs)
 }
 
 #[no_mangle]
 pub extern "C" fn quote_tick_hash(delta: &QuoteTick) -> u64 {
     let mut hasher = DefaultHasher::new();
     delta.hash(&mut hasher);
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/data/trade.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/data/trade.rs`

 * *Files 2% similar despite different names*

```diff
@@ -42,16 +42,16 @@
 ) -> TradeTick {
     TradeTick::new(
         instrument_id,
         Price::from_raw(price_raw, price_prec).unwrap(),
         Quantity::from_raw(size_raw, size_prec).unwrap(),
         aggressor_side,
         trade_id,
-        ts_event,
-        ts_init,
+        ts_event.into(),
+        ts_init.into(),
     )
 }
 
 #[no_mangle]
 pub extern "C" fn trade_tick_eq(lhs: &TradeTick, rhs: &TradeTick) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/enums.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/enums.rs`

 * *Files 2% similar despite different names*

```diff
@@ -17,15 +17,16 @@
 
 use nautilus_core::ffi::string::{cstr_to_str, str_to_cstr};
 
 use crate::enums::{
     AccountType, AggregationSource, AggressorSide, AssetClass, BarAggregation, BookAction,
     BookType, ContingencyType, CurrencyType, HaltReason, InstrumentClass, InstrumentCloseType,
     LiquiditySide, MarketStatus, OmsType, OptionKind, OrderSide, OrderStatus, OrderType,
-    PositionSide, PriceType, TimeInForce, TradingState, TrailingOffsetType, TriggerType,
+    PositionSide, PriceType, RecordFlag, TimeInForce, TradingState, TrailingOffsetType,
+    TriggerType,
 };
 
 #[no_mangle]
 pub extern "C" fn account_type_to_cstr(value: AccountType) -> *const c_char {
     str_to_cstr(value.as_ref())
 }
 
@@ -381,14 +382,31 @@
 pub unsafe extern "C" fn price_type_from_cstr(ptr: *const c_char) -> PriceType {
     let value = cstr_to_str(ptr);
     PriceType::from_str(value)
         .unwrap_or_else(|_| panic!("invalid `PriceType` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
+pub extern "C" fn record_flag_to_cstr(value: RecordFlag) -> *const c_char {
+    str_to_cstr(value.as_ref())
+}
+
+/// Returns an enum from a Python string.
+///
+/// # Safety
+///
+/// - Assumes `ptr` is a valid C string pointer.
+#[no_mangle]
+pub unsafe extern "C" fn record_flag_from_cstr(ptr: *const c_char) -> RecordFlag {
+    let value = cstr_to_str(ptr);
+    RecordFlag::from_str(value)
+        .unwrap_or_else(|_| panic!("invalid `RecordFlag` enum string value, was '{value}'"))
+}
+
+#[no_mangle]
 pub extern "C" fn time_in_force_to_cstr(value: TimeInForce) -> *const c_char {
     str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/events/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/events/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/events/order.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/events/order.rs`

 * *Files 0% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::ffi::c_char;
 
-use nautilus_core::{ffi::string::cstr_to_ustr, time::UnixNanos, uuid::UUID4};
+use nautilus_core::{ffi::string::cstr_to_ustr, nanos::UnixNanos, uuid::UUID4};
 
 use crate::{
     events::order::{
         accepted::OrderAccepted, denied::OrderDenied, emulated::OrderEmulated,
         rejected::OrderRejected, released::OrderReleased, submitted::OrderSubmitted,
     },
     identifiers::{
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/account_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/account_id.rs`

 * *Files 8% similar despite different names*

```diff
@@ -27,15 +27,15 @@
 #[no_mangle]
 pub unsafe extern "C" fn account_id_new(ptr: *const c_char) -> AccountId {
     AccountId::from(cstr_to_str(ptr))
 }
 
 #[no_mangle]
 pub extern "C" fn account_id_hash(id: &AccountId) -> u64 {
-    id.value.precomputed_hash()
+    id.inner().precomputed_hash()
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
@@ -47,26 +47,26 @@
 
     #[rstest]
     fn test_account_id_round_trip() {
         let s = "IB-U123456789";
         let c_string = CString::new(s).unwrap();
         let ptr = c_string.as_ptr();
         let account_id = unsafe { account_id_new(ptr) };
-        let char_ptr = account_id.value.as_char_ptr();
+        let char_ptr = account_id.inner().as_char_ptr();
         let account_id_2 = unsafe { account_id_new(char_ptr) };
         assert_eq!(account_id, account_id_2);
     }
 
     #[rstest]
     fn test_account_id_to_cstr_and_back() {
         let s = "IB-U123456789";
         let c_string = CString::new(s).unwrap();
         let ptr = c_string.as_ptr();
         let account_id = unsafe { account_id_new(ptr) };
-        let cstr_ptr = account_id.value.as_char_ptr();
+        let cstr_ptr = account_id.inner().as_char_ptr();
         let c_str = unsafe { CStr::from_ptr(cstr_ptr) };
         assert_eq!(c_str.to_str().unwrap(), s);
     }
 
     #[rstest]
     fn test_account_id_hash_c() {
         let s1 = "IB-U123456789";
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/client_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/client_id.rs`

 * *Files 10% similar despite different names*

```diff
@@ -27,15 +27,15 @@
 #[no_mangle]
 pub unsafe extern "C" fn client_id_new(ptr: *const c_char) -> ClientId {
     ClientId::from(cstr_to_str(ptr))
 }
 
 #[no_mangle]
 pub extern "C" fn client_id_hash(id: &ClientId) -> u64 {
-    id.value.precomputed_hash()
+    id.inner().precomputed_hash()
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
@@ -45,15 +45,15 @@
 
     use super::*;
     use crate::identifiers::stubs::*;
 
     #[rstest]
     fn test_client_id_to_cstr_c() {
         let id = ClientId::from("BINANCE");
-        let c_string = id.value.as_char_ptr();
+        let c_string = id.inner().as_char_ptr();
         let rust_string = unsafe { CStr::from_ptr(c_string) }.to_str().unwrap();
         assert_eq!(rust_string, "BINANCE");
     }
 
     #[rstest]
     fn test_client_id_hash_c() {
         let id1 = client_id_binance();
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/client_order_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/client_order_id.rs`

 * *Files 2% similar despite different names*

```diff
@@ -27,9 +27,9 @@
 #[no_mangle]
 pub unsafe extern "C" fn client_order_id_new(ptr: *const c_char) -> ClientOrderId {
     ClientOrderId::from(cstr_to_str(ptr))
 }
 
 #[no_mangle]
 pub extern "C" fn client_order_id_hash(id: &ClientOrderId) -> u64 {
-    id.value.precomputed_hash()
+    id.inner().precomputed_hash()
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/component_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/component_id.rs`

 * *Files 7% similar despite different names*

```diff
@@ -27,9 +27,9 @@
 #[no_mangle]
 pub unsafe extern "C" fn component_id_new(ptr: *const c_char) -> ComponentId {
     ComponentId::from(cstr_to_str(ptr))
 }
 
 #[no_mangle]
 pub extern "C" fn component_id_hash(id: &ComponentId) -> u64 {
-    id.value.precomputed_hash()
+    id.inner().precomputed_hash()
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/exec_algorithm_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/exec_algorithm_id.rs`

 * *Files 2% similar despite different names*

```diff
@@ -27,9 +27,9 @@
 #[no_mangle]
 pub unsafe extern "C" fn exec_algorithm_id_new(ptr: *const c_char) -> ExecAlgorithmId {
     ExecAlgorithmId::from(cstr_to_str(ptr))
 }
 
 #[no_mangle]
 pub extern "C" fn exec_algorithm_id_hash(id: &ExecAlgorithmId) -> u64 {
-    id.value.precomputed_hash()
+    id.inner().precomputed_hash()
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/instrument_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/instrument_id.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/order_list_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/order_list_id.rs`

 * *Files 8% similar despite different names*

```diff
@@ -27,9 +27,9 @@
 #[no_mangle]
 pub unsafe extern "C" fn order_list_id_new(ptr: *const c_char) -> OrderListId {
     OrderListId::from(cstr_to_str(ptr))
 }
 
 #[no_mangle]
 pub extern "C" fn order_list_id_hash(id: &OrderListId) -> u64 {
-    id.value.precomputed_hash()
+    id.inner().precomputed_hash()
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/position_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/position_id.rs`

 * *Files 8% similar despite different names*

```diff
@@ -27,9 +27,9 @@
 #[no_mangle]
 pub unsafe extern "C" fn position_id_new(ptr: *const c_char) -> PositionId {
     PositionId::from(cstr_to_str(ptr))
 }
 
 #[no_mangle]
 pub extern "C" fn position_id_hash(id: &PositionId) -> u64 {
-    id.value.precomputed_hash()
+    id.inner().precomputed_hash()
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/strategy_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/strategy_id.rs`

 * *Files 6% similar despite different names*

```diff
@@ -27,9 +27,9 @@
 #[no_mangle]
 pub unsafe extern "C" fn strategy_id_new(ptr: *const c_char) -> StrategyId {
     StrategyId::from(cstr_to_str(ptr))
 }
 
 #[no_mangle]
 pub extern "C" fn strategy_id_hash(id: &StrategyId) -> u64 {
-    id.value.precomputed_hash()
+    id.inner().precomputed_hash()
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/symbol.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/symbol.rs`

 * *Files 2% similar despite different names*

```diff
@@ -27,9 +27,9 @@
 #[no_mangle]
 pub unsafe extern "C" fn symbol_new(ptr: *const c_char) -> Symbol {
     Symbol::from(cstr_to_str(ptr))
 }
 
 #[no_mangle]
 pub extern "C" fn symbol_hash(id: &Symbol) -> u64 {
-    id.value.precomputed_hash()
+    id.inner().precomputed_hash()
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/trade_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/trade_id.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/trader_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/venue_order_id.rs`

 * *Files 12% similar despite different names*

```diff
@@ -13,23 +13,23 @@
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::ffi::c_char;
 
 use nautilus_core::ffi::string::cstr_to_str;
 
-use crate::identifiers::trader_id::TraderId;
+use crate::identifiers::venue_order_id::VenueOrderId;
 
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
 ///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
-pub unsafe extern "C" fn trader_id_new(ptr: *const c_char) -> TraderId {
-    TraderId::from(cstr_to_str(ptr))
+pub unsafe extern "C" fn venue_order_id_new(ptr: *const c_char) -> VenueOrderId {
+    VenueOrderId::from(cstr_to_str(ptr))
 }
 
 #[no_mangle]
-pub extern "C" fn trader_id_hash(id: &TraderId) -> u64 {
-    id.value.precomputed_hash()
+pub extern "C" fn venue_order_id_hash(id: &VenueOrderId) -> u64 {
+    id.inner().precomputed_hash()
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/venue.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/identifiers/venue.rs`

 * *Files 1% similar despite different names*

```diff
@@ -27,15 +27,15 @@
 #[no_mangle]
 pub unsafe extern "C" fn venue_new(ptr: *const c_char) -> Venue {
     Venue::from(cstr_to_str(ptr))
 }
 
 #[no_mangle]
 pub extern "C" fn venue_hash(id: &Venue) -> u64 {
-    id.value.precomputed_hash()
+    id.inner().precomputed_hash()
 }
 
 #[no_mangle]
 pub extern "C" fn venue_is_synthetic(venue: &Venue) -> u8 {
     u8::from(venue.is_synthetic())
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/identifiers/venue_order_id.rs` & `nautilus_trader-1.191.0/nautilus_core/indicators/src/testing.rs`

 * *Files 20% similar despite different names*

```diff
@@ -9,27 +9,29 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::ffi::c_char;
-
-use nautilus_core::ffi::string::cstr_to_str;
-
-use crate::identifiers::venue_order_id::VenueOrderId;
-
-/// Returns a Nautilus identifier from a C string pointer.
+/// Checks if two floating-point numbers are approximately equal within the
+/// margin of floating-point precision.
 ///
-/// # Safety
+/// * `a` - The first floating-point number.
+/// * `b` - The second floating-point number.
 ///
-/// - Assumes `ptr` is a valid C string pointer.
-#[no_mangle]
-pub unsafe extern "C" fn venue_order_id_new(ptr: *const c_char) -> VenueOrderId {
-    VenueOrderId::from(cstr_to_str(ptr))
-}
-
-#[no_mangle]
-pub extern "C" fn venue_order_id_hash(id: &VenueOrderId) -> u64 {
-    id.value.precomputed_hash()
+/// # Returns
+///
+/// Returns `true` if the absolute difference between `a` and `b` is less than
+/// `f64::EPSILON`, indicating that they are approximately equal.
+///
+/// # Example
+///
+/// ```
+/// let a = 0.1 + 0.2;
+/// let b = 0.3;
+/// assert!(approx_equal(a, b));
+/// ```
+#[must_use]
+pub fn approx_equal(a: f64, b: f64) -> bool {
+    (a - b).abs() < f64::EPSILON
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/instruments/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/instruments/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/instruments/synthetic.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/instruments/synthetic.rs`

 * *Files 2% similar despite different names*

```diff
@@ -20,15 +20,15 @@
 
 use nautilus_core::{
     ffi::{
         cvec::CVec,
         parsing::{bytes_to_string_vec, string_vec_to_bytes},
         string::{cstr_to_str, str_to_cstr},
     },
-    time::UnixNanos,
+    nanos::UnixNanos,
 };
 
 use crate::{
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     instruments::synthetic::SyntheticInstrument,
     types::price::{Price, ERROR_PRICE},
 };
@@ -80,16 +80,16 @@
         .collect::<Vec<InstrumentId>>();
     let formula = cstr_to_str(formula_ptr).to_string();
     let synth = SyntheticInstrument::new(
         symbol,
         price_precision,
         components,
         formula,
-        ts_event,
-        ts_init,
+        ts_event.into(),
+        ts_init.into(),
     );
 
     SyntheticInstrument_API(Box::new(synth.unwrap()))
 }
 
 #[no_mangle]
 pub extern "C" fn synthetic_instrument_drop(synth: SyntheticInstrument_API) {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/orderbook/book.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/orderbook/book.rs`

 * *Files 4% similar despite different names*

```diff
@@ -16,54 +16,59 @@
 use std::{
     ffi::c_char,
     ops::{Deref, DerefMut},
 };
 
 use nautilus_core::ffi::{cvec::CVec, string::str_to_cstr};
 
-use super::{container::OrderBookContainer, level::Level_API};
+use super::level::Level_API;
 use crate::{
     data::{
         delta::OrderBookDelta, deltas::OrderBookDeltas_API, depth::OrderBookDepth10,
         order::BookOrder, quote::QuoteTick, trade::TradeTick,
     },
     enums::{BookType, OrderSide},
     identifiers::instrument_id::InstrumentId,
+    orderbook::{
+        aggregation::{update_book_with_quote_tick, update_book_with_trade_tick},
+        analysis::book_check_integrity,
+        book::OrderBook,
+    },
     types::{price::Price, quantity::Quantity},
 };
 
 /// Provides a C compatible Foreign Function Interface (FFI) for an underlying `OrderBook`.
 ///
 /// This struct wraps `OrderBook` in a way that makes it compatible with C function
 /// calls, enabling interaction with `OrderBook` in a C environment.
 ///
 /// It implements the `Deref` trait, allowing instances of `OrderBook_API` to be
 /// dereferenced to `OrderBook`, providing access to `OrderBook`'s methods without
 /// having to manually access the underlying `OrderBook` instance.
 #[repr(C)]
 #[allow(non_camel_case_types)]
-pub struct OrderBook_API(Box<OrderBookContainer>);
+pub struct OrderBook_API(Box<OrderBook>);
 
 impl Deref for OrderBook_API {
-    type Target = OrderBookContainer;
+    type Target = OrderBook;
 
     fn deref(&self) -> &Self::Target {
         &self.0
     }
 }
 
 impl DerefMut for OrderBook_API {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.0
     }
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_new(instrument_id: InstrumentId, book_type: BookType) -> OrderBook_API {
-    OrderBook_API(Box::new(OrderBookContainer::new(instrument_id, book_type)))
+    OrderBook_API(Box::new(OrderBook::new(book_type, instrument_id)))
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_drop(book: OrderBook_API) {
     drop(book); // Memory freed here
 }
 
@@ -80,70 +85,73 @@
 #[no_mangle]
 pub extern "C" fn orderbook_book_type(book: &OrderBook_API) -> BookType {
     book.book_type
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_sequence(book: &OrderBook_API) -> u64 {
-    book.sequence()
+    book.sequence
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_ts_last(book: &OrderBook_API) -> u64 {
-    book.ts_last()
+    book.ts_last.into()
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_count(book: &OrderBook_API) -> u64 {
-    book.count()
+    book.count
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_add(
     book: &mut OrderBook_API,
     order: BookOrder,
-    ts_event: u64,
+    flags: u8,
     sequence: u64,
+    ts_event: u64,
 ) {
-    book.add(order, ts_event, sequence);
+    book.add(order, flags, sequence, ts_event.into());
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_update(
     book: &mut OrderBook_API,
     order: BookOrder,
-    ts_event: u64,
+    flags: u8,
     sequence: u64,
+    ts_event: u64,
 ) {
-    book.update(order, ts_event, sequence);
+    book.update(order, flags, sequence, ts_event.into());
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_delete(
     book: &mut OrderBook_API,
     order: BookOrder,
-    ts_event: u64,
+    flags: u8,
     sequence: u64,
+    ts_event: u64,
 ) {
-    book.delete(order, ts_event, sequence);
+    book.delete(order, flags, sequence, ts_event.into());
 }
 
 #[no_mangle]
-pub extern "C" fn orderbook_clear(book: &mut OrderBook_API, ts_event: u64, sequence: u64) {
-    book.clear(ts_event, sequence);
+pub extern "C" fn orderbook_clear(book: &mut OrderBook_API, sequence: u64, ts_event: u64) {
+    book.clear(sequence, ts_event.into());
 }
 
 #[no_mangle]
-pub extern "C" fn orderbook_clear_bids(book: &mut OrderBook_API, ts_event: u64, sequence: u64) {
-    book.clear_bids(ts_event, sequence);
+pub extern "C" fn orderbook_clear_bids(book: &mut OrderBook_API, sequence: u64, ts_event: u64) {
+    book.clear_bids(sequence, ts_event.into());
 }
 
 #[no_mangle]
-pub extern "C" fn orderbook_clear_asks(book: &mut OrderBook_API, ts_event: u64, sequence: u64) {
-    book.clear_asks(ts_event, sequence);
+pub extern "C" fn orderbook_clear_asks(book: &mut OrderBook_API, sequence: u64, ts_event: u64) {
+    book.clear_asks(sequence, ts_event.into());
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_apply_delta(book: &mut OrderBook_API, delta: OrderBookDelta) {
     book.apply_delta(delta);
 }
 
@@ -156,26 +164,28 @@
 #[no_mangle]
 pub extern "C" fn orderbook_apply_depth(book: &mut OrderBook_API, depth: OrderBookDepth10) {
     book.apply_depth(depth);
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_bids(book: &mut OrderBook_API) -> CVec {
-    book.bids()
-        .iter()
-        .map(|l| Level_API::new(l.to_owned().clone()))
+    book.bids
+        .levels
+        .values()
+        .map(|level| Level_API::new(level.clone()))
         .collect::<Vec<Level_API>>()
         .into()
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_asks(book: &mut OrderBook_API) -> CVec {
-    book.asks()
-        .iter()
-        .map(|l| Level_API::new(l.to_owned().clone()))
+    book.asks
+        .levels
+        .values()
+        .map(|level| Level_API::new(level.clone()))
         .collect::<Vec<Level_API>>()
         .into()
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_has_bid(book: &mut OrderBook_API) -> u8 {
     u8::from(book.has_bid())
@@ -236,32 +246,42 @@
     book: &mut OrderBook_API,
     price: Price,
     order_side: OrderSide,
 ) -> f64 {
     book.get_quantity_for_price(price, order_side)
 }
 
+/// Updates the order book with a quote tick.
+///
+/// # Panics
+///
+/// If book type is not `L1_MBP`.
 #[no_mangle]
-pub extern "C" fn orderbook_update_quote_tick(book: &mut OrderBook_API, tick: &QuoteTick) {
-    book.update_quote_tick(tick);
+pub extern "C" fn orderbook_update_quote_tick(book: &mut OrderBook_API, quote: &QuoteTick) {
+    update_book_with_quote_tick(book, quote).unwrap();
 }
 
+/// Updates the order book with a trade tick.
+///
+/// # Panics
+///
+/// If book type is not `L1_MBP`.
 #[no_mangle]
 pub extern "C" fn orderbook_update_trade_tick(book: &mut OrderBook_API, tick: &TradeTick) {
-    book.update_trade_tick(tick);
+    update_book_with_trade_tick(book, tick).unwrap();
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_simulate_fills(book: &OrderBook_API, order: BookOrder) -> CVec {
     book.simulate_fills(&order).into()
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_check_integrity(book: &OrderBook_API) -> u8 {
-    u8::from(book.check_integrity().is_ok())
+    u8::from(book_check_integrity(book).is_ok())
 }
 
 // TODO: This struct implementation potentially leaks memory
 // TODO: Skip clippy check for now since it requires large modification
 #[allow(clippy::drop_non_drop)]
 #[no_mangle]
 pub extern "C" fn vec_fills_drop(v: CVec) {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/orderbook/level.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/orderbook/level.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/orderbook/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/python/wranglers/mod.rs`

 * *Files 5% similar despite different names*

```diff
@@ -9,10 +9,11 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod book;
-pub mod container;
-pub mod level;
+pub mod bar;
+pub mod delta;
+pub mod quote;
+pub mod trade;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/types/currency.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/types/currency.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/types/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/types/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/types/money.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/types/money.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/types/price.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/types/price.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/ffi/types/quantity.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/types/quantity.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/account_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/component_id.rs`

 * *Files 19% similar despite different names*

```diff
@@ -14,102 +14,83 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     fmt::{Debug, Display, Formatter},
     hash::Hash,
 };
 
-use nautilus_core::correctness::{check_string_contains, check_valid_string};
+use nautilus_core::correctness::check_valid_string;
 use ustr::Ustr;
 
-/// Represents a valid account ID.
-///
-/// Must be correctly formatted with two valid strings either side of a hyphen '-'.
-/// It is expected an account ID is the name of the issuer with an account number
-/// separated by a hyphen.
-///
-/// Example: "IB-D02851908".
+/// Represents a valid component ID.
 #[repr(C)]
 #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct AccountId {
-    /// The account ID value.
-    pub value: Ustr,
-}
+pub struct ComponentId(Ustr);
 
-impl AccountId {
+impl ComponentId {
+    /// Creates a new `ComponentId` instance from the given identifier value.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the value is not a valid string.
     pub fn new(value: &str) -> anyhow::Result<Self> {
         check_valid_string(value, stringify!(value))?;
-        check_string_contains(value, "-", stringify!(value))?;
 
-        Ok(Self {
-            value: Ustr::from(value),
-        })
+        Ok(Self(Ustr::from(value)))
+    }
+
+    /// Sets the inner identifier value.
+    pub(crate) fn set_inner(&mut self, value: &str) {
+        self.0 = Ustr::from(value);
     }
-}
 
-impl Default for AccountId {
-    fn default() -> Self {
-        Self {
-            value: Ustr::from("SIM-001"),
-        }
+    /// Returns the inner identifier value.
+    #[must_use]
+    pub fn inner(&self) -> Ustr {
+        self.0
+    }
+
+    /// Returns the inner identifier value as a string slice.
+    #[must_use]
+    pub fn as_str(&self) -> &str {
+        self.0.as_str()
     }
 }
 
-impl Debug for AccountId {
+impl Debug for ComponentId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+        write!(f, "{:?}", self.0)
     }
 }
 
-impl Display for AccountId {
+impl Display for ComponentId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        write!(f, "{}", self.0)
     }
 }
 
-impl From<&str> for AccountId {
+impl From<&str> for ComponentId {
     fn from(input: &str) -> Self {
         Self::new(input).unwrap()
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use rstest::rstest;
 
-    use super::*;
+    use super::ComponentId;
     use crate::identifiers::stubs::*;
 
     #[rstest]
-    fn test_account_id_new_invalid_string() {
-        let s = "";
-        let result = AccountId::new(s);
-        assert!(result.is_err());
-    }
-
-    #[rstest]
-    fn test_account_id_new_missing_hyphen() {
-        let s = "123456789";
-        let result = AccountId::new(s);
-        assert!(result.is_err());
-    }
-
-    #[rstest]
-    fn test_account_id_fmt() {
-        let s = "IB-U123456789";
-        let account_id = AccountId::new(s).unwrap();
-        let formatted = format!("{account_id}");
-        assert_eq!(formatted, s);
-    }
-
-    #[rstest]
-    fn test_string_reprs(account_ib: AccountId) {
-        assert_eq!(account_ib.to_string(), "IB-1234567890");
+    fn test_string_reprs(component_risk_engine: ComponentId) {
+        assert_eq!(component_risk_engine.as_str(), "RiskEngine");
+        assert_eq!(format!("{component_risk_engine}"), "RiskEngine");
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/client_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/client_id.rs`

 * *Files 13% similar despite different names*

```diff
@@ -24,38 +24,62 @@
 /// Represents a system client ID.
 #[repr(C)]
 #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct ClientId {
-    /// The client ID value.
-    pub value: Ustr,
-}
+pub struct ClientId(Ustr);
 
 impl ClientId {
+    /// Creates a new `ClientId` instance from the given identifier value.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the value is not a valid string.
     pub fn new(value: &str) -> anyhow::Result<Self> {
         check_valid_string(value, stringify!(value))?;
 
-        Ok(Self {
-            value: Ustr::from(value),
-        })
+        Ok(Self(Ustr::from(value)))
+    }
+
+    /// Sets the inner identifier value.
+    pub(crate) fn set_inner(&mut self, value: &str) {
+        self.0 = Ustr::from(value);
+    }
+
+    /// Returns the inner identifier value.
+    #[must_use]
+    pub fn inner(&self) -> Ustr {
+        self.0
+    }
+
+    /// Returns the inner identifier value as a string slice.
+    #[must_use]
+    pub fn as_str(&self) -> &str {
+        self.0.as_str()
+    }
+}
+
+impl Default for ClientId {
+    fn default() -> Self {
+        // SAFETY: Default value is safe
+        Self::new("SIM").unwrap()
     }
 }
 
 impl Debug for ClientId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+        write!(f, "{:?}", self.0)
     }
 }
 
 impl Display for ClientId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        write!(f, "{}", self.0)
     }
 }
 
 impl From<&str> for ClientId {
     fn from(input: &str) -> Self {
         Self::new(input).unwrap()
     }
@@ -69,11 +93,11 @@
     use rstest::rstest;
 
     use super::*;
     use crate::identifiers::stubs::*;
 
     #[rstest]
     fn test_string_reprs(client_id_binance: ClientId) {
-        assert_eq!(client_id_binance.to_string(), "BINANCE");
+        assert_eq!(client_id_binance.as_str(), "BINANCE");
         assert_eq!(format!("{client_id_binance}"), "BINANCE");
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/client_order_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/client_order_id.rs`

 * *Files 8% similar despite different names*

```diff
@@ -24,46 +24,60 @@
 /// Represents a valid client order ID (assigned by the Nautilus system).
 #[repr(C)]
 #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct ClientOrderId {
-    /// The client order ID value.
-    pub value: Ustr,
-}
+pub struct ClientOrderId(Ustr);
 
 impl ClientOrderId {
+    /// Creates a new `ClientOrderId` instance from the given identifier value.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the value is not a valid string.
     pub fn new(value: &str) -> anyhow::Result<Self> {
         check_valid_string(value, stringify!(value))?;
 
-        Ok(Self {
-            value: Ustr::from(value),
-        })
+        Ok(Self(Ustr::from(value)))
+    }
+
+    /// Sets the inner identifier value.
+    pub(crate) fn set_inner(&mut self, value: &str) {
+        self.0 = Ustr::from(value);
+    }
+
+    /// Returns the inner identifier value.
+    pub fn inner(&self) -> Ustr {
+        self.0
+    }
+
+    /// Returns the inner identifier value as a string slice.
+    pub fn as_str(&self) -> &str {
+        self.0.as_str()
     }
 }
 
 impl Default for ClientOrderId {
     fn default() -> Self {
-        Self {
-            value: Ustr::from("O-123456789"),
-        }
+        // SAFETY: Default value is safe
+        Self::new("O-123456789").unwrap()
     }
 }
 
 impl Debug for ClientOrderId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+        write!(f, "{:?}", self.0)
     }
 }
 
 impl Display for ClientOrderId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        write!(f, "{}", self.0)
     }
 }
 
 #[must_use]
 pub fn optional_ustr_to_vec_client_order_ids(s: Option<Ustr>) -> Option<Vec<ClientOrderId>> {
     s.map(|ustr| {
         let s_str = ustr.to_string();
@@ -75,15 +89,15 @@
 }
 
 #[must_use]
 pub fn optional_vec_client_order_ids_to_ustr(vec: Option<Vec<ClientOrderId>>) -> Option<Ustr> {
     vec.map(|client_order_ids| {
         let s: String = client_order_ids
             .into_iter()
-            .map(|id| id.value.to_string())
+            .map(|id| id.to_string())
             .collect::<Vec<String>>()
             .join(",");
         Ustr::from(&s)
     })
 }
 
 impl From<&str> for ClientOrderId {
@@ -106,29 +120,29 @@
             optional_ustr_to_vec_client_order_ids, optional_vec_client_order_ids_to_ustr,
         },
         stubs::*,
     };
 
     #[rstest]
     fn test_string_reprs(client_order_id: ClientOrderId) {
-        assert_eq!(client_order_id.to_string(), "O-20200814-102234-001-001-1");
+        assert_eq!(client_order_id.as_str(), "O-20200814-102234-001-001-1");
         assert_eq!(format!("{client_order_id}"), "O-20200814-102234-001-001-1");
     }
 
     #[rstest]
     fn test_optional_ustr_to_vec_client_order_ids() {
         // Test with None
         assert_eq!(optional_ustr_to_vec_client_order_ids(None), None);
 
         // Test with Some
         let ustr = Ustr::from("id1,id2,id3");
         let client_order_ids = optional_ustr_to_vec_client_order_ids(Some(ustr)).unwrap();
-        assert_eq!(client_order_ids[0].value.to_string(), "id1");
-        assert_eq!(client_order_ids[1].value.to_string(), "id2");
-        assert_eq!(client_order_ids[2].value.to_string(), "id3");
+        assert_eq!(client_order_ids[0].as_str(), "id1");
+        assert_eq!(client_order_ids[1].as_str(), "id2");
+        assert_eq!(client_order_ids[2].as_str(), "id3");
     }
 
     #[rstest]
     fn test_optional_vec_client_order_ids_to_ustr() {
         // Test with None
         assert_eq!(optional_vec_client_order_ids_to_ustr(None), None);
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/component_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/exec_algorithm_id.rs`

 * *Files 17% similar despite different names*

```diff
@@ -17,63 +17,80 @@
     fmt::{Debug, Display, Formatter},
     hash::Hash,
 };
 
 use nautilus_core::correctness::check_valid_string;
 use ustr::Ustr;
 
-/// Represents a valid component ID.
+/// Represents a valid execution algorithm ID.
 #[repr(C)]
 #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct ComponentId {
-    /// The component ID value.
-    pub value: Ustr,
-}
+pub struct ExecAlgorithmId(Ustr);
 
-impl ComponentId {
+impl ExecAlgorithmId {
+    /// Creates a new `ExecAlgorithmId` instance from the given identifier value.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the value is not a valid string.
     pub fn new(value: &str) -> anyhow::Result<Self> {
         check_valid_string(value, stringify!(value))?;
 
-        Ok(Self {
-            value: Ustr::from(value),
-        })
+        Ok(Self(Ustr::from(value)))
+    }
+
+    /// Sets the inner identifier value.
+    pub(crate) fn set_inner(&mut self, value: &str) {
+        self.0 = Ustr::from(value);
+    }
+
+    /// Returns the inner identifier value.
+    #[must_use]
+    pub fn inner(&self) -> Ustr {
+        self.0
+    }
+
+    /// Returns the inner identifier value as a string slice.
+    #[must_use]
+    pub fn as_str(&self) -> &str {
+        self.0.as_str()
     }
 }
 
-impl Debug for ComponentId {
+impl Debug for ExecAlgorithmId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+        write!(f, "{:?}", self.0)
     }
 }
 
-impl Display for ComponentId {
+impl Display for ExecAlgorithmId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        write!(f, "{}", self.0)
     }
 }
 
-impl From<&str> for ComponentId {
+impl From<&str> for ExecAlgorithmId {
     fn from(input: &str) -> Self {
         Self::new(input).unwrap()
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use rstest::rstest;
 
-    use super::ComponentId;
+    use super::*;
     use crate::identifiers::stubs::*;
 
     #[rstest]
-    fn test_string_reprs(component_risk_engine: ComponentId) {
-        assert_eq!(component_risk_engine.to_string(), "RiskEngine");
-        assert_eq!(format!("{component_risk_engine}"), "RiskEngine");
+    fn test_string_reprs(exec_algorithm_id: ExecAlgorithmId) {
+        assert_eq!(exec_algorithm_id.as_str(), "001");
+        assert_eq!(format!("{exec_algorithm_id}"), "001");
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/exec_algorithm_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/order_list_id.rs`

 * *Files 21% similar despite different names*

```diff
@@ -17,49 +17,66 @@
     fmt::{Debug, Display, Formatter},
     hash::Hash,
 };
 
 use nautilus_core::correctness::check_valid_string;
 use ustr::Ustr;
 
-/// Represents a valid execution algorithm ID.
+/// Represents a valid order list ID (assigned by the Nautilus system).
 #[repr(C)]
 #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct ExecAlgorithmId {
-    /// The execution algorithm ID value.
-    pub value: Ustr,
-}
+pub struct OrderListId(Ustr);
 
-impl ExecAlgorithmId {
+impl OrderListId {
+    /// Creates a new `OrderListId` instance from the given identifier value.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the value is not a valid string.
     pub fn new(value: &str) -> anyhow::Result<Self> {
         check_valid_string(value, stringify!(value))?;
 
-        Ok(Self {
-            value: Ustr::from(value),
-        })
+        Ok(Self(Ustr::from(value)))
+    }
+
+    /// Sets the inner identifier value.
+    pub(crate) fn set_inner(&mut self, value: &str) {
+        self.0 = Ustr::from(value);
+    }
+
+    /// Returns the inner identifier value.
+    #[must_use]
+    pub fn inner(&self) -> Ustr {
+        self.0
+    }
+
+    /// Returns the inner identifier value as a string slice.
+    #[must_use]
+    pub fn as_str(&self) -> &str {
+        self.0.as_str()
     }
 }
 
-impl Debug for ExecAlgorithmId {
+impl Debug for OrderListId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+        write!(f, "{:?}", self.0)
     }
 }
 
-impl Display for ExecAlgorithmId {
+impl Display for OrderListId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        write!(f, "{}", self.0)
     }
 }
 
-impl From<&str> for ExecAlgorithmId {
+impl From<&str> for OrderListId {
     fn from(input: &str) -> Self {
         Self::new(input).unwrap()
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
@@ -68,12 +85,12 @@
 mod tests {
     use rstest::rstest;
 
     use super::*;
     use crate::identifiers::stubs::*;
 
     #[rstest]
-    fn test_string_reprs(exec_algorithm_id: ExecAlgorithmId) {
-        assert_eq!(exec_algorithm_id.to_string(), "001");
-        assert_eq!(format!("{exec_algorithm_id}"), "001");
+    fn test_string_reprs(order_list_id_test: OrderListId) {
+        assert_eq!(order_list_id_test.as_str(), "001");
+        assert_eq!(format!("{order_list_id_test}"), "001");
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/instrument_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/instrument_id.rs`

 * *Files 2% similar despite different names*

```diff
@@ -36,14 +36,15 @@
     /// The instruments ticker symbol.
     pub symbol: Symbol,
     /// The instruments trading venue.
     pub venue: Venue,
 }
 
 impl InstrumentId {
+    /// Creates a new `InstrumentId` instance from the given `Symbol` and `Venue`.
     #[must_use]
     pub fn new(symbol: Symbol, venue: Venue) -> Self {
         Self { symbol, venue }
     }
 
     #[must_use]
     pub fn is_synthetic(&self) -> bool {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/macros.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/macros.rs`

 * *Files 9% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 macro_rules! impl_serialization_for_identifier {
     ($ty:ty) => {
         impl Serialize for $ty {
             fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
             where
                 S: Serializer,
             {
-                self.value.serialize(serializer)
+                self.inner().serialize(serializer)
             }
         }
 
         impl<'de> Deserialize<'de> for $ty {
             fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
             where
                 D: Deserializer<'de>,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/order_list_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/venue_order_id.rs`

 * *Files 21% similar despite different names*

```diff
@@ -17,63 +17,86 @@
     fmt::{Debug, Display, Formatter},
     hash::Hash,
 };
 
 use nautilus_core::correctness::check_valid_string;
 use ustr::Ustr;
 
-/// Represents a valid order list ID (assigned by the Nautilus system).
+/// Represents a valid venue order ID (assigned by a trading venue).
 #[repr(C)]
 #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct OrderListId {
-    /// The order list ID value.
-    pub value: Ustr,
-}
+pub struct VenueOrderId(Ustr);
 
-impl OrderListId {
+impl VenueOrderId {
+    /// Creates a new `VenueOrderId` instance from the given identifier value.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the value is not a valid string.
     pub fn new(value: &str) -> anyhow::Result<Self> {
         check_valid_string(value, stringify!(value))?;
 
-        Ok(Self {
-            value: Ustr::from(value),
-        })
+        Ok(Self(Ustr::from(value)))
+    }
+
+    /// Sets the inner identifier value.
+    pub(crate) fn set_inner(&mut self, value: &str) {
+        self.0 = Ustr::from(value);
+    }
+
+    /// Returns the inner identifier value.
+    #[must_use]
+    pub fn inner(&self) -> Ustr {
+        self.0
+    }
+
+    /// Returns the inner identifier value as a string slice.
+    #[must_use]
+    pub fn as_str(&self) -> &str {
+        self.0.as_str()
+    }
+}
+
+impl Default for VenueOrderId {
+    fn default() -> Self {
+        // SAFETY: Default value is safe
+        Self::new("001").unwrap()
     }
 }
 
-impl Debug for OrderListId {
+impl Debug for VenueOrderId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+        write!(f, "{:?}", self.0)
     }
 }
 
-impl Display for OrderListId {
+impl Display for VenueOrderId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        write!(f, "{}", self.0)
     }
 }
 
-impl From<&str> for OrderListId {
+impl From<&str> for VenueOrderId {
     fn from(input: &str) -> Self {
         Self::new(input).unwrap()
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use rstest::rstest;
 
-    use super::*;
-    use crate::identifiers::stubs::*;
+    use crate::identifiers::{stubs::*, venue_order_id::VenueOrderId};
 
     #[rstest]
-    fn test_string_reprs(order_list_id_test: OrderListId) {
-        assert_eq!(order_list_id_test.to_string(), "001");
-        assert_eq!(format!("{order_list_id_test}"), "001");
+    fn test_string_reprs(venue_order_id: VenueOrderId) {
+        assert_eq!(venue_order_id.as_str(), "001");
+        assert_eq!(format!("{venue_order_id}"), "001");
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/position_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/position_id.rs`

 * *Files 14% similar despite different names*

```diff
@@ -24,45 +24,61 @@
 /// Represents a valid position ID.
 #[repr(C)]
 #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct PositionId {
-    /// The position ID value.
-    pub value: Ustr,
-}
+pub struct PositionId(Ustr);
 
 impl PositionId {
+    /// Creates a new `PositionId` instance from the given identifier value.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the value is not a valid string.
     pub fn new(value: &str) -> anyhow::Result<Self> {
         check_valid_string(value, stringify!(value))?;
 
-        Ok(Self {
-            value: Ustr::from(value),
-        })
+        Ok(Self(Ustr::from(value)))
+    }
+
+    /// Sets the inner identifier value.
+    pub(crate) fn set_inner(&mut self, value: &str) {
+        self.0 = Ustr::from(value);
+    }
+
+    /// Returns the inner identifier value.
+    #[must_use]
+    pub fn inner(&self) -> Ustr {
+        self.0
+    }
+
+    /// Returns the inner identifier value as a string slice.
+    #[must_use]
+    pub fn as_str(&self) -> &str {
+        self.0.as_str()
     }
 }
 
 impl Default for PositionId {
     fn default() -> Self {
-        Self {
-            value: Ustr::from("P-001"),
-        }
+        // SAFETY: Default value is safe
+        Self::new("P-001").unwrap()
     }
 }
 
 impl Debug for PositionId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+        write!(f, "{:?}", self.0)
     }
 }
 impl Display for PositionId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        write!(f, "{}", self.0)
     }
 }
 
 impl From<&str> for PositionId {
     fn from(input: &str) -> Self {
         Self::new(input).unwrap()
     }
@@ -76,11 +92,11 @@
     use rstest::rstest;
 
     use super::PositionId;
     use crate::identifiers::stubs::*;
 
     #[rstest]
     fn test_string_reprs(position_id_test: PositionId) {
-        assert_eq!(position_id_test.to_string(), "P-123456789");
+        assert_eq!(position_id_test.as_str(), "P-123456789");
         assert_eq!(format!("{position_id_test}"), "P-123456789");
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/strategy_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/strategy_id.rs`

 * *Files 15% similar despite different names*

```diff
@@ -33,67 +33,82 @@
 /// do not collide with those from another strategy within the node instance.
 #[repr(C)]
 #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct StrategyId {
-    /// The strategy ID value.
-    pub value: Ustr,
-}
+pub struct StrategyId(Ustr);
 
 impl StrategyId {
+    /// Creates a new `StrategyId` instance from the given identifier value.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the value is not a valid string, or does not contain a hyphen '-' separator.
     pub fn new(value: &str) -> anyhow::Result<Self> {
         check_valid_string(value, stringify!(value))?;
         if value != EXTERNAL_STRATEGY_ID {
             check_string_contains(value, "-", stringify!(value))?;
         }
 
-        Ok(Self {
-            value: Ustr::from(value),
-        })
+        Ok(Self(Ustr::from(value)))
+    }
+
+    /// Sets the inner identifier value.
+    pub(crate) fn set_inner(&mut self, value: &str) {
+        self.0 = Ustr::from(value);
+    }
+
+    /// Returns the inner identifier value.
+    #[must_use]
+    pub fn inner(&self) -> Ustr {
+        self.0
+    }
+
+    /// Returns the inner identifier value as a string slice.
+    #[must_use]
+    pub fn as_str(&self) -> &str {
+        self.0.as_str()
     }
 
     #[must_use]
     pub fn external() -> Self {
-        Self {
-            value: Ustr::from(EXTERNAL_STRATEGY_ID),
-        }
+        // SAFETY:: Constant value is safe
+        Self::new(EXTERNAL_STRATEGY_ID).unwrap()
     }
 
     #[must_use]
     pub fn is_external(&self) -> bool {
-        self.value == EXTERNAL_STRATEGY_ID
+        self.0 == EXTERNAL_STRATEGY_ID
     }
 
     #[must_use]
     pub fn get_tag(&self) -> &str {
         // SAFETY: Unwrap safe as value previously validated
-        self.value.split('-').last().unwrap()
+        self.0.split('-').last().unwrap()
     }
 }
 
 impl Default for StrategyId {
     fn default() -> Self {
-        Self {
-            value: Ustr::from("S-001"),
-        }
+        // SAFETY: Default value is safe
+        Self::new("S-001").unwrap()
     }
 }
 
 impl Debug for StrategyId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+        write!(f, "{:?}", self.0)
     }
 }
 
 impl Display for StrategyId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        write!(f, "{}", self.0)
     }
 }
 
 impl From<&str> for StrategyId {
     fn from(input: &str) -> Self {
         Self::new(input).unwrap()
     }
@@ -107,21 +122,21 @@
     use rstest::rstest;
 
     use super::StrategyId;
     use crate::identifiers::stubs::*;
 
     #[rstest]
     fn test_string_reprs(strategy_id_ema_cross: StrategyId) {
-        assert_eq!(strategy_id_ema_cross.to_string(), "EMACross-001");
+        assert_eq!(strategy_id_ema_cross.as_str(), "EMACross-001");
         assert_eq!(format!("{strategy_id_ema_cross}"), "EMACross-001");
     }
 
     #[rstest]
     fn test_get_external() {
-        assert_eq!(StrategyId::external().value, "EXTERNAL");
+        assert_eq!(StrategyId::external().as_str(), "EXTERNAL");
     }
 
     #[rstest]
     fn test_is_external() {
         assert!(StrategyId::external().is_external());
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/stubs.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/stubs.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/symbol.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/symbol.rs`

 * *Files 17% similar despite different names*

```diff
@@ -17,60 +17,80 @@
     fmt::{Debug, Display, Formatter},
     hash::Hash,
 };
 
 use nautilus_core::correctness::check_valid_string;
 use ustr::Ustr;
 
-/// Represents a valid ticker symbol ID for a tradable financial market instrument.
+/// Represents a valid ticker symbol ID for a tradable instrument.
 #[repr(C)]
 #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct Symbol {
-    /// The ticker symbol ID value.
-    pub value: Ustr,
-}
+pub struct Symbol(Ustr);
 
 impl Symbol {
+    /// Creates a new `Symbol` instance from the given identifier value.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the value is not a valid string.
     pub fn new(value: &str) -> anyhow::Result<Self> {
         check_valid_string(value, stringify!(value))?;
 
-        Ok(Self {
-            value: Ustr::from(value),
-        })
+        Ok(Self(Ustr::from(value)))
+    }
+
+    /// Sets the inner identifier value.
+    pub(crate) fn set_inner(&mut self, value: &str) {
+        self.0 = Ustr::from(value);
     }
 
     #[must_use]
     pub fn from_str_unchecked(s: &str) -> Self {
-        Self {
-            value: Ustr::from(s),
-        }
+        Self(Ustr::from(s))
+    }
+
+    /// Returns the inner identifier value.
+    #[must_use]
+    pub fn inner(&self) -> Ustr {
+        self.0
+    }
+
+    /// Returns the inner identifier value as a string slice.
+    #[must_use]
+    pub fn as_str(&self) -> &str {
+        self.0.as_str()
     }
 }
 
 impl Default for Symbol {
     fn default() -> Self {
-        Self {
-            value: Ustr::from("AUD/USD"),
-        }
+        // SAFETY: Default value is safe
+        Self::new("AUD/USD").unwrap()
     }
 }
 
 impl Debug for Symbol {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+        write!(f, "{:?}", self.0)
     }
 }
 
 impl Display for Symbol {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        write!(f, "{}", self.0)
+    }
+}
+
+impl From<Ustr> for Symbol {
+    fn from(input: Ustr) -> Self {
+        Self(input)
     }
 }
 
 impl From<&str> for Symbol {
     fn from(input: &str) -> Self {
         Self::new(input).unwrap()
     }
@@ -83,11 +103,11 @@
 mod tests {
     use rstest::rstest;
 
     use crate::identifiers::{stubs::*, symbol::Symbol};
 
     #[rstest]
     fn test_string_reprs(symbol_eth_perp: Symbol) {
-        assert_eq!(symbol_eth_perp.to_string(), "ETH-PERP");
+        assert_eq!(symbol_eth_perp.as_str(), "ETH-PERP");
         assert_eq!(format!("{symbol_eth_perp}"), "ETH-PERP");
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/trade_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/trade_id.rs`

 * *Files 9% similar despite different names*

```diff
@@ -41,14 +41,19 @@
 )]
 pub struct TradeId {
     /// The trade match ID value as a fixed-length C string byte array (includes null terminator).
     pub(crate) value: [u8; 37], // cbindgen issue using the constant in the array
 }
 
 impl TradeId {
+    /// Creates a new `TradeId` instance from the given identifier value.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the value is not a valid string, or value length is greater than 36.
     pub fn new(value: &str) -> anyhow::Result<Self> {
         let cstr = CString::new(value).expect("`CString` conversion failed");
         Self::from_cstr(cstr)
     }
 
     pub fn from_cstr(cstr: CString) -> anyhow::Result<Self> {
         let bytes = cstr.as_bytes_with_nul();
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/trader_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/trader_id.rs`

 * *Files 13% similar despite different names*

```diff
@@ -30,53 +30,69 @@
 /// do not collide with those from another node instance.
 #[repr(C)]
 #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct TraderId {
-    /// The trader ID value.
-    pub value: Ustr,
-}
+pub struct TraderId(Ustr);
 
 impl TraderId {
+    /// Creates a new `TraderId` instance from the given identifier value.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the value is not a valid string, or does not contain a hyphen '-' separator.
     pub fn new(value: &str) -> anyhow::Result<Self> {
         check_valid_string(value, stringify!(value))?;
         check_string_contains(value, "-", stringify!(value))?;
 
-        Ok(Self {
-            value: Ustr::from(value),
-        })
+        Ok(Self(Ustr::from(value)))
+    }
+
+    /// Sets the inner identifier value.
+    pub(crate) fn set_inner(&mut self, value: &str) {
+        self.0 = Ustr::from(value);
+    }
+
+    /// Returns the inner identifier value.
+    #[must_use]
+    pub fn inner(&self) -> Ustr {
+        self.0
+    }
+
+    /// Returns the inner identifier value as a string slice.
+    #[must_use]
+    pub fn as_str(&self) -> &str {
+        self.0.as_str()
     }
 
     #[must_use]
     pub fn get_tag(&self) -> &str {
         // SAFETY: Unwrap safe as value previously validated
-        self.value.split('-').last().unwrap()
+        self.0.split('-').last().unwrap()
     }
 }
 
 impl Default for TraderId {
     fn default() -> Self {
-        Self {
-            value: Ustr::from("TRADER-000"),
-        }
+        // SAFETY: Default value is safe
+        Self(Ustr::from("TRADER-000"))
     }
 }
 
 impl Debug for TraderId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+        write!(f, "{:?}", self.0)
     }
 }
 
 impl Display for TraderId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        write!(f, "{}", self.0)
     }
 }
 
 impl From<&str> for TraderId {
     fn from(input: &str) -> Self {
         Self::new(input).unwrap()
     }
@@ -89,15 +105,15 @@
 mod tests {
     use rstest::rstest;
 
     use crate::identifiers::{stubs::*, trader_id::TraderId};
 
     #[rstest]
     fn test_string_reprs(trader_id: TraderId) {
-        assert_eq!(trader_id.to_string(), "TRADER-001");
+        assert_eq!(trader_id.as_str(), "TRADER-001");
         assert_eq!(format!("{trader_id}"), "TRADER-001");
     }
 
     #[rstest]
     fn test_get_tag(trader_id: TraderId) {
         assert_eq!(trader_id.get_tag(), "001");
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/identifiers/venue.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/identifiers/venue.rs`

 * *Files 22% similar despite different names*

```diff
@@ -28,33 +28,48 @@
 /// Represents a valid trading venue ID.
 #[repr(C)]
 #[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct Venue {
-    /// The venue ID value.
-    pub value: Ustr,
-}
+pub struct Venue(Ustr);
 
 impl Venue {
+    /// Creates a new `Venue` instance from the given identifier value.
+    ///
+    /// # Panics
+    ///
+    /// Panics if the value is not a valid string.
     pub fn new(value: &str) -> anyhow::Result<Self> {
         check_valid_string(value, stringify!(value))?;
 
-        Ok(Self {
-            value: Ustr::from(value),
-        })
+        Ok(Self(Ustr::from(value)))
+    }
+
+    /// Sets the inner identifier value.
+    pub(crate) fn set_inner(&mut self, value: &str) {
+        self.0 = Ustr::from(value);
+    }
+
+    /// Returns the inner identifier value.
+    #[must_use]
+    pub fn inner(&self) -> Ustr {
+        self.0
+    }
+
+    /// Returns the inner value as a string slice.
+    #[must_use]
+    pub fn as_str(&self) -> &str {
+        self.0.as_str()
     }
 
     #[must_use]
     pub fn from_str_unchecked(s: &str) -> Self {
-        Self {
-            value: Ustr::from(s),
-        }
+        Self(Ustr::from(s))
     }
 
     pub fn from_code(code: &str) -> anyhow::Result<Self> {
         let map_guard = VENUE_MAP
             .lock()
             .map_err(|e| anyhow::anyhow!("Error acquiring lock on `VENUE_MAP`: {e}"))?;
         map_guard
@@ -67,35 +82,34 @@
     pub fn synthetic() -> Self {
         // SAFETY: Unwrap safe as using known synthetic venue constant
         Self::new(SYNTHETIC_VENUE).unwrap()
     }
 
     #[must_use]
     pub fn is_synthetic(&self) -> bool {
-        self.value.as_str() == SYNTHETIC_VENUE
+        self.0.as_str() == SYNTHETIC_VENUE
     }
 }
 
 impl Default for Venue {
     fn default() -> Self {
-        Self {
-            value: Ustr::from("SIM"),
-        }
+        // SAFETY: Default value is safe
+        Self::new("SIM").unwrap()
     }
 }
 
 impl Debug for Venue {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+        write!(f, "{:?}", self.0)
     }
 }
 
 impl Display for Venue {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        write!(f, "{}", self.0)
     }
 }
 
 impl From<&str> for Venue {
     fn from(input: &str) -> Self {
         Self::new(input).unwrap()
     }
@@ -108,11 +122,11 @@
 mod tests {
     use rstest::rstest;
 
     use crate::identifiers::{stubs::*, venue::Venue};
 
     #[rstest]
     fn test_string_reprs(venue_binance: Venue) {
-        assert_eq!(venue_binance.to_string(), "BINANCE");
+        assert_eq!(venue_binance.as_str(), "BINANCE");
         assert_eq!(format!("{venue_binance}"), "BINANCE");
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/instruments/crypto_future.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/instruments/crypto_future.rs`

 * *Files 3% similar despite different names*

```diff
@@ -9,27 +9,24 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{
-    any::Any,
-    hash::{Hash, Hasher},
-};
+use std::hash::{Hash, Hasher};
 
 use nautilus_core::{
     correctness::{check_equal_u8, check_positive_i64, check_positive_u64},
-    time::UnixNanos,
+    nanos::UnixNanos,
 };
 use rust_decimal::Decimal;
 use serde::{Deserialize, Serialize};
 
-use super::Instrument;
+use super::{Instrument, InstrumentAny};
 use crate::{
     enums::{AssetClass, InstrumentClass},
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
 };
 
 #[repr(C)]
@@ -41,14 +38,15 @@
 #[cfg_attr(feature = "trivial_copy", derive(Copy))]
 pub struct CryptoFuture {
     pub id: InstrumentId,
     pub raw_symbol: Symbol,
     pub underlying: Currency,
     pub quote_currency: Currency,
     pub settlement_currency: Currency,
+    pub is_inverse: bool,
     pub activation_ns: UnixNanos,
     pub expiration_ns: UnixNanos,
     pub price_precision: u8,
     pub size_precision: u8,
     pub price_increment: Price,
     pub size_increment: Quantity,
     pub maker_fee: Decimal,
@@ -70,14 +68,15 @@
     #[allow(clippy::too_many_arguments)]
     pub fn new(
         id: InstrumentId,
         raw_symbol: Symbol,
         underlying: Currency,
         quote_currency: Currency,
         settlement_currency: Currency,
+        is_inverse: bool,
         activation_ns: UnixNanos,
         expiration_ns: UnixNanos,
         price_precision: u8,
         size_precision: u8,
         price_increment: Price,
         size_increment: Quantity,
         maker_fee: Decimal,
@@ -111,14 +110,15 @@
 
         Ok(Self {
             id,
             raw_symbol,
             underlying,
             quote_currency,
             settlement_currency,
+            is_inverse,
             activation_ns,
             expiration_ns,
             price_precision,
             size_precision,
             price_increment,
             size_increment,
             maker_fee,
@@ -149,14 +149,18 @@
 impl Hash for CryptoFuture {
     fn hash<H: Hasher>(&self, state: &mut H) {
         self.id.hash(state);
     }
 }
 
 impl Instrument for CryptoFuture {
+    fn into_any(self) -> InstrumentAny {
+        InstrumentAny::CryptoFuture(self)
+    }
+
     fn id(&self) -> InstrumentId {
         self.id
     }
 
     fn raw_symbol(&self) -> Symbol {
         self.raw_symbol
     }
@@ -178,15 +182,15 @@
     }
 
     fn settlement_currency(&self) -> Currency {
         self.settlement_currency
     }
 
     fn is_inverse(&self) -> bool {
-        false
+        self.is_inverse
     }
 
     fn price_precision(&self) -> u8 {
         self.price_precision
     }
 
     fn size_precision(&self) -> u8 {
@@ -229,18 +233,14 @@
     fn ts_event(&self) -> UnixNanos {
         self.ts_event
     }
 
     fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
-
-    fn as_any(&self) -> &dyn Any {
-        self
-    }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/instruments/crypto_perpetual.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/instruments/crypto_perpetual.rs`

 * *Files 2% similar despite different names*

```diff
@@ -9,26 +9,24 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{
-    any::Any,
-    hash::{Hash, Hasher},
-};
+use std::hash::{Hash, Hasher};
 
 use nautilus_core::{
     correctness::{check_equal_u8, check_positive_i64, check_positive_u64},
-    time::UnixNanos,
+    nanos::UnixNanos,
 };
 use rust_decimal::Decimal;
 use serde::{Deserialize, Serialize};
 
+use super::InstrumentAny;
 use crate::{
     enums::{AssetClass, InstrumentClass},
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     instruments::Instrument,
     types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
 };
 
@@ -146,14 +144,18 @@
 impl Hash for CryptoPerpetual {
     fn hash<H: Hasher>(&self, state: &mut H) {
         self.id.hash(state);
     }
 }
 
 impl Instrument for CryptoPerpetual {
+    fn into_any(self) -> InstrumentAny {
+        InstrumentAny::CryptoPerpetual(self)
+    }
+
     fn id(&self) -> InstrumentId {
         self.id
     }
 
     fn raw_symbol(&self) -> Symbol {
         self.raw_symbol
     }
@@ -226,18 +228,14 @@
         self.ts_event
     }
 
     fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
 
-    fn as_any(&self) -> &dyn Any {
-        self
-    }
-
     fn taker_fee(&self) -> Decimal {
         self.taker_fee
     }
 
     fn maker_fee(&self) -> Decimal {
         self.maker_fee
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/instruments/currency_pair.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/instruments/currency_pair.rs`

 * *Files 2% similar despite different names*

```diff
@@ -9,27 +9,24 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{
-    any::Any,
-    hash::{Hash, Hasher},
-};
+use std::hash::{Hash, Hasher};
 
 use nautilus_core::{
     correctness::{check_equal_u8, check_positive_i64, check_positive_u64},
-    time::UnixNanos,
+    nanos::UnixNanos,
 };
 use rust_decimal::Decimal;
 use serde::{Deserialize, Serialize};
 
-use super::Instrument;
+use super::{Instrument, InstrumentAny};
 use crate::{
     enums::{AssetClass, InstrumentClass},
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
 };
 
 #[repr(C)]
@@ -140,14 +137,18 @@
 impl Hash for CurrencyPair {
     fn hash<H: Hasher>(&self, state: &mut H) {
         self.id.hash(state);
     }
 }
 
 impl Instrument for CurrencyPair {
+    fn into_any(self) -> InstrumentAny {
+        InstrumentAny::CurrencyPair(self)
+    }
+
     fn id(&self) -> InstrumentId {
         self.id
     }
 
     fn raw_symbol(&self) -> Symbol {
         self.raw_symbol
     }
@@ -221,18 +222,14 @@
         self.ts_event
     }
 
     fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
 
-    fn as_any(&self) -> &dyn Any {
-        self
-    }
-
     fn margin_init(&self) -> Decimal {
         self.margin_init
     }
 
     fn margin_maint(&self) -> Decimal {
         self.margin_maint
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/instruments/equity.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/instruments/equity.rs`

 * *Files 5% similar despite different names*

```diff
@@ -9,28 +9,25 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{
-    any::Any,
-    hash::{Hash, Hasher},
-};
+use std::hash::{Hash, Hasher};
 
 use nautilus_core::{
     correctness::{check_equal_u8, check_positive_i64, check_valid_string_optional},
-    time::UnixNanos,
+    nanos::UnixNanos,
 };
 use rust_decimal::Decimal;
 use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
-use super::Instrument;
+use super::{Instrument, InstrumentAny};
 use crate::{
     enums::{AssetClass, InstrumentClass},
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     types::{currency::Currency, price::Price, quantity::Quantity},
 };
 
 #[repr(C)]
@@ -124,14 +121,18 @@
 impl Hash for Equity {
     fn hash<H: Hasher>(&self, state: &mut H) {
         self.id.hash(state);
     }
 }
 
 impl Instrument for Equity {
+    fn into_any(self) -> InstrumentAny {
+        InstrumentAny::Equity(self)
+    }
+
     fn id(&self) -> InstrumentId {
         self.id
     }
 
     fn raw_symbol(&self) -> Symbol {
         self.raw_symbol
     }
@@ -203,18 +204,14 @@
     fn ts_event(&self) -> UnixNanos {
         self.ts_event
     }
 
     fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
-
-    fn as_any(&self) -> &dyn Any {
-        self
-    }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/instruments/futures_contract.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/instruments/futures_contract.rs`

 * *Files 2% similar despite different names*

```diff
@@ -9,30 +9,27 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{
-    any::Any,
-    hash::{Hash, Hasher},
-};
+use std::hash::{Hash, Hasher};
 
 use nautilus_core::{
     correctness::{
         check_equal_u8, check_positive_i64, check_valid_string, check_valid_string_optional,
     },
-    time::UnixNanos,
+    nanos::UnixNanos,
 };
 use rust_decimal::Decimal;
 use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
-use super::Instrument;
+use super::{Instrument, InstrumentAny};
 use crate::{
     enums::{AssetClass, InstrumentClass},
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     types::{currency::Currency, price::Price, quantity::Quantity},
 };
 
 #[repr(C)]
@@ -140,14 +137,18 @@
 impl Hash for FuturesContract {
     fn hash<H: Hasher>(&self, state: &mut H) {
         self.id.hash(state);
     }
 }
 
 impl Instrument for FuturesContract {
+    fn into_any(self) -> InstrumentAny {
+        InstrumentAny::FuturesContract(self)
+    }
+
     fn id(&self) -> InstrumentId {
         self.id
     }
 
     fn raw_symbol(&self) -> Symbol {
         self.raw_symbol
     }
@@ -219,18 +220,14 @@
     fn ts_event(&self) -> UnixNanos {
         self.ts_event
     }
 
     fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
-
-    fn as_any(&self) -> &dyn Any {
-        self
-    }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/instruments/futures_spread.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/instruments/futures_spread.rs`

 * *Files 2% similar despite different names*

```diff
@@ -9,30 +9,27 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{
-    any::Any,
-    hash::{Hash, Hasher},
-};
+use std::hash::{Hash, Hasher};
 
 use nautilus_core::{
     correctness::{
         check_equal_u8, check_positive_i64, check_valid_string, check_valid_string_optional,
     },
-    time::UnixNanos,
+    nanos::UnixNanos,
 };
 use rust_decimal::Decimal;
 use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
-use super::Instrument;
+use super::{Instrument, InstrumentAny};
 use crate::{
     enums::{AssetClass, InstrumentClass},
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     types::{currency::Currency, price::Price, quantity::Quantity},
 };
 
 #[repr(C)]
@@ -144,14 +141,18 @@
 impl Hash for FuturesSpread {
     fn hash<H: Hasher>(&self, state: &mut H) {
         self.id.hash(state);
     }
 }
 
 impl Instrument for FuturesSpread {
+    fn into_any(self) -> InstrumentAny {
+        InstrumentAny::FuturesSpread(self)
+    }
+
     fn id(&self) -> InstrumentId {
         self.id
     }
 
     fn raw_symbol(&self) -> Symbol {
         self.raw_symbol
     }
@@ -223,18 +224,14 @@
     fn ts_event(&self) -> UnixNanos {
         self.ts_event
     }
 
     fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
-
-    fn as_any(&self) -> &dyn Any {
-        self
-    }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/instruments/options_contract.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/instruments/options_contract.rs`

 * *Files 2% similar despite different names*

```diff
@@ -9,30 +9,27 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{
-    any::Any,
-    hash::{Hash, Hasher},
-};
+use std::hash::{Hash, Hasher};
 
 use nautilus_core::{
     correctness::{
         check_equal_u8, check_positive_i64, check_valid_string, check_valid_string_optional,
     },
-    time::UnixNanos,
+    nanos::UnixNanos,
 };
 use rust_decimal::Decimal;
 use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
-use super::Instrument;
+use super::{Instrument, InstrumentAny};
 use crate::{
     enums::{AssetClass, InstrumentClass, OptionKind},
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     types::{currency::Currency, price::Price, quantity::Quantity},
 };
 
 #[repr(C)]
@@ -146,14 +143,18 @@
 impl Hash for OptionsContract {
     fn hash<H: Hasher>(&self, state: &mut H) {
         self.id.hash(state);
     }
 }
 
 impl Instrument for OptionsContract {
+    fn into_any(self) -> InstrumentAny {
+        InstrumentAny::OptionsContract(self)
+    }
+
     fn id(&self) -> InstrumentId {
         self.id
     }
 
     fn raw_symbol(&self) -> Symbol {
         self.raw_symbol
     }
@@ -225,18 +226,14 @@
     fn ts_event(&self) -> UnixNanos {
         self.ts_event
     }
 
     fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
-
-    fn as_any(&self) -> &dyn Any {
-        self
-    }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/instruments/options_spread.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/instruments/options_spread.rs`

 * *Files 1% similar despite different names*

```diff
@@ -9,30 +9,27 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{
-    any::Any,
-    hash::{Hash, Hasher},
-};
+use std::hash::{Hash, Hasher};
 
 use nautilus_core::{
     correctness::{
         check_equal_u8, check_positive_i64, check_valid_string, check_valid_string_optional,
     },
-    time::UnixNanos,
+    nanos::UnixNanos,
 };
 use rust_decimal::Decimal;
 use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
-use super::Instrument;
+use super::{Instrument, InstrumentAny};
 use crate::{
     enums::{AssetClass, InstrumentClass},
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     types::{currency::Currency, price::Price, quantity::Quantity},
 };
 
 #[repr(C)]
@@ -144,14 +141,18 @@
 impl Hash for OptionsSpread {
     fn hash<H: Hasher>(&self, state: &mut H) {
         self.id.hash(state);
     }
 }
 
 impl Instrument for OptionsSpread {
+    fn into_any(self) -> InstrumentAny {
+        InstrumentAny::OptionsSpread(self)
+    }
+
     fn id(&self) -> InstrumentId {
         self.id
     }
 
     fn raw_symbol(&self) -> Symbol {
         self.raw_symbol
     }
@@ -223,18 +224,14 @@
     fn ts_event(&self) -> UnixNanos {
         self.ts_event
     }
 
     fn ts_init(&self) -> UnixNanos {
         self.ts_init
     }
-
-    fn as_any(&self) -> &dyn Any {
-        self
-    }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/instruments/stubs.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/instruments/stubs.rs`

 * *Files 14% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use chrono::{TimeZone, Utc};
-use nautilus_core::time::UnixNanos;
+use nautilus_core::nanos::UnixNanos;
 use rstest::fixture;
 use rust_decimal_macros::dec;
 use ustr::Ustr;
 
 use super::{futures_spread::FuturesSpread, options_spread::OptionsSpread};
 use crate::{
     enums::{AssetClass, OptionKind},
@@ -41,16 +41,17 @@
     let expiration = Utc.with_ymd_and_hms(2014, 7, 8, 0, 0, 0).unwrap();
     CryptoFuture::new(
         InstrumentId::from("ETHUSDT-123.BINANCE"),
         Symbol::from("BTCUSDT"),
         Currency::from("BTC"),
         Currency::from("USDT"),
         Currency::from("USDT"),
-        activation.timestamp_nanos_opt().unwrap() as UnixNanos,
-        expiration.timestamp_nanos_opt().unwrap() as UnixNanos,
+        false,
+        UnixNanos::from(activation.timestamp_nanos_opt().unwrap() as u64),
+        UnixNanos::from(expiration.timestamp_nanos_opt().unwrap() as u64),
         2,
         6,
         Price::from("0.01"),
         Quantity::from("0.000001"),
         dec!(0),
         dec!(0),
         dec!(0),
@@ -58,16 +59,16 @@
         None,
         Some(Quantity::from("9000.0")),
         Some(Quantity::from("0.000001")),
         None,
         Some(Money::new(10.00, Currency::from("USDT")).unwrap()),
         Some(Price::from("1000000.00")),
         Some(Price::from("0.01")),
-        0,
-        0,
+        0.into(),
+        0.into(),
     )
     .unwrap()
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // CryptoPerpetual
 ////////////////////////////////////////////////////////////////////////////////
@@ -92,16 +93,16 @@
         None,
         Some(Quantity::from("10000.0")),
         Some(Quantity::from("0.001")),
         None,
         Some(Money::new(10.00, Currency::from("USDT")).unwrap()),
         Some(Price::from("15000.00")),
         Some(Price::from("1.0")),
-        0,
-        0,
+        0.into(),
+        0.into(),
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn xbtusd_bitmex() -> CryptoPerpetual {
     CryptoPerpetual::new(
@@ -122,16 +123,16 @@
         None,
         None,
         None,
         Some(Money::from("10000000 USD")),
         Some(Money::from("1 USD")),
         Some(Price::from("10000000")),
         Some(Price::from("0.01")),
-        0,
-        0,
+        0.into(),
+        0.into(),
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn ethusdt_bitmex() -> CryptoPerpetual {
     CryptoPerpetual::new(
@@ -152,16 +153,16 @@
         None,
         None,
         None,
         None,
         None,
         Some(Price::from("10000000")),
         Some(Price::from("0.01")),
-        0,
-        0,
+        0.into(),
+        0.into(),
     )
     .unwrap()
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // CurrencyPair
 ////////////////////////////////////////////////////////////////////////////////
@@ -184,16 +185,16 @@
         None,
         Some(Quantity::from("9000")),
         Some(Quantity::from("0.000001")),
         None,
         None,
         Some(Price::from("1000000")),
         Some(Price::from("0.01")),
-        0,
-        0,
+        0.into(),
+        0.into(),
     )
     .unwrap()
 }
 
 #[fixture]
 pub fn currency_pair_ethusdt() -> CurrencyPair {
     CurrencyPair::new(
@@ -212,26 +213,26 @@
         None,
         Some(Quantity::from("9000")),
         Some(Quantity::from("0.00001")),
         None,
         None,
         Some(Price::from("1000000")),
         Some(Price::from("0.01")),
-        0,
-        0,
+        0.into(),
+        0.into(),
     )
     .unwrap()
 }
 
 #[must_use]
 pub fn default_fx_ccy(symbol: Symbol, venue: Option<Venue>) -> CurrencyPair {
     let target_venue = venue.unwrap_or(Venue::from("SIM"));
     let instrument_id = InstrumentId::new(symbol, target_venue);
-    let base_currency = symbol.value.split('/').next().unwrap();
-    let quote_currency = symbol.value.split('/').last().unwrap();
+    let base_currency = symbol.as_str().split('/').next().unwrap();
+    let quote_currency = symbol.as_str().split('/').last().unwrap();
     let price_precision = if quote_currency == "JPY" { 3 } else { 5 };
     let price_increment = Price::new(1.0 / 10.0f64, price_precision).unwrap();
     CurrencyPair::new(
         instrument_id,
         symbol,
         Currency::from(base_currency),
         Currency::from(quote_currency),
@@ -246,16 +247,16 @@
         Some(Quantity::from("1000")),
         Some(Quantity::from("1000000")),
         Some(Quantity::from("100")),
         None,
         None,
         None,
         None,
-        0,
-        0,
+        0.into(),
+        0.into(),
     )
     .unwrap()
 }
 #[fixture]
 pub fn audusd_sim() -> CurrencyPair {
     default_fx_ccy(Symbol::from("AUD/USD"), Some(Venue::from("SIM")))
 }
@@ -283,16 +284,16 @@
         None,
         None,
         None,
         None,
         None,
         None,
         None,
-        0,
-        0,
+        0.into(),
+        0.into(),
     )
     .unwrap()
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // FuturesContract
 ////////////////////////////////////////////////////////////////////////////////
@@ -303,29 +304,29 @@
     let expiration = Utc.with_ymd_and_hms(2021, 7, 8, 0, 0, 0).unwrap();
     FuturesContract::new(
         InstrumentId::from("ESZ1.GLBX"),
         Symbol::from("ESZ1"),
         AssetClass::Index,
         Some(Ustr::from("XCME")),
         Ustr::from("ES"),
-        activation.timestamp_nanos_opt().unwrap() as UnixNanos,
-        expiration.timestamp_nanos_opt().unwrap() as UnixNanos,
+        UnixNanos::from(activation.timestamp_nanos_opt().unwrap() as u64),
+        UnixNanos::from(expiration.timestamp_nanos_opt().unwrap() as u64),
         Currency::USD(),
         2,
         Price::from("0.01"),
         Quantity::from(1),
         Quantity::from(1),
         None,
         None,
         None,
         None,
         None,
         None,
-        0,
-        0,
+        0.into(),
+        0.into(),
     )
     .unwrap()
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // FuturesSpread
 ////////////////////////////////////////////////////////////////////////////////
@@ -337,29 +338,29 @@
     FuturesSpread::new(
         InstrumentId::from("ESM4-ESU4.GLBX"),
         Symbol::from("ESM4-ESU4"),
         AssetClass::Index,
         Some(Ustr::from("XCME")),
         Ustr::from("ES"),
         Ustr::from("EQ"),
-        activation.timestamp_nanos_opt().unwrap() as UnixNanos,
-        expiration.timestamp_nanos_opt().unwrap() as UnixNanos,
+        UnixNanos::from(activation.timestamp_nanos_opt().unwrap() as u64),
+        UnixNanos::from(expiration.timestamp_nanos_opt().unwrap() as u64),
         Currency::USD(),
         2,
         Price::from("0.01"),
         Quantity::from(1),
         Quantity::from(1),
         None,
         None,
         None,
         None,
         None,
         None,
-        0,
-        0,
+        0.into(),
+        0.into(),
     )
     .unwrap()
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // OptionsContract
 ////////////////////////////////////////////////////////////////////////////////
@@ -371,30 +372,30 @@
     OptionsContract::new(
         InstrumentId::from("AAPL211217C00150000.OPRA"),
         Symbol::from("AAPL211217C00150000"),
         AssetClass::Equity,
         Some(Ustr::from("GMNI")), // Nasdaq GEMX
         Ustr::from("AAPL"),
         OptionKind::Call,
-        activation.timestamp_nanos_opt().unwrap() as UnixNanos,
-        expiration.timestamp_nanos_opt().unwrap() as UnixNanos,
+        UnixNanos::from(activation.timestamp_nanos_opt().unwrap() as u64),
+        UnixNanos::from(expiration.timestamp_nanos_opt().unwrap() as u64),
         Price::from("149.0"),
         Currency::USD(),
         2,
         Price::from("0.01"),
         Quantity::from(1),
         Quantity::from(1),
         None,
         None,
         None,
         None,
         None,
         None,
-        0,
-        0,
+        0.into(),
+        0.into(),
     )
     .unwrap()
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // OptionsSpread
 ////////////////////////////////////////////////////////////////////////////////
@@ -406,25 +407,25 @@
     OptionsSpread::new(
         InstrumentId::from("UD:U$: GN 2534559.GLBX"),
         Symbol::from("UD:U$: GN 2534559"),
         AssetClass::FX,
         Some(Ustr::from("XCME")),
         Ustr::from("SR3"), // British Pound futures (option on futures)
         Ustr::from("GN"),
-        activation.timestamp_nanos_opt().unwrap() as UnixNanos,
-        expiration.timestamp_nanos_opt().unwrap() as UnixNanos,
+        UnixNanos::from(activation.timestamp_nanos_opt().unwrap() as u64),
+        UnixNanos::from(expiration.timestamp_nanos_opt().unwrap() as u64),
         Currency::USD(),
         2,
         Price::from("0.01"),
         Quantity::from(1),
         Quantity::from(1),
         None,
         None,
         None,
         None,
         None,
         None,
-        0,
-        0,
+        0.into(),
+        0.into(),
     )
     .unwrap()
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/instruments/synthetic.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/instruments/synthetic.rs`

 * *Files 2% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 
 use std::{
     collections::HashMap,
     hash::{Hash, Hasher},
 };
 
 use evalexpr::{ContextWithMutableVariables, HashMapContext, Node, Value};
-use nautilus_core::time::UnixNanos;
+use nautilus_core::nanos::UnixNanos;
 
 use crate::{
     identifiers::{instrument_id::InstrumentId, symbol::Symbol, venue::Venue},
     types::price::Price,
 };
 
 /// Represents a synthetic instrument with prices derived from component instruments using a
@@ -160,16 +160,16 @@
         let ltc_binance = InstrumentId::from("LTC.BINANCE");
         let formula = "(BTC.BINANCE + LTC.BINANCE) / 2".to_string();
         let mut synth = SyntheticInstrument::new(
             Symbol::new("BTC-LTC").unwrap(),
             2,
             vec![btc_binance, ltc_binance],
             formula.clone(),
-            0,
-            0,
+            0.into(),
+            0.into(),
         )
         .unwrap();
 
         let mut inputs = HashMap::new();
         inputs.insert("BTC.BINANCE".to_string(), 100.0);
         inputs.insert("LTC.BINANCE".to_string(), 200.0);
 
@@ -185,16 +185,16 @@
         let ltc_binance = InstrumentId::from("LTC.BINANCE");
         let formula = "(BTC.BINANCE + LTC.BINANCE) / 2.0".to_string();
         let mut synth = SyntheticInstrument::new(
             Symbol::new("BTC-LTC").unwrap(),
             2,
             vec![btc_binance, ltc_binance],
             formula.clone(),
-            0,
-            0,
+            0.into(),
+            0.into(),
         )
         .unwrap();
 
         let inputs = vec![100.0, 200.0];
         let price = synth.calculate(&inputs).unwrap();
 
         assert_eq!(price.as_f64(), 150.0);
@@ -207,16 +207,16 @@
         let ltc_binance = InstrumentId::from("LTC.BINANCE");
         let formula = "(BTC.BINANCE + LTC.BINANCE) / 2".to_string();
         let mut synth = SyntheticInstrument::new(
             Symbol::new("BTC-LTC").unwrap(),
             2,
             vec![btc_binance, ltc_binance],
             formula,
-            0,
-            0,
+            0.into(),
+            0.into(),
         )
         .unwrap();
 
         let new_formula = "(BTC.BINANCE + LTC.BINANCE) / 4".to_string();
         synth.change_formula(new_formula.clone()).unwrap();
 
         let mut inputs = HashMap::new();
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/lib.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/lib.rs`

 * *Files 12% similar despite different names*

```diff
@@ -18,14 +18,15 @@
 pub mod enums;
 pub mod events;
 pub mod identifiers;
 pub mod instruments;
 pub mod macros;
 pub mod orderbook;
 pub mod orders;
+pub mod polymorphism;
 pub mod position;
 pub mod types;
 pub mod venues;
 
 #[cfg(feature = "ffi")]
 pub mod ffi;
 #[cfg(feature = "python")]
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/macros.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/macros.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orderbook/book_mbo.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/backend/kmerge_batch.rs`

 * *Files 25% similar despite different names*

```diff
@@ -9,327 +9,317 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_core::time::UnixNanos;
+use std::{sync::Arc, vec::IntoIter};
 
-use super::{
-    book::{get_avg_px_for_quantity, get_quantity_for_price},
-    display::pprint_book,
-    level::Level,
-};
-use crate::{
-    data::{
-        delta::OrderBookDelta, deltas::OrderBookDeltas, depth::OrderBookDepth10, order::BookOrder,
-    },
-    enums::{BookAction, OrderSide},
-    identifiers::instrument_id::InstrumentId,
-    orderbook::{book::BookIntegrityError, ladder::Ladder},
-    types::{price::Price, quantity::Quantity},
+use binary_heap_plus::{BinaryHeap, PeekMut};
+use compare::Compare;
+use futures::{Stream, StreamExt};
+use tokio::{
+    runtime::Runtime,
+    sync::mpsc::{self, Receiver},
+    task::JoinHandle,
 };
 
-/// Provides an order book which can handle MBO (market by order, a.k.a L3)
-/// granularity data.
-#[derive(Clone, Debug)]
-#[cfg_attr(
-    feature = "python",
-    pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
-)]
-pub struct OrderBookMbo {
-    /// The instrument ID for the order book.
-    pub instrument_id: InstrumentId,
-    /// The last event sequence number for the order book.
-    pub sequence: u64,
-    /// The timestamp of the last event applied to the order book.
-    pub ts_last: UnixNanos,
-    /// The current count of events applied to the order book.
-    pub count: u64,
-    bids: Ladder,
-    asks: Ladder,
+pub struct EagerStream<T> {
+    rx: Receiver<T>,
+    task: JoinHandle<()>,
+    runtime: Arc<Runtime>,
 }
 
-impl OrderBookMbo {
-    #[must_use]
-    pub fn new(instrument_id: InstrumentId) -> Self {
-        Self {
-            instrument_id,
-            sequence: 0,
-            ts_last: 0,
-            count: 0,
-            bids: Ladder::new(OrderSide::Buy),
-            asks: Ladder::new(OrderSide::Sell),
-        }
-    }
-
-    pub fn reset(&mut self) {
-        self.bids.clear();
-        self.asks.clear();
-        self.sequence = 0;
-        self.ts_last = 0;
-        self.count = 0;
-    }
-
-    pub fn add(&mut self, order: BookOrder, ts_event: u64, sequence: u64) {
-        match order.side {
-            OrderSide::Buy => self.bids.add(order),
-            OrderSide::Sell => self.asks.add(order),
-            _ => panic!("{}", BookIntegrityError::NoOrderSide),
-        }
-
-        self.increment(ts_event, sequence);
-    }
-
-    pub fn update(&mut self, order: BookOrder, ts_event: u64, sequence: u64) {
-        match order.side {
-            OrderSide::Buy => self.bids.update(order),
-            OrderSide::Sell => self.asks.update(order),
-            _ => panic!("{}", BookIntegrityError::NoOrderSide),
-        }
-
-        self.increment(ts_event, sequence);
-    }
-
-    pub fn delete(&mut self, order: BookOrder, ts_event: u64, sequence: u64) {
-        match order.side {
-            OrderSide::Buy => self.bids.delete(order, ts_event, sequence),
-            OrderSide::Sell => self.asks.delete(order, ts_event, sequence),
-            _ => panic!("{}", BookIntegrityError::NoOrderSide),
-        }
-
-        self.increment(ts_event, sequence);
-    }
-
-    pub fn clear(&mut self, ts_event: u64, sequence: u64) {
-        self.bids.clear();
-        self.asks.clear();
-        self.increment(ts_event, sequence);
-    }
+impl<T> EagerStream<T> {
+    pub fn from_stream_with_runtime<S>(stream: S, runtime: Arc<Runtime>) -> Self
+    where
+        S: Stream<Item = T> + Send + 'static,
+        T: Send + 'static,
+    {
+        let _guard = runtime.enter();
+        let (tx, rx) = mpsc::channel(1);
+        let task = tokio::spawn(async move {
+            stream
+                .for_each(|item| async {
+                    let _ = tx.send(item).await;
+                })
+                .await;
+        });
 
-    pub fn clear_bids(&mut self, ts_event: u64, sequence: u64) {
-        self.bids.clear();
-        self.increment(ts_event, sequence);
+        Self { rx, task, runtime }
     }
+}
 
-    pub fn clear_asks(&mut self, ts_event: u64, sequence: u64) {
-        self.asks.clear();
-        self.increment(ts_event, sequence);
-    }
+impl<T> Iterator for EagerStream<T> {
+    type Item = T;
 
-    pub fn apply_delta(&mut self, delta: OrderBookDelta) {
-        match delta.action {
-            BookAction::Add => self.add(delta.order, delta.ts_event, delta.sequence),
-            BookAction::Update => self.update(delta.order, delta.ts_event, delta.sequence),
-            BookAction::Delete => self.delete(delta.order, delta.ts_event, delta.sequence),
-            BookAction::Clear => self.clear(delta.ts_event, delta.sequence),
-        }
+    fn next(&mut self) -> Option<Self::Item> {
+        self.runtime.block_on(self.rx.recv())
     }
+}
 
-    pub fn apply_deltas(&mut self, deltas: OrderBookDeltas) {
-        for delta in deltas.deltas {
-            self.apply_delta(delta);
-        }
+impl<T> Drop for EagerStream<T> {
+    fn drop(&mut self) {
+        self.task.abort();
+        self.rx.close();
     }
+}
 
-    pub fn apply_depth(&mut self, depth: OrderBookDepth10) {
-        self.bids.clear();
-        self.asks.clear();
-
-        for order in depth.bids {
-            self.add(order, depth.ts_event, depth.sequence);
-        }
+// TODO: Investigate implementing Iterator for ElementBatchIter
+// to reduce next element duplication. May be difficult to make it peekable.
+pub struct ElementBatchIter<I, T>
+where
+    I: Iterator<Item = IntoIter<T>>,
+{
+    pub item: T,
+    batch: I::Item,
+    iter: I,
+}
 
-        for order in depth.asks {
-            self.add(order, depth.ts_event, depth.sequence);
+impl<I, T> ElementBatchIter<I, T>
+where
+    I: Iterator<Item = IntoIter<T>>,
+{
+    fn new_from_iter(mut iter: I) -> Option<Self> {
+        loop {
+            match iter.next() {
+                Some(mut batch) => match batch.next() {
+                    Some(item) => {
+                        break Some(Self { item, batch, iter });
+                    }
+                    None => continue,
+                },
+                None => break None,
+            }
         }
     }
+}
 
-    pub fn bids(&self) -> impl Iterator<Item = &Level> {
-        self.bids.levels.values()
-    }
-
-    pub fn asks(&self) -> impl Iterator<Item = &Level> {
-        self.asks.levels.values()
-    }
-
-    #[must_use]
-    pub fn has_bid(&self) -> bool {
-        match self.bids.top() {
-            Some(top) => !top.orders.is_empty(),
-            None => false,
-        }
-    }
+pub struct KMerge<I, T, C>
+where
+    I: Iterator<Item = IntoIter<T>>,
+{
+    heap: BinaryHeap<ElementBatchIter<I, T>, C>,
+}
 
-    #[must_use]
-    pub fn has_ask(&self) -> bool {
-        match self.asks.top() {
-            Some(top) => !top.orders.is_empty(),
-            None => false,
+impl<I, T, C> KMerge<I, T, C>
+where
+    I: Iterator<Item = IntoIter<T>>,
+    C: Compare<ElementBatchIter<I, T>>,
+{
+    pub fn new(cmp: C) -> Self {
+        Self {
+            heap: BinaryHeap::from_vec_cmp(Vec::new(), cmp),
         }
     }
 
-    #[must_use]
-    pub fn best_bid_price(&self) -> Option<Price> {
-        self.bids.top().map(|top| top.price.value)
-    }
-
-    #[must_use]
-    pub fn best_ask_price(&self) -> Option<Price> {
-        self.asks.top().map(|top| top.price.value)
-    }
-
-    #[must_use]
-    pub fn best_bid_size(&self) -> Option<Quantity> {
-        match self.bids.top() {
-            Some(top) => top.first().map(|order| order.size),
-            None => None,
+    pub fn push_iter(&mut self, s: I) {
+        if let Some(heap_elem) = ElementBatchIter::new_from_iter(s) {
+            self.heap.push(heap_elem);
         }
     }
+}
 
-    #[must_use]
-    pub fn best_ask_size(&self) -> Option<Quantity> {
-        match self.asks.top() {
-            Some(top) => top.first().map(|order| order.size),
+impl<I, T, C> Iterator for KMerge<I, T, C>
+where
+    I: Iterator<Item = IntoIter<T>>,
+    C: Compare<ElementBatchIter<I, T>>,
+{
+    type Item = T;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        match self.heap.peek_mut() {
+            Some(mut heap_elem) => {
+                // Get next element from batch
+                match heap_elem.batch.next() {
+                    // Swap current heap element with new element
+                    // return the old element
+                    Some(mut item) => {
+                        std::mem::swap(&mut item, &mut heap_elem.item);
+                        Some(item)
+                    }
+                    // Otherwise get the next batch and the element from it
+                    // Unless the underlying iterator is exhausted
+                    None => loop {
+                        match heap_elem.iter.next() {
+                            Some(mut batch) => match batch.next() {
+                                Some(mut item) => {
+                                    heap_elem.batch = batch;
+                                    std::mem::swap(&mut item, &mut heap_elem.item);
+                                    break Some(item);
+                                }
+                                // Get next batch from iterator
+                                None => continue,
+                            },
+                            // Iterator has no more batches return current element
+                            // and pop the heap element
+                            None => {
+                                let ElementBatchIter {
+                                    item,
+                                    batch: _,
+                                    iter: _,
+                                } = PeekMut::pop(heap_elem);
+                                break Some(item);
+                            }
+                        }
+                    },
+                }
+            }
             None => None,
         }
     }
-
-    #[must_use]
-    pub fn spread(&self) -> Option<f64> {
-        match (self.best_ask_price(), self.best_bid_price()) {
-            (Some(ask), Some(bid)) => Some(ask.as_f64() - bid.as_f64()),
-            _ => None,
-        }
-    }
-
-    #[must_use]
-    pub fn midpoint(&self) -> Option<f64> {
-        match (self.best_ask_price(), self.best_bid_price()) {
-            (Some(ask), Some(bid)) => Some((ask.as_f64() + bid.as_f64()) / 2.0),
-            _ => None,
-        }
-    }
-
-    #[must_use]
-    pub fn get_avg_px_for_quantity(&self, qty: Quantity, order_side: OrderSide) -> f64 {
-        let levels = match order_side {
-            OrderSide::Buy => &self.asks.levels,
-            OrderSide::Sell => &self.bids.levels,
-            _ => panic!("Invalid `OrderSide` {order_side}"),
-        };
-
-        get_avg_px_for_quantity(qty, levels)
-    }
-
-    #[must_use]
-    pub fn get_quantity_for_price(&self, price: Price, order_side: OrderSide) -> f64 {
-        let levels = match order_side {
-            OrderSide::Buy => &self.asks.levels,
-            OrderSide::Sell => &self.bids.levels,
-            _ => panic!("Invalid `OrderSide` {order_side}"),
-        };
-
-        get_quantity_for_price(price, order_side, levels)
-    }
-
-    #[must_use]
-    pub fn simulate_fills(&self, order: &BookOrder) -> Vec<(Price, Quantity)> {
-        match order.side {
-            OrderSide::Buy => self.asks.simulate_fills(order),
-            OrderSide::Sell => self.bids.simulate_fills(order),
-            _ => panic!("{}", BookIntegrityError::NoOrderSide),
-        }
-    }
-
-    /// Return a [`String`] representation of the order book in a human-readable table format.
-    #[must_use]
-    pub fn pprint(&self, num_levels: usize) -> String {
-        pprint_book(&self.bids, &self.asks, num_levels)
-    }
-
-    pub fn check_integrity(&self) -> Result<(), BookIntegrityError> {
-        let top_bid_level = self.bids.top();
-        let top_ask_level = self.asks.top();
-
-        if top_bid_level.is_none() || top_ask_level.is_none() {
-            return Ok(());
-        }
-
-        // SAFETY: Levels were already checked for None
-        let best_bid = top_bid_level.unwrap().price;
-        let best_ask = top_ask_level.unwrap().price;
-
-        if best_bid.value >= best_ask.value {
-            return Err(BookIntegrityError::OrdersCrossed(best_bid, best_ask));
-        }
-
-        Ok(())
-    }
-
-    fn increment(&mut self, ts_event: u64, sequence: u64) {
-        self.ts_last = ts_event;
-        self.sequence = sequence;
-        self.count += 1;
-    }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
+
+    use quickcheck::{empty_shrinker, Arbitrary};
+    use quickcheck_macros::quickcheck;
     use rstest::rstest;
 
     use super::*;
-    use crate::identifiers::instrument_id::InstrumentId;
+
+    struct OrdComparator;
+    impl<S> Compare<ElementBatchIter<S, i32>> for OrdComparator
+    where
+        S: Iterator<Item = IntoIter<i32>>,
+    {
+        fn compare(
+            &self,
+            l: &ElementBatchIter<S, i32>,
+            r: &ElementBatchIter<S, i32>,
+        ) -> std::cmp::Ordering {
+            // Max heap ordering must be reversed
+            l.item.cmp(&r.item).reverse()
+        }
+    }
+
+    impl<S> Compare<ElementBatchIter<S, u64>> for OrdComparator
+    where
+        S: Iterator<Item = IntoIter<u64>>,
+    {
+        fn compare(
+            &self,
+            l: &ElementBatchIter<S, u64>,
+            r: &ElementBatchIter<S, u64>,
+        ) -> std::cmp::Ordering {
+            // Max heap ordering must be reversed
+            l.item.cmp(&r.item).reverse()
+        }
+    }
 
     #[rstest]
-    fn test_orderbook_creation() {
-        let instrument_id = InstrumentId::from("AAPL.XNAS");
-        let book = OrderBookMbo::new(instrument_id);
-
-        assert_eq!(book.instrument_id, instrument_id);
-        assert_eq!(book.sequence, 0);
-        assert_eq!(book.ts_last, 0);
-        assert_eq!(book.count, 0);
+    fn test1() {
+        let iter_a = vec![vec![1, 2, 3].into_iter(), vec![7, 8, 9].into_iter()].into_iter();
+        let iter_b = vec![vec![4, 5, 6].into_iter()].into_iter();
+        let mut kmerge: KMerge<_, i32, _> = KMerge::new(OrdComparator);
+        kmerge.push_iter(iter_a);
+        kmerge.push_iter(iter_b);
+
+        let values: Vec<i32> = kmerge.collect();
+        assert_eq!(values, vec![1, 2, 3, 4, 5, 6, 7, 8, 9]);
     }
 
     #[rstest]
-    fn test_orderbook_reset() {
-        let instrument_id = InstrumentId::from("AAPL.XNAS");
-        let mut book = OrderBookMbo::new(instrument_id);
-        book.sequence = 10;
-        book.ts_last = 100;
-        book.count = 3;
-
-        book.reset();
-
-        assert_eq!(book.sequence, 0);
-        assert_eq!(book.ts_last, 0);
-        assert_eq!(book.count, 0);
+    fn test2() {
+        let iter_a = vec![vec![1, 2, 6].into_iter(), vec![7, 8, 9].into_iter()].into_iter();
+        let iter_b = vec![vec![3, 4, 5, 6].into_iter()].into_iter();
+        let mut kmerge: KMerge<_, i32, _> = KMerge::new(OrdComparator);
+        kmerge.push_iter(iter_a);
+        kmerge.push_iter(iter_b);
+
+        let values: Vec<i32> = kmerge.collect();
+        assert_eq!(values, vec![1, 2, 3, 4, 5, 6, 6, 7, 8, 9]);
     }
 
     #[rstest]
-    fn test_check_integrity_when_crossed() {
-        let instrument_id = InstrumentId::from("ETHUSDT-PERP.BINANCE");
-        let mut book = OrderBookMbo::new(instrument_id);
-
-        let ask1 = BookOrder::new(
-            OrderSide::Sell,
-            Price::from("1.000"),
-            Quantity::from("1.0"),
-            0, // order_id not applicable
+    fn test3() {
+        let iter_a = vec![vec![1, 4, 7].into_iter(), vec![24, 35, 56].into_iter()].into_iter();
+        let iter_b = vec![vec![2, 4, 8].into_iter()].into_iter();
+        let iter_c = vec![vec![3, 5, 9].into_iter(), vec![12, 12, 90].into_iter()].into_iter();
+        let mut kmerge: KMerge<_, i32, _> = KMerge::new(OrdComparator);
+        kmerge.push_iter(iter_a);
+        kmerge.push_iter(iter_b);
+        kmerge.push_iter(iter_c);
+
+        let values: Vec<i32> = kmerge.collect();
+        assert_eq!(
+            values,
+            vec![1, 2, 3, 4, 4, 5, 7, 8, 9, 12, 12, 24, 35, 56, 90]
         );
-        let bid1 = BookOrder::new(
-            OrderSide::Buy,
-            Price::from("2.000"),
-            Quantity::from("1.0"),
-            0, // order_id not applicable
-        );
-        book.add(bid1, 0, 1);
-        book.add(ask1, 0, 1);
+    }
+
+    #[rstest]
+    fn test5() {
+        let iter_a = vec![
+            vec![1, 3, 5].into_iter(),
+            vec![].into_iter(),
+            vec![7, 9, 11].into_iter(),
+        ]
+        .into_iter();
+        let iter_b = vec![vec![2, 4, 6].into_iter()].into_iter();
+        let mut kmerge: KMerge<_, i32, _> = KMerge::new(OrdComparator);
+        kmerge.push_iter(iter_a);
+        kmerge.push_iter(iter_b);
+
+        let values: Vec<i32> = kmerge.collect();
+        assert_eq!(values, vec![1, 2, 3, 4, 5, 6, 7, 9, 11]);
+    }
+
+    #[derive(Debug, Clone)]
+    struct SortedNestedVec(Vec<Vec<u64>>);
+
+    impl Arbitrary for SortedNestedVec {
+        fn arbitrary(g: &mut quickcheck::Gen) -> Self {
+            // Generate a random Vec<u64>
+            let mut vec: Vec<u64> = Arbitrary::arbitrary(g);
+
+            // Sort the vector
+            vec.sort_unstable();
+
+            // Recreate nested Vec structure by splitting the flattened_sorted_vec into sorted chunks
+            let mut nested_sorted_vec = Vec::new();
+            let mut start = 0;
+            while start < vec.len() {
+                // let chunk_size: usize = g.rng.gen_range(0, vec.len() - start + 1);
+                let chunk_size: usize = Arbitrary::arbitrary(g);
+                let chunk_size = chunk_size % (vec.len() - start + 1);
+                let end = start + chunk_size;
+                let chunk = vec[start..end].to_vec();
+                nested_sorted_vec.push(chunk);
+                start = end;
+            }
+
+            // Wrap the sorted nested vector in the SortedNestedVecU64 struct
+            Self(nested_sorted_vec)
+        }
+
+        // Optionally, implement the `shrink` method if you want to shrink the generated data on test failures
+        fn shrink(&self) -> Box<dyn Iterator<Item = Self>> {
+            empty_shrinker()
+        }
+    }
+
+    #[quickcheck]
+    fn prop_test(all_data: Vec<SortedNestedVec>) -> bool {
+        let mut kmerge: KMerge<_, u64, _> = KMerge::new(OrdComparator);
+
+        let copy_data = all_data.clone();
+        for stream in copy_data {
+            let input = stream.0.into_iter().map(std::iter::IntoIterator::into_iter);
+            kmerge.push_iter(input);
+        }
+        let merged_data: Vec<u64> = kmerge.collect();
+
+        let mut sorted_data: Vec<u64> = all_data
+            .into_iter()
+            .flat_map(|stream| stream.0.into_iter().flatten())
+            .collect();
+        sorted_data.sort_unstable();
 
-        assert!(book.check_integrity().is_err());
+        merged_data.len() == sorted_data.len() && merged_data.eq(&sorted_data)
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orderbook/display.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orderbook/display.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orderbook/ladder.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orderbook/ladder.rs`

 * *Files 0% similar despite different names*

```diff
@@ -15,15 +15,17 @@
 
 use std::{
     cmp::Ordering,
     collections::{BTreeMap, HashMap},
     fmt::{Display, Formatter},
 };
 
-use super::book::BookIntegrityError;
+use nautilus_core::nanos::UnixNanos;
+
+use super::error::BookIntegrityError;
 use crate::{
     data::order::{BookOrder, OrderId},
     enums::OrderSide,
     orderbook::level::Level,
     types::{price::Price, quantity::Quantity},
 };
 
@@ -109,34 +111,31 @@
 
     pub fn clear(&mut self) {
         self.levels.clear();
         self.cache.clear();
     }
 
     pub fn add(&mut self, order: BookOrder) {
-        let order_id = order.order_id;
         let book_price = order.to_book_price();
-
-        self.cache.insert(order_id, book_price);
+        self.cache.insert(order.order_id, book_price);
 
         match self.levels.get_mut(&book_price) {
             Some(level) => {
                 level.add(order);
             }
             None => {
                 let level = Level::from_order(order);
                 self.levels.insert(book_price, level);
             }
         }
     }
 
     pub fn update(&mut self, order: BookOrder) {
-        let price_opt = self.cache.get(&order.order_id).copied();
-
-        if let Some(price) = price_opt {
+        let price = self.cache.get(&order.order_id).copied();
+        if let Some(price) = price {
             if let Some(level) = self.levels.get_mut(&price) {
                 if order.price == level.price.value {
                     // Update at current price level
                     level.update(order);
                     return;
                 }
 
@@ -148,22 +147,22 @@
                 }
             }
         }
 
         self.add(order);
     }
 
-    pub fn delete(&mut self, order: BookOrder, ts_event: u64, sequence: u64) {
-        self.remove(order.order_id, ts_event, sequence);
+    pub fn delete(&mut self, order: BookOrder, sequence: u64, ts_event: UnixNanos) {
+        self.remove(order.order_id, sequence, ts_event);
     }
 
-    pub fn remove(&mut self, order_id: OrderId, ts_event: u64, sequence: u64) {
+    pub fn remove(&mut self, order_id: OrderId, sequence: u64, ts_event: UnixNanos) {
         if let Some(price) = self.cache.remove(&order_id) {
             if let Some(level) = self.levels.get_mut(&price) {
-                level.remove_by_id(order_id, ts_event, sequence);
+                level.remove_by_id(order_id, sequence, ts_event);
                 if level.is_empty() {
                     self.levels.remove(&price);
                 }
             }
         }
     }
 
@@ -187,15 +186,14 @@
             None => Option::None,
         }
     }
 
     #[must_use]
     pub fn simulate_fills(&self, order: &BookOrder) -> Vec<(Price, Quantity)> {
         let is_reversed = self.side == OrderSide::Buy;
-
         let mut fills = Vec::new();
         let mut cumulative_denominator = Quantity::zero(order.size.precision);
         let target = order.size;
 
         for level in self.levels.values() {
             if (is_reversed && level.price.value < order.price)
                 || (!is_reversed && level.price.value > order.price)
@@ -412,29 +410,29 @@
     }
 
     #[rstest]
     fn test_delete_non_existing_order() {
         let mut ladder = Ladder::new(OrderSide::Buy);
         let order = BookOrder::new(OrderSide::Buy, Price::from("10.00"), Quantity::from(20), 1);
 
-        ladder.delete(order, 0, 0);
+        ladder.delete(order, 0, 0.into());
 
         assert_eq!(ladder.len(), 0);
     }
 
     #[rstest]
     fn test_delete_buy_order() {
         let mut ladder = Ladder::new(OrderSide::Buy);
         let order = BookOrder::new(OrderSide::Buy, Price::from("11.00"), Quantity::from(20), 1);
 
         ladder.add(order);
 
         let order = BookOrder::new(OrderSide::Buy, Price::from("11.00"), Quantity::from(10), 1);
 
-        ladder.delete(order, 0, 0);
+        ladder.delete(order, 0, 0.into());
         assert_eq!(ladder.len(), 0);
         assert_eq!(ladder.sizes(), 0.0);
         assert_eq!(ladder.exposures(), 0.0);
         assert_eq!(ladder.top(), None);
     }
 
     #[rstest]
@@ -442,15 +440,15 @@
         let mut ladder = Ladder::new(OrderSide::Sell);
         let order = BookOrder::new(OrderSide::Sell, Price::from("10.00"), Quantity::from(10), 1);
 
         ladder.add(order);
 
         let order = BookOrder::new(OrderSide::Sell, Price::from("10.00"), Quantity::from(10), 1);
 
-        ladder.delete(order, 0, 0);
+        ladder.delete(order, 0, 0.into());
         assert_eq!(ladder.len(), 0);
         assert_eq!(ladder.sizes(), 0.0);
         assert_eq!(ladder.exposures(), 0.0);
         assert_eq!(ladder.top(), None);
     }
 
     #[rstest]
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orderbook/level.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orderbook/level.rs`

 * *Files 1% similar despite different names*

```diff
@@ -11,17 +11,19 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::{cmp::Ordering, collections::BTreeMap};
 
+use nautilus_core::nanos::UnixNanos;
+
 use crate::{
     data::order::{BookOrder, OrderId},
-    orderbook::{book::BookIntegrityError, ladder::BookPrice},
+    orderbook::{error::BookIntegrityError, ladder::BookPrice},
     types::fixed::FIXED_SCALAR,
 };
 
 /// Represents a discrete price level in an order book.
 ///
 /// The level maintains a collection of orders as well as tracking insertion order
 /// to preserve FIFO queue dynamics.
@@ -139,19 +141,19 @@
     }
 
     pub fn delete(&mut self, order: &BookOrder) {
         self.orders.remove(&order.order_id);
         self.update_insertion_order();
     }
 
-    pub fn remove_by_id(&mut self, order_id: OrderId, ts_event: u64, sequence: u64) {
+    pub fn remove_by_id(&mut self, order_id: OrderId, sequence: u64, ts_event: UnixNanos) {
         assert!(
             self.orders.remove(&order_id).is_some(),
             "{}",
-            &BookIntegrityError::OrderNotFound(order_id, ts_event, sequence)
+            &BookIntegrityError::OrderNotFound(order_id, sequence, ts_event)
         );
         self.update_insertion_order();
     }
 
     fn check_order_for_this_level(&self, order: &BookOrder) {
         assert_eq!(order.price, self.price.value);
     }
@@ -327,15 +329,15 @@
             Price::from("1.00"),
             Quantity::from(20),
             order2_id,
         );
 
         level.add(order1);
         level.add(order2);
-        level.remove_by_id(order2_id, 0, 0);
+        level.remove_by_id(order2_id, 0, 0.into());
         assert_eq!(level.len(), 1);
         assert!(level.orders.contains_key(&order1_id));
         assert_eq!(level.size(), 10.0);
         assert_eq!(level.exposure(), 10.0);
     }
 
     #[rstest]
@@ -361,19 +363,19 @@
         assert_eq!(level.len(), 2);
         assert_eq!(level.size(), 30.0);
         assert_eq!(level.exposure(), 60.0);
     }
 
     #[rstest]
     #[should_panic(
-        expected = "Integrity error: order not found: order_id=1, ts_event=2, sequence=3"
+        expected = "Integrity error: order not found: order_id=1, sequence=2, ts_event=3"
     )]
     fn test_remove_nonexistent_order() {
         let mut level = Level::new(BookPrice::new(Price::from("1.00"), OrderSide::Buy));
-        level.remove_by_id(1, 2, 3);
+        level.remove_by_id(1, 2, 3.into());
     }
 
     #[rstest]
     fn test_size() {
         let mut level = Level::new(BookPrice::new(Price::from("1.00"), OrderSide::Buy));
         let order1 = BookOrder::new(OrderSide::Buy, Price::from("1.00"), Quantity::from(10), 0);
         let order2 = BookOrder::new(OrderSide::Buy, Price::from("1.00"), Quantity::from(15), 1);
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orderbook/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/types/mod.rs`

 * *Files 8% similar despite different names*

```diff
@@ -9,13 +9,12 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod book;
-pub mod book_mbo;
-pub mod book_mbp;
-pub mod display;
-pub mod ladder;
-pub mod level;
+pub mod balance;
+pub mod currency;
+pub mod money;
+pub mod price;
+pub mod quantity;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orders/base.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orders/base.rs`

 * *Files 17% similar despite different names*

```diff
@@ -11,29 +11,29 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::collections::HashMap;
 
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use rust_decimal::Decimal;
 use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
 use super::{
-    limit::LimitOrder, limit_if_touched::LimitIfTouchedOrder,
+    limit::LimitOrder, limit_if_touched::LimitIfTouchedOrder, market::MarketOrder,
     market_if_touched::MarketIfTouchedOrder, market_to_limit::MarketToLimitOrder,
     stop_limit::StopLimitOrder, stop_market::StopMarketOrder,
     trailing_stop_limit::TrailingStopLimitOrder, trailing_stop_market::TrailingStopMarketOrder,
 };
 use crate::{
     enums::{
-        ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, PositionSide,
-        TimeInForce, TrailingOffsetType, TriggerType,
+        ContingencyType, LiquiditySide, OrderSide, OrderSideSpecified, OrderStatus, OrderType,
+        PositionSide, TimeInForce, TrailingOffsetType, TriggerType,
     },
     events::order::{
         accepted::OrderAccepted, cancel_rejected::OrderCancelRejected, canceled::OrderCanceled,
         denied::OrderDenied, emulated::OrderEmulated, event::OrderEvent, expired::OrderExpired,
         filled::OrderFilled, initialized::OrderInitialized, modify_rejected::OrderModifyRejected,
         pending_cancel::OrderPendingCancel, pending_update::OrderPendingUpdate,
         rejected::OrderRejected, released::OrderReleased, submitted::OrderSubmitted,
@@ -41,31 +41,42 @@
     },
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, exec_algorithm_id::ExecAlgorithmId,
         instrument_id::InstrumentId, order_list_id::OrderListId, position_id::PositionId,
         strategy_id::StrategyId, symbol::Symbol, trade_id::TradeId, trader_id::TraderId,
         venue::Venue, venue_order_id::VenueOrderId,
     },
+    polymorphism::{
+        GetClientOrderId, GetEmulationTrigger, GetExecAlgorithmId, GetExecSpawnId, GetInstrumentId,
+        GetLimitPrice, GetOrderSide, GetOrderSideSpecified, GetStopPrice, GetStrategyId,
+        GetVenueOrderId,
+    },
     types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
 };
 
-const VALID_STOP_ORDER_TYPES: &[OrderType] = &[
+const STOP_ORDER_TYPES: &[OrderType] = &[
     OrderType::StopMarket,
     OrderType::StopLimit,
     OrderType::MarketIfTouched,
     OrderType::LimitIfTouched,
 ];
 
-const VALID_LIMIT_ORDER_TYPES: &[OrderType] = &[
+const LIMIT_ORDER_TYPES: &[OrderType] = &[
     OrderType::Limit,
     OrderType::StopLimit,
     OrderType::LimitIfTouched,
     OrderType::MarketIfTouched,
 ];
 
+const LOCAL_ACTIVE_ORDER_STATUS: &[OrderStatus] = &[
+    OrderStatus::Initialized,
+    OrderStatus::Emulated,
+    OrderStatus::Released,
+];
+
 #[derive(thiserror::Error, Debug)]
 pub enum OrderError {
     #[error("Order not found: {0}")]
     NotFound(ClientOrderId),
     #[error("Order invariant failed: must have a side for this operation")]
     NoOrderSide,
     #[error("Invalid event for order type")]
@@ -74,188 +85,427 @@
     InvalidStateTransition,
     #[error("Order was already initialized")]
     AlreadyInitialized,
     #[error("Order had no previous state")]
     NoPreviousState,
 }
 
-pub enum OrderSideFixed {
-    /// The order is a BUY.
-    Buy = 1,
-    /// The order is a SELL.
-    Sell = 2,
+#[derive(Clone, Debug, Serialize, Deserialize)]
+pub enum OrderAny {
+    Limit(LimitOrder),
+    LimitIfTouched(LimitIfTouchedOrder),
+    Market(MarketOrder),
+    MarketIfTouched(MarketIfTouchedOrder),
+    MarketToLimit(MarketToLimitOrder),
+    StopLimit(StopLimitOrder),
+    StopMarket(StopMarketOrder),
+    TrailingStopLimit(TrailingStopLimitOrder),
+    TrailingStopMarket(TrailingStopMarketOrder),
+}
+
+impl OrderAny {
+    #[must_use]
+    pub fn from_limit(order: LimitOrder) -> Self {
+        Self::Limit(order)
+    }
+
+    #[must_use]
+    pub fn from_limit_if_touched(order: LimitIfTouchedOrder) -> Self {
+        Self::LimitIfTouched(order)
+    }
+
+    #[must_use]
+    pub fn from_market(order: MarketOrder) -> Self {
+        Self::Market(order)
+    }
+
+    #[must_use]
+    pub fn from_market_if_touched(order: MarketIfTouchedOrder) -> Self {
+        Self::MarketIfTouched(order)
+    }
+
+    #[must_use]
+    pub fn from_market_to_limit(order: MarketToLimitOrder) -> Self {
+        Self::MarketToLimit(order)
+    }
+
+    #[must_use]
+    pub fn from_stop_limit(order: StopLimitOrder) -> Self {
+        Self::StopLimit(order)
+    }
+
+    #[must_use]
+    pub fn from_stop_market(order: StopMarketOrder) -> Self {
+        Self::StopMarket(order)
+    }
+
+    #[must_use]
+    pub fn from_trailing_stop_limit(order: StopLimitOrder) -> Self {
+        Self::StopLimit(order)
+    }
+
+    #[must_use]
+    pub fn from_trailing_stop_market(order: StopMarketOrder) -> Self {
+        Self::StopMarket(order)
+    }
+}
+
+impl GetInstrumentId for OrderAny {
+    fn instrument_id(&self) -> InstrumentId {
+        match self {
+            Self::Limit(order) => order.instrument_id,
+            Self::LimitIfTouched(order) => order.instrument_id,
+            Self::Market(order) => order.instrument_id,
+            Self::MarketIfTouched(order) => order.instrument_id,
+            Self::MarketToLimit(order) => order.instrument_id,
+            Self::StopLimit(order) => order.instrument_id,
+            Self::StopMarket(order) => order.instrument_id,
+            Self::TrailingStopLimit(order) => order.instrument_id,
+            Self::TrailingStopMarket(order) => order.instrument_id,
+        }
+    }
+}
+
+impl GetClientOrderId for OrderAny {
+    fn client_order_id(&self) -> ClientOrderId {
+        match self {
+            Self::Limit(order) => order.client_order_id,
+            Self::LimitIfTouched(order) => order.client_order_id,
+            Self::Market(order) => order.client_order_id,
+            Self::MarketIfTouched(order) => order.client_order_id,
+            Self::MarketToLimit(order) => order.client_order_id,
+            Self::StopLimit(order) => order.client_order_id,
+            Self::StopMarket(order) => order.client_order_id,
+            Self::TrailingStopLimit(order) => order.client_order_id,
+            Self::TrailingStopMarket(order) => order.client_order_id,
+        }
+    }
+}
+
+impl GetVenueOrderId for OrderAny {
+    fn venue_order_id(&self) -> Option<VenueOrderId> {
+        match self {
+            Self::Limit(order) => order.venue_order_id,
+            Self::LimitIfTouched(order) => order.venue_order_id,
+            Self::Market(order) => order.venue_order_id,
+            Self::MarketIfTouched(order) => order.venue_order_id,
+            Self::MarketToLimit(order) => order.venue_order_id,
+            Self::StopLimit(order) => order.venue_order_id,
+            Self::StopMarket(order) => order.venue_order_id,
+            Self::TrailingStopLimit(order) => order.venue_order_id,
+            Self::TrailingStopMarket(order) => order.venue_order_id,
+        }
+    }
+}
+
+impl GetStrategyId for OrderAny {
+    fn strategy_id(&self) -> StrategyId {
+        match self {
+            Self::Limit(order) => order.strategy_id,
+            Self::LimitIfTouched(order) => order.strategy_id,
+            Self::Market(order) => order.strategy_id,
+            Self::MarketIfTouched(order) => order.strategy_id,
+            Self::MarketToLimit(order) => order.strategy_id,
+            Self::StopLimit(order) => order.strategy_id,
+            Self::StopMarket(order) => order.strategy_id,
+            Self::TrailingStopLimit(order) => order.strategy_id,
+            Self::TrailingStopMarket(order) => order.strategy_id,
+        }
+    }
+}
+
+impl GetExecAlgorithmId for OrderAny {
+    fn exec_algorithm_id(&self) -> Option<ExecAlgorithmId> {
+        match self {
+            Self::Limit(order) => order.exec_algorithm_id,
+            Self::LimitIfTouched(order) => order.exec_algorithm_id,
+            Self::Market(order) => order.exec_algorithm_id,
+            Self::MarketIfTouched(order) => order.exec_algorithm_id,
+            Self::MarketToLimit(order) => order.exec_algorithm_id,
+            Self::StopLimit(order) => order.exec_algorithm_id,
+            Self::StopMarket(order) => order.exec_algorithm_id,
+            Self::TrailingStopLimit(order) => order.exec_algorithm_id,
+            Self::TrailingStopMarket(order) => order.exec_algorithm_id,
+        }
+    }
+}
+
+impl GetExecSpawnId for OrderAny {
+    fn exec_spawn_id(&self) -> Option<ClientOrderId> {
+        match self {
+            Self::Limit(order) => order.exec_spawn_id,
+            Self::LimitIfTouched(order) => order.exec_spawn_id,
+            Self::Market(order) => order.exec_spawn_id,
+            Self::MarketIfTouched(order) => order.exec_spawn_id,
+            Self::MarketToLimit(order) => order.exec_spawn_id,
+            Self::StopLimit(order) => order.exec_spawn_id,
+            Self::StopMarket(order) => order.exec_spawn_id,
+            Self::TrailingStopLimit(order) => order.exec_spawn_id,
+            Self::TrailingStopMarket(order) => order.exec_spawn_id,
+        }
+    }
+}
+
+impl GetOrderSide for OrderAny {
+    fn order_side(&self) -> OrderSide {
+        match self {
+            Self::Limit(order) => order.side,
+            Self::LimitIfTouched(order) => order.side,
+            Self::Market(order) => order.side,
+            Self::MarketIfTouched(order) => order.side,
+            Self::MarketToLimit(order) => order.side,
+            Self::StopLimit(order) => order.side,
+            Self::StopMarket(order) => order.side,
+            Self::TrailingStopLimit(order) => order.side,
+            Self::TrailingStopMarket(order) => order.side,
+        }
+    }
+}
+
+impl GetOrderSideSpecified for OrderAny {
+    fn order_side_specified(&self) -> OrderSideSpecified {
+        match self {
+            Self::Limit(order) => order.side.as_specified(),
+            Self::LimitIfTouched(order) => order.side.as_specified(),
+            Self::Market(order) => order.side.as_specified(),
+            Self::MarketIfTouched(order) => order.side.as_specified(),
+            Self::MarketToLimit(order) => order.side.as_specified(),
+            Self::StopLimit(order) => order.side.as_specified(),
+            Self::StopMarket(order) => order.side.as_specified(),
+            Self::TrailingStopLimit(order) => order.side.as_specified(),
+            Self::TrailingStopMarket(order) => order.side.as_specified(),
+        }
+    }
 }
 
-fn order_side_to_fixed(side: OrderSide) -> OrderSideFixed {
-    match side {
-        OrderSide::Buy => OrderSideFixed::Buy,
-        OrderSide::Sell => OrderSideFixed::Sell,
-        _ => panic!("Order invariant failed: side must be Buy or Sell"),
+impl GetEmulationTrigger for OrderAny {
+    fn emulation_trigger(&self) -> Option<TriggerType> {
+        match self {
+            Self::Limit(order) => order.emulation_trigger,
+            Self::LimitIfTouched(order) => order.emulation_trigger,
+            Self::Market(order) => order.emulation_trigger,
+            Self::MarketIfTouched(order) => order.emulation_trigger,
+            Self::MarketToLimit(order) => order.emulation_trigger,
+            Self::StopLimit(order) => order.emulation_trigger,
+            Self::StopMarket(order) => order.emulation_trigger,
+            Self::TrailingStopLimit(order) => order.emulation_trigger,
+            Self::TrailingStopMarket(order) => order.emulation_trigger,
+        }
     }
 }
 
 #[derive(Clone, Debug)]
-pub enum PassiveOrderType {
-    Limit(LimitOrderType),
-    Stop(StopOrderType),
+pub enum PassiveOrderAny {
+    Limit(LimitOrderAny),
+    Stop(StopOrderAny),
 }
 
-impl PartialEq for PassiveOrderType {
+impl PassiveOrderAny {
+    #[must_use]
+    pub fn is_closed(&self) -> bool {
+        match self {
+            Self::Limit(o) => o.is_closed(),
+            Self::Stop(o) => o.is_closed(),
+        }
+    }
+
+    #[must_use]
+    pub fn expire_time(&self) -> Option<UnixNanos> {
+        match self {
+            Self::Limit(o) => o.expire_time(),
+            Self::Stop(o) => o.expire_time(),
+        }
+    }
+}
+
+impl PartialEq for PassiveOrderAny {
     fn eq(&self, rhs: &Self) -> bool {
         match self {
-            Self::Limit(o) => o.get_client_order_id() == rhs.get_client_order_id(),
-            Self::Stop(o) => o.get_client_order_id() == rhs.get_client_order_id(),
+            Self::Limit(order) => order.client_order_id() == rhs.client_order_id(),
+            Self::Stop(order) => order.client_order_id() == rhs.client_order_id(),
         }
     }
 }
 
 #[derive(Clone, Debug)]
-pub enum LimitOrderType {
+pub enum LimitOrderAny {
     Limit(LimitOrder),
     MarketToLimit(MarketToLimitOrder),
     StopLimit(StopLimitOrder),
     TrailingStopLimit(TrailingStopLimitOrder),
 }
 
-impl PartialEq for LimitOrderType {
-    fn eq(&self, rhs: &Self) -> bool {
+impl LimitOrderAny {
+    #[must_use]
+    pub fn is_closed(&self) -> bool {
         match self {
-            Self::Limit(o) => o.client_order_id == rhs.get_client_order_id(),
-            Self::MarketToLimit(o) => o.client_order_id == rhs.get_client_order_id(),
-            Self::StopLimit(o) => o.client_order_id == rhs.get_client_order_id(),
-            Self::TrailingStopLimit(o) => o.client_order_id == rhs.get_client_order_id(),
+            Self::Limit(o) => o.is_closed(),
+            Self::MarketToLimit(o) => o.is_closed(),
+            Self::StopLimit(o) => o.is_closed(),
+            Self::TrailingStopLimit(o) => o.is_closed(),
         }
     }
-}
 
-#[derive(Clone, Debug)]
-pub enum StopOrderType {
-    StopMarket(StopMarketOrder),
-    StopLimit(StopLimitOrder),
-    MarketIfTouched(MarketIfTouchedOrder),
-    LimitIfTouched(LimitIfTouchedOrder),
-    TrailingStopMarket(TrailingStopMarketOrder),
-    TrailingStopLimit(TrailingStopLimitOrder),
+    #[must_use]
+    pub fn expire_time(&self) -> Option<UnixNanos> {
+        match self {
+            Self::Limit(o) => o.expire_time,
+            Self::MarketToLimit(o) => o.expire_time,
+            Self::StopLimit(o) => o.expire_time,
+            Self::TrailingStopLimit(o) => o.expire_time,
+        }
+    }
 }
 
-impl PartialEq for StopOrderType {
+impl PartialEq for LimitOrderAny {
     fn eq(&self, rhs: &Self) -> bool {
         match self {
-            Self::StopMarket(o) => o.client_order_id == rhs.get_client_order_id(),
-            Self::StopLimit(o) => o.client_order_id == rhs.get_client_order_id(),
-            Self::MarketIfTouched(o) => o.client_order_id == rhs.get_client_order_id(),
-            Self::LimitIfTouched(o) => o.client_order_id == rhs.get_client_order_id(),
-            Self::TrailingStopMarket(o) => o.client_order_id == rhs.get_client_order_id(),
-            Self::TrailingStopLimit(o) => o.client_order_id == rhs.get_client_order_id(),
+            Self::Limit(order) => order.client_order_id == rhs.client_order_id(),
+            Self::MarketToLimit(order) => order.client_order_id == rhs.client_order_id(),
+            Self::StopLimit(order) => order.client_order_id == rhs.client_order_id(),
+            Self::TrailingStopLimit(order) => order.client_order_id == rhs.client_order_id(),
         }
     }
 }
 
-pub trait GetClientOrderId {
-    fn get_client_order_id(&self) -> ClientOrderId;
+#[derive(Clone, Debug)]
+pub enum StopOrderAny {
+    LimitIfTouched(LimitIfTouchedOrder),
+    MarketIfTouched(MarketIfTouchedOrder),
+    StopLimit(StopLimitOrder),
+    StopMarket(StopMarketOrder),
+    TrailingStopLimit(TrailingStopLimitOrder),
+    TrailingStopMarket(TrailingStopMarketOrder),
 }
 
-pub trait GetOrderSide {
-    fn get_order_side(&self) -> OrderSideFixed;
-}
+impl StopOrderAny {
+    #[must_use]
+    pub fn is_closed(&self) -> bool {
+        match self {
+            Self::LimitIfTouched(o) => o.is_closed(),
+            Self::MarketIfTouched(o) => o.is_closed(),
+            Self::StopLimit(o) => o.is_closed(),
+            Self::StopMarket(o) => o.is_closed(),
+            Self::TrailingStopLimit(o) => o.is_closed(),
+            Self::TrailingStopMarket(o) => o.is_closed(),
+        }
+    }
 
-pub trait GetLimitPrice {
-    fn get_limit_px(&self) -> Price;
+    #[must_use]
+    pub fn expire_time(&self) -> Option<UnixNanos> {
+        match self {
+            Self::LimitIfTouched(o) => o.expire_time,
+            Self::MarketIfTouched(o) => o.expire_time,
+            Self::StopLimit(o) => o.expire_time,
+            Self::StopMarket(o) => o.expire_time,
+            Self::TrailingStopLimit(o) => o.expire_time,
+            Self::TrailingStopMarket(o) => o.expire_time,
+        }
+    }
 }
 
-pub trait GetStopPrice {
-    fn get_stop_px(&self) -> Price;
+impl PartialEq for StopOrderAny {
+    fn eq(&self, rhs: &Self) -> bool {
+        match self {
+            Self::LimitIfTouched(order) => order.client_order_id == rhs.client_order_id(),
+            Self::StopLimit(order) => order.client_order_id == rhs.client_order_id(),
+            Self::StopMarket(order) => order.client_order_id == rhs.client_order_id(),
+            Self::MarketIfTouched(order) => order.client_order_id == rhs.client_order_id(),
+            Self::TrailingStopLimit(order) => order.client_order_id == rhs.client_order_id(),
+            Self::TrailingStopMarket(order) => order.client_order_id == rhs.client_order_id(),
+        }
+    }
 }
 
-impl GetClientOrderId for PassiveOrderType {
-    fn get_client_order_id(&self) -> ClientOrderId {
+impl GetClientOrderId for PassiveOrderAny {
+    fn client_order_id(&self) -> ClientOrderId {
         match self {
-            Self::Limit(o) => o.get_client_order_id(),
-            Self::Stop(o) => o.get_client_order_id(),
+            Self::Limit(order) => order.client_order_id(),
+            Self::Stop(order) => order.client_order_id(),
         }
     }
 }
 
-impl GetOrderSide for PassiveOrderType {
-    fn get_order_side(&self) -> OrderSideFixed {
+impl GetOrderSideSpecified for PassiveOrderAny {
+    fn order_side_specified(&self) -> OrderSideSpecified {
         match self {
-            Self::Limit(o) => o.get_order_side(),
-            Self::Stop(o) => o.get_order_side(),
+            Self::Limit(order) => order.order_side_specified(),
+            Self::Stop(order) => order.order_side_specified(),
         }
     }
 }
 
-impl GetClientOrderId for LimitOrderType {
-    fn get_client_order_id(&self) -> ClientOrderId {
+impl GetClientOrderId for LimitOrderAny {
+    fn client_order_id(&self) -> ClientOrderId {
         match self {
-            Self::Limit(o) => o.client_order_id,
-            Self::MarketToLimit(o) => o.client_order_id,
-            Self::StopLimit(o) => o.client_order_id,
-            Self::TrailingStopLimit(o) => o.client_order_id,
+            Self::Limit(order) => order.client_order_id,
+            Self::MarketToLimit(order) => order.client_order_id,
+            Self::StopLimit(order) => order.client_order_id,
+            Self::TrailingStopLimit(order) => order.client_order_id,
         }
     }
 }
 
-impl GetOrderSide for LimitOrderType {
-    fn get_order_side(&self) -> OrderSideFixed {
+impl GetOrderSideSpecified for LimitOrderAny {
+    fn order_side_specified(&self) -> OrderSideSpecified {
         match self {
-            Self::Limit(o) => order_side_to_fixed(o.side),
-            Self::MarketToLimit(o) => order_side_to_fixed(o.side),
-            Self::StopLimit(o) => order_side_to_fixed(o.side),
-            Self::TrailingStopLimit(o) => order_side_to_fixed(o.side),
+            Self::Limit(order) => order.side.as_specified(),
+            Self::MarketToLimit(order) => order.side.as_specified(),
+            Self::StopLimit(order) => order.side.as_specified(),
+            Self::TrailingStopLimit(order) => order.side.as_specified(),
         }
     }
 }
 
-impl GetLimitPrice for LimitOrderType {
-    fn get_limit_px(&self) -> Price {
+impl GetLimitPrice for LimitOrderAny {
+    fn limit_px(&self) -> Price {
         match self {
-            Self::Limit(o) => o.price,
-            Self::MarketToLimit(o) => o.price.expect("No price for order"), // TBD
-            Self::StopLimit(o) => o.price,
-            Self::TrailingStopLimit(o) => o.price,
+            Self::Limit(order) => order.price,
+            Self::MarketToLimit(order) => order.price.expect("No price for order"), // TBD
+            Self::StopLimit(order) => order.price,
+            Self::TrailingStopLimit(order) => order.price,
         }
     }
 }
 
-impl GetClientOrderId for StopOrderType {
-    fn get_client_order_id(&self) -> ClientOrderId {
+impl GetClientOrderId for StopOrderAny {
+    fn client_order_id(&self) -> ClientOrderId {
         match self {
-            Self::StopMarket(o) => o.client_order_id,
-            Self::StopLimit(o) => o.client_order_id,
-            Self::MarketIfTouched(o) => o.client_order_id,
-            Self::LimitIfTouched(o) => o.client_order_id,
-            Self::TrailingStopMarket(o) => o.client_order_id,
-            Self::TrailingStopLimit(o) => o.client_order_id,
+            Self::LimitIfTouched(order) => order.client_order_id,
+            Self::MarketIfTouched(order) => order.client_order_id,
+            Self::StopLimit(order) => order.client_order_id,
+            Self::StopMarket(order) => order.client_order_id,
+            Self::TrailingStopLimit(order) => order.client_order_id,
+            Self::TrailingStopMarket(order) => order.client_order_id,
         }
     }
 }
 
-impl GetOrderSide for StopOrderType {
-    fn get_order_side(&self) -> OrderSideFixed {
+impl GetOrderSideSpecified for StopOrderAny {
+    fn order_side_specified(&self) -> OrderSideSpecified {
         match self {
-            Self::StopMarket(o) => order_side_to_fixed(o.side),
-            Self::StopLimit(o) => order_side_to_fixed(o.side),
-            Self::MarketIfTouched(o) => order_side_to_fixed(o.side),
-            Self::LimitIfTouched(o) => order_side_to_fixed(o.side),
-            Self::TrailingStopMarket(o) => order_side_to_fixed(o.side),
-            Self::TrailingStopLimit(o) => order_side_to_fixed(o.side),
+            Self::LimitIfTouched(order) => order.side.as_specified(),
+            Self::MarketIfTouched(order) => order.side.as_specified(),
+            Self::StopLimit(order) => order.side.as_specified(),
+            Self::StopMarket(order) => order.side.as_specified(),
+            Self::TrailingStopLimit(order) => order.side.as_specified(),
+            Self::TrailingStopMarket(order) => order.side.as_specified(),
         }
     }
 }
 
-impl GetStopPrice for StopOrderType {
-    fn get_stop_px(&self) -> Price {
+impl GetStopPrice for StopOrderAny {
+    fn stop_px(&self) -> Price {
         match self {
-            Self::StopMarket(o) => o.trigger_price,
-            Self::StopLimit(o) => o.trigger_price,
-            Self::MarketIfTouched(o) => o.trigger_price,
             Self::LimitIfTouched(o) => o.trigger_price,
-            Self::TrailingStopMarket(o) => o.trigger_price,
+            Self::MarketIfTouched(o) => o.trigger_price,
+            Self::StopLimit(o) => o.trigger_price,
+            Self::StopMarket(o) => o.trigger_price,
             Self::TrailingStopLimit(o) => o.trigger_price,
+            Self::TrailingStopMarket(o) => o.trigger_price,
         }
     }
 }
 
 #[must_use]
 pub fn ustr_hashmap_to_str(h: HashMap<Ustr, Ustr>) -> HashMap<String, String> {
     h.into_iter()
@@ -338,14 +588,15 @@
             _ => return Err(OrderError::InvalidStateTransition),
         };
         Ok(new_state)
     }
 }
 
 pub trait Order {
+    fn into_any(self) -> OrderAny;
     fn status(&self) -> OrderStatus;
     fn trader_id(&self) -> TraderId;
     fn strategy_id(&self) -> StrategyId;
     fn instrument_id(&self) -> InstrumentId;
     fn symbol(&self) -> Symbol;
     fn venue(&self) -> Venue;
     fn client_order_id(&self) -> ClientOrderId;
@@ -588,78 +839,57 @@
     pub slippage: Option<f64>,
     pub init_id: UUID4,
     pub ts_init: UnixNanos,
     pub ts_last: UnixNanos,
 }
 
 impl OrderCore {
-    #[must_use]
-    #[allow(clippy::too_many_arguments)]
-    pub fn new(
-        trader_id: TraderId,
-        strategy_id: StrategyId,
-        instrument_id: InstrumentId,
-        client_order_id: ClientOrderId,
-        order_side: OrderSide,
-        order_type: OrderType,
-        quantity: Quantity,
-        time_in_force: TimeInForce,
-        reduce_only: bool,
-        quote_quantity: bool,
-        emulation_trigger: Option<TriggerType>,
-        contingency_type: Option<ContingencyType>,
-        order_list_id: Option<OrderListId>,
-        linked_order_ids: Option<Vec<ClientOrderId>>,
-        parent_order_id: Option<ClientOrderId>,
-        exec_algorithm_id: Option<ExecAlgorithmId>,
-        exec_algorithm_params: Option<HashMap<Ustr, Ustr>>,
-        exec_spawn_id: Option<ClientOrderId>,
-        tags: Option<Ustr>,
-        init_id: UUID4,
-        ts_init: UnixNanos,
-    ) -> Self {
-        Self {
-            events: Vec::new(),
+    pub fn new(init: OrderInitialized) -> anyhow::Result<Self> {
+        let events: Vec<OrderEvent> = vec![OrderEvent::OrderInitialized(init.clone())];
+        Ok(Self {
+            events,
             commissions: HashMap::new(),
             venue_order_ids: Vec::new(),
             trade_ids: Vec::new(),
             previous_status: None,
             status: OrderStatus::Initialized,
-            trader_id,
-            strategy_id,
-            instrument_id,
-            client_order_id,
+            trader_id: init.trader_id,
+            strategy_id: init.strategy_id,
+            instrument_id: init.instrument_id,
+            client_order_id: init.client_order_id,
             venue_order_id: None,
             position_id: None,
             account_id: None,
             last_trade_id: None,
-            side: order_side,
-            order_type,
-            quantity,
-            time_in_force,
+            side: init.order_side,
+            order_type: init.order_type,
+            quantity: init.quantity,
+            time_in_force: init.time_in_force,
             liquidity_side: Some(LiquiditySide::NoLiquiditySide),
-            is_reduce_only: reduce_only,
-            is_quote_quantity: quote_quantity,
-            emulation_trigger: emulation_trigger.or(Some(TriggerType::NoTrigger)),
-            contingency_type: contingency_type.or(Some(ContingencyType::NoContingency)),
-            order_list_id,
-            linked_order_ids,
-            parent_order_id,
-            exec_algorithm_id,
-            exec_algorithm_params,
-            exec_spawn_id,
-            tags,
-            filled_qty: Quantity::zero(quantity.precision),
-            leaves_qty: quantity,
+            is_reduce_only: init.reduce_only,
+            is_quote_quantity: init.quote_quantity,
+            emulation_trigger: init.emulation_trigger.or(Some(TriggerType::NoTrigger)),
+            contingency_type: init
+                .contingency_type
+                .or(Some(ContingencyType::NoContingency)),
+            order_list_id: init.order_list_id,
+            linked_order_ids: init.linked_order_ids,
+            parent_order_id: init.parent_order_id,
+            exec_algorithm_id: init.exec_algorithm_id,
+            exec_algorithm_params: init.exec_algorithm_params,
+            exec_spawn_id: init.exec_spawn_id,
+            tags: init.tags,
+            filled_qty: Quantity::zero(init.quantity.precision),
+            leaves_qty: init.quantity,
             avg_px: None,
             slippage: None,
-            init_id,
-            ts_init,
-            ts_last: ts_init,
-        }
+            init_id: init.event_id,
+            ts_init: init.ts_event,
+            ts_last: init.ts_event,
+        })
     }
 
     pub fn apply(&mut self, event: OrderEvent) -> Result<(), OrderError> {
         assert_eq!(self.client_order_id, event.client_order_id());
         assert_eq!(self.strategy_id, event.strategy_id());
 
         let new_status = self.status.transition(&event)?;
@@ -841,16 +1071,16 @@
 
     #[must_use]
     pub fn commissions(&self) -> HashMap<Currency, Money> {
         self.commissions.clone()
     }
 
     #[must_use]
-    pub fn init_event(&self) -> Option<&OrderEvent> {
-        self.events.first()
+    pub fn init_event(&self) -> Option<OrderEvent> {
+        self.events.first().cloned()
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
@@ -947,15 +1177,15 @@
         let event = OrderEvent::OrderDenied(denied);
 
         order.apply(event.clone()).unwrap();
 
         assert_eq!(order.status, OrderStatus::Denied);
         assert!(order.is_closed());
         assert!(!order.is_open());
-        assert_eq!(order.event_count(), 1);
+        assert_eq!(order.event_count(), 2);
         assert_eq!(order.last_event(), &event);
     }
 
     #[rstest]
     fn test_order_life_cycle_to_filled() {
         let init = OrderInitializedBuilder::default().build().unwrap();
         let submitted = OrderSubmittedBuilder::default().build().unwrap();
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orders/default.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orders/default.rs`

 * *Files 12% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_core::uuid::UUID4;
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 
 use super::{
     limit::LimitOrder, limit_if_touched::LimitIfTouchedOrder, market::MarketOrder,
     market_if_touched::MarketIfTouchedOrder, market_to_limit::MarketToLimitOrder,
     stop_limit::StopLimitOrder, stop_market::StopMarketOrder,
     trailing_stop_limit::TrailingStopLimitOrder, trailing_stop_market::TrailingStopMarketOrder,
 };
@@ -54,15 +54,15 @@
             None,
             None,
             None,
             None,
             None,
             None,
             UUID4::default(),
-            0,
+            UnixNanos::default(),
         )
         .unwrap() // SAFETY: Valid default values are used
     }
 }
 
 /// Provides a default [`LimitIfTouchedOrder`] used for testing.
 impl Default for LimitIfTouchedOrder {
@@ -90,15 +90,15 @@
             None,
             None,
             None,
             None,
             None,
             None,
             UUID4::default(),
-            0,
+            UnixNanos::default(),
         )
         .unwrap() // SAFETY: Valid default values are used
     }
 }
 
 /// Provides a default [`MarketOrder`] used for testing.
 impl Default for MarketOrder {
@@ -108,15 +108,15 @@
             StrategyId::default(),
             InstrumentId::default(),
             ClientOrderId::default(),
             OrderSide::Buy,
             Quantity::from(100_000),
             TimeInForce::Day,
             UUID4::default(),
-            0,
+            UnixNanos::default(),
             false,
             false,
             None,
             None,
             None,
             None,
             None,
@@ -152,15 +152,15 @@
             None,
             None,
             None,
             None,
             None,
             None,
             UUID4::default(),
-            0,
+            UnixNanos::default(),
         )
         .unwrap() // SAFETY: Valid default values are used
     }
 }
 
 /// Provides a default [`MarketToLimitOrder`] used for testing.
 impl Default for MarketToLimitOrder {
@@ -183,15 +183,15 @@
             None,
             None,
             None,
             None,
             None,
             None,
             UUID4::default(),
-            0,
+            UnixNanos::default(),
         )
         .unwrap() // SAFETY: Valid default values are used
     }
 }
 
 /// Provides a default [`StopLimitOrder`] used for testing.
 impl Default for StopLimitOrder {
@@ -219,15 +219,15 @@
             None,
             None,
             None,
             None,
             None,
             None,
             UUID4::default(),
-            0,
+            UnixNanos::default(),
         )
         .unwrap() // SAFETY: Valid default values are used
     }
 }
 
 /// Provides a default [`StopMarketOrder`] used for testing.
 impl Default for StopMarketOrder {
@@ -253,15 +253,15 @@
             None,
             None,
             None,
             None,
             None,
             None,
             UUID4::default(),
-            0,
+            UnixNanos::default(),
         )
         .unwrap() // SAFETY: Valid default values are used
     }
 }
 
 /// Provides a default [`TrailingStopLimitOrder`] used for testing.
 impl Default for TrailingStopLimitOrder {
@@ -292,15 +292,15 @@
             None,
             None,
             None,
             None,
             None,
             None,
             UUID4::default(),
-            0,
+            UnixNanos::default(),
         )
         .unwrap() // SAFETY: Valid default values are used
     }
 }
 
 /// Provides a default [`TrailingStopMarketOrder`] used for testing.
 impl Default for TrailingStopMarketOrder {
@@ -328,12 +328,12 @@
             None,
             None,
             None,
             None,
             None,
             None,
             UUID4::default(),
-            0,
+            UnixNanos::default(),
         )
         .unwrap() // SAFETY: Valid default values are used
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orders/limit.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orders/limit.rs`

 * *Files 3% similar despite different names*

```diff
@@ -15,19 +15,19 @@
 
 use std::{
     collections::HashMap,
     fmt::Display,
     ops::{Deref, DerefMut},
 };
 
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
-use super::base::{Order, OrderCore};
+use super::base::{Order, OrderAny, OrderCore};
 use crate::{
     enums::{
         ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, TimeInForce,
         TrailingOffsetType, TriggerType,
     },
     events::order::{event::OrderEvent, initialized::OrderInitialized, updated::OrderUpdated},
     identifiers::{
@@ -93,41 +93,55 @@
             }
             if let Some(time) = expire_time {
                 if time == 0 {
                     anyhow::bail!("`expire_time` for `GTD` Limit order should be higher then 0")
                 }
             }
         }
+        let init_order = OrderInitialized::new(
+            trader_id,
+            strategy_id,
+            instrument_id,
+            client_order_id,
+            order_side,
+            OrderType::Limit,
+            quantity,
+            time_in_force,
+            post_only,
+            reduce_only,
+            quote_quantity,
+            false,
+            init_id,
+            ts_init, // ts_event timestamp identical to ts_init
+            ts_init,
+            Some(price),
+            None,
+            None,
+            None,
+            None,
+            None,
+            expire_time,
+            display_qty,
+            emulation_trigger,
+            trigger_instrument_id,
+            contingency_type,
+            order_list_id,
+            linked_order_ids,
+            parent_order_id,
+            exec_algorithm_id,
+            exec_algorithm_params,
+            exec_spawn_id,
+            tags,
+        )
+        .unwrap();
 
         Ok(Self {
-            core: OrderCore::new(
-                trader_id,
-                strategy_id,
-                instrument_id,
-                client_order_id,
-                order_side,
-                OrderType::Limit,
-                quantity,
-                time_in_force,
-                reduce_only,
-                quote_quantity,
-                emulation_trigger,
-                contingency_type,
-                order_list_id,
-                linked_order_ids,
-                parent_order_id,
-                exec_algorithm_id,
-                exec_algorithm_params,
-                exec_spawn_id,
-                tags,
-                init_id,
-                ts_init,
-            ),
+            core: OrderCore::new(init_order).unwrap(),
             price,
-            expire_time: expire_time.or(Some(0)),
+            expire_time: expire_time.or(Some(UnixNanos::default())),
             is_post_only: post_only,
             display_qty,
             trigger_instrument_id,
         })
     }
 }
 
@@ -148,14 +162,18 @@
 impl PartialEq for LimitOrder {
     fn eq(&self, other: &Self) -> bool {
         self.client_order_id == other.client_order_id
     }
 }
 
 impl Order for LimitOrder {
+    fn into_any(self) -> OrderAny {
+        OrderAny::Limit(self)
+    }
+
     fn status(&self) -> OrderStatus {
         self.status
     }
 
     fn trader_id(&self) -> TraderId {
         self.trader_id
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orders/limit_if_touched.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orders/market_if_touched.rs`

 * *Files 2% similar despite different names*

```diff
@@ -14,18 +14,19 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::HashMap,
     ops::{Deref, DerefMut},
 };
 
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
+use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
-use super::base::{Order, OrderCore, OrderError};
+use super::base::{Order, OrderAny, OrderCore, OrderError};
 use crate::{
     enums::{
         ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, TimeInForce,
         TrailingOffsetType, TriggerType,
     },
     events::order::{event::OrderEvent, initialized::OrderInitialized, updated::OrderUpdated},
     identifiers::{
@@ -33,47 +34,43 @@
         instrument_id::InstrumentId, order_list_id::OrderListId, position_id::PositionId,
         strategy_id::StrategyId, symbol::Symbol, trade_id::TradeId, trader_id::TraderId,
         venue::Venue, venue_order_id::VenueOrderId,
     },
     types::{price::Price, quantity::Quantity},
 };
 
-#[derive(Clone, Debug)]
+#[derive(Clone, Debug, Serialize, Deserialize)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct LimitIfTouchedOrder {
-    pub price: Price,
+pub struct MarketIfTouchedOrder {
     pub trigger_price: Price,
     pub trigger_type: TriggerType,
     pub expire_time: Option<UnixNanos>,
-    pub is_post_only: bool,
     pub display_qty: Option<Quantity>,
     pub trigger_instrument_id: Option<InstrumentId>,
     pub is_triggered: bool,
     pub ts_triggered: Option<UnixNanos>,
     core: OrderCore,
 }
 
-impl LimitIfTouchedOrder {
+impl MarketIfTouchedOrder {
     #[allow(clippy::too_many_arguments)]
     pub fn new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         order_side: OrderSide,
         quantity: Quantity,
-        price: Price,
         trigger_price: Price,
         trigger_type: TriggerType,
         time_in_force: TimeInForce,
         expire_time: Option<UnixNanos>,
-        post_only: bool,
         reduce_only: bool,
         quote_quantity: bool,
         display_qty: Option<Quantity>,
         emulation_trigger: Option<TriggerType>,
         trigger_instrument_id: Option<InstrumentId>,
         contingency_type: Option<ContingencyType>,
         order_list_id: Option<OrderListId>,
@@ -82,66 +79,82 @@
         exec_algorithm_id: Option<ExecAlgorithmId>,
         exec_algorithm_params: Option<HashMap<Ustr, Ustr>>,
         exec_spawn_id: Option<ClientOrderId>,
         tags: Option<Ustr>,
         init_id: UUID4,
         ts_init: UnixNanos,
     ) -> anyhow::Result<Self> {
+        let init_order = OrderInitialized::new(
+            trader_id,
+            strategy_id,
+            instrument_id,
+            client_order_id,
+            order_side,
+            OrderType::MarketIfTouched,
+            quantity,
+            time_in_force,
+            false,
+            reduce_only,
+            quote_quantity,
+            false,
+            init_id,
+            ts_init,
+            ts_init,
+            None,
+            Some(trigger_price),
+            Some(trigger_type),
+            None,
+            None,
+            None,
+            expire_time,
+            display_qty,
+            emulation_trigger,
+            trigger_instrument_id,
+            contingency_type,
+            order_list_id,
+            linked_order_ids,
+            parent_order_id,
+            exec_algorithm_id,
+            exec_algorithm_params,
+            exec_spawn_id,
+            tags,
+        )
+        .unwrap();
         Ok(Self {
-            core: OrderCore::new(
-                trader_id,
-                strategy_id,
-                instrument_id,
-                client_order_id,
-                order_side,
-                OrderType::LimitIfTouched,
-                quantity,
-                time_in_force,
-                reduce_only,
-                quote_quantity,
-                emulation_trigger,
-                contingency_type,
-                order_list_id,
-                linked_order_ids,
-                parent_order_id,
-                exec_algorithm_id,
-                exec_algorithm_params,
-                exec_spawn_id,
-                tags,
-                init_id,
-                ts_init,
-            ),
-            price,
+            core: OrderCore::new(init_order).unwrap(),
             trigger_price,
             trigger_type,
             expire_time,
-            is_post_only: post_only,
             display_qty,
             trigger_instrument_id,
             is_triggered: false,
             ts_triggered: None,
         })
     }
 }
 
-impl Deref for LimitIfTouchedOrder {
+impl Deref for MarketIfTouchedOrder {
     type Target = OrderCore;
 
     fn deref(&self) -> &Self::Target {
         &self.core
     }
 }
 
-impl DerefMut for LimitIfTouchedOrder {
+impl DerefMut for MarketIfTouchedOrder {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.core
     }
 }
 
-impl Order for LimitIfTouchedOrder {
+impl Order for MarketIfTouchedOrder {
+    fn into_any(self) -> OrderAny {
+        OrderAny::MarketIfTouched(self)
+    }
+
     fn status(&self) -> OrderStatus {
         self.status
     }
 
     fn trader_id(&self) -> TraderId {
         self.trader_id
     }
@@ -199,15 +212,15 @@
     }
 
     fn expire_time(&self) -> Option<UnixNanos> {
         self.expire_time
     }
 
     fn price(&self) -> Option<Price> {
-        Some(self.price)
+        None
     }
 
     fn trigger_price(&self) -> Option<Price> {
         Some(self.trigger_price)
     }
 
     fn trigger_type(&self) -> Option<TriggerType> {
@@ -215,15 +228,15 @@
     }
 
     fn liquidity_side(&self) -> Option<LiquiditySide> {
         self.liquidity_side
     }
 
     fn is_post_only(&self) -> bool {
-        self.is_post_only
+        false
     }
 
     fn is_reduce_only(&self) -> bool {
         self.is_reduce_only
     }
 
     fn is_quote_quantity(&self) -> bool {
@@ -331,57 +344,51 @@
             self.update(event);
         };
         let is_order_filled = matches!(event, OrderEvent::OrderFilled(_));
 
         self.core.apply(event)?;
 
         if is_order_filled {
-            self.core.set_slippage(self.price);
+            self.core.set_slippage(self.trigger_price);
         };
 
         Ok(())
     }
 
     fn update(&mut self, event: &OrderUpdated) {
-        if let Some(price) = event.price {
-            self.price = price;
-        }
+        assert!(event.price.is_none(), "{}", OrderError::InvalidOrderEvent);
 
         if let Some(trigger_price) = event.trigger_price {
             self.trigger_price = trigger_price;
         }
 
         self.quantity = event.quantity;
         self.leaves_qty = self.quantity - self.filled_qty;
     }
 }
 
-impl From<OrderInitialized> for LimitIfTouchedOrder {
+impl From<OrderInitialized> for MarketIfTouchedOrder {
     fn from(event: OrderInitialized) -> Self {
         Self::new(
             event.trader_id,
             event.strategy_id,
             event.instrument_id,
             event.client_order_id,
             event.order_side,
             event.quantity,
             event
-                .price // TODO: Improve this error, model order domain errors
-                .expect("Error initializing order: `price` was `None` for `LimitIfTouchedOrder"),
-            event
                 .trigger_price // TODO: Improve this error, model order domain errors
                 .expect(
-                    "Error initializing order: `trigger_price` was `None` for `LimitIfTouchedOrder",
+                    "Error initializing order: `trigger_price` was `None` for `MarketIfTouchedOrder`",
                 ),
             event
                 .trigger_type
-                .expect("Error initializing order: `trigger_type` was `None`"),
+                .expect("Error initializing order: `trigger_type` was `None` for `MarketIfTouchedOrder`"),
             event.time_in_force,
             event.expire_time,
-            event.post_only,
             event.reduce_only,
             event.quote_quantity,
             event.display_qty,
             event.emulation_trigger,
             event.trigger_instrument_id,
             event.contingency_type,
             event.order_list_id,
@@ -389,11 +396,10 @@
             event.parent_order_id,
             event.exec_algorithm_id,
             event.exec_algorithm_params,
             event.exec_spawn_id,
             event.tags,
             event.event_id,
             event.ts_event,
-        )
-        .unwrap() // SAFETY: From can panic
+        ).unwrap() // SAFETY: From can panic
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orders/market.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orders/market.rs`

 * *Files 4% similar despite different names*

```diff
@@ -15,19 +15,19 @@
 
 use std::{
     collections::HashMap,
     fmt::Display,
     ops::{Deref, DerefMut},
 };
 
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
-use super::base::{Order, OrderCore};
+use super::base::{Order, OrderAny, OrderCore};
 use crate::{
     enums::{
         ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, TimeInForce,
         TrailingOffsetType, TriggerType,
     },
     events::order::{event::OrderEvent, initialized::OrderInitialized, updated::OrderUpdated},
     identifiers::{
@@ -73,41 +73,55 @@
         exec_algorithm_id: Option<ExecAlgorithmId>,
         exec_algorithm_params: Option<HashMap<Ustr, Ustr>>,
         exec_spawn_id: Option<ClientOrderId>,
         tags: Option<Ustr>,
     ) -> anyhow::Result<Self> {
         check_quantity_positive(quantity)?;
         if time_in_force == TimeInForce::Gtd {
-            anyhow::bail!("{}", "GTD not supported for Market orders");
+            anyhow::bail!("GTD not supported for Market orders");
         }
+        let init_order = OrderInitialized::new(
+            trader_id,
+            strategy_id,
+            instrument_id,
+            client_order_id,
+            order_side,
+            OrderType::Market,
+            quantity,
+            time_in_force,
+            false,
+            reduce_only,
+            quote_quantity,
+            false,
+            init_id,
+            ts_init,
+            ts_init,
+            None,
+            None,
+            Some(TriggerType::NoTrigger),
+            None,
+            None,
+            None,
+            None,
+            None,
+            None,
+            None,
+            contingency_type,
+            order_list_id,
+            linked_order_ids,
+            parent_order_id,
+            exec_algorithm_id,
+            exec_algorithm_params,
+            exec_spawn_id,
+            tags,
+        )
+        .unwrap();
 
         Ok(Self {
-            core: OrderCore::new(
-                trader_id,
-                strategy_id,
-                instrument_id,
-                client_order_id,
-                order_side,
-                OrderType::Market,
-                quantity,
-                time_in_force,
-                reduce_only,
-                quote_quantity,
-                None, // Emulation trigger
-                contingency_type,
-                order_list_id,
-                linked_order_ids,
-                parent_order_id,
-                exec_algorithm_id,
-                exec_algorithm_params,
-                exec_spawn_id,
-                tags,
-                init_id,
-                ts_init,
-            ),
+            core: OrderCore::new(init_order).unwrap(),
         })
     }
 }
 
 impl Deref for MarketOrder {
     type Target = OrderCore;
 
@@ -125,14 +139,18 @@
 impl PartialEq for MarketOrder {
     fn eq(&self, other: &Self) -> bool {
         self.client_order_id == other.client_order_id
     }
 }
 
 impl Order for MarketOrder {
+    fn into_any(self) -> OrderAny {
+        OrderAny::Market(self)
+    }
+
     fn status(&self) -> OrderStatus {
         self.status
     }
 
     fn trader_id(&self) -> TraderId {
         self.trader_id
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orders/market_if_touched.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orders/stop_market.rs`

 * *Files 5% similar despite different names*

```diff
@@ -14,50 +14,52 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::HashMap,
     ops::{Deref, DerefMut},
 };
 
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
+use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
-use super::base::{Order, OrderCore, OrderError};
+use super::base::{Order, OrderAny, OrderCore};
 use crate::{
     enums::{
         ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, TimeInForce,
         TrailingOffsetType, TriggerType,
     },
     events::order::{event::OrderEvent, initialized::OrderInitialized, updated::OrderUpdated},
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, exec_algorithm_id::ExecAlgorithmId,
         instrument_id::InstrumentId, order_list_id::OrderListId, position_id::PositionId,
         strategy_id::StrategyId, symbol::Symbol, trade_id::TradeId, trader_id::TraderId,
         venue::Venue, venue_order_id::VenueOrderId,
     },
+    orders::base::OrderError,
     types::{price::Price, quantity::Quantity},
 };
 
-#[derive(Clone, Debug)]
+#[derive(Clone, Debug, Serialize, Deserialize)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct MarketIfTouchedOrder {
+pub struct StopMarketOrder {
     pub trigger_price: Price,
     pub trigger_type: TriggerType,
     pub expire_time: Option<UnixNanos>,
     pub display_qty: Option<Quantity>,
     pub trigger_instrument_id: Option<InstrumentId>,
     pub is_triggered: bool,
     pub ts_triggered: Option<UnixNanos>,
     core: OrderCore,
 }
 
-impl MarketIfTouchedOrder {
+impl StopMarketOrder {
     #[allow(clippy::too_many_arguments)]
     pub fn new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         order_side: OrderSide,
@@ -78,64 +80,82 @@
         exec_algorithm_id: Option<ExecAlgorithmId>,
         exec_algorithm_params: Option<HashMap<Ustr, Ustr>>,
         exec_spawn_id: Option<ClientOrderId>,
         tags: Option<Ustr>,
         init_id: UUID4,
         ts_init: UnixNanos,
     ) -> anyhow::Result<Self> {
+        let init_order = OrderInitialized::new(
+            trader_id,
+            strategy_id,
+            instrument_id,
+            client_order_id,
+            order_side,
+            OrderType::StopMarket,
+            quantity,
+            time_in_force,
+            false,
+            reduce_only,
+            quote_quantity,
+            false,
+            init_id,
+            ts_init,
+            ts_init,
+            None,
+            Some(trigger_price),
+            Some(trigger_type),
+            None,
+            None,
+            None,
+            expire_time,
+            display_qty,
+            emulation_trigger,
+            trigger_instrument_id,
+            contingency_type,
+            order_list_id,
+            linked_order_ids,
+            parent_order_id,
+            exec_algorithm_id,
+            exec_algorithm_params,
+            exec_spawn_id,
+            tags,
+        )
+        .unwrap();
         Ok(Self {
-            core: OrderCore::new(
-                trader_id,
-                strategy_id,
-                instrument_id,
-                client_order_id,
-                order_side,
-                OrderType::MarketIfTouched,
-                quantity,
-                time_in_force,
-                reduce_only,
-                quote_quantity,
-                emulation_trigger,
-                contingency_type,
-                order_list_id,
-                linked_order_ids,
-                parent_order_id,
-                exec_algorithm_id,
-                exec_algorithm_params,
-                exec_spawn_id,
-                tags,
-                init_id,
-                ts_init,
-            ),
+            core: OrderCore::new(init_order).unwrap(),
             trigger_price,
             trigger_type,
             expire_time,
             display_qty,
             trigger_instrument_id,
             is_triggered: false,
             ts_triggered: None,
         })
     }
 }
 
-impl Deref for MarketIfTouchedOrder {
+impl Deref for StopMarketOrder {
     type Target = OrderCore;
 
     fn deref(&self) -> &Self::Target {
         &self.core
     }
 }
 
-impl DerefMut for MarketIfTouchedOrder {
+impl DerefMut for StopMarketOrder {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.core
     }
 }
 
-impl Order for MarketIfTouchedOrder {
+impl Order for StopMarketOrder {
+    fn into_any(self) -> OrderAny {
+        OrderAny::StopMarket(self)
+    }
+
     fn status(&self) -> OrderStatus {
         self.status
     }
 
     fn trader_id(&self) -> TraderId {
         self.trader_id
     }
@@ -343,31 +363,31 @@
         }
 
         self.quantity = event.quantity;
         self.leaves_qty = self.quantity - self.filled_qty;
     }
 }
 
-impl From<OrderInitialized> for MarketIfTouchedOrder {
+impl From<OrderInitialized> for StopMarketOrder {
     fn from(event: OrderInitialized) -> Self {
         Self::new(
             event.trader_id,
             event.strategy_id,
             event.instrument_id,
             event.client_order_id,
             event.order_side,
             event.quantity,
             event
                 .trigger_price // TODO: Improve this error, model order domain errors
                 .expect(
-                    "Error initializing order: `trigger_price` was `None` for `MarketIfTouchedOrder`",
+                    "Error initializing order: `trigger_price` was `None` for `StopMarketOrder`",
                 ),
-            event
-                .trigger_type
-                .expect("Error initializing order: `trigger_type` was `None` for `MarketIfTouchedOrder`"),
+            event.trigger_type.expect(
+                "Error initializing order: `trigger_type` was `None` for `StopMarketOrder`",
+            ),
             event.time_in_force,
             event.expire_time,
             event.reduce_only,
             event.quote_quantity,
             event.display_qty,
             event.emulation_trigger,
             event.trigger_instrument_id,
@@ -377,10 +397,11 @@
             event.parent_order_id,
             event.exec_algorithm_id,
             event.exec_algorithm_params,
             event.exec_spawn_id,
             event.tags,
             event.event_id,
             event.ts_event,
-        ).unwrap() // SAFETY: From can panic
+        )
+        .unwrap() // SAFETY: From can panic
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orders/market_to_limit.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orders/market_to_limit.rs`

 * *Files 4% similar despite different names*

```diff
@@ -14,18 +14,19 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::HashMap,
     ops::{Deref, DerefMut},
 };
 
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
+use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
-use super::base::{Order, OrderCore};
+use super::base::{Order, OrderAny, OrderCore};
 use crate::{
     enums::{
         ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, TimeInForce,
         TrailingOffsetType, TriggerType,
     },
     events::order::{event::OrderEvent, initialized::OrderInitialized, updated::OrderUpdated},
     identifiers::{
@@ -34,15 +35,15 @@
         strategy_id::StrategyId, symbol::Symbol, trade_id::TradeId, trader_id::TraderId,
         venue::Venue, venue_order_id::VenueOrderId,
     },
     orders::base::OrderError,
     types::{price::Price, quantity::Quantity},
 };
 
-#[derive(Clone, Debug)]
+#[derive(Clone, Debug, Serialize, Deserialize)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
 pub struct MarketToLimitOrder {
     core: OrderCore,
     pub price: Option<Price>,
@@ -73,38 +74,52 @@
         exec_algorithm_id: Option<ExecAlgorithmId>,
         exec_algorithm_params: Option<HashMap<Ustr, Ustr>>,
         exec_spawn_id: Option<ClientOrderId>,
         tags: Option<Ustr>,
         init_id: UUID4,
         ts_init: UnixNanos,
     ) -> anyhow::Result<Self> {
+        let init_order = OrderInitialized::new(
+            trader_id,
+            strategy_id,
+            instrument_id,
+            client_order_id,
+            order_side,
+            OrderType::MarketToLimit,
+            quantity,
+            time_in_force,
+            post_only,
+            reduce_only,
+            quote_quantity,
+            false,
+            init_id,
+            ts_init,
+            ts_init,
+            None,
+            None,
+            None,
+            None,
+            None,
+            None,
+            expire_time,
+            display_qty,
+            Some(TriggerType::NoTrigger),
+            None,
+            contingency_type,
+            order_list_id,
+            linked_order_ids,
+            parent_order_id,
+            exec_algorithm_id,
+            exec_algorithm_params,
+            exec_spawn_id,
+            tags,
+        )
+        .unwrap();
         Ok(Self {
-            core: OrderCore::new(
-                trader_id,
-                strategy_id,
-                instrument_id,
-                client_order_id,
-                order_side,
-                OrderType::MarketToLimit,
-                quantity,
-                time_in_force,
-                reduce_only,
-                quote_quantity,
-                None, // Emulation trigger
-                contingency_type,
-                order_list_id,
-                linked_order_ids,
-                parent_order_id,
-                exec_algorithm_id,
-                exec_algorithm_params,
-                exec_spawn_id,
-                tags,
-                init_id,
-                ts_init,
-            ),
+            core: OrderCore::new(init_order).unwrap(),
             price: None, // Price will be determined on fill
             expire_time,
             is_post_only: post_only,
             display_qty,
         })
     }
 }
@@ -120,14 +135,18 @@
 impl DerefMut for MarketToLimitOrder {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.core
     }
 }
 
 impl Order for MarketToLimitOrder {
+    fn into_any(self) -> OrderAny {
+        OrderAny::MarketToLimit(self)
+    }
+
     fn status(&self) -> OrderStatus {
         self.status
     }
 
     fn trader_id(&self) -> TraderId {
         self.trader_id
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orders/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orders/mod.rs`

 * *Files 10% similar despite different names*

```diff
@@ -15,14 +15,15 @@
 
 #![allow(dead_code)]
 
 pub mod base;
 pub mod default;
 pub mod limit;
 pub mod limit_if_touched;
+pub mod list;
 pub mod market;
 pub mod market_if_touched;
 pub mod market_to_limit;
 pub mod stop_limit;
 pub mod stop_market;
 pub mod trailing_stop_limit;
 pub mod trailing_stop_market;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orders/stop_limit.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orders/stop_limit.rs`

 * *Files 10% similar despite different names*

```diff
@@ -11,21 +11,23 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::HashMap,
+    fmt::Display,
     ops::{Deref, DerefMut},
 };
 
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
+use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
-use super::base::{Order, OrderCore, OrderError};
+use super::base::{Order, OrderAny, OrderCore, OrderError};
 use crate::{
     enums::{
         ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, TimeInForce,
         TrailingOffsetType, TriggerType,
     },
     events::order::{event::OrderEvent, initialized::OrderInitialized, updated::OrderUpdated},
     identifiers::{
@@ -33,15 +35,15 @@
         instrument_id::InstrumentId, order_list_id::OrderListId, position_id::PositionId,
         strategy_id::StrategyId, symbol::Symbol, trade_id::TradeId, trader_id::TraderId,
         venue::Venue, venue_order_id::VenueOrderId,
     },
     types::{price::Price, quantity::Quantity},
 };
 
-#[derive(Clone, Debug)]
+#[derive(Clone, Debug, Serialize, Deserialize)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
 pub struct StopLimitOrder {
     pub price: Price,
     pub trigger_price: Price,
@@ -82,38 +84,52 @@
         exec_algorithm_id: Option<ExecAlgorithmId>,
         exec_algorithm_params: Option<HashMap<Ustr, Ustr>>,
         exec_spawn_id: Option<ClientOrderId>,
         tags: Option<Ustr>,
         init_id: UUID4,
         ts_init: UnixNanos,
     ) -> anyhow::Result<Self> {
+        let init_order = OrderInitialized::new(
+            trader_id,
+            strategy_id,
+            instrument_id,
+            client_order_id,
+            order_side,
+            OrderType::StopLimit,
+            quantity,
+            time_in_force,
+            post_only,
+            reduce_only,
+            quote_quantity,
+            false,
+            init_id,
+            ts_init,
+            ts_init,
+            Some(price),
+            Some(trigger_price),
+            Some(trigger_type),
+            None,
+            None,
+            None,
+            expire_time,
+            display_qty,
+            emulation_trigger,
+            trigger_instrument_id,
+            contingency_type,
+            order_list_id,
+            linked_order_ids,
+            parent_order_id,
+            exec_algorithm_id,
+            exec_algorithm_params,
+            exec_spawn_id,
+            tags,
+        )
+        .unwrap();
         Ok(Self {
-            core: OrderCore::new(
-                trader_id,
-                strategy_id,
-                instrument_id,
-                client_order_id,
-                order_side,
-                OrderType::LimitIfTouched,
-                quantity,
-                time_in_force,
-                reduce_only,
-                quote_quantity,
-                emulation_trigger,
-                contingency_type,
-                order_list_id,
-                linked_order_ids,
-                parent_order_id,
-                exec_algorithm_id,
-                exec_algorithm_params,
-                exec_spawn_id,
-                tags,
-                init_id,
-                ts_init,
-            ),
+            core: OrderCore::new(init_order).unwrap(),
             price,
             trigger_price,
             trigger_type,
             expire_time,
             is_post_only: post_only,
             display_qty,
             trigger_instrument_id,
@@ -133,15 +149,25 @@
 
 impl DerefMut for StopLimitOrder {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.core
     }
 }
 
+impl PartialEq for StopLimitOrder {
+    fn eq(&self, other: &Self) -> bool {
+        self.client_order_id == other.client_order_id
+    }
+}
+
 impl Order for StopLimitOrder {
+    fn into_any(self) -> OrderAny {
+        OrderAny::StopLimit(self)
+    }
+
     fn status(&self) -> OrderStatus {
         self.status
     }
 
     fn trader_id(&self) -> TraderId {
         self.trader_id
     }
@@ -393,7 +419,29 @@
             event.tags,
             event.event_id,
             event.ts_event,
         )
         .unwrap() // SAFETY: From can panic
     }
 }
+
+impl Display for StopLimitOrder {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        write!(
+            f,
+            "StopLimitOrder({} {} {} {} @ {}-STOP[{}] {}-LIMIT {}, status={}, client_order_id={}, venue_order_id={}, position_id={}, tags={})",
+            self.side,
+            self.quantity.to_formatted_string(),
+            self.instrument_id,
+            self.order_type,
+            self.trigger_price,
+            self.trigger_type,
+            self.price,
+            self.time_in_force,
+            self.status,
+            self.client_order_id,
+            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}") ),
+            self.position_id.map_or_else(|| "None".to_string(), |position_id| format!("{position_id}")),
+            self.tags.map_or_else(|| "None".to_string(), |tags| format!("{tags}"))
+        )
+    }
+}
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orders/stop_market.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orders/trailing_stop_market.rs`

 * *Files 8% similar despite different names*

```diff
@@ -14,18 +14,19 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::HashMap,
     ops::{Deref, DerefMut},
 };
 
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
+use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
-use super::base::{Order, OrderCore};
+use super::base::{Order, OrderAny, OrderCore};
 use crate::{
     enums::{
         ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, TimeInForce,
         TrailingOffsetType, TriggerType,
     },
     events::order::{event::OrderEvent, initialized::OrderInitialized, updated::OrderUpdated},
     identifiers::{
@@ -34,41 +35,45 @@
         strategy_id::StrategyId, symbol::Symbol, trade_id::TradeId, trader_id::TraderId,
         venue::Venue, venue_order_id::VenueOrderId,
     },
     orders::base::OrderError,
     types::{price::Price, quantity::Quantity},
 };
 
-#[derive(Clone, Debug)]
+#[derive(Clone, Debug, Serialize, Deserialize)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
-pub struct StopMarketOrder {
+pub struct TrailingStopMarketOrder {
+    core: OrderCore,
     pub trigger_price: Price,
     pub trigger_type: TriggerType,
+    pub trailing_offset: Price,
+    pub trailing_offset_type: TrailingOffsetType,
     pub expire_time: Option<UnixNanos>,
     pub display_qty: Option<Quantity>,
     pub trigger_instrument_id: Option<InstrumentId>,
     pub is_triggered: bool,
     pub ts_triggered: Option<UnixNanos>,
-    core: OrderCore,
 }
 
-impl StopMarketOrder {
+impl TrailingStopMarketOrder {
     #[allow(clippy::too_many_arguments)]
     pub fn new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         order_side: OrderSide,
         quantity: Quantity,
         trigger_price: Price,
         trigger_type: TriggerType,
+        trailing_offset: Price,
+        trailing_offset_type: TrailingOffsetType,
         time_in_force: TimeInForce,
         expire_time: Option<UnixNanos>,
         reduce_only: bool,
         quote_quantity: bool,
         display_qty: Option<Quantity>,
         emulation_trigger: Option<TriggerType>,
         trigger_instrument_id: Option<InstrumentId>,
@@ -79,64 +84,84 @@
         exec_algorithm_id: Option<ExecAlgorithmId>,
         exec_algorithm_params: Option<HashMap<Ustr, Ustr>>,
         exec_spawn_id: Option<ClientOrderId>,
         tags: Option<Ustr>,
         init_id: UUID4,
         ts_init: UnixNanos,
     ) -> anyhow::Result<Self> {
+        let init_order = OrderInitialized::new(
+            trader_id,
+            strategy_id,
+            instrument_id,
+            client_order_id,
+            order_side,
+            OrderType::TrailingStopMarket,
+            quantity,
+            time_in_force,
+            false,
+            reduce_only,
+            quote_quantity,
+            false,
+            init_id,
+            ts_init,
+            ts_init,
+            None,
+            Some(trigger_price),
+            Some(trigger_type),
+            None,
+            Some(trailing_offset),
+            Some(trailing_offset_type),
+            expire_time,
+            display_qty,
+            emulation_trigger,
+            trigger_instrument_id,
+            contingency_type,
+            order_list_id,
+            linked_order_ids,
+            parent_order_id,
+            exec_algorithm_id,
+            exec_algorithm_params,
+            exec_spawn_id,
+            tags,
+        )
+        .unwrap();
         Ok(Self {
-            core: OrderCore::new(
-                trader_id,
-                strategy_id,
-                instrument_id,
-                client_order_id,
-                order_side,
-                OrderType::StopMarket,
-                quantity,
-                time_in_force,
-                reduce_only,
-                quote_quantity,
-                emulation_trigger,
-                contingency_type,
-                order_list_id,
-                linked_order_ids,
-                parent_order_id,
-                exec_algorithm_id,
-                exec_algorithm_params,
-                exec_spawn_id,
-                tags,
-                init_id,
-                ts_init,
-            ),
+            core: OrderCore::new(init_order).unwrap(),
             trigger_price,
             trigger_type,
+            trailing_offset,
+            trailing_offset_type,
             expire_time,
             display_qty,
             trigger_instrument_id,
             is_triggered: false,
             ts_triggered: None,
         })
     }
 }
 
-impl Deref for StopMarketOrder {
+impl Deref for TrailingStopMarketOrder {
     type Target = OrderCore;
 
     fn deref(&self) -> &Self::Target {
         &self.core
     }
 }
 
-impl DerefMut for StopMarketOrder {
+impl DerefMut for TrailingStopMarketOrder {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.core
     }
 }
 
-impl Order for StopMarketOrder {
+impl Order for TrailingStopMarketOrder {
+    fn into_any(self) -> OrderAny {
+        OrderAny::TrailingStopMarket(self)
+    }
+
     fn status(&self) -> OrderStatus {
         self.status
     }
 
     fn trader_id(&self) -> TraderId {
         self.trader_id
     }
@@ -230,19 +255,19 @@
     }
 
     fn limit_offset(&self) -> Option<Price> {
         None
     }
 
     fn trailing_offset(&self) -> Option<Price> {
-        None
+        Some(self.trailing_offset)
     }
 
     fn trailing_offset_type(&self) -> Option<TrailingOffsetType> {
-        None
+        Some(self.trailing_offset_type)
     }
 
     fn emulation_trigger(&self) -> Option<TriggerType> {
         self.emulation_trigger
     }
 
     fn trigger_instrument_id(&self) -> Option<InstrumentId> {
@@ -344,31 +369,33 @@
         }
 
         self.quantity = event.quantity;
         self.leaves_qty = self.quantity - self.filled_qty;
     }
 }
 
-impl From<OrderInitialized> for StopMarketOrder {
+impl From<OrderInitialized> for TrailingStopMarketOrder {
     fn from(event: OrderInitialized) -> Self {
         Self::new(
             event.trader_id,
             event.strategy_id,
             event.instrument_id,
             event.client_order_id,
             event.order_side,
             event.quantity,
             event
                 .trigger_price // TODO: Improve this error, model order domain errors
                 .expect(
-                    "Error initializing order: `trigger_price` was `None` for `StopMarketOrder`",
+                    "Error initializing order: `trigger_price` was `None` for `TrailingStopMarketOrder`",
                 ),
-            event.trigger_type.expect(
-                "Error initializing order: `trigger_type` was `None` for `StopMarketOrder`",
-            ),
+            event
+                .trigger_type
+                .expect("Error initializing order: `trigger_type` was `None` for `TrailingStopMarketOrder`"),
+            event.trailing_offset.unwrap(),  // TODO
+            event.trailing_offset_type.unwrap(),  // TODO
             event.time_in_force,
             event.expire_time,
             event.reduce_only,
             event.quote_quantity,
             event.display_qty,
             event.emulation_trigger,
             event.trigger_instrument_id,
@@ -378,11 +405,10 @@
             event.parent_order_id,
             event.exec_algorithm_id,
             event.exec_algorithm_params,
             event.exec_spawn_id,
             event.tags,
             event.event_id,
             event.ts_event,
-        )
-        .unwrap() // SAFETY: From can panic
+        ).unwrap() // SAFETY: From can panic
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orders/stubs.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orders/stubs.rs`

 * *Files 3% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::str::FromStr;
 
-use nautilus_core::uuid::UUID4;
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 
 use super::{limit::LimitOrder, stop_market::StopMarketOrder};
 use crate::{
     enums::{LiquiditySide, OrderSide, TimeInForce, TriggerType},
     events::order::filled::OrderFilled,
     identifiers::{
         account_id::AccountId,
@@ -46,27 +46,27 @@
         instrument: &I,
         strategy_id: Option<StrategyId>,
         trade_id: Option<TradeId>,
         position_id: Option<PositionId>,
         last_px: Option<Price>,
         last_qty: Option<Quantity>,
         commission: Option<Money>,
-        ts_filled_ns: Option<u64>,
+        ts_filled_ns: Option<UnixNanos>,
     ) -> OrderFilled {
         let trader_id = trader_id();
         let strategy_id = strategy_id.unwrap_or(order.strategy_id());
         let instrument_id = order.instrument_id();
         let venue_order_id = order
             .venue_order_id()
             .unwrap_or(VenueOrderId::new("1").unwrap());
         let account_id = order
             .account_id()
             .unwrap_or(AccountId::new("SIM-001").unwrap());
         let trade_id = trade_id.unwrap_or(
-            TradeId::new(order.client_order_id().value.replace('O', "E").as_str()).unwrap(),
+            TradeId::new(order.client_order_id().as_str().replace('O', "E").as_str()).unwrap(),
         );
         let liquidity_side = order.liquidity_side().unwrap_or(LiquiditySide::Maker);
         let event = UUID4::new();
         let position_id = position_id
             .or_else(|| order.position_id())
             .unwrap_or(PositionId::new("1").unwrap());
         let commission = commission.unwrap_or(Money::from_str("2 USD").unwrap());
@@ -83,16 +83,16 @@
             order.side(),
             order.order_type(),
             last_qty,
             last_px,
             instrument.quote_currency(),
             liquidity_side,
             event,
-            ts_filled_ns.unwrap_or(0),
-            0,
+            ts_filled_ns.unwrap_or_default(),
+            UnixNanos::default(),
             false,
             Some(position_id),
             Some(commission),
         )
         .unwrap()
     }
 }
@@ -118,15 +118,15 @@
             strategy,
             instrument_id,
             client_order_id,
             order_side,
             quantity,
             time_in_force,
             UUID4::new(),
-            12_321_312_321_312,
+            UnixNanos::default(),
             false,
             false,
             None,
             None,
             None,
             None,
             None,
@@ -172,15 +172,15 @@
             None,
             None,
             None,
             None,
             Some(client_order_id),
             None,
             UUID4::new(),
-            12_321_312_321_312,
+            UnixNanos::default(),
         )
         .unwrap()
     }
 
     #[must_use]
     pub fn stop_market_order(
         instrument_id: InstrumentId,
@@ -217,12 +217,12 @@
             None,
             None,
             None,
             None,
             None,
             None,
             UUID4::new(),
-            12_321_312_321_312,
+            UnixNanos::default(),
         )
         .unwrap()
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orders/trailing_stop_limit.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/orders/trailing_stop_limit.rs`

 * *Files 2% similar despite different names*

```diff
@@ -14,18 +14,19 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::HashMap,
     ops::{Deref, DerefMut},
 };
 
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
+use serde::{Deserialize, Serialize};
 use ustr::Ustr;
 
-use super::base::{Order, OrderCore, OrderError};
+use super::base::{Order, OrderAny, OrderCore, OrderError};
 use crate::{
     enums::{
         ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, TimeInForce,
         TrailingOffsetType, TriggerType,
     },
     events::order::{event::OrderEvent, initialized::OrderInitialized, updated::OrderUpdated},
     identifiers::{
@@ -33,15 +34,15 @@
         instrument_id::InstrumentId, order_list_id::OrderListId, position_id::PositionId,
         strategy_id::StrategyId, symbol::Symbol, trade_id::TradeId, trader_id::TraderId,
         venue::Venue, venue_order_id::VenueOrderId,
     },
     types::{price::Price, quantity::Quantity},
 };
 
-#[derive(Clone, Debug)]
+#[derive(Clone, Debug, Serialize, Deserialize)]
 #[cfg_attr(
     feature = "python",
     pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
 )]
 pub struct TrailingStopLimitOrder {
     core: OrderCore,
     pub price: Price,
@@ -88,38 +89,52 @@
         exec_algorithm_id: Option<ExecAlgorithmId>,
         exec_algorithm_params: Option<HashMap<Ustr, Ustr>>,
         exec_spawn_id: Option<ClientOrderId>,
         tags: Option<Ustr>,
         init_id: UUID4,
         ts_init: UnixNanos,
     ) -> anyhow::Result<Self> {
+        let init_order = OrderInitialized::new(
+            trader_id,
+            strategy_id,
+            instrument_id,
+            client_order_id,
+            order_side,
+            OrderType::TrailingStopLimit,
+            quantity,
+            time_in_force,
+            post_only,
+            reduce_only,
+            quote_quantity,
+            false,
+            init_id,
+            ts_init,
+            ts_init,
+            Some(price),
+            Some(trigger_price),
+            Some(trigger_type),
+            Some(limit_offset),
+            Some(trailing_offset),
+            Some(trailing_offset_type),
+            expire_time,
+            display_qty,
+            emulation_trigger,
+            trigger_instrument_id,
+            contingency_type,
+            order_list_id,
+            linked_order_ids,
+            parent_order_id,
+            exec_algorithm_id,
+            exec_algorithm_params,
+            exec_spawn_id,
+            tags,
+        )
+        .unwrap();
         Ok(Self {
-            core: OrderCore::new(
-                trader_id,
-                strategy_id,
-                instrument_id,
-                client_order_id,
-                order_side,
-                OrderType::TrailingStopLimit,
-                quantity,
-                time_in_force,
-                reduce_only,
-                quote_quantity,
-                emulation_trigger,
-                contingency_type,
-                order_list_id,
-                linked_order_ids,
-                parent_order_id,
-                exec_algorithm_id,
-                exec_algorithm_params,
-                exec_spawn_id,
-                tags,
-                init_id,
-                ts_init,
-            ),
+            core: OrderCore::new(init_order).unwrap(),
             price,
             trigger_price,
             trigger_type,
             limit_offset,
             trailing_offset,
             trailing_offset_type,
             expire_time,
@@ -143,14 +158,18 @@
 impl DerefMut for TrailingStopLimitOrder {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.core
     }
 }
 
 impl Order for TrailingStopLimitOrder {
+    fn into_any(self) -> OrderAny {
+        OrderAny::TrailingStopLimit(self)
+    }
+
     fn status(&self) -> OrderStatus {
         self.status
     }
 
     fn trader_id(&self) -> TraderId {
         self.trader_id
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/orders/trailing_stop_market.rs` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/order.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,395 +1,286 @@
-// -------------------------------------------------------------------------------------------------
-//  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
-//  https://nautechsystems.io
-//
-//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-//  You may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-// -------------------------------------------------------------------------------------------------
-
-use std::{
-    collections::HashMap,
-    ops::{Deref, DerefMut},
-};
-
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
-use ustr::Ustr;
-
-use super::base::{Order, OrderCore};
-use crate::{
-    enums::{
-        ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, TimeInForce,
-        TrailingOffsetType, TriggerType,
-    },
-    events::order::{event::OrderEvent, initialized::OrderInitialized, updated::OrderUpdated},
-    identifiers::{
-        account_id::AccountId, client_order_id::ClientOrderId, exec_algorithm_id::ExecAlgorithmId,
-        instrument_id::InstrumentId, order_list_id::OrderListId, position_id::PositionId,
-        strategy_id::StrategyId, symbol::Symbol, trade_id::TradeId, trader_id::TraderId,
-        venue::Venue, venue_order_id::VenueOrderId,
-    },
-    orders::base::OrderError,
-    types::{price::Price, quantity::Quantity},
-};
-
-#[derive(Clone, Debug)]
-#[cfg_attr(
-    feature = "python",
-    pyo3::pyclass(module = "nautilus_trader.core.nautilus_pyo3.model")
-)]
-pub struct TrailingStopMarketOrder {
-    core: OrderCore,
-    pub trigger_price: Price,
-    pub trigger_type: TriggerType,
-    pub trailing_offset: Price,
-    pub trailing_offset_type: TrailingOffsetType,
-    pub expire_time: Option<UnixNanos>,
-    pub display_qty: Option<Quantity>,
-    pub trigger_instrument_id: Option<InstrumentId>,
-    pub is_triggered: bool,
-    pub ts_triggered: Option<UnixNanos>,
-}
-
-impl TrailingStopMarketOrder {
-    #[allow(clippy::too_many_arguments)]
-    pub fn new(
-        trader_id: TraderId,
-        strategy_id: StrategyId,
-        instrument_id: InstrumentId,
-        client_order_id: ClientOrderId,
-        order_side: OrderSide,
-        quantity: Quantity,
-        trigger_price: Price,
-        trigger_type: TriggerType,
-        trailing_offset: Price,
-        trailing_offset_type: TrailingOffsetType,
-        time_in_force: TimeInForce,
-        expire_time: Option<UnixNanos>,
-        reduce_only: bool,
-        quote_quantity: bool,
-        display_qty: Option<Quantity>,
-        emulation_trigger: Option<TriggerType>,
-        trigger_instrument_id: Option<InstrumentId>,
-        contingency_type: Option<ContingencyType>,
-        order_list_id: Option<OrderListId>,
-        linked_order_ids: Option<Vec<ClientOrderId>>,
-        parent_order_id: Option<ClientOrderId>,
-        exec_algorithm_id: Option<ExecAlgorithmId>,
-        exec_algorithm_params: Option<HashMap<Ustr, Ustr>>,
-        exec_spawn_id: Option<ClientOrderId>,
-        tags: Option<Ustr>,
-        init_id: UUID4,
-        ts_init: UnixNanos,
-    ) -> anyhow::Result<Self> {
-        Ok(Self {
-            core: OrderCore::new(
-                trader_id,
-                strategy_id,
-                instrument_id,
-                client_order_id,
-                order_side,
-                OrderType::TrailingStopMarket,
-                quantity,
-                time_in_force,
-                reduce_only,
-                quote_quantity,
-                emulation_trigger,
-                contingency_type,
-                order_list_id,
-                linked_order_ids,
-                parent_order_id,
-                exec_algorithm_id,
-                exec_algorithm_params,
-                exec_spawn_id,
-                tags,
-                init_id,
-                ts_init,
-            ),
-            trigger_price,
-            trigger_type,
-            trailing_offset,
-            trailing_offset_type,
-            expire_time,
-            display_qty,
-            trigger_instrument_id,
-            is_triggered: false,
-            ts_triggered: None,
-        })
-    }
-}
-
-impl Deref for TrailingStopMarketOrder {
-    type Target = OrderCore;
-
-    fn deref(&self) -> &Self::Target {
-        &self.core
-    }
-}
-
-impl DerefMut for TrailingStopMarketOrder {
-    fn deref_mut(&mut self) -> &mut Self::Target {
-        &mut self.core
-    }
-}
-
-impl Order for TrailingStopMarketOrder {
-    fn status(&self) -> OrderStatus {
-        self.status
-    }
-
-    fn trader_id(&self) -> TraderId {
-        self.trader_id
-    }
-
-    fn strategy_id(&self) -> StrategyId {
-        self.strategy_id
-    }
-
-    fn instrument_id(&self) -> InstrumentId {
-        self.instrument_id
-    }
-
-    fn symbol(&self) -> Symbol {
-        self.instrument_id.symbol
-    }
-
-    fn venue(&self) -> Venue {
-        self.instrument_id.venue
-    }
-
-    fn client_order_id(&self) -> ClientOrderId {
-        self.client_order_id
-    }
-
-    fn venue_order_id(&self) -> Option<VenueOrderId> {
-        self.venue_order_id
-    }
-
-    fn position_id(&self) -> Option<PositionId> {
-        self.position_id
-    }
-
-    fn account_id(&self) -> Option<AccountId> {
-        self.account_id
-    }
-
-    fn last_trade_id(&self) -> Option<TradeId> {
-        self.last_trade_id
-    }
-
-    fn side(&self) -> OrderSide {
-        self.side
-    }
-
-    fn order_type(&self) -> OrderType {
-        self.order_type
-    }
-
-    fn quantity(&self) -> Quantity {
-        self.quantity
-    }
-
-    fn time_in_force(&self) -> TimeInForce {
-        self.time_in_force
-    }
-
-    fn expire_time(&self) -> Option<UnixNanos> {
-        self.expire_time
-    }
-
-    fn price(&self) -> Option<Price> {
-        None
-    }
-
-    fn trigger_price(&self) -> Option<Price> {
-        Some(self.trigger_price)
-    }
-
-    fn trigger_type(&self) -> Option<TriggerType> {
-        Some(self.trigger_type)
-    }
-
-    fn liquidity_side(&self) -> Option<LiquiditySide> {
-        self.liquidity_side
-    }
-
-    fn is_post_only(&self) -> bool {
-        false
-    }
-
-    fn is_reduce_only(&self) -> bool {
-        self.is_reduce_only
-    }
-
-    fn is_quote_quantity(&self) -> bool {
-        self.is_quote_quantity
-    }
-
-    fn display_qty(&self) -> Option<Quantity> {
-        self.display_qty
-    }
-
-    fn limit_offset(&self) -> Option<Price> {
-        None
-    }
-
-    fn trailing_offset(&self) -> Option<Price> {
-        Some(self.trailing_offset)
-    }
-
-    fn trailing_offset_type(&self) -> Option<TrailingOffsetType> {
-        Some(self.trailing_offset_type)
-    }
-
-    fn emulation_trigger(&self) -> Option<TriggerType> {
-        self.emulation_trigger
-    }
-
-    fn trigger_instrument_id(&self) -> Option<InstrumentId> {
-        self.trigger_instrument_id
-    }
-
-    fn contingency_type(&self) -> Option<ContingencyType> {
-        self.contingency_type
-    }
-
-    fn order_list_id(&self) -> Option<OrderListId> {
-        self.order_list_id
-    }
-
-    fn linked_order_ids(&self) -> Option<Vec<ClientOrderId>> {
-        self.linked_order_ids.clone()
-    }
-
-    fn parent_order_id(&self) -> Option<ClientOrderId> {
-        self.parent_order_id
-    }
-
-    fn exec_algorithm_id(&self) -> Option<ExecAlgorithmId> {
-        self.exec_algorithm_id
-    }
-
-    fn exec_algorithm_params(&self) -> Option<HashMap<Ustr, Ustr>> {
-        self.exec_algorithm_params.clone()
-    }
-
-    fn exec_spawn_id(&self) -> Option<ClientOrderId> {
-        self.exec_spawn_id
-    }
-
-    fn tags(&self) -> Option<Ustr> {
-        self.tags
-    }
-
-    fn filled_qty(&self) -> Quantity {
-        self.filled_qty
-    }
-
-    fn leaves_qty(&self) -> Quantity {
-        self.leaves_qty
-    }
-
-    fn avg_px(&self) -> Option<f64> {
-        self.avg_px
-    }
-
-    fn slippage(&self) -> Option<f64> {
-        self.slippage
-    }
-
-    fn init_id(&self) -> UUID4 {
-        self.init_id
-    }
-
-    fn ts_init(&self) -> UnixNanos {
-        self.ts_init
-    }
-
-    fn ts_last(&self) -> UnixNanos {
-        self.ts_last
-    }
-
-    fn events(&self) -> Vec<&OrderEvent> {
-        self.events.iter().collect()
-    }
-
-    fn venue_order_ids(&self) -> Vec<&VenueOrderId> {
-        self.venue_order_ids.iter().collect()
-    }
-
-    fn trade_ids(&self) -> Vec<&TradeId> {
-        self.trade_ids.iter().collect()
-    }
-
-    fn apply(&mut self, event: OrderEvent) -> Result<(), OrderError> {
-        if let OrderEvent::OrderUpdated(ref event) = event {
-            self.update(event);
-        };
-        let is_order_filled = matches!(event, OrderEvent::OrderFilled(_));
-
-        self.core.apply(event)?;
-
-        if is_order_filled {
-            self.core.set_slippage(self.trigger_price);
-        };
-
-        Ok(())
-    }
-
-    fn update(&mut self, event: &OrderUpdated) {
-        assert!(event.price.is_none(), "{}", OrderError::InvalidOrderEvent);
-
-        if let Some(trigger_price) = event.trigger_price {
-            self.trigger_price = trigger_price;
-        }
-
-        self.quantity = event.quantity;
-        self.leaves_qty = self.quantity - self.filled_qty;
-    }
-}
-
-impl From<OrderInitialized> for TrailingStopMarketOrder {
-    fn from(event: OrderInitialized) -> Self {
-        Self::new(
-            event.trader_id,
-            event.strategy_id,
-            event.instrument_id,
-            event.client_order_id,
-            event.order_side,
-            event.quantity,
-            event
-                .trigger_price // TODO: Improve this error, model order domain errors
-                .expect(
-                    "Error initializing order: `trigger_price` was `None` for `TrailingStopMarketOrder`",
-                ),
-            event
-                .trigger_type
-                .expect("Error initializing order: `trigger_type` was `None` for `TrailingStopMarketOrder`"),
-            event.trailing_offset.unwrap(),  // TODO
-            event.trailing_offset_type.unwrap(),  // TODO
-            event.time_in_force,
-            event.expire_time,
-            event.reduce_only,
-            event.quote_quantity,
-            event.display_qty,
-            event.emulation_trigger,
-            event.trigger_instrument_id,
-            event.contingency_type,
-            event.order_list_id,
-            event.linked_order_ids,
-            event.parent_order_id,
-            event.exec_algorithm_id,
-            event.exec_algorithm_params,
-            event.exec_spawn_id,
-            event.tags,
-            event.event_id,
-            event.ts_event,
-        ).unwrap() // SAFETY: From can panic
-    }
-}
+# -------------------------------------------------------------------------------------------------
+#  Copyright (C) 2015-2021 Nautech Systems Pty Ltd. All rights reserved.
+#  https://nautechsystems.io
+#
+#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+#  You may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+# -------------------------------------------------------------------------------------------------
+
+from decimal import Decimal
+
+from ibapi.commission_report import CommissionReport
+from ibapi.contract import Contract
+from ibapi.execution import Execution
+from ibapi.order import Order as IBOrder
+from ibapi.order_state import OrderState as IBOrderState
+
+from nautilus_trader.adapters.interactive_brokers.client.common import AccountOrderRef
+from nautilus_trader.adapters.interactive_brokers.client.common import BaseMixin
+from nautilus_trader.adapters.interactive_brokers.common import IBContract
+from nautilus_trader.common.enums import LogColor
+
+
+class InteractiveBrokersClientOrderMixin(BaseMixin):
+    """
+    Manages orders for the InteractiveBrokersClient.
+
+    This class enables the execution and management of trades. It maintains an internal
+    state that tracks the relationship between Nautilus orders and IB API orders,
+    ensuring that actions such as placing, modifying, and canceling orders are correctly
+    reflected in both systems.
+
+    """
+
+    def place_order(self, order: IBOrder) -> None:
+        """
+        Place an order through the EClient.
+
+        Parameters
+        ----------
+        order : IBOrder
+            The order object containing details such as the order ID, contract
+            details, and order specifics.
+
+        """
+        self._order_id_to_order_ref[order.orderId] = AccountOrderRef(
+            account_id=order.account,
+            order_id=order.orderRef.rsplit(":", 1)[0],
+        )
+        order.orderRef = f"{order.orderRef}:{order.orderId}"
+        self._eclient.placeOrder(order.orderId, order.contract, order)
+
+    def place_order_list(self, orders: list[IBOrder]) -> None:
+        """
+        Place a list of orders through the EClient.
+
+        Parameters
+        ----------
+        orders : list[IBOrder]
+            A list of order objects to be placed.
+
+        """
+        for order in orders:
+            order.orderRef = f"{order.orderRef}:{order.orderId}"
+            self._eclient.placeOrder(order.orderId, order.contract, order)
+
+    def cancel_order(self, order_id: int, manual_cancel_order_time: str = "") -> None:
+        """
+        Cancel an order through the EClient.
+
+        Parameters
+        ----------
+        order_id : int
+            The unique identifier for the order to be canceled.
+        manual_cancel_order_time : str, optional
+            The timestamp indicating when the order was canceled manually.
+
+        """
+        self._eclient.cancelOrder(order_id, manual_cancel_order_time)
+
+    def cancel_all_orders(self) -> None:
+        """
+        Request to cancel all open orders through the EClient.
+        """
+        self._log.warning(
+            "Canceling all open orders, regardless of how they were originally placed.",
+        )
+        self._eclient.reqGlobalCancel()
+
+    async def get_open_orders(self, account_id: str) -> list[IBOrder]:
+        """
+        Retrieve a list of open orders for a specific account. Once the request is
+        completed, openOrderEnd() will be called.
+
+        Parameters
+        ----------
+        account_id : str
+            The account identifier for which to retrieve open orders.
+
+        Returns
+        -------
+        list[IBOrder]
+
+        """
+        self._log.debug(f"Requesting open orders for {account_id}")
+        name = "OpenOrders"
+        if not (request := self._requests.get(name=name)):
+            request = self._requests.add(
+                req_id=self._next_req_id(),
+                name=name,
+                handle=self._eclient.reqOpenOrders,
+            )
+            if not request:
+                return []
+            request.handle()
+
+        all_orders: list[IBOrder] | None = await self._await_request(request, 30)
+        if all_orders:
+            orders: list[IBOrder] = [order for order in all_orders if order.account == account_id]
+        else:
+            orders = []
+
+        return orders
+
+    def next_order_id(self) -> int:
+        """
+        Retrieve the next valid order ID to be used for a new order.
+
+        Returns
+        -------
+        int
+
+        """
+        order_id: int = self._next_valid_order_id
+        self._next_valid_order_id += 1
+        self._eclient.reqIds(-1)
+        return order_id
+
+    async def process_next_valid_id(self, *, order_id: int) -> None:
+        """
+        Receive the next valid order id.
+
+        Will be invoked automatically upon successful API client connection,
+        or after call to EClient::reqIds
+        Important: the next valid order ID is only valid at the time it is received.
+
+        """
+        self._next_valid_order_id = max(self._next_valid_order_id, order_id, 101)
+        if self.accounts() and not self._is_ib_connected.is_set():
+            self._log.debug("`_is_ib_connected` set by `nextValidId`.", LogColor.BLUE)
+            self._is_ib_connected.set()
+
+    async def process_open_order(
+        self,
+        *,
+        order_id: int,
+        contract: Contract,
+        order: IBOrder,
+        order_state: IBOrderState,
+    ) -> None:
+        """
+        Feed in currently open orders.
+        """
+        # Handle response to on-demand request
+        if request := self._requests.get(name="OpenOrders"):
+            order.contract = IBContract(**contract.__dict__)
+            order.order_state = order_state
+            order.orderRef = order.orderRef.rsplit(":", 1)[0]
+            request.result.append(order)
+            # Validate and add reverse mapping, if not exists
+            if order_ref := self._order_id_to_order_ref.get(order.orderId):
+                if not (
+                    order_ref.account_id == order.account and order_ref.order_id == order.orderRef
+                ):
+                    self._log.warning(
+                        f"Discrepancy found in order, expected {order_ref}, "
+                        f"was (account={order.account}, order_id={order.orderRef}",
+                    )
+            else:
+                self._order_id_to_order_ref[order.orderId] = AccountOrderRef(
+                    account_id=order.account,
+                    order_id=order.orderRef,
+                )
+            return
+
+        # Handle event based response
+        name = f"openOrder-{order.account}"
+        if handler := self._event_subscriptions.get(name, None):
+            handler(
+                order_ref=order.orderRef.rsplit(":", 1)[0],
+                order=order,
+                order_state=order_state,
+            )
+
+    async def process_open_order_end(self) -> None:
+        """
+        Notifies the end of the open orders' reception.
+        """
+        if request := self._requests.get(name="OpenOrders"):
+            self._end_request(request.req_id)
+
+    async def process_order_status(
+        self,
+        *,
+        order_id: int,
+        status: str,
+        filled: Decimal,
+        remaining: Decimal,
+        avg_fill_price: float,
+        perm_id: int,
+        parent_id: int,
+        last_fill_price: float,
+        client_id: int,
+        why_held: str,
+        mkt_cap_price: float,
+    ) -> None:
+        """
+        Get the up-to-date information of an order every time it changes.
+
+        Note: Often there are duplicate orderStatus messages.
+
+        """
+        order_ref = self._order_id_to_order_ref.get(order_id, None)
+        if order_ref:
+            name = f"orderStatus-{order_ref.account_id}"
+            if handler := self._event_subscriptions.get(name, None):
+                handler(
+                    order_ref=self._order_id_to_order_ref[order_id].order_id,
+                    order_status=status,
+                )
+
+    async def process_exec_details(
+        self,
+        *,
+        req_id: int,
+        contract: Contract,
+        execution: Execution,
+    ) -> None:
+        """
+        Provide the executions that happened in the prior 24 hours.
+        """
+        if not (cache := self._exec_id_details.get(execution.execId, None)):
+            self._exec_id_details[execution.execId] = {}
+            cache = self._exec_id_details[execution.execId]
+        cache["execution"] = execution
+        cache["order_ref"] = execution.orderRef.rsplit(":", 1)[0]
+
+        name = f"execDetails-{execution.acctNumber}"
+        if (handler := self._event_subscriptions.get(name, None)) and cache.get(
+            "commission_report",
+        ):
+            handler(
+                order_ref=cache["order_ref"],
+                execution=cache["execution"],
+                commission_report=cache["commission_report"],
+            )
+            cache.pop(execution.execId, None)
+
+    async def process_commission_report(
+        self,
+        *,
+        commission_report: CommissionReport,
+    ) -> None:
+        """
+        Provide the CommissionReport of an Execution.
+        """
+        if not (cache := self._exec_id_details.get(commission_report.execId, None)):
+            self._exec_id_details[commission_report.execId] = {}
+            cache = self._exec_id_details[commission_report.execId]
+        cache["commission_report"] = commission_report
+
+        if cache.get("execution") and (account := getattr(cache["execution"], "acctNumber", None)):
+            name = f"execDetails-{account}"
+            if handler := self._event_subscriptions.get(name, None):
+                handler(
+                    order_ref=cache["order_ref"],
+                    execution=cache["execution"],
+                    commission_report=cache["commission_report"],
+                )
+                cache.pop(commission_report.execId, None)
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/position.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/position.rs`

 * *Files 1% similar despite different names*

```diff
@@ -15,30 +15,30 @@
 
 use std::{
     collections::{HashMap, HashSet},
     fmt::Display,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::time::UnixNanos;
+use nautilus_core::nanos::UnixNanos;
 use serde::{Deserialize, Serialize};
 
 use crate::{
     enums::{OrderSide, PositionSide},
     events::order::filled::OrderFilled,
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         position_id::PositionId, strategy_id::StrategyId, symbol::Symbol, trade_id::TradeId,
         trader_id::TraderId, venue::Venue, venue_order_id::VenueOrderId,
     },
     instruments::Instrument,
     types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
 };
 
-/// Represents a position in a financial market.
+/// Represents a position in a market.
 ///
 /// The position ID may be assigned at the trading venue, or can be system
 /// generated depending on a strategies OMS (Order Management System) settings.
 #[repr(C)]
 #[derive(Debug, Clone, Serialize, Deserialize)]
 #[cfg_attr(
     feature = "python",
@@ -188,15 +188,15 @@
             self.entry = OrderSide::Sell;
             self.side = PositionSide::Short;
         } else {
             self.side = PositionSide::Flat;
             self.closing_order_id = Some(fill.client_order_id);
             self.ts_closed = Some(fill.ts_event);
             self.duration_ns = if self.ts_closed.is_some() {
-                self.ts_closed.unwrap() - self.ts_opened
+                self.ts_closed.unwrap().as_u64() - self.ts_opened.as_u64()
             } else {
                 0
             };
         }
 
         self.ts_last = fill.ts_event;
     }
@@ -517,14 +517,15 @@
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use std::str::FromStr;
 
+    use nautilus_core::nanos::UnixNanos;
     use rstest::rstest;
 
     use crate::{
         enums::{LiquiditySide, OrderSide, OrderType, PositionSide},
         events::order::filled::OrderFilled,
         identifiers::{
             account_id::AccountId, position_id::PositionId, strategy_id::StrategyId, stubs::uuid4,
@@ -624,15 +625,15 @@
         assert!(position.closing_order_id.is_none());
         assert_eq!(position.quantity, Quantity::from(100_000));
         assert_eq!(position.peak_qty, Quantity::from(100_000));
         assert_eq!(position.size_precision, 0);
         assert_eq!(position.signed_qty, 100_000.0);
         assert_eq!(position.entry, OrderSide::Buy);
         assert_eq!(position.side, PositionSide::Long);
-        assert_eq!(position.ts_opened, 0);
+        assert_eq!(position.ts_opened.as_u64(), 0);
         assert_eq!(position.duration_ns, 0);
         assert_eq!(position.avg_px_open, 1.00001);
         assert_eq!(position.event_count(), 1);
         assert_eq!(position.id, PositionId::new("1").unwrap());
         assert_eq!(position.events.len(), 1);
         assert!(position.is_long());
         assert!(!position.is_short());
@@ -689,15 +690,15 @@
         assert_eq!(position, position); // equality operator test
         assert!(position.closing_order_id.is_none());
         assert_eq!(position.quantity, Quantity::from(100_000));
         assert_eq!(position.peak_qty, Quantity::from(100_000));
         assert_eq!(position.signed_qty, -100_000.0);
         assert_eq!(position.entry, OrderSide::Sell);
         assert_eq!(position.side, PositionSide::Short);
-        assert_eq!(position.ts_opened, 0);
+        assert_eq!(position.ts_opened.as_u64(), 0);
         assert_eq!(position.avg_px_open, 1.00001);
         assert_eq!(position.event_count(), 1);
         assert_eq!(position.id, PositionId::new("1").unwrap());
         assert_eq!(position.events.len(), 1);
         assert!(!position.is_long());
         assert!(position.is_short());
         assert!(position.is_open());
@@ -749,15 +750,15 @@
         let position = Position::new(audusd_sim, fill).unwrap();
         assert_eq!(position.quantity, Quantity::from(50_000));
         assert_eq!(position.peak_qty, Quantity::from(50_000));
         assert_eq!(position.side, PositionSide::Long);
         assert_eq!(position.signed_qty, 50000.0);
         assert_eq!(position.avg_px_open, 1.00001);
         assert_eq!(position.event_count(), 1);
-        assert_eq!(position.ts_opened, 0);
+        assert_eq!(position.ts_opened.as_u64(), 0);
         assert!(position.is_long());
         assert!(!position.is_short());
         assert!(position.is_open());
         assert!(!position.is_closed());
         assert_eq!(position.realized_return, 0.0);
         assert_eq!(
             position.realized_pnl,
@@ -860,15 +861,15 @@
             &audusd_sim,
             Some(StrategyId::new("S-001").unwrap()),
             Some(TradeId::new("1").unwrap()),
             Some(PositionId::new("P-1").unwrap()),
             Some(Price::from("1.00001")),
             None,
             None,
-            Some(1_000_000_000),
+            Some(UnixNanos::from(1_000_000_000)),
         );
         let mut position = Position::new(audusd_sim, fill).unwrap();
 
         let fill2 = OrderFilled::new(
             order.trader_id,
             StrategyId::new("S-001").unwrap(),
             order.instrument_id,
@@ -881,16 +882,16 @@
             OrderSide::Sell,
             OrderType::Market,
             order.quantity,
             Price::from("1.00011"),
             audusd_sim.quote_currency,
             LiquiditySide::Taker,
             uuid4(),
-            2_000_000_000,
-            0,
+            2_000_000_000.into(),
+            0.into(),
             false,
             Some(PositionId::new("T1").unwrap()),
             Some(Money::from_str("0.0 USD").unwrap()),
         )
         .unwrap();
         position.apply(&fill2);
         let last = Price::from_str("1.0005").unwrap();
@@ -900,15 +901,15 @@
             position.quantity,
             Quantity::zero(audusd_sim.price_precision)
         );
         assert_eq!(position.size_precision, 0);
         assert_eq!(position.signed_qty, 0.0);
         assert_eq!(position.side, PositionSide::Flat);
         assert_eq!(position.ts_opened, 1_000_000_000);
-        assert_eq!(position.ts_closed, Some(2_000_000_000));
+        assert_eq!(position.ts_closed, Some(UnixNanos::from(2_000_000_000)));
         assert_eq!(position.duration_ns, 1_000_000_000);
         assert_eq!(position.avg_px_open, 1.00001);
         assert_eq!(position.avg_px_close, Some(1.00011));
         assert!(!position.is_long());
         assert!(!position.is_short());
         assert!(!position.is_open());
         assert!(position.is_closed());
@@ -988,15 +989,15 @@
             position.quantity,
             Quantity::zero(audusd_sim.price_precision)
         );
         assert_eq!(position.side, PositionSide::Flat);
         assert_eq!(position.ts_opened, 0);
         assert_eq!(position.avg_px_open, 1.0);
         assert_eq!(position.events.len(), 3);
-        assert_eq!(position.ts_closed, Some(0));
+        assert_eq!(position.ts_closed, Some(UnixNanos::default()));
         assert_eq!(position.avg_px_close, Some(1.00002));
         assert!(!position.is_long());
         assert!(!position.is_short());
         assert!(!position.is_open());
         assert!(position.is_closed());
         assert_eq!(
             position.commissions(),
@@ -1067,15 +1068,15 @@
             Quantity::zero(audusd_sim.price_precision)
         );
         assert_eq!(position.side, PositionSide::Flat);
         assert_eq!(position.ts_opened, 0);
         assert_eq!(position.avg_px_open, 1.0);
         assert_eq!(position.events.len(), 2);
         assert_eq!(position.trade_ids, vec![fill1.trade_id, fill2.trade_id]);
-        assert_eq!(position.ts_closed, Some(0));
+        assert_eq!(position.ts_closed, Some(UnixNanos::default()));
         assert_eq!(position.avg_px_close, Some(1.0));
         assert!(!position.is_long());
         assert!(!position.is_short());
         assert!(!position.is_open());
         assert!(position.is_closed());
         assert_eq!(
             position.commissions(),
@@ -1168,15 +1169,15 @@
         assert_eq!(position.ts_opened, 0);
         assert_eq!(position.avg_px_open, 1.000_005);
         assert_eq!(position.events.len(), 3);
         assert_eq!(
             position.trade_ids,
             vec![fill1.trade_id, fill2.trade_id, fill3.trade_id]
         );
-        assert_eq!(position.ts_closed, Some(0));
+        assert_eq!(position.ts_closed, Some(UnixNanos::default()));
         assert_eq!(position.avg_px_close, Some(1.0001));
         assert!(position.is_closed());
         assert!(!position.is_open());
         assert!(!position.is_long());
         assert!(!position.is_short());
         assert_eq!(
             position.commissions(),
@@ -1347,15 +1348,15 @@
             &audusd_sim,
             Some(StrategyId::from("S-001")),
             Some(TradeId::new("5").unwrap()),
             Some(PositionId::new("P-123456").unwrap()),
             Some(Price::from("1.00001")),
             None,
             Some(commission1),
-            Some(1_000_000_000),
+            Some(UnixNanos::from(1_000_000_000)),
         );
         let mut position = Position::new(audusd_sim, fill1).unwrap();
 
         let fill2 = OrderFilled::new(
             order.trader_id,
             order.strategy_id,
             order.instrument_id,
@@ -1368,16 +1369,16 @@
             OrderSide::Sell,
             OrderType::Market,
             order.quantity,
             Price::from("1.00011"),
             audusd_sim.quote_currency,
             LiquiditySide::Taker,
             uuid4(),
-            2_000_000_000,
-            0,
+            UnixNanos::from(2_000_000_000),
+            UnixNanos::default(),
             false,
             Some(PositionId::from("P-123456")),
             Some(Money::from("0 USD")),
         )
         .unwrap();
         position.apply(&fill2);
         let fill3 = OrderFilled::new(
@@ -1393,16 +1394,16 @@
             OrderSide::Buy,
             OrderType::Market,
             order.quantity,
             Price::from("1.00012"),
             audusd_sim.quote_currency,
             LiquiditySide::Taker,
             uuid4(),
-            3_000_000_000,
-            0,
+            UnixNanos::from(3_000_000_000),
+            UnixNanos::default(),
             false,
             Some(PositionId::from("P-123456")),
             Some(Money::from("0 USD")),
         )
         .unwrap();
         position.apply(&fill3);
         let last = Price::from("1.0003");
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/common.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/common.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/data/bar.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/data/delta.rs`

 * *Files 14% similar despite different names*

```diff
@@ -18,136 +18,108 @@
     hash::{Hash, Hasher},
     str::FromStr,
 };
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
     serialization::Serializable,
-    time::UnixNanos,
 };
-use pyo3::{prelude::*, pyclass::CompareOp, types::PyDict};
+use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
 
 use super::data_to_pycapsule;
 use crate::{
     data::{
-        bar::{Bar, BarSpecification, BarType},
+        delta::OrderBookDelta,
+        order::{BookOrder, OrderId, NULL_ORDER},
         Data,
     },
-    enums::{AggregationSource, BarAggregation, PriceType},
+    enums::{BookAction, FromU8, OrderSide},
     identifiers::instrument_id::InstrumentId,
     python::common::PY_MODULE_MODEL,
     types::{price::Price, quantity::Quantity},
 };
 
-#[pymethods]
-impl BarSpecification {
-    #[new]
-    fn py_new(step: usize, aggregation: BarAggregation, price_type: PriceType) -> Self {
-        Self {
-            step,
-            aggregation,
-            price_type,
-        }
-    }
+impl OrderBookDelta {
+    /// Create a new [`OrderBookDelta`] extracted from the given [`PyAny`].
+    pub fn from_pyobject(obj: &PyAny) -> PyResult<Self> {
+        let instrument_id_obj: &PyAny = obj.getattr("instrument_id")?.extract()?;
+        let instrument_id_str = instrument_id_obj.getattr("value")?.extract()?;
+        let instrument_id = InstrumentId::from_str(instrument_id_str)
+            .map_err(to_pyvalue_err)
+            .unwrap();
+
+        let action_obj: &PyAny = obj.getattr("action")?.extract()?;
+        let action_u8 = action_obj.getattr("value")?.extract()?;
+        let action = BookAction::from_u8(action_u8).unwrap();
+
+        let flags: u8 = obj.getattr("flags")?.extract()?;
+        let sequence: u64 = obj.getattr("sequence")?.extract()?;
+        let ts_event: u64 = obj.getattr("ts_event")?.extract()?;
+        let ts_init: u64 = obj.getattr("ts_init")?.extract()?;
+
+        let order_pyobject = obj.getattr("order")?;
+        let order: BookOrder = if order_pyobject.is_none() {
+            NULL_ORDER
+        } else {
+            let side_obj: &PyAny = order_pyobject.getattr("side")?.extract()?;
+            let side_u8 = side_obj.getattr("value")?.extract()?;
+            let side = OrderSide::from_u8(side_u8).unwrap();
+
+            let price_py: &PyAny = order_pyobject.getattr("price")?;
+            let price_raw: i64 = price_py.getattr("raw")?.extract()?;
+            let price_prec: u8 = price_py.getattr("precision")?.extract()?;
+            let price = Price::from_raw(price_raw, price_prec).map_err(to_pyvalue_err)?;
+
+            let size_py: &PyAny = order_pyobject.getattr("size")?;
+            let size_raw: u64 = size_py.getattr("raw")?.extract()?;
+            let size_prec: u8 = size_py.getattr("precision")?.extract()?;
+            let size = Quantity::from_raw(size_raw, size_prec).map_err(to_pyvalue_err)?;
+
+            let order_id: OrderId = order_pyobject.getattr("order_id")?.extract()?;
+            BookOrder {
+                side,
+                price,
+                size,
+                order_id,
+            }
+        };
 
-    fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
-        match op {
-            CompareOp::Eq => self.eq(other).into_py(py),
-            CompareOp::Ne => self.ne(other).into_py(py),
-            _ => py.NotImplemented(),
-        }
-    }
-
-    fn __hash__(&self) -> isize {
-        let mut h = DefaultHasher::new();
-        self.hash(&mut h);
-        h.finish() as isize
-    }
-
-    fn __str__(&self) -> String {
-        self.to_string()
-    }
-
-    fn __repr__(&self) -> String {
-        format!("{self:?}")
-    }
-
-    #[staticmethod]
-    #[pyo3(name = "fully_qualified_name")]
-    fn py_fully_qualified_name() -> String {
-        format!("{}:{}", PY_MODULE_MODEL, stringify!(BarSpecification))
+        Ok(Self::new(
+            instrument_id,
+            action,
+            order,
+            flags,
+            sequence,
+            ts_event.into(),
+            ts_init.into(),
+        ))
     }
 }
 
 #[pymethods]
-impl BarType {
+impl OrderBookDelta {
     #[new]
-    #[pyo3(signature = (instrument_id, spec, aggregation_source = AggregationSource::External))]
     fn py_new(
         instrument_id: InstrumentId,
-        spec: BarSpecification,
-        aggregation_source: AggregationSource,
+        action: BookAction,
+        order: BookOrder,
+        flags: u8,
+        sequence: u64,
+        ts_event: u64,
+        ts_init: u64,
     ) -> Self {
-        Self {
+        Self::new(
             instrument_id,
-            spec,
-            aggregation_source,
-        }
-    }
-
-    fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
-        match op {
-            CompareOp::Eq => self.eq(other).into_py(py),
-            CompareOp::Ne => self.ne(other).into_py(py),
-            _ => py.NotImplemented(),
-        }
-    }
-
-    fn __hash__(&self) -> isize {
-        let mut h = DefaultHasher::new();
-        self.hash(&mut h);
-        h.finish() as isize
-    }
-
-    fn __str__(&self) -> String {
-        self.to_string()
-    }
-
-    fn __repr__(&self) -> String {
-        format!("{self:?}")
-    }
-
-    #[staticmethod]
-    #[pyo3(name = "fully_qualified_name")]
-    fn py_fully_qualified_name() -> String {
-        format!("{}:{}", PY_MODULE_MODEL, stringify!(BarType))
-    }
-
-    #[staticmethod]
-    #[pyo3(name = "from_str")]
-    fn py_from_str(value: &str) -> PyResult<Self> {
-        Self::from_str(value).map_err(to_pyvalue_err)
-    }
-}
-
-#[pymethods]
-#[allow(clippy::too_many_arguments)]
-impl Bar {
-    #[new]
-    fn py_new(
-        bar_type: BarType,
-        open: Price,
-        high: Price,
-        low: Price,
-        close: Price,
-        volume: Quantity,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
-    ) -> Self {
-        Self::new(bar_type, open, high, low, close, volume, ts_event, ts_init)
+            action,
+            order,
+            flags,
+            sequence,
+            ts_event.into(),
+            ts_init.into(),
+        )
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
             CompareOp::Ne => self.ne(other).into_py(py),
             _ => py.NotImplemented(),
@@ -165,86 +137,80 @@
     }
 
     fn __repr__(&self) -> String {
         format!("{self:?}")
     }
 
     #[getter]
-    #[pyo3(name = "bar_type")]
-    fn py_bar_type(&self) -> BarType {
-        self.bar_type
+    #[pyo3(name = "instrument_id")]
+    fn py_instrument_id(&self) -> InstrumentId {
+        self.instrument_id
     }
 
     #[getter]
-    #[pyo3(name = "open")]
-    fn py_open(&self) -> Price {
-        self.open
+    #[pyo3(name = "action")]
+    fn py_action(&self) -> BookAction {
+        self.action
     }
 
     #[getter]
-    #[pyo3(name = "high")]
-    fn py_high(&self) -> Price {
-        self.high
+    #[pyo3(name = "order")]
+    fn py_order(&self) -> BookOrder {
+        self.order
     }
 
     #[getter]
-    #[pyo3(name = "low")]
-    fn py_low(&self) -> Price {
-        self.low
+    #[pyo3(name = "flags")]
+    fn py_flags(&self) -> u8 {
+        self.flags
     }
 
     #[getter]
-    #[pyo3(name = "close")]
-    fn py_close(&self) -> Price {
-        self.close
-    }
-
-    #[getter]
-    #[pyo3(name = "volume")]
-    fn py_volume(&self) -> Quantity {
-        self.volume
+    #[pyo3(name = "sequence")]
+    fn py_sequence(&self) -> u64 {
+        self.sequence
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[staticmethod]
     #[pyo3(name = "fully_qualified_name")]
     fn py_fully_qualified_name() -> String {
-        format!("{}:{}", PY_MODULE_MODEL, stringify!(Bar))
+        format!("{}:{}", PY_MODULE_MODEL, stringify!(OrderBookDelta))
     }
 
-    /// Creates a `PyCapsule` containing a raw pointer to a `Data::Bar` object.
+    /// Creates a `PyCapsule` containing a raw pointer to a `Data::Delta` object.
     ///
     /// This function takes the current object (assumed to be of a type that can be represented as
-    /// `Data::Bar`), and encapsulates a raw pointer to it within a `PyCapsule`.
+    /// `Data::Delta`), and encapsulates a raw pointer to it within a `PyCapsule`.
     ///
     /// # Safety
     ///
     /// This function is safe as long as the following conditions are met:
     /// - The `Data::Delta` object pointed to by the capsule must remain valid for the lifetime of the capsule.
     /// - The consumer of the capsule must ensure proper handling to avoid dereferencing a dangling pointer.
     ///
     /// # Panics
     ///
     /// The function will panic if the `PyCapsule` creation fails, which can occur if the
-    /// `Data::Bar` object cannot be converted into a raw pointer.
+    /// `Data::Delta` object cannot be converted into a raw pointer.
     ///
     #[pyo3(name = "as_pycapsule")]
     fn py_as_pycapsule(&self, py: Python<'_>) -> PyObject {
-        data_to_pycapsule(py, Data::Bar(*self))
+        data_to_pycapsule(py, Data::Delta(*self))
     }
 
     /// Return a dictionary representation of the object.
     #[pyo3(name = "as_dict")]
     fn py_as_dict(&self, py: Python<'_>) -> PyResult<Py<PyDict>> {
         // Serialize object to JSON bytes
         let json_str = serde_json::to_string(self).map_err(to_pyvalue_err)?;
@@ -261,20 +227,20 @@
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[staticmethod]
     #[pyo3(name = "get_metadata")]
     fn py_get_metadata(
-        bar_type: &BarType,
+        instrument_id: &InstrumentId,
         price_precision: u8,
         size_precision: u8,
     ) -> PyResult<HashMap<String, String>> {
         Ok(Self::get_metadata(
-            bar_type,
+            instrument_id,
             price_precision,
             size_precision,
         ))
     }
 
     #[staticmethod]
     #[pyo3(name = "get_fields")]
@@ -315,48 +281,48 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use pyo3::{IntoPy, Python};
     use rstest::rstest;
 
-    use crate::data::bar::{stubs::stub_bar, Bar};
+    use super::*;
+    use crate::data::stubs::*;
 
     #[rstest]
-    fn test_as_dict(stub_bar: Bar) {
+    fn test_as_dict(stub_delta: OrderBookDelta) {
         pyo3::prepare_freethreaded_python();
-        let bar = stub_bar;
+        let delta = stub_delta;
 
         Python::with_gil(|py| {
-            let dict_string = bar.py_as_dict(py).unwrap().to_string();
-            let expected_string = r"{'type': 'Bar', 'bar_type': 'AUDUSD.SIM-1-MINUTE-BID-EXTERNAL', 'open': '1.00001', 'high': '1.00004', 'low': '1.00002', 'close': '1.00003', 'volume': '100000', 'ts_event': 0, 'ts_init': 1}";
+            let dict_string = delta.py_as_dict(py).unwrap().to_string();
+            let expected_string = r"{'type': 'OrderBookDelta', 'instrument_id': 'AAPL.XNAS', 'action': 'ADD', 'order': {'side': 'BUY', 'price': '100.00', 'size': '10', 'order_id': 123456}, 'flags': 0, 'sequence': 1, 'ts_event': 1, 'ts_init': 2}";
             assert_eq!(dict_string, expected_string);
         });
     }
 
     #[rstest]
-    fn test_as_from_dict(stub_bar: Bar) {
+    fn test_from_dict(stub_delta: OrderBookDelta) {
         pyo3::prepare_freethreaded_python();
-        let bar = stub_bar;
+        let delta = stub_delta;
 
         Python::with_gil(|py| {
-            let dict = bar.py_as_dict(py).unwrap();
-            let parsed = Bar::py_from_dict(py, dict).unwrap();
-            assert_eq!(parsed, bar);
+            let dict = delta.py_as_dict(py).unwrap();
+            let parsed = OrderBookDelta::py_from_dict(py, dict).unwrap();
+            assert_eq!(parsed, delta);
         });
     }
 
     #[rstest]
-    fn test_from_pyobject(stub_bar: Bar) {
+    fn test_from_pyobject(stub_delta: OrderBookDelta) {
         pyo3::prepare_freethreaded_python();
-        let bar = stub_bar;
+        let delta = stub_delta;
 
         Python::with_gil(|py| {
-            let bar_pyobject = bar.into_py(py);
-            let parsed_bar = Bar::from_pyobject(bar_pyobject.as_ref(py)).unwrap();
-            assert_eq!(parsed_bar, bar);
+            let delta_pyobject = delta.into_py(py);
+            let parsed_delta = OrderBookDelta::from_pyobject(delta_pyobject.as_ref(py)).unwrap();
+            assert_eq!(parsed_delta, delta);
         });
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/data/delta.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/data/bar.rs`

 * *Files 16% similar despite different names*

```diff
@@ -18,108 +18,189 @@
     hash::{Hash, Hasher},
     str::FromStr,
 };
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
     serialization::Serializable,
-    time::UnixNanos,
 };
-use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
+use pyo3::{prelude::*, pyclass::CompareOp, types::PyDict};
 
 use super::data_to_pycapsule;
 use crate::{
     data::{
-        delta::OrderBookDelta,
-        order::{BookOrder, OrderId, NULL_ORDER},
+        bar::{Bar, BarSpecification, BarType},
         Data,
     },
-    enums::{BookAction, FromU8, OrderSide},
+    enums::{AggregationSource, BarAggregation, PriceType},
     identifiers::instrument_id::InstrumentId,
     python::common::PY_MODULE_MODEL,
     types::{price::Price, quantity::Quantity},
 };
 
-impl OrderBookDelta {
-    /// Create a new [`OrderBookDelta`] extracted from the given [`PyAny`].
+#[pymethods]
+impl BarSpecification {
+    #[new]
+    fn py_new(step: usize, aggregation: BarAggregation, price_type: PriceType) -> Self {
+        Self {
+            step,
+            aggregation,
+            price_type,
+        }
+    }
+
+    fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
+        match op {
+            CompareOp::Eq => self.eq(other).into_py(py),
+            CompareOp::Ne => self.ne(other).into_py(py),
+            _ => py.NotImplemented(),
+        }
+    }
+
+    fn __hash__(&self) -> isize {
+        let mut h = DefaultHasher::new();
+        self.hash(&mut h);
+        h.finish() as isize
+    }
+
+    fn __str__(&self) -> String {
+        self.to_string()
+    }
+
+    fn __repr__(&self) -> String {
+        format!("{self:?}")
+    }
+
+    #[staticmethod]
+    #[pyo3(name = "fully_qualified_name")]
+    fn py_fully_qualified_name() -> String {
+        format!("{}:{}", PY_MODULE_MODEL, stringify!(BarSpecification))
+    }
+}
+
+#[pymethods]
+impl BarType {
+    #[new]
+    #[pyo3(signature = (instrument_id, spec, aggregation_source = AggregationSource::External))]
+    fn py_new(
+        instrument_id: InstrumentId,
+        spec: BarSpecification,
+        aggregation_source: AggregationSource,
+    ) -> Self {
+        Self {
+            instrument_id,
+            spec,
+            aggregation_source,
+        }
+    }
+
+    fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
+        match op {
+            CompareOp::Eq => self.eq(other).into_py(py),
+            CompareOp::Ne => self.ne(other).into_py(py),
+            _ => py.NotImplemented(),
+        }
+    }
+
+    fn __hash__(&self) -> isize {
+        let mut h = DefaultHasher::new();
+        self.hash(&mut h);
+        h.finish() as isize
+    }
+
+    fn __str__(&self) -> String {
+        self.to_string()
+    }
+
+    fn __repr__(&self) -> String {
+        format!("{self:?}")
+    }
+
+    #[staticmethod]
+    #[pyo3(name = "fully_qualified_name")]
+    fn py_fully_qualified_name() -> String {
+        format!("{}:{}", PY_MODULE_MODEL, stringify!(BarType))
+    }
+
+    #[staticmethod]
+    #[pyo3(name = "from_str")]
+    fn py_from_str(value: &str) -> PyResult<Self> {
+        Self::from_str(value).map_err(to_pyvalue_err)
+    }
+}
+
+impl Bar {
     pub fn from_pyobject(obj: &PyAny) -> PyResult<Self> {
-        let instrument_id_obj: &PyAny = obj.getattr("instrument_id")?.extract()?;
-        let instrument_id_str = instrument_id_obj.getattr("value")?.extract()?;
-        let instrument_id = InstrumentId::from_str(instrument_id_str)
+        let bar_type_obj: &PyAny = obj.getattr("bar_type")?.extract()?;
+        let bar_type_str = bar_type_obj.call_method0("__str__")?.extract()?;
+        let bar_type = BarType::from_str(bar_type_str)
             .map_err(to_pyvalue_err)
             .unwrap();
 
-        let action_obj: &PyAny = obj.getattr("action")?.extract()?;
-        let action_u8 = action_obj.getattr("value")?.extract()?;
-        let action = BookAction::from_u8(action_u8).unwrap();
-
-        let flags: u8 = obj.getattr("flags")?.extract()?;
-        let sequence: u64 = obj.getattr("sequence")?.extract()?;
-        let ts_event: UnixNanos = obj.getattr("ts_event")?.extract()?;
-        let ts_init: UnixNanos = obj.getattr("ts_init")?.extract()?;
-
-        let order_pyobject = obj.getattr("order")?;
-        let order: BookOrder = if order_pyobject.is_none() {
-            NULL_ORDER
-        } else {
-            let side_obj: &PyAny = order_pyobject.getattr("side")?.extract()?;
-            let side_u8 = side_obj.getattr("value")?.extract()?;
-            let side = OrderSide::from_u8(side_u8).unwrap();
-
-            let price_py: &PyAny = order_pyobject.getattr("price")?;
-            let price_raw: i64 = price_py.getattr("raw")?.extract()?;
-            let price_prec: u8 = price_py.getattr("precision")?.extract()?;
-            let price = Price::from_raw(price_raw, price_prec).map_err(to_pyvalue_err)?;
-
-            let size_py: &PyAny = order_pyobject.getattr("size")?;
-            let size_raw: u64 = size_py.getattr("raw")?.extract()?;
-            let size_prec: u8 = size_py.getattr("precision")?.extract()?;
-            let size = Quantity::from_raw(size_raw, size_prec).map_err(to_pyvalue_err)?;
-
-            let order_id: OrderId = order_pyobject.getattr("order_id")?.extract()?;
-            BookOrder {
-                side,
-                price,
-                size,
-                order_id,
-            }
-        };
+        let open_py: &PyAny = obj.getattr("open")?;
+        let price_prec: u8 = open_py.getattr("precision")?.extract()?;
+        let open_raw: i64 = open_py.getattr("raw")?.extract()?;
+        let open = Price::from_raw(open_raw, price_prec).map_err(to_pyvalue_err)?;
+
+        let high_py: &PyAny = obj.getattr("high")?;
+        let high_raw: i64 = high_py.getattr("raw")?.extract()?;
+        let high = Price::from_raw(high_raw, price_prec).map_err(to_pyvalue_err)?;
+
+        let low_py: &PyAny = obj.getattr("low")?;
+        let low_raw: i64 = low_py.getattr("raw")?.extract()?;
+        let low = Price::from_raw(low_raw, price_prec).map_err(to_pyvalue_err)?;
+
+        let close_py: &PyAny = obj.getattr("close")?;
+        let close_raw: i64 = close_py.getattr("raw")?.extract()?;
+        let close = Price::from_raw(close_raw, price_prec).map_err(to_pyvalue_err)?;
+
+        let volume_py: &PyAny = obj.getattr("volume")?;
+        let volume_raw: u64 = volume_py.getattr("raw")?.extract()?;
+        let volume_prec: u8 = volume_py.getattr("precision")?.extract()?;
+        let volume = Quantity::from_raw(volume_raw, volume_prec).map_err(to_pyvalue_err)?;
+
+        let ts_event: u64 = obj.getattr("ts_event")?.extract()?;
+        let ts_init: u64 = obj.getattr("ts_init")?.extract()?;
 
         Ok(Self::new(
-            instrument_id,
-            action,
-            order,
-            flags,
-            sequence,
-            ts_event,
-            ts_init,
+            bar_type,
+            open,
+            high,
+            low,
+            close,
+            volume,
+            ts_event.into(),
+            ts_init.into(),
         ))
     }
 }
 
 #[pymethods]
-impl OrderBookDelta {
+#[allow(clippy::too_many_arguments)]
+impl Bar {
     #[new]
     fn py_new(
-        instrument_id: InstrumentId,
-        action: BookAction,
-        order: BookOrder,
-        flags: u8,
-        sequence: u64,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        bar_type: BarType,
+        open: Price,
+        high: Price,
+        low: Price,
+        close: Price,
+        volume: Quantity,
+        ts_event: u64,
+        ts_init: u64,
     ) -> Self {
         Self::new(
-            instrument_id,
-            action,
-            order,
-            flags,
-            sequence,
-            ts_event,
-            ts_init,
+            bar_type,
+            open,
+            high,
+            low,
+            close,
+            volume,
+            ts_event.into(),
+            ts_init.into(),
         )
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
             CompareOp::Ne => self.ne(other).into_py(py),
@@ -138,80 +219,86 @@
     }
 
     fn __repr__(&self) -> String {
         format!("{self:?}")
     }
 
     #[getter]
-    #[pyo3(name = "instrument_id")]
-    fn py_instrument_id(&self) -> InstrumentId {
-        self.instrument_id
+    #[pyo3(name = "bar_type")]
+    fn py_bar_type(&self) -> BarType {
+        self.bar_type
     }
 
     #[getter]
-    #[pyo3(name = "action")]
-    fn py_action(&self) -> BookAction {
-        self.action
+    #[pyo3(name = "open")]
+    fn py_open(&self) -> Price {
+        self.open
     }
 
     #[getter]
-    #[pyo3(name = "order")]
-    fn py_order(&self) -> BookOrder {
-        self.order
+    #[pyo3(name = "high")]
+    fn py_high(&self) -> Price {
+        self.high
     }
 
     #[getter]
-    #[pyo3(name = "flags")]
-    fn py_flags(&self) -> u8 {
-        self.flags
+    #[pyo3(name = "low")]
+    fn py_low(&self) -> Price {
+        self.low
     }
 
     #[getter]
-    #[pyo3(name = "sequence")]
-    fn py_sequence(&self) -> u64 {
-        self.sequence
+    #[pyo3(name = "close")]
+    fn py_close(&self) -> Price {
+        self.close
+    }
+
+    #[getter]
+    #[pyo3(name = "volume")]
+    fn py_volume(&self) -> Quantity {
+        self.volume
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[staticmethod]
     #[pyo3(name = "fully_qualified_name")]
     fn py_fully_qualified_name() -> String {
-        format!("{}:{}", PY_MODULE_MODEL, stringify!(OrderBookDelta))
+        format!("{}:{}", PY_MODULE_MODEL, stringify!(Bar))
     }
 
-    /// Creates a `PyCapsule` containing a raw pointer to a `Data::Delta` object.
+    /// Creates a `PyCapsule` containing a raw pointer to a `Data::Bar` object.
     ///
     /// This function takes the current object (assumed to be of a type that can be represented as
-    /// `Data::Delta`), and encapsulates a raw pointer to it within a `PyCapsule`.
+    /// `Data::Bar`), and encapsulates a raw pointer to it within a `PyCapsule`.
     ///
     /// # Safety
     ///
     /// This function is safe as long as the following conditions are met:
     /// - The `Data::Delta` object pointed to by the capsule must remain valid for the lifetime of the capsule.
     /// - The consumer of the capsule must ensure proper handling to avoid dereferencing a dangling pointer.
     ///
     /// # Panics
     ///
     /// The function will panic if the `PyCapsule` creation fails, which can occur if the
-    /// `Data::Delta` object cannot be converted into a raw pointer.
+    /// `Data::Bar` object cannot be converted into a raw pointer.
     ///
     #[pyo3(name = "as_pycapsule")]
     fn py_as_pycapsule(&self, py: Python<'_>) -> PyObject {
-        data_to_pycapsule(py, Data::Delta(*self))
+        data_to_pycapsule(py, Data::Bar(*self))
     }
 
     /// Return a dictionary representation of the object.
     #[pyo3(name = "as_dict")]
     fn py_as_dict(&self, py: Python<'_>) -> PyResult<Py<PyDict>> {
         // Serialize object to JSON bytes
         let json_str = serde_json::to_string(self).map_err(to_pyvalue_err)?;
@@ -228,20 +315,20 @@
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[staticmethod]
     #[pyo3(name = "get_metadata")]
     fn py_get_metadata(
-        instrument_id: &InstrumentId,
+        bar_type: &BarType,
         price_precision: u8,
         size_precision: u8,
     ) -> PyResult<HashMap<String, String>> {
         Ok(Self::get_metadata(
-            instrument_id,
+            bar_type,
             price_precision,
             size_precision,
         ))
     }
 
     #[staticmethod]
     #[pyo3(name = "get_fields")]
@@ -282,48 +369,48 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
+    use pyo3::{IntoPy, Python};
     use rstest::rstest;
 
-    use super::*;
-    use crate::data::stubs::*;
+    use crate::data::bar::{stubs::stub_bar, Bar};
 
     #[rstest]
-    fn test_as_dict(stub_delta: OrderBookDelta) {
+    fn test_as_dict(stub_bar: Bar) {
         pyo3::prepare_freethreaded_python();
-        let delta = stub_delta;
+        let bar = stub_bar;
 
         Python::with_gil(|py| {
-            let dict_string = delta.py_as_dict(py).unwrap().to_string();
-            let expected_string = r"{'type': 'OrderBookDelta', 'instrument_id': 'AAPL.XNAS', 'action': 'ADD', 'order': {'side': 'BUY', 'price': '100.00', 'size': '10', 'order_id': 123456}, 'flags': 0, 'sequence': 1, 'ts_event': 1, 'ts_init': 2}";
+            let dict_string = bar.py_as_dict(py).unwrap().to_string();
+            let expected_string = r"{'type': 'Bar', 'bar_type': 'AUDUSD.SIM-1-MINUTE-BID-EXTERNAL', 'open': '1.00001', 'high': '1.00004', 'low': '1.00002', 'close': '1.00003', 'volume': '100000', 'ts_event': 0, 'ts_init': 1}";
             assert_eq!(dict_string, expected_string);
         });
     }
 
     #[rstest]
-    fn test_from_dict(stub_delta: OrderBookDelta) {
+    fn test_as_from_dict(stub_bar: Bar) {
         pyo3::prepare_freethreaded_python();
-        let delta = stub_delta;
+        let bar = stub_bar;
 
         Python::with_gil(|py| {
-            let dict = delta.py_as_dict(py).unwrap();
-            let parsed = OrderBookDelta::py_from_dict(py, dict).unwrap();
-            assert_eq!(parsed, delta);
+            let dict = bar.py_as_dict(py).unwrap();
+            let parsed = Bar::py_from_dict(py, dict).unwrap();
+            assert_eq!(parsed, bar);
         });
     }
 
     #[rstest]
-    fn test_from_pyobject(stub_delta: OrderBookDelta) {
+    fn test_from_pyobject(stub_bar: Bar) {
         pyo3::prepare_freethreaded_python();
-        let delta = stub_delta;
+        let bar = stub_bar;
 
         Python::with_gil(|py| {
-            let delta_pyobject = delta.into_py(py);
-            let parsed_delta = OrderBookDelta::from_pyobject(delta_pyobject.as_ref(py)).unwrap();
-            assert_eq!(parsed_delta, delta);
+            let bar_pyobject = bar.into_py(py);
+            let parsed_bar = Bar::from_pyobject(bar_pyobject.as_ref(py)).unwrap();
+            assert_eq!(parsed_bar, bar);
         });
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/data/deltas.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/data/deltas.rs`

 * *Files 2% similar despite different names*

```diff
@@ -15,15 +15,14 @@
 
 use std::{
     collections::hash_map::DefaultHasher,
     hash::{Hash, Hasher},
     ops::Deref,
 };
 
-use nautilus_core::time::UnixNanos;
 use pyo3::{prelude::*, pyclass::CompareOp, types::PyCapsule};
 
 use super::data_to_pycapsule;
 use crate::{
     data::{
         delta::OrderBookDelta,
         deltas::{OrderBookDeltas, OrderBookDeltas_API},
@@ -85,22 +84,22 @@
     #[pyo3(name = "sequence")]
     fn py_sequence(&self) -> u64 {
         self.sequence
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[staticmethod]
     #[pyo3(name = "fully_qualified_name")]
     fn py_fully_qualified_name() -> String {
         format!("{}:{}", PY_MODULE_MODEL, stringify!(OrderBookDeltas))
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/data/depth.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/data/depth.rs`

 * *Files 8% similar despite different names*

```diff
@@ -17,15 +17,14 @@
     collections::{hash_map::DefaultHasher, HashMap},
     hash::{Hash, Hasher},
 };
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
     serialization::Serializable,
-    time::UnixNanos,
 };
 use pyo3::{prelude::*, pyclass::CompareOp, types::PyDict};
 
 use super::data_to_pycapsule;
 use crate::{
     data::{
         depth::{OrderBookDepth10, DEPTH10_LEN},
@@ -46,27 +45,27 @@
         instrument_id: InstrumentId,
         bids: [BookOrder; DEPTH10_LEN],
         asks: [BookOrder; DEPTH10_LEN],
         bid_counts: [u32; DEPTH10_LEN],
         ask_counts: [u32; DEPTH10_LEN],
         flags: u8,
         sequence: u64,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
     ) -> Self {
         Self::new(
             instrument_id,
             bids,
             asks,
             bid_counts,
             ask_counts,
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
             CompareOp::Ne => self.ne(other).into_py(py),
@@ -128,22 +127,22 @@
     #[pyo3(name = "sequence")]
     fn py_sequence(&self) -> u64 {
         self.sequence
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[staticmethod]
     #[pyo3(name = "fully_qualified_name")]
     fn py_fully_qualified_name() -> String {
         format!("{}:{}", PY_MODULE_MODEL, stringify!(OrderBookDepth10))
     }
@@ -269,16 +268,16 @@
             instrument_id,
             bids,
             asks,
             bid_counts,
             ask_counts,
             flags,
             sequence,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
     }
 
     #[staticmethod]
     #[pyo3(name = "from_json")]
     fn py_from_json(data: Vec<u8>) -> PyResult<Self> {
         Self::from_json_bytes(data).map_err(to_pyvalue_err)
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/data/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/data/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/data/order.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/data/order.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/data/quote.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/data/quote.rs`

 * *Files 5% similar despite different names*

```diff
@@ -16,17 +16,17 @@
 use std::{
     collections::{hash_map::DefaultHasher, HashMap},
     hash::{Hash, Hasher},
     str::FromStr,
 };
 
 use nautilus_core::{
+    nanos::UnixNanos,
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
     serialization::Serializable,
-    time::UnixNanos,
 };
 use pyo3::{
     prelude::*,
     pyclass::CompareOp,
     types::{PyDict, PyLong, PyString, PyTuple},
 };
 
@@ -62,50 +62,50 @@
         let bid_size = Quantity::from_raw(bid_size_raw, bid_size_prec).map_err(to_pyvalue_err)?;
 
         let ask_size_py: &PyAny = obj.getattr("ask_size")?;
         let ask_size_raw: u64 = ask_size_py.getattr("raw")?.extract()?;
         let ask_size_prec: u8 = ask_size_py.getattr("precision")?.extract()?;
         let ask_size = Quantity::from_raw(ask_size_raw, ask_size_prec).map_err(to_pyvalue_err)?;
 
-        let ts_event: UnixNanos = obj.getattr("ts_event")?.extract()?;
-        let ts_init: UnixNanos = obj.getattr("ts_init")?.extract()?;
+        let ts_event: u64 = obj.getattr("ts_event")?.extract()?;
+        let ts_init: u64 = obj.getattr("ts_init")?.extract()?;
 
         Self::new(
             instrument_id,
             bid_price,
             ask_price,
             bid_size,
             ask_size,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 }
 
 #[pymethods]
 impl QuoteTick {
     #[new]
     fn py_new(
         instrument_id: InstrumentId,
         bid_price: Price,
         ask_price: Price,
         bid_size: Quantity,
         ask_size: Quantity,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
     ) -> PyResult<Self> {
         Self::new(
             instrument_id,
             bid_price,
             ask_price,
             bid_size,
             ask_size,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __setstate__(&mut self, py: Python, state: PyObject) -> PyResult<()> {
         let tuple: (
             &PyString,
@@ -126,22 +126,24 @@
         let bid_price_prec = tuple.3.extract()?;
         let ask_price_prec = tuple.4.extract()?;
 
         let bid_size_raw = tuple.5.extract()?;
         let ask_size_raw = tuple.6.extract()?;
         let bid_size_prec = tuple.7.extract()?;
         let ask_size_prec = tuple.8.extract()?;
+        let ts_event: u64 = tuple.9.extract()?;
+        let ts_init: u64 = tuple.10.extract()?;
 
         self.instrument_id = InstrumentId::from_str(instrument_id_str).map_err(to_pyvalue_err)?;
         self.bid_price = Price::from_raw(bid_price_raw, bid_price_prec).map_err(to_pyvalue_err)?;
         self.ask_price = Price::from_raw(ask_price_raw, ask_price_prec).map_err(to_pyvalue_err)?;
         self.bid_size = Quantity::from_raw(bid_size_raw, bid_size_prec).map_err(to_pyvalue_err)?;
         self.ask_size = Quantity::from_raw(ask_size_raw, ask_size_prec).map_err(to_pyvalue_err)?;
-        self.ts_event = tuple.9.extract()?;
-        self.ts_init = tuple.10.extract()?;
+        self.ts_event = ts_event.into();
+        self.ts_init = ts_init.into();
 
         Ok(())
     }
 
     fn __getstate__(&self, _py: Python) -> PyResult<PyObject> {
         Ok((
             self.instrument_id.to_string(),
@@ -149,16 +151,16 @@
             self.ask_price.raw,
             self.bid_price.precision,
             self.ask_price.precision,
             self.bid_size.raw,
             self.ask_size.raw,
             self.bid_size.precision,
             self.ask_size.precision,
-            self.ts_event,
-            self.ts_init,
+            self.ts_event.as_u64(),
+            self.ts_init.as_u64(),
         )
             .to_object(_py))
     }
 
     fn __reduce__(&self, py: Python) -> PyResult<PyObject> {
         let safe_constructor = py.get_type::<Self>().getattr("_safe_constructor")?;
         let state = self.__getstate__(py)?;
@@ -169,16 +171,16 @@
     fn _safe_constructor() -> PyResult<Self> {
         Ok(Self::new(
             InstrumentId::from("NULL.NULL"),
             Price::zero(0),
             Price::zero(0),
             Quantity::zero(0),
             Quantity::zero(0),
-            0,
-            0,
+            UnixNanos::default(),
+            UnixNanos::default(),
         )
         .unwrap()) // Safe default
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
@@ -229,22 +231,22 @@
     #[pyo3(name = "ask_size")]
     fn py_ask_size(&self) -> Quantity {
         self.ask_size
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[staticmethod]
     #[pyo3(name = "fully_qualified_name")]
     fn py_fully_qualified_name() -> String {
         format!("{}:{}", PY_MODULE_MODEL, stringify!(QuoteTick))
     }
@@ -302,25 +304,25 @@
         ask_price_raw: i64,
         bid_price_prec: u8,
         ask_price_prec: u8,
         bid_size_raw: u64,
         ask_size_raw: u64,
         bid_size_prec: u8,
         ask_size_prec: u8,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
     ) -> PyResult<Self> {
         Self::new(
             instrument_id,
             Price::from_raw(bid_price_raw, bid_price_prec).map_err(to_pyvalue_err)?,
             Price::from_raw(ask_price_raw, ask_price_prec).map_err(to_pyvalue_err)?,
             Quantity::from_raw(bid_size_raw, bid_size_prec).map_err(to_pyvalue_err)?,
             Quantity::from_raw(ask_size_raw, ask_size_prec).map_err(to_pyvalue_err)?,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
     /// Return a new object from the given dictionary representation.
     #[staticmethod]
     #[pyo3(name = "from_dict")]
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/data/trade.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/data/trade.rs`

 * *Files 3% similar despite different names*

```diff
@@ -16,17 +16,17 @@
 use std::{
     collections::{hash_map::DefaultHasher, HashMap},
     hash::{Hash, Hasher},
     str::FromStr,
 };
 
 use nautilus_core::{
+    nanos::UnixNanos,
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
     serialization::Serializable,
-    time::UnixNanos,
 };
 use pyo3::{
     prelude::*,
     pyclass::CompareOp,
     types::{PyDict, PyLong, PyString, PyTuple},
 };
 
@@ -60,49 +60,49 @@
         let aggressor_side_u8 = aggressor_side_obj.getattr("value")?.extract()?;
         let aggressor_side = AggressorSide::from_u8(aggressor_side_u8).unwrap();
 
         let trade_id_obj: &PyAny = obj.getattr("trade_id")?.extract()?;
         let trade_id_str = trade_id_obj.getattr("value")?.extract()?;
         let trade_id = TradeId::from_str(trade_id_str).map_err(to_pyvalue_err)?;
 
-        let ts_event: UnixNanos = obj.getattr("ts_event")?.extract()?;
-        let ts_init: UnixNanos = obj.getattr("ts_init")?.extract()?;
+        let ts_event: u64 = obj.getattr("ts_event")?.extract()?;
+        let ts_init: u64 = obj.getattr("ts_init")?.extract()?;
 
         Ok(Self::new(
             instrument_id,
             price,
             size,
             aggressor_side,
             trade_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         ))
     }
 }
 
 #[pymethods]
 impl TradeTick {
     #[new]
     fn py_new(
         instrument_id: InstrumentId,
         price: Price,
         size: Quantity,
         aggressor_side: AggressorSide,
         trade_id: TradeId,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
     ) -> Self {
         Self::new(
             instrument_id,
             price,
             size,
             aggressor_side,
             trade_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
     }
 
     fn __setstate__(&mut self, py: Python, state: PyObject) -> PyResult<()> {
         let tuple: (
             &PyString,
             &PyLong,
@@ -117,37 +117,39 @@
         let instrument_id_str: &str = tuple.0.extract()?;
         let price_raw = tuple.1.extract()?;
         let price_prec = tuple.2.extract()?;
         let size_raw = tuple.3.extract()?;
         let size_prec = tuple.4.extract()?;
         let aggressor_side_u8 = tuple.5.extract()?;
         let trade_id_str = tuple.6.extract()?;
+        let ts_event: u64 = tuple.7.extract()?;
+        let ts_init: u64 = tuple.8.extract()?;
 
         self.instrument_id = InstrumentId::from_str(instrument_id_str).map_err(to_pyvalue_err)?;
         self.price = Price::from_raw(price_raw, price_prec).map_err(to_pyvalue_err)?;
         self.size = Quantity::from_raw(size_raw, size_prec).map_err(to_pyvalue_err)?;
         self.aggressor_side = AggressorSide::from_u8(aggressor_side_u8).unwrap();
         self.trade_id = TradeId::from_str(trade_id_str).map_err(to_pyvalue_err)?;
-        self.ts_event = tuple.7.extract()?;
-        self.ts_init = tuple.8.extract()?;
+        self.ts_event = ts_event.into();
+        self.ts_init = ts_init.into();
 
         Ok(())
     }
 
     fn __getstate__(&self, _py: Python) -> PyResult<PyObject> {
         Ok((
             self.instrument_id.to_string(),
             self.price.raw,
             self.price.precision,
             self.size.raw,
             self.size.precision,
             self.aggressor_side as u8,
             self.trade_id.to_string(),
-            self.ts_event,
-            self.ts_init,
+            self.ts_event.as_u64(),
+            self.ts_init.as_u64(),
         )
             .to_object(_py))
     }
 
     fn __reduce__(&self, py: Python) -> PyResult<PyObject> {
         let safe_constructor = py.get_type::<Self>().getattr("_safe_constructor")?;
         let state = self.__getstate__(py)?;
@@ -158,16 +160,16 @@
     fn _safe_constructor() -> PyResult<Self> {
         Ok(Self::new(
             InstrumentId::from("NULL.NULL"),
             Price::zero(0),
             Quantity::zero(0),
             AggressorSide::NoAggressor,
             TradeId::from("NULL"),
-            0,
-            0,
+            UnixNanos::default(),
+            UnixNanos::default(),
         ))
         // Safe default
     }
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
             CompareOp::Ne => self.ne(other).into_py(py),
@@ -217,22 +219,22 @@
     #[pyo3(name = "trade_id")]
     fn py_trade_id(&self) -> TradeId {
         self.trade_id
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[staticmethod]
     #[pyo3(name = "fully_qualified_name")]
     fn py_fully_qualified_name() -> String {
         format!("{}:{}", PY_MODULE_MODEL, stringify!(TradeTick))
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/enums.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/enums.rs`

 * *Files 1% similar despite different names*

```diff
@@ -19,15 +19,16 @@
 use pyo3::{prelude::*, types::PyType, PyTypeInfo};
 
 use crate::{
     enums::{
         AccountType, AggregationSource, AggressorSide, AssetClass, BarAggregation, BookAction,
         BookType, ContingencyType, CurrencyType, HaltReason, InstrumentClass, InstrumentCloseType,
         LiquiditySide, MarketStatus, OmsType, OptionKind, OrderSide, OrderStatus, OrderType,
-        PositionSide, PriceType, TimeInForce, TradingState, TrailingOffsetType, TriggerType,
+        PositionSide, PriceType, RecordFlag, TimeInForce, TradingState, TrailingOffsetType,
+        TriggerType,
     },
     python::common::EnumIterator,
 };
 
 #[pymethods]
 impl AccountType {
     #[new]
@@ -1626,14 +1627,94 @@
     #[pyo3(name = "LAST")]
     fn py_last() -> Self {
         Self::Last
     }
 }
 
 #[pymethods]
+impl RecordFlag {
+    #[new]
+    fn py_new(py: Python<'_>, value: &PyAny) -> PyResult<Self> {
+        let t = Self::type_object(py);
+        Self::py_from_str(t, value)
+    }
+
+    fn __hash__(&self) -> isize {
+        *self as isize
+    }
+
+    fn __str__(&self) -> String {
+        self.to_string()
+    }
+
+    fn __repr__(&self) -> String {
+        format!(
+            "<{}.{}: '{}'>",
+            stringify!(RecordFlag),
+            self.name(),
+            self.value(),
+        )
+    }
+
+    #[getter]
+    #[must_use]
+    pub fn name(&self) -> String {
+        self.to_string()
+    }
+
+    #[getter]
+    #[must_use]
+    pub fn value(&self) -> u8 {
+        *self as u8
+    }
+
+    #[classmethod]
+    fn variants(_: &PyType, py: Python<'_>) -> EnumIterator {
+        EnumIterator::new::<Self>(py)
+    }
+
+    #[classmethod]
+    #[pyo3(name = "from_str")]
+    fn py_from_str(_: &PyType, data: &PyAny) -> PyResult<Self> {
+        let data_str: &str = data.str().and_then(|s| s.extract())?;
+        let tokenized = data_str.to_uppercase();
+        Self::from_str(&tokenized).map_err(to_pyvalue_err)
+    }
+
+    #[classattr]
+    #[pyo3(name = "LAST")]
+    fn py_last() -> Self {
+        Self::F_LAST
+    }
+
+    #[classattr]
+    #[pyo3(name = "TOB")]
+    fn py_tob() -> Self {
+        Self::F_TOB
+    }
+
+    #[classattr]
+    #[pyo3(name = "SNAPSHOT")]
+    fn py_snapshot() -> Self {
+        Self::F_SNAPSHOT
+    }
+
+    #[classattr]
+    #[pyo3(name = "MBP")]
+    fn py_mbp() -> Self {
+        Self::F_MBP
+    }
+
+    #[pyo3(name = "matches")]
+    fn py_matches(&self, value: u8) -> bool {
+        self.matches(value)
+    }
+}
+
+#[pymethods]
 impl TimeInForce {
     #[new]
     fn py_new(py: Python<'_>, value: &PyAny) -> PyResult<Self> {
         let t = Self::type_object(py);
         Self::py_from_str(t, value)
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/account/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/account/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/account/state.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/account/state.rs`

 * *Files 3% similar despite different names*

```diff
@@ -11,21 +11,20 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::str::FromStr;
 
-use nautilus_core::{python::to_pyvalue_err, time::UnixNanos, uuid::UUID4};
+use nautilus_core::{python::to_pyvalue_err, uuid::UUID4};
 use pyo3::{
     basic::CompareOp,
     prelude::*,
     types::{PyDict, PyList},
 };
-use rust_decimal::prelude::ToPrimitive;
 
 use crate::{
     enums::AccountType,
     events::account::state::AccountState,
     identifiers::account_id::AccountId,
     types::{
         balance::{AccountBalance, MarginBalance},
@@ -40,27 +39,27 @@
     fn py_new(
         account_id: AccountId,
         account_type: AccountType,
         balances: Vec<AccountBalance>,
         margins: Vec<MarginBalance>,
         is_reported: bool,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         base_currency: Option<Currency>,
     ) -> PyResult<Self> {
         Self::new(
             account_id,
             account_type,
             balances,
             margins,
             is_reported,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             base_currency,
         )
         .map_err(to_pyvalue_err)
     }
 
     #[getter]
     fn account_id(&self) -> AccountId {
@@ -157,16 +156,16 @@
         let account = Self::new(
             AccountId::from_str(account_id).unwrap(),
             AccountType::from_str(account_type).unwrap(),
             balances,
             margins,
             reported,
             UUID4::from_str(event_id).unwrap(),
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             Some(Currency::from_str(base_currency).map_err(to_pyvalue_err)?),
         )
         .unwrap();
         Ok(account)
     }
 
     #[pyo3(name = "to_dict")]
@@ -181,16 +180,16 @@
         let margins_dict: PyResult<Vec<_>> =
             self.margins.iter().map(|m| m.py_to_dict(py)).collect();
         dict.set_item("balances", balances_dict?)?;
         dict.set_item("margins", margins_dict?)?;
         dict.set_item("reported", self.is_reported)?;
         dict.set_item("event_id", self.event_id.to_string())?;
         dict.set_item("info", PyDict::new(py))?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         match self.base_currency {
             Some(base_currency) => {
                 dict.set_item("base_currency", base_currency.code.to_string())?;
             }
             None => dict.set_item("base_currency", "None")?,
         }
         Ok(dict.into())
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/infrastructure/src/python/redis/mod.rs`

 * *Files 2% similar despite different names*

```diff
@@ -9,9 +9,9 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod account;
-pub mod order;
+pub mod cache;
+pub mod msgbus;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/accepted.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/accepted.rs`

 * *Files 7% similar despite different names*

```diff
@@ -11,19 +11,17 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 
 use crate::{
     events::order::accepted::OrderAccepted,
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
     },
@@ -37,28 +35,28 @@
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         venue_order_id: VenueOrderId,
         account_id: AccountId,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         reconciliation: bool,
     ) -> PyResult<Self> {
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             venue_order_id,
             account_id,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             reconciliation,
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
@@ -92,14 +90,20 @@
             self.client_order_id,
             self.venue_order_id,
             self.account_id,
             self.ts_event,
         )
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderAccepted)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
@@ -108,13 +112,13 @@
         dict.set_item("trader_id", self.trader_id.to_string())?;
         dict.set_item("strategy_id", self.strategy_id.to_string())?;
         dict.set_item("instrument_id", self.instrument_id.to_string())?;
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("venue_order_id", self.venue_order_id.to_string())?;
         dict.set_item("account_id", self.account_id.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         dict.set_item("reconciliation", self.reconciliation)?;
         Ok(dict.into())
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/cancel_rejected.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/cancel_rejected.rs`

 * *Files 5% similar despite different names*

```diff
@@ -13,19 +13,17 @@
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::str::FromStr;
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 use ustr::Ustr;
 
 use crate::{
     events::order::cancel_rejected::OrderCancelRejected,
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
@@ -39,30 +37,30 @@
     fn py_new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         reason: &str,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         reconciliation: bool,
         venue_order_id: Option<VenueOrderId>,
         account_id: Option<AccountId>,
     ) -> PyResult<Self> {
         let reason = Ustr::from_str(reason).unwrap();
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             reason,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             reconciliation,
             venue_order_id,
             account_id,
         )
         .map_err(to_pyvalue_err)
     }
 
@@ -100,14 +98,20 @@
             self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
             self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
             self.reason,
             self.ts_event,
         )
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderCancelRejected)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
@@ -115,16 +119,16 @@
         let dict = PyDict::new(py);
         dict.set_item("trader_id", self.trader_id.to_string())?;
         dict.set_item("strategy_id", self.strategy_id.to_string())?;
         dict.set_item("instrument_id", self.instrument_id.to_string())?;
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("reason", self.reason.as_str())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         dict.set_item("reconciliation", self.reconciliation)?;
         match self.venue_order_id {
             Some(venue_order_id) => dict.set_item("venue_order_id", venue_order_id.to_string())?,
             None => dict.set_item("venue_order_id", py.None())?,
         }
         match self.account_id {
             Some(account_id) => dict.set_item("account_id", account_id.to_string())?,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/canceled.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/expired.rs`

 * *Files 3% similar despite different names*

```diff
@@ -11,52 +11,50 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 
 use crate::{
-    events::order::canceled::OrderCanceled,
+    events::order::expired::OrderExpired,
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
     },
 };
 
 #[pymethods]
-impl OrderCanceled {
+impl OrderExpired {
     #[allow(clippy::too_many_arguments)]
     #[new]
     fn py_new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         reconciliation: bool,
         venue_order_id: Option<VenueOrderId>,
         account_id: Option<AccountId>,
     ) -> PyResult<Self> {
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             reconciliation,
             venue_order_id,
             account_id,
         )
         .map_err(to_pyvalue_err)
     }
 
@@ -67,15 +65,15 @@
             _ => py.NotImplemented(),
         }
     }
 
     fn __repr__(&self) -> String {
         format!(
             "{}(trader_id={}, strategy_id={}, instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, event_id={}, ts_event={}, ts_init={})",
-            stringify!(OrderCanceled),
+            stringify!(OrderExpired),
             self.trader_id,
             self.strategy_id,
             self.instrument_id,
             self.client_order_id,
             self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
             self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
             self.event_id,
@@ -83,39 +81,45 @@
             self.ts_init
         )
     }
 
     fn __str__(&self) -> String {
         format!(
             "{}(instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, ts_event={})",
-            stringify!(OrderCanceled),
+            stringify!(OrderExpired),
             self.instrument_id,
             self.client_order_id,
             self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
             self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
             self.ts_event,
         )
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderExpired)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
     fn py_to_dict(&self, py: Python<'_>) -> PyResult<PyObject> {
         let dict = PyDict::new(py);
         dict.set_item("trader_id", self.trader_id.to_string())?;
         dict.set_item("strategy_id", self.strategy_id.to_string())?;
         dict.set_item("instrument_id", self.instrument_id.to_string())?;
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         dict.set_item("reconciliation", self.reconciliation)?;
         match self.venue_order_id {
             Some(venue_order_id) => dict.set_item("venue_order_id", venue_order_id.to_string())?,
             None => dict.set_item("venue_order_id", py.None())?,
         }
         match self.account_id {
             Some(account_id) => dict.set_item("account_id", account_id.to_string())?,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/denied.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/denied.rs`

 * *Files 12% similar despite different names*

```diff
@@ -13,19 +13,17 @@
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::str::FromStr;
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 use ustr::Ustr;
 
 use crate::{
     events::order::denied::OrderDenied,
     identifiers::{
         client_order_id::ClientOrderId, instrument_id::InstrumentId, strategy_id::StrategyId,
         trader_id::TraderId,
@@ -39,27 +37,27 @@
     fn py_new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         reason: &str,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
     ) -> PyResult<Self> {
         let reason = Ustr::from_str(reason).unwrap();
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             reason,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __repr__(&self) -> String {
         format!(
             "{}(trader_id={}, strategy_id={}, instrument_id={}, client_order_id={}, reason={}, event_id={}, ts_init={})",
@@ -88,14 +86,20 @@
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
             CompareOp::Ne => self.ne(other).into_py(py),
             _ => py.NotImplemented(),
         }
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderDenied)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
@@ -103,12 +107,12 @@
         let dict = PyDict::new(py);
         dict.set_item("trader_id", self.trader_id.to_string())?;
         dict.set_item("strategy_id", self.strategy_id.to_string())?;
         dict.set_item("instrument_id", self.instrument_id.to_string())?;
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("reason", self.reason.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         Ok(dict.into())
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/emulated.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/emulated.rs`

 * *Files 12% similar despite different names*

```diff
@@ -11,19 +11,17 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 
 use crate::{
     events::order::emulated::OrderEmulated,
     identifiers::{
         client_order_id::ClientOrderId, instrument_id::InstrumentId, strategy_id::StrategyId,
         trader_id::TraderId,
     },
@@ -35,25 +33,25 @@
     #[new]
     fn py_new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
     ) -> PyResult<Self> {
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
@@ -77,26 +75,32 @@
     fn __str__(&self) -> String {
         format!(
             "OrderEmulated(instrument_id={}, client_order_id={})",
             self.instrument_id, self.client_order_id,
         )
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderEmulated)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
     fn py_to_dict(&self, py: Python<'_>) -> PyResult<PyObject> {
         let dict = PyDict::new(py);
         dict.set_item("trader_id", self.trader_id.to_string())?;
         dict.set_item("strategy_id", self.strategy_id.to_string())?;
         dict.set_item("instrument_id", self.instrument_id.to_string())?;
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         Ok(dict.into())
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/expired.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/canceled.rs`

 * *Files 6% similar despite different names*

```diff
@@ -11,52 +11,50 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 
 use crate::{
-    events::order::expired::OrderExpired,
+    events::order::canceled::OrderCanceled,
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
     },
 };
 
 #[pymethods]
-impl OrderExpired {
+impl OrderCanceled {
     #[allow(clippy::too_many_arguments)]
     #[new]
     fn py_new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         reconciliation: bool,
         venue_order_id: Option<VenueOrderId>,
         account_id: Option<AccountId>,
     ) -> PyResult<Self> {
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             reconciliation,
             venue_order_id,
             account_id,
         )
         .map_err(to_pyvalue_err)
     }
 
@@ -67,15 +65,15 @@
             _ => py.NotImplemented(),
         }
     }
 
     fn __repr__(&self) -> String {
         format!(
             "{}(trader_id={}, strategy_id={}, instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, event_id={}, ts_event={}, ts_init={})",
-            stringify!(OrderExpired),
+            stringify!(OrderCanceled),
             self.trader_id,
             self.strategy_id,
             self.instrument_id,
             self.client_order_id,
             self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
             self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
             self.event_id,
@@ -83,39 +81,45 @@
             self.ts_init
         )
     }
 
     fn __str__(&self) -> String {
         format!(
             "{}(instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, ts_event={})",
-            stringify!(OrderExpired),
+            stringify!(OrderCanceled),
             self.instrument_id,
             self.client_order_id,
             self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
             self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
             self.ts_event,
         )
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderCanceled)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
     fn py_to_dict(&self, py: Python<'_>) -> PyResult<PyObject> {
         let dict = PyDict::new(py);
         dict.set_item("trader_id", self.trader_id.to_string())?;
         dict.set_item("strategy_id", self.strategy_id.to_string())?;
         dict.set_item("instrument_id", self.instrument_id.to_string())?;
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         dict.set_item("reconciliation", self.reconciliation)?;
         match self.venue_order_id {
             Some(venue_order_id) => dict.set_item("venue_order_id", venue_order_id.to_string())?,
             None => dict.set_item("venue_order_id", py.None())?,
         }
         match self.account_id {
             Some(account_id) => dict.set_item("account_id", account_id.to_string())?,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/filled.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/filled.rs`

 * *Files 2% similar despite different names*

```diff
@@ -11,19 +11,17 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 
 use crate::{
     enums::{LiquiditySide, OrderSide, OrderType},
     events::order::filled::OrderFilled,
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         position_id::PositionId, strategy_id::StrategyId, trade_id::TradeId, trader_id::TraderId,
@@ -47,16 +45,16 @@
         order_side: OrderSide,
         order_type: OrderType,
         last_qty: Quantity,
         last_px: Price,
         currency: Currency,
         liquidity_side: LiquiditySide,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         reconciliation: bool,
         position_id: Option<PositionId>,
         commission: Option<Money>,
     ) -> PyResult<Self> {
         Self::new(
             trader_id,
             strategy_id,
@@ -68,16 +66,16 @@
             order_side,
             order_type,
             last_qty,
             last_px,
             currency,
             liquidity_side,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             reconciliation,
             position_id,
             commission,
         )
         .map_err(to_pyvalue_err)
     }
 
@@ -170,14 +168,20 @@
             commission_str,
             self.liquidity_side,
             self.ts_event
         )
     }
 
     #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderFilled)
+    }
+
+    #[getter]
     #[pyo3(name = "is_buy")]
     fn py_is_buy(&self) -> bool {
         self.is_buy()
     }
 
     #[getter]
     #[pyo3(name = "is_sell")]
@@ -269,22 +273,22 @@
     #[pyo3(name = "event_id")]
     fn py_event_id(&self) -> UUID4 {
         self.event_id
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "reconciliation")]
     fn py_reconciliation(&self) -> bool {
         self.reconciliation
     }
@@ -326,16 +330,16 @@
         dict.set_item("order_side", self.order_side.to_string())?;
         dict.set_item("order_type", self.order_type.to_string())?;
         dict.set_item("last_qty", self.last_qty.to_string())?;
         dict.set_item("last_px", self.last_px.to_string())?;
         dict.set_item("currency", self.currency.code.to_string())?;
         dict.set_item("liquidity_side", self.liquidity_side.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         dict.set_item("reconciliation", self.reconciliation)?;
         match self.position_id {
             Some(position_id) => dict.set_item("position_id", position_id.to_string())?,
             None => dict.set_item("position_id", py.None())?,
         }
         match self.commission {
             Some(commission) => dict.set_item("commission", commission.to_string())?,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/initialized.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/initialized.rs`

 * *Files 2% similar despite different names*

```diff
@@ -12,24 +12,23 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::collections::HashMap;
 
 use nautilus_core::{
+    nanos::UnixNanos,
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{
     basic::CompareOp,
     prelude::*,
     types::{PyDict, PyList},
 };
-use rust_decimal::prelude::ToPrimitive;
 use ustr::Ustr;
 
 use crate::{
     enums::{ContingencyType, OrderSide, OrderType, TimeInForce, TrailingOffsetType, TriggerType},
     events::order::initialized::OrderInitialized,
     identifiers::{
         client_order_id::ClientOrderId, exec_algorithm_id::ExecAlgorithmId,
@@ -54,23 +53,23 @@
         quantity: Quantity,
         time_in_force: TimeInForce,
         post_only: bool,
         reduce_only: bool,
         quote_quantity: bool,
         reconciliation: bool,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         price: Option<Price>,
         trigger_price: Option<Price>,
         trigger_type: Option<TriggerType>,
         limit_offset: Option<Price>,
         trailing_offset: Option<Price>,
         trailing_offset_type: Option<TrailingOffsetType>,
-        expire_time: Option<UnixNanos>,
+        expire_time: Option<u64>,
         display_qty: Option<Quantity>,
         emulation_trigger: Option<TriggerType>,
         trigger_instrument_id: Option<InstrumentId>,
         contingency_type: Option<ContingencyType>,
         order_list_id: Option<OrderListId>,
         linked_order_ids: Option<Vec<ClientOrderId>>,
         parent_order_id: Option<ClientOrderId>,
@@ -89,23 +88,23 @@
             quantity,
             time_in_force,
             post_only,
             reduce_only,
             quote_quantity,
             reconciliation,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             price,
             trigger_price,
             trigger_type,
             limit_offset,
             trailing_offset,
             trailing_offset_type,
-            expire_time,
+            expire_time.map(UnixNanos::from),
             display_qty,
             emulation_trigger,
             trigger_instrument_id,
             contingency_type,
             order_list_id,
             linked_order_ids,
             parent_order_id,
@@ -210,14 +209,20 @@
         )
     }
 
     fn __str__(&self) -> String {
         format!("{self}")
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderInitialized)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
@@ -232,16 +237,16 @@
         dict.set_item("quantity", self.quantity.to_string())?;
         dict.set_item("time_in_force", self.time_in_force.to_string())?;
         dict.set_item("post_only", self.post_only)?;
         dict.set_item("reduce_only", self.reduce_only)?;
         dict.set_item("quote_quantity", self.quote_quantity)?;
         dict.set_item("reconciliation", self.reconciliation)?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         match self.price {
             Some(price) => dict.set_item("price", price.to_string())?,
             None => dict.set_item("price", py.None())?,
         }
         match self.trigger_price {
             Some(trigger_price) => dict.set_item("trigger_price", trigger_price.to_string())?,
             None => dict.set_item("trigger_price", py.None())?,
@@ -263,15 +268,15 @@
         match self.trailing_offset_type {
             Some(trailing_offset_type) => {
                 dict.set_item("trailing_offset_type", trailing_offset_type.to_string())?;
             }
             None => dict.set_item("trailing_offset_type", py.None())?,
         }
         match self.expire_time {
-            Some(expire_time) => dict.set_item("expire_time", expire_time.to_u64())?,
+            Some(expire_time) => dict.set_item("expire_time", expire_time.as_u64())?,
             None => dict.set_item("expire_time", py.None())?,
         }
         match self.display_qty {
             Some(display_qty) => dict.set_item("display_qty", display_qty.to_string())?,
             None => dict.set_item("display_qty", py.None())?,
         }
         match self.emulation_trigger {
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/orders/mod.rs`

 * *Files 24% similar despite different names*

```diff
@@ -9,23 +9,16 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod accepted;
-pub mod cancel_rejected;
-pub mod canceled;
-pub mod denied;
-pub mod emulated;
-pub mod expired;
-pub mod filled;
-pub mod initialized;
-pub mod modify_rejected;
-pub mod pending_cancel;
-pub mod pending_update;
-pub mod rejected;
-pub mod released;
-pub mod submitted;
-pub mod triggered;
-pub mod updated;
+pub mod limit;
+pub mod limit_if_touched;
+pub mod market;
+pub mod market_if_touched;
+pub mod market_to_limit;
+pub mod stop_limit;
+pub mod stop_market;
+pub mod trailing_stop_limit;
+pub mod trailing_stop_market;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/modify_rejected.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/modify_rejected.rs`

 * *Files 5% similar despite different names*

```diff
@@ -13,19 +13,17 @@
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::str::FromStr;
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 use ustr::Ustr;
 
 use crate::{
     events::order::modify_rejected::OrderModifyRejected,
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
@@ -39,30 +37,30 @@
     fn py_new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         reason: &str,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         reconciliation: bool,
         venue_order_id: Option<VenueOrderId>,
         account_id: Option<AccountId>,
     ) -> PyResult<Self> {
         let reason = Ustr::from_str(reason).unwrap();
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             reason,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             reconciliation,
             venue_order_id,
             account_id,
         )
         .map_err(to_pyvalue_err)
     }
 
@@ -78,37 +76,43 @@
         format!(
             "{}(trader_id={}, strategy_id={}, instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, reason={}, event_id={}, ts_event={}, ts_init={})",
             stringify!(OrderModifyRejected),
             self.trader_id,
             self.strategy_id,
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
-            self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
+            self.venue_order_id.map_or("None".to_string(), |venue_order_id| format!("{venue_order_id}")),
+            self.account_id.map_or("None".to_string(), |account_id| format!("{account_id}")),
             self.reason,
             self.event_id,
             self.ts_event,
             self.ts_init
 
         )
     }
 
     fn __str__(&self) -> String {
         format!(
             "{}(instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, reason={}, ts_event={})",
             stringify!(OrderModifyRejected),
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
-            self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
+            self.venue_order_id.map_or("None".to_string(), |venue_order_id| format!("{venue_order_id}")),
+            self.account_id.map_or("None".to_string(), |account_id| format!("{account_id}")),
             self.reason,
             self.ts_event,
         )
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderModifyRejected)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
@@ -129,12 +133,12 @@
             "account_id",
             self.account_id
                 .map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
         )?;
         dict.set_item("reason", self.reason.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
         dict.set_item("reconciliation", self.reconciliation)?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         Ok(dict.into())
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/pending_cancel.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/pending_cancel.rs`

 * *Files 3% similar despite different names*

```diff
@@ -11,19 +11,17 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 
 use crate::{
     events::order::pending_cancel::OrderPendingCancel,
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
     },
@@ -36,28 +34,28 @@
     fn py_new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         account_id: AccountId,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         reconciliation: bool,
         venue_order_id: Option<VenueOrderId>,
     ) -> PyResult<Self> {
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             account_id,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             reconciliation,
             venue_order_id,
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
@@ -92,14 +90,20 @@
             self.client_order_id,
             self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
             self.account_id,
             self.ts_event,
         )
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderPendingCancel)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
@@ -107,16 +111,16 @@
         let dict = PyDict::new(py);
         dict.set_item("trader_id", self.trader_id.to_string())?;
         dict.set_item("strategy_id", self.strategy_id.to_string())?;
         dict.set_item("instrument_id", self.instrument_id.to_string())?;
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("account_id", self.account_id.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         dict.set_item("reconciliation", self.reconciliation)?;
         match self.venue_order_id {
             Some(venue_order_id) => dict.set_item("venue_order_id", venue_order_id.to_string())?,
             None => dict.set_item("venue_order_id", py.None())?,
         }
         Ok(dict.into())
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/pending_update.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/pending_update.rs`

 * *Files 8% similar despite different names*

```diff
@@ -11,19 +11,17 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 
 use crate::{
     events::order::pending_update::OrderPendingUpdate,
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
     },
@@ -36,28 +34,28 @@
     fn py_new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         account_id: AccountId,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         reconciliation: bool,
         venue_order_id: Option<VenueOrderId>,
     ) -> PyResult<Self> {
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             account_id,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             reconciliation,
             venue_order_id,
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
@@ -92,14 +90,20 @@
             self.client_order_id,
             self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
             self.account_id,
             self.ts_event,
         )
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderPendingUpdate)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
@@ -107,16 +111,16 @@
         let dict = PyDict::new(py);
         dict.set_item("trader_id", self.trader_id.to_string())?;
         dict.set_item("strategy_id", self.strategy_id.to_string())?;
         dict.set_item("instrument_id", self.instrument_id.to_string())?;
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("account_id", self.account_id.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         dict.set_item("reconciliation", self.reconciliation)?;
         match self.venue_order_id {
             Some(venue_order_id) => dict.set_item("venue_order_id", venue_order_id.to_string())?,
             None => dict.set_item("venue_order_id", py.None())?,
         }
         Ok(dict.into())
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/rejected.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/rejected.rs`

 * *Files 3% similar despite different names*

```diff
@@ -13,19 +13,17 @@
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::str::FromStr;
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 use ustr::Ustr;
 
 use crate::{
     events::order::rejected::OrderRejected,
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         strategy_id::StrategyId, trader_id::TraderId,
@@ -39,29 +37,29 @@
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         account_id: AccountId,
         reason: &str,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         reconciliation: bool,
     ) -> PyResult<Self> {
         let reason = Ustr::from_str(reason).unwrap();
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             account_id,
             reason,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             reconciliation,
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
@@ -95,14 +93,20 @@
             self.client_order_id,
             self.account_id,
             self.reason,
             self.ts_event,
         )
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderRejected)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
@@ -111,13 +115,13 @@
         dict.set_item("trader_id", self.trader_id.to_string())?;
         dict.set_item("strategy_id", self.strategy_id.to_string())?;
         dict.set_item("instrument_id", self.instrument_id.to_string())?;
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("account_id", self.account_id.to_string())?;
         dict.set_item("reason", self.reason.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         dict.set_item("reconciliation", self.reconciliation)?;
         Ok(dict.into())
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/released.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/released.rs`

 * *Files 7% similar despite different names*

```diff
@@ -11,19 +11,17 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 
 use crate::{
     events::order::released::OrderReleased,
     identifiers::{
         client_order_id::ClientOrderId, instrument_id::InstrumentId, strategy_id::StrategyId,
         trader_id::TraderId,
     },
@@ -37,26 +35,26 @@
     fn py_new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         released_price: Price,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
     ) -> PyResult<Self> {
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             released_price,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
@@ -85,14 +83,20 @@
             stringify!(OrderReleased),
             self.instrument_id,
             self.client_order_id,
             self.released_price
         )
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderReleased)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
@@ -100,12 +104,12 @@
         let dict = PyDict::new(py);
         dict.set_item("trader_id", self.trader_id.to_string())?;
         dict.set_item("strategy_id", self.strategy_id.to_string())?;
         dict.set_item("instrument_id", self.instrument_id.to_string())?;
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("released_price", self.released_price.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         Ok(dict.into())
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/submitted.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/submitted.rs`

 * *Files 10% similar despite different names*

```diff
@@ -11,19 +11,17 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 
 use crate::{
     events::order::submitted::OrderSubmitted,
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         strategy_id::StrategyId, trader_id::TraderId,
     },
@@ -36,26 +34,26 @@
     fn py_new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         account_id: AccountId,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
     ) -> PyResult<Self> {
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             account_id,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
@@ -86,14 +84,20 @@
             self.instrument_id,
             self.client_order_id,
             self.account_id,
             self.ts_event,
         )
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderSubmitted)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
@@ -101,12 +105,12 @@
         let dict = PyDict::new(py);
         dict.set_item("trader_id", self.trader_id.to_string())?;
         dict.set_item("strategy_id", self.strategy_id.to_string())?;
         dict.set_item("instrument_id", self.instrument_id.to_string())?;
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("account_id", self.account_id.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         Ok(dict.into())
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/triggered.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/triggered.rs`

 * *Files 10% similar despite different names*

```diff
@@ -11,19 +11,17 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 
 use crate::{
     events::order::triggered::OrderTriggered,
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
     },
@@ -35,28 +33,28 @@
     #[new]
     fn py_new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         reconciliation: bool,
         venue_order_id: Option<VenueOrderId>,
         account_id: Option<AccountId>,
     ) -> PyResult<Self> {
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             reconciliation,
             venue_order_id,
             account_id,
         )
         .map_err(to_pyvalue_err)
     }
 
@@ -72,51 +70,57 @@
         format!(
             "{}(trader_id={}, strategy_id={}, instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, event_id={}, ts_event={}, ts_init={})",
             stringify!(OrderTriggered),
             self.trader_id,
             self.strategy_id,
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
-            self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
+            self.venue_order_id.map_or("None".to_string(), |venue_order_id| format!("{venue_order_id}")),
+            self.account_id.map_or("None".to_string(), |account_id| format!("{account_id}")),
             self.event_id,
             self.ts_event,
             self.ts_init
         )
     }
 
     fn __str__(&self) -> String {
         format!(
             "{}(instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, ts_event={})",
             stringify!(OrderTriggered),
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}"))
+            self.venue_order_id.map_or("None".to_string(), |venue_order_id| format!("{venue_order_id}"))
             ,
-            self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
+            self.account_id.map_or("None".to_string(), |account_id| format!("{account_id}")),
             self.ts_event,
         )
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderTriggered)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
     fn py_to_dict(&self, py: Python<'_>) -> PyResult<PyObject> {
         let dict = PyDict::new(py);
         dict.set_item("trader_id", self.trader_id.to_string())?;
         dict.set_item("strategy_id", self.strategy_id.to_string())?;
         dict.set_item("instrument_id", self.instrument_id.to_string())?;
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         dict.set_item("reconciliation", self.reconciliation)?;
         match self.venue_order_id {
             Some(venue_order_id) => dict.set_item("venue_order_id", venue_order_id.to_string())?,
             None => dict.set_item("venue_order_id", "None")?,
         }
         match self.account_id {
             Some(account_id) => dict.set_item("account_id", account_id.to_string())?,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/events/order/updated.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/events/order/updated.rs`

 * *Files 8% similar despite different names*

```diff
@@ -11,19 +11,17 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use nautilus_core::{
     python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
     uuid::UUID4,
 };
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::prelude::ToPrimitive;
 
 use crate::{
     events::order::updated::OrderUpdated,
     identifiers::{
         account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
         strategy_id::StrategyId, trader_id::TraderId, venue_order_id::VenueOrderId,
     },
@@ -37,31 +35,31 @@
     fn py_new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         quantity: Quantity,
         event_id: UUID4,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         reconciliation: bool,
         venue_order_id: Option<VenueOrderId>,
         account_id: Option<AccountId>,
         price: Option<Price>,
         trigger_price: Option<Price>,
     ) -> PyResult<Self> {
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             quantity,
             event_id,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
             reconciliation,
             venue_order_id,
             account_id,
             price,
             trigger_price,
         )
         .map_err(to_pyvalue_err)
@@ -80,40 +78,46 @@
             "{}(trader_id={}, strategy_id={}, instrument_id={}, client_order_id={}, \
             venue_order_id={}, account_id={}, quantity={}, price={}, trigger_price={}, event_id={}, ts_event={}, ts_init={})",
             stringify!(OrderUpdated),
             self.trader_id,
             self.strategy_id,
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
-            self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
+            self.venue_order_id.map_or("None".to_string(), |venue_order_id| format!("{venue_order_id}")),
+            self.account_id.map_or("None".to_string(), |account_id| format!("{account_id}")),
             self.quantity,
-            self.price.map_or_else(|| "None".to_string(), |price| format!("{price}")),
-            self.trigger_price.map_or_else(|| "None".to_string(), |trigger_price| format!("{trigger_price}")),
+            self.price.map_or("None".to_string(), |price| format!("{price}")),
+            self.trigger_price.map_or("None".to_string(), |trigger_price| format!("{trigger_price}")),
             self.event_id,
             self.ts_event,
             self.ts_init
         )
     }
 
     fn __str__(&self) -> String {
         format!(
             "{}(instrument_id={}, client_order_id={}, venue_order_id={}, account_id={}, quantity={}, price={}, trigger_price={}, ts_event={})",
             stringify!(OrderUpdated),
             self.instrument_id,
             self.client_order_id,
-            self.venue_order_id.map_or_else(|| "None".to_string(), |venue_order_id| format!("{venue_order_id}")),
-            self.account_id.map_or_else(|| "None".to_string(), |account_id| format!("{account_id}")),
+            self.venue_order_id.map_or("None".to_string(), |venue_order_id| format!("{venue_order_id}")),
+            self.account_id.map_or("None".to_string(), |account_id| format!("{account_id}")),
             self.quantity,
-            self.price.map_or_else(|| "None".to_string(), |price| format!("{price}")),
-            self.trigger_price.map_or_else(|| "None".to_string(), |trigger_price| format!("{trigger_price}")),
+            self.price.map_or("None".to_string(), |price| format!("{price}")),
+            self.trigger_price.map_or("None".to_string(), |trigger_price| format!("{trigger_price}")),
             self.ts_event,
         )
     }
 
+    #[getter]
+    #[pyo3(name = "order_event_type")]
+    fn py_order_event_type(&self) -> &str {
+        stringify!(OrderUpdated)
+    }
+
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
@@ -121,16 +125,16 @@
         let dict = PyDict::new(py);
         dict.set_item("trader_id", self.trader_id.to_string())?;
         dict.set_item("strategy_id", self.strategy_id.to_string())?;
         dict.set_item("instrument_id", self.instrument_id.to_string())?;
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("quantity", self.quantity.to_string())?;
         dict.set_item("event_id", self.event_id.to_string())?;
-        dict.set_item("ts_event", self.ts_event.to_u64())?;
-        dict.set_item("ts_init", self.ts_init.to_u64())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         dict.set_item("reconciliation", self.reconciliation)?;
         match self.venue_order_id {
             Some(venue_order_id) => dict.set_item("venue_order_id", venue_order_id.to_string())?,
             None => dict.set_item("venue_order_id", py.None())?,
         }
         match self.account_id {
             Some(account_id) => dict.set_item("account_id", account_id.to_string())?,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/identifiers/instrument_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/identifiers/instrument_id.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/identifiers/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/identifiers/mod.rs`

 * *Files 4% similar despite different names*

```diff
@@ -17,15 +17,14 @@
 
 use nautilus_core::python::to_pyvalue_err;
 use pyo3::{
     prelude::*,
     pyclass::CompareOp,
     types::{PyString, PyTuple},
 };
-use ustr::Ustr;
 
 use crate::identifier_for_python;
 
 pub mod instrument_id;
 pub mod trade_id;
 
 identifier_for_python!(crate::identifiers::account_id::AccountId);
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/identifiers/trade_id.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/identifiers/trade_id.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/crypto_future.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/crypto_perpetual.rs`

 * *Files 7% similar despite different names*

```diff
@@ -14,65 +14,60 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::hash_map::DefaultHasher,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::{
-    python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
-};
+use nautilus_core::python::{serialization::from_dict_pyo3, to_pyvalue_err};
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::{prelude::ToPrimitive, Decimal};
+use rust_decimal::Decimal;
 
 use crate::{
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
-    instruments::crypto_future::CryptoFuture,
+    instruments::crypto_perpetual::CryptoPerpetual,
     types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
 };
 
 #[pymethods]
-impl CryptoFuture {
+impl CryptoPerpetual {
     #[allow(clippy::too_many_arguments)]
     #[new]
     fn py_new(
         id: InstrumentId,
-        raw_symbol: Symbol,
-        underlying: Currency,
+        symbol: Symbol,
+        base_currency: Currency,
         quote_currency: Currency,
         settlement_currency: Currency,
-        activation_ns: UnixNanos,
-        expiration_ns: UnixNanos,
+        is_inverse: bool,
         price_precision: u8,
         size_precision: u8,
         price_increment: Price,
         size_increment: Quantity,
         maker_fee: Decimal,
         taker_fee: Decimal,
         margin_init: Decimal,
         margin_maint: Decimal,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         lot_size: Option<Quantity>,
         max_quantity: Option<Quantity>,
         min_quantity: Option<Quantity>,
         max_notional: Option<Money>,
         min_notional: Option<Money>,
         max_price: Option<Price>,
         min_price: Option<Price>,
     ) -> PyResult<Self> {
         Self::new(
             id,
-            raw_symbol,
-            underlying,
+            symbol,
+            base_currency,
             quote_currency,
             settlement_currency,
-            activation_ns,
-            expiration_ns,
+            is_inverse,
             price_precision,
             size_precision,
             price_increment,
             size_increment,
             maker_fee,
             taker_fee,
             margin_init,
@@ -80,37 +75,37 @@
             lot_size,
             max_quantity,
             min_quantity,
             max_notional,
             min_notional,
             max_price,
             min_price,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
-    fn __hash__(&self) -> isize {
-        let mut hasher = DefaultHasher::new();
-        self.hash(&mut hasher);
-        hasher.finish() as isize
-    }
-
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
             _ => panic!("Not implemented"),
         }
     }
 
+    fn __hash__(&self) -> isize {
+        let mut hasher = DefaultHasher::new();
+        self.hash(&mut hasher);
+        hasher.finish() as isize
+    }
+
     #[getter]
     #[pyo3(name = "instrument_type")]
     fn py_instrument_type(&self) -> &str {
-        stringify!(CryptoFuture)
+        stringify!(CryptoPerpetual)
     }
 
     #[getter]
     #[pyo3(name = "id")]
     fn py_id(&self) -> InstrumentId {
         self.id
     }
@@ -118,17 +113,17 @@
     #[getter]
     #[pyo3(name = "raw_symbol")]
     fn py_raw_symbol(&self) -> Symbol {
         self.raw_symbol
     }
 
     #[getter]
-    #[pyo3(name = "underlying")]
-    fn py_underlying(&self) -> Currency {
-        self.underlying
+    #[pyo3(name = "base_currency")]
+    fn py_base_currency(&self) -> Currency {
+        self.base_currency
     }
 
     #[getter]
     #[pyo3(name = "quote_currency")]
     fn py_quote_currency(&self) -> Currency {
         self.quote_currency
     }
@@ -136,23 +131,17 @@
     #[getter]
     #[pyo3(name = "settlement_currency")]
     fn py_settlement_currency(&self) -> Currency {
         self.settlement_currency
     }
 
     #[getter]
-    #[pyo3(name = "activation_ns")]
-    fn py_activation_ns(&self) -> UnixNanos {
-        self.activation_ns
-    }
-
-    #[getter]
-    #[pyo3(name = "expiration_ns")]
-    fn py_expiration_ns(&self) -> UnixNanos {
-        self.expiration_ns
+    #[pyo3(name = "is_inverse")]
+    fn py_is_inverse(&self) -> bool {
+        self.is_inverse
     }
 
     #[getter]
     #[pyo3(name = "price_precision")]
     fn py_price_precision(&self) -> u8 {
         self.price_precision
     }
@@ -173,16 +162,16 @@
     #[pyo3(name = "size_increment")]
     fn py_size_increment(&self) -> Quantity {
         self.size_increment
     }
 
     #[getter]
     #[pyo3(name = "lot_size")]
-    fn py_lot_size(&self) -> Option<Quantity> {
-        Some(self.lot_size)
+    fn py_lot_size(&self) -> Quantity {
+        self.lot_size
     }
 
     #[getter]
     #[pyo3(name = "max_quantity")]
     fn py_max_quantity(&self) -> Option<Quantity> {
         self.max_quantity
     }
@@ -214,14 +203,26 @@
     #[getter]
     #[pyo3(name = "min_price")]
     fn py_min_price(&self) -> Option<Price> {
         self.min_price
     }
 
     #[getter]
+    #[pyo3(name = "ts_event")]
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
+    }
+
+    #[getter]
+    #[pyo3(name = "ts_init")]
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
+    }
+
+    #[getter]
     #[pyo3(name = "margin_init")]
     fn py_margin_init(&self) -> Decimal {
         self.margin_init
     }
 
     #[getter]
     #[pyo3(name = "margin_maint")]
@@ -243,58 +244,45 @@
 
     #[getter]
     #[pyo3(name = "info")]
     fn py_info(&self, py: Python<'_>) -> PyResult<PyObject> {
         Ok(PyDict::new(py).into())
     }
 
-    #[getter]
-    #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
-    }
-
-    #[getter]
-    #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
-    }
-
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
     fn py_to_dict(&self, py: Python<'_>) -> PyResult<PyObject> {
         let dict = PyDict::new(py);
-        dict.set_item("type", stringify!(CryptoFuture))?;
+        dict.set_item("type", stringify!(CryptoPerpetual))?;
         dict.set_item("id", self.id.to_string())?;
         dict.set_item("raw_symbol", self.raw_symbol.to_string())?;
-        dict.set_item("underlying", self.underlying.code.to_string())?;
+        dict.set_item("base_currency", self.base_currency.code.to_string())?;
         dict.set_item("quote_currency", self.quote_currency.code.to_string())?;
         dict.set_item(
             "settlement_currency",
             self.settlement_currency.code.to_string(),
         )?;
-        dict.set_item("activation_ns", self.activation_ns.to_u64())?;
-        dict.set_item("expiration_ns", self.expiration_ns.to_u64())?;
+        dict.set_item("is_inverse", self.is_inverse)?;
         dict.set_item("price_precision", self.price_precision)?;
         dict.set_item("size_precision", self.size_precision)?;
         dict.set_item("price_increment", self.price_increment.to_string())?;
         dict.set_item("size_increment", self.size_increment.to_string())?;
+        dict.set_item("maker_fee", self.maker_fee.to_string())?;
+        dict.set_item("taker_fee", self.taker_fee.to_string())?;
         dict.set_item("margin_init", self.margin_init.to_string())?;
         dict.set_item("margin_maint", self.margin_maint.to_string())?;
-        dict.set_item("lot_size", self.lot_size.to_string())?;
         dict.set_item("info", PyDict::new(py))?;
-        dict.set_item("maker_fee", self.maker_fee.to_string())?;
-        dict.set_item("taker_fee", self.taker_fee.to_string())?;
-        dict.set_item("ts_event", self.ts_event)?;
-        dict.set_item("ts_init", self.ts_init)?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
+        dict.set_item("lot_size", self.lot_size.to_string())?;
         match self.max_quantity {
             Some(value) => dict.set_item("max_quantity", value.to_string())?,
             None => dict.set_item("max_quantity", py.None())?,
         }
         match self.min_quantity {
             Some(value) => dict.set_item("min_quantity", value.to_string())?,
             None => dict.set_item("min_quantity", py.None())?,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/crypto_perpetual.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/futures_spread.rs`

 * *Files 11% similar despite different names*

```diff
@@ -14,80 +14,75 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::hash_map::DefaultHasher,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::{
-    python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
-};
+use nautilus_core::python::{serialization::from_dict_pyo3, to_pyvalue_err};
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
 use rust_decimal::Decimal;
+use ustr::Ustr;
 
 use crate::{
+    enums::AssetClass,
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
-    instruments::crypto_perpetual::CryptoPerpetual,
-    types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
+    instruments::futures_spread::FuturesSpread,
+    types::{currency::Currency, price::Price, quantity::Quantity},
 };
 
 #[pymethods]
-impl CryptoPerpetual {
+impl FuturesSpread {
     #[allow(clippy::too_many_arguments)]
     #[new]
     fn py_new(
         id: InstrumentId,
-        symbol: Symbol,
-        base_currency: Currency,
-        quote_currency: Currency,
-        settlement_currency: Currency,
-        is_inverse: bool,
+        raw_symbol: Symbol,
+        asset_class: AssetClass,
+        underlying: String,
+        strategy_type: String,
+        activation_ns: u64,
+        expiration_ns: u64,
+        currency: Currency,
         price_precision: u8,
-        size_precision: u8,
         price_increment: Price,
-        size_increment: Quantity,
-        maker_fee: Decimal,
-        taker_fee: Decimal,
-        margin_init: Decimal,
-        margin_maint: Decimal,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
-        lot_size: Option<Quantity>,
+        multiplier: Quantity,
+        lot_size: Quantity,
+        ts_event: u64,
+        ts_init: u64,
+        margin_init: Option<Decimal>,
+        margin_maint: Option<Decimal>,
         max_quantity: Option<Quantity>,
         min_quantity: Option<Quantity>,
-        max_notional: Option<Money>,
-        min_notional: Option<Money>,
         max_price: Option<Price>,
         min_price: Option<Price>,
+        exchange: Option<String>,
     ) -> PyResult<Self> {
         Self::new(
             id,
-            symbol,
-            base_currency,
-            quote_currency,
-            settlement_currency,
-            is_inverse,
+            raw_symbol,
+            asset_class,
+            exchange.map(|e| Ustr::from(&e)),
+            underlying.into(),
+            strategy_type.into(),
+            activation_ns.into(),
+            expiration_ns.into(),
+            currency,
             price_precision,
-            size_precision,
             price_increment,
-            size_increment,
-            maker_fee,
-            taker_fee,
-            margin_init,
-            margin_maint,
+            multiplier,
             lot_size,
             max_quantity,
             min_quantity,
-            max_notional,
-            min_notional,
             max_price,
             min_price,
-            ts_event,
-            ts_init,
+            margin_init,
+            margin_maint,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
@@ -100,15 +95,15 @@
         self.hash(&mut hasher);
         hasher.finish() as isize
     }
 
     #[getter]
     #[pyo3(name = "instrument_type")]
     fn py_instrument_type(&self) -> &str {
-        stringify!(CryptoPerpetual)
+        stringify!(FuturesSpread)
     }
 
     #[getter]
     #[pyo3(name = "id")]
     fn py_id(&self) -> InstrumentId {
         self.id
     }
@@ -116,47 +111,59 @@
     #[getter]
     #[pyo3(name = "raw_symbol")]
     fn py_raw_symbol(&self) -> Symbol {
         self.raw_symbol
     }
 
     #[getter]
-    #[pyo3(name = "base_currency")]
-    fn py_base_currency(&self) -> Currency {
-        self.base_currency
+    #[pyo3(name = "asset_class")]
+    fn py_asset_class(&self) -> AssetClass {
+        self.asset_class
     }
 
     #[getter]
-    #[pyo3(name = "quote_currency")]
-    fn py_quote_currency(&self) -> Currency {
-        self.quote_currency
+    #[pyo3(name = "exchange")]
+    fn py_exchange(&self) -> Option<String> {
+        self.exchange.map(|e| e.to_string())
     }
 
     #[getter]
-    #[pyo3(name = "settlement_currency")]
-    fn py_settlement_currency(&self) -> Currency {
-        self.settlement_currency
+    #[pyo3(name = "underlying")]
+    fn py_underlying(&self) -> &str {
+        self.underlying.as_str()
     }
 
     #[getter]
-    #[pyo3(name = "is_inverse")]
-    fn py_is_inverse(&self) -> bool {
-        self.is_inverse
+    #[pyo3(name = "strategy_type")]
+    fn py_strategy_type(&self) -> &str {
+        self.strategy_type.as_str()
     }
 
     #[getter]
-    #[pyo3(name = "price_precision")]
-    fn py_price_precision(&self) -> u8 {
-        self.price_precision
+    #[pyo3(name = "activation_ns")]
+    fn py_activation_ns(&self) -> u64 {
+        self.activation_ns.as_u64()
     }
 
     #[getter]
-    #[pyo3(name = "size_precision")]
-    fn py_size_precision(&self) -> u8 {
-        self.size_precision
+    #[pyo3(name = "expiration_ns")]
+    fn py_expiration_ns(&self) -> u64 {
+        self.expiration_ns.as_u64()
+    }
+
+    #[getter]
+    #[pyo3(name = "currency")]
+    fn py_currency(&self) -> Currency {
+        self.currency
+    }
+
+    #[getter]
+    #[pyo3(name = "price_precision")]
+    fn py_price_precision(&self) -> u8 {
+        self.price_precision
     }
 
     #[getter]
     #[pyo3(name = "price_increment")]
     fn py_price_increment(&self) -> Price {
         self.price_increment
     }
@@ -164,14 +171,26 @@
     #[getter]
     #[pyo3(name = "size_increment")]
     fn py_size_increment(&self) -> Quantity {
         self.size_increment
     }
 
     #[getter]
+    #[pyo3(name = "size_precision")]
+    fn py_size_precision(&self) -> u8 {
+        self.size_precision
+    }
+
+    #[getter]
+    #[pyo3(name = "multiplier")]
+    fn py_multiplier(&self) -> Quantity {
+        self.multiplier
+    }
+
+    #[getter]
     #[pyo3(name = "lot_size")]
     fn py_lot_size(&self) -> Quantity {
         self.lot_size
     }
 
     #[getter]
     #[pyo3(name = "max_quantity")]
@@ -182,130 +201,100 @@
     #[getter]
     #[pyo3(name = "min_quantity")]
     fn py_min_quantity(&self) -> Option<Quantity> {
         self.min_quantity
     }
 
     #[getter]
-    #[pyo3(name = "max_notional")]
-    fn py_max_notional(&self) -> Option<Money> {
-        self.max_notional
-    }
-
-    #[getter]
-    #[pyo3(name = "min_notional")]
-    fn py_min_notional(&self) -> Option<Money> {
-        self.min_notional
-    }
-
-    #[getter]
     #[pyo3(name = "max_price")]
     fn py_max_price(&self) -> Option<Price> {
         self.max_price
     }
 
     #[getter]
     #[pyo3(name = "min_price")]
     fn py_min_price(&self) -> Option<Price> {
         self.min_price
     }
 
     #[getter]
-    #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
-    }
-
-    #[getter]
-    #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
-    }
-
-    #[getter]
     #[pyo3(name = "margin_init")]
     fn py_margin_init(&self) -> Decimal {
         self.margin_init
     }
 
     #[getter]
     #[pyo3(name = "margin_maint")]
     fn py_margin_maint(&self) -> Decimal {
         self.margin_maint
     }
 
     #[getter]
-    #[pyo3(name = "maker_fee")]
-    fn py_maker_fee(&self) -> Decimal {
-        self.maker_fee
+    #[pyo3(name = "info")]
+    fn py_info(&self, py: Python<'_>) -> PyResult<PyObject> {
+        Ok(PyDict::new(py).into())
     }
 
     #[getter]
-    #[pyo3(name = "taker_fee")]
-    fn py_taker_fee(&self) -> Decimal {
-        self.taker_fee
+    #[pyo3(name = "ts_event")]
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
-    #[pyo3(name = "info")]
-    fn py_info(&self, py: Python<'_>) -> PyResult<PyObject> {
-        Ok(PyDict::new(py).into())
+    #[pyo3(name = "ts_init")]
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
     fn py_to_dict(&self, py: Python<'_>) -> PyResult<PyObject> {
         let dict = PyDict::new(py);
-        dict.set_item("type", stringify!(CryptoPerpetual))?;
+        dict.set_item("type", stringify!(FuturesSpread))?;
         dict.set_item("id", self.id.to_string())?;
         dict.set_item("raw_symbol", self.raw_symbol.to_string())?;
-        dict.set_item("base_currency", self.base_currency.code.to_string())?;
-        dict.set_item("quote_currency", self.quote_currency.code.to_string())?;
-        dict.set_item(
-            "settlement_currency",
-            self.settlement_currency.code.to_string(),
-        )?;
-        dict.set_item("is_inverse", self.is_inverse)?;
+        dict.set_item("asset_class", self.asset_class.to_string())?;
+        dict.set_item("underlying", self.underlying.to_string())?;
+        dict.set_item("strategy_type", self.strategy_type.to_string())?;
+        dict.set_item("activation_ns", self.activation_ns.as_u64())?;
+        dict.set_item("expiration_ns", self.expiration_ns.as_u64())?;
+        dict.set_item("currency", self.currency.code.to_string())?;
         dict.set_item("price_precision", self.price_precision)?;
-        dict.set_item("size_precision", self.size_precision)?;
         dict.set_item("price_increment", self.price_increment.to_string())?;
         dict.set_item("size_increment", self.size_increment.to_string())?;
-        dict.set_item("maker_fee", self.maker_fee.to_string())?;
-        dict.set_item("taker_fee", self.taker_fee.to_string())?;
+        dict.set_item("size_precision", self.size_precision)?;
+        dict.set_item("multiplier", self.multiplier.to_string())?;
+        dict.set_item("lot_size", self.lot_size.to_string())?;
         dict.set_item("margin_init", self.margin_init.to_string())?;
         dict.set_item("margin_maint", self.margin_maint.to_string())?;
         dict.set_item("info", PyDict::new(py))?;
-        dict.set_item("ts_event", self.ts_event)?;
-        dict.set_item("ts_init", self.ts_init)?;
-        dict.set_item("lot_size", self.lot_size.to_string())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         match self.max_quantity {
             Some(value) => dict.set_item("max_quantity", value.to_string())?,
             None => dict.set_item("max_quantity", py.None())?,
         }
         match self.min_quantity {
             Some(value) => dict.set_item("min_quantity", value.to_string())?,
             None => dict.set_item("min_quantity", py.None())?,
         }
-        match self.max_notional {
-            Some(value) => dict.set_item("max_notional", value.to_string())?,
-            None => dict.set_item("max_notional", py.None())?,
-        }
-        match self.min_notional {
-            Some(value) => dict.set_item("min_notional", value.to_string())?,
-            None => dict.set_item("min_notional", py.None())?,
-        }
         match self.max_price {
             Some(value) => dict.set_item("max_price", value.to_string())?,
             None => dict.set_item("max_price", py.None())?,
         }
         match self.min_price {
             Some(value) => dict.set_item("min_price", value.to_string())?,
             None => dict.set_item("min_price", py.None())?,
         }
+        match self.exchange {
+            Some(value) => dict.set_item("exchange", value.to_string())?,
+            None => dict.set_item("exchange", py.None())?,
+        }
         Ok(dict.into())
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/currency_pair.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/currency_pair.rs`

 * *Files 2% similar despite different names*

```diff
@@ -14,18 +14,15 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::hash_map::DefaultHasher,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::{
-    python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
-};
+use nautilus_core::python::{serialization::from_dict_pyo3, to_pyvalue_err};
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
 use rust_decimal::Decimal;
 
 use crate::{
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     instruments::currency_pair::CurrencyPair,
     types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
@@ -44,16 +41,16 @@
         size_precision: u8,
         price_increment: Price,
         size_increment: Quantity,
         maker_fee: Decimal,
         taker_fee: Decimal,
         margin_init: Decimal,
         margin_maint: Decimal,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         lot_size: Option<Quantity>,
         max_quantity: Option<Quantity>,
         min_quantity: Option<Quantity>,
         max_notional: Option<Money>,
         min_notional: Option<Money>,
         max_price: Option<Price>,
         min_price: Option<Price>,
@@ -74,16 +71,16 @@
             lot_size,
             max_quantity,
             min_quantity,
             max_notional,
             min_notional,
             max_price,
             min_price,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
@@ -215,22 +212,22 @@
     #[pyo3(name = "margin_init")]
     fn py_margin_init(&self) -> Decimal {
         self.margin_init
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "info")]
     fn py_info(&self, py: Python<'_>) -> PyResult<PyObject> {
         Ok(PyDict::new(py).into())
     }
@@ -254,16 +251,16 @@
         dict.set_item("price_increment", self.price_increment.to_string())?;
         dict.set_item("size_increment", self.size_increment.to_string())?;
         dict.set_item("maker_fee", self.maker_fee.to_string())?;
         dict.set_item("taker_fee", self.taker_fee.to_string())?;
         dict.set_item("margin_init", self.margin_init.to_string())?;
         dict.set_item("margin_maint", self.margin_maint.to_string())?;
         dict.set_item("info", PyDict::new(py))?;
-        dict.set_item("ts_event", self.ts_event)?;
-        dict.set_item("ts_init", self.ts_init)?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         match self.lot_size {
             Some(value) => dict.set_item("lot_size", value.to_string())?,
             None => dict.set_item("lot_size", py.None())?,
         }
         match self.max_quantity {
             Some(value) => dict.set_item("max_quantity", value.to_string())?,
             None => dict.set_item("max_quantity", py.None())?,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/equity.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/equity.rs`

 * *Files 3% similar despite different names*

```diff
@@ -14,18 +14,15 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::hash_map::DefaultHasher,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::{
-    python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
-};
+use nautilus_core::python::{serialization::from_dict_pyo3, to_pyvalue_err};
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
 use rust_decimal::Decimal;
 use ustr::Ustr;
 
 use crate::{
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     instruments::equity::Equity,
@@ -38,16 +35,16 @@
     #[new]
     fn py_new(
         id: InstrumentId,
         raw_symbol: Symbol,
         currency: Currency,
         price_precision: u8,
         price_increment: Price,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         maker_fee: Option<Decimal>,
         taker_fee: Option<Decimal>,
         margin_init: Option<Decimal>,
         margin_maint: Option<Decimal>,
         isin: Option<String>,
         lot_size: Option<Quantity>,
         max_quantity: Option<Quantity>,
@@ -67,16 +64,16 @@
             margin_init,
             margin_maint,
             lot_size,
             max_quantity,
             min_quantity,
             max_price,
             min_price,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
@@ -163,22 +160,28 @@
     #[pyo3(name = "min_price")]
     fn py_min_price(&self) -> Option<Price> {
         self.min_price
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
+    }
+
+    #[getter]
+    #[pyo3(name = "info")]
+    fn py_info(&self, py: Python<'_>) -> PyResult<PyObject> {
+        Ok(PyDict::new(py).into())
     }
 
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
@@ -188,16 +191,17 @@
         let dict = PyDict::new(py);
         dict.set_item("type", stringify!(Equity))?;
         dict.set_item("id", self.id.to_string())?;
         dict.set_item("raw_symbol", self.raw_symbol.to_string())?;
         dict.set_item("currency", self.currency.code.to_string())?;
         dict.set_item("price_precision", self.price_precision)?;
         dict.set_item("price_increment", self.price_increment.to_string())?;
-        dict.set_item("ts_event", self.ts_event)?;
-        dict.set_item("ts_init", self.ts_init)?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
+        dict.set_item("info", PyDict::new(py))?;
         dict.set_item("maker_fee", self.maker_fee.to_string())?;
         dict.set_item("taker_fee", self.taker_fee.to_string())?;
         dict.set_item("margin_init", self.margin_init.to_string())?;
         dict.set_item("margin_maint", self.margin_maint.to_string())?;
         match &self.isin {
             Some(value) => dict.set_item("isin", value.to_string())?,
             None => dict.set_item("isin", py.None())?,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/futures_contract.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/futures_contract.rs`

 * *Files 4% similar despite different names*

```diff
@@ -14,20 +14,17 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::hash_map::DefaultHasher,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::{
-    python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
-};
+use nautilus_core::python::{serialization::from_dict_pyo3, to_pyvalue_err};
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::{prelude::ToPrimitive, Decimal};
+use rust_decimal::Decimal;
 use ustr::Ustr;
 
 use crate::{
     enums::AssetClass,
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     instruments::futures_contract::FuturesContract,
     types::{currency::Currency, price::Price, quantity::Quantity},
@@ -38,52 +35,52 @@
     #[allow(clippy::too_many_arguments)]
     #[new]
     fn py_new(
         id: InstrumentId,
         raw_symbol: Symbol,
         asset_class: AssetClass,
         underlying: String,
-        activation_ns: UnixNanos,
-        expiration_ns: UnixNanos,
+        activation_ns: u64,
+        expiration_ns: u64,
         currency: Currency,
         price_precision: u8,
         price_increment: Price,
         multiplier: Quantity,
         lot_size: Quantity,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         margin_init: Option<Decimal>,
         margin_maint: Option<Decimal>,
         max_quantity: Option<Quantity>,
         min_quantity: Option<Quantity>,
         max_price: Option<Price>,
         min_price: Option<Price>,
         exchange: Option<String>,
     ) -> PyResult<Self> {
         Self::new(
             id,
             raw_symbol,
             asset_class,
             exchange.map(|e| Ustr::from(&e)),
             underlying.into(),
-            activation_ns,
-            expiration_ns,
+            activation_ns.into(),
+            expiration_ns.into(),
             currency,
             price_precision,
             price_increment,
             multiplier,
             lot_size,
             max_quantity,
             min_quantity,
             max_price,
             min_price,
             margin_init,
             margin_maint,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
@@ -131,22 +128,22 @@
     #[pyo3(name = "underlying")]
     fn py_underlying(&self) -> &str {
         self.underlying.as_str()
     }
 
     #[getter]
     #[pyo3(name = "activation_ns")]
-    fn py_activation_ns(&self) -> UnixNanos {
-        self.activation_ns
+    fn py_activation_ns(&self) -> u64 {
+        self.activation_ns.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "expiration_ns")]
-    fn py_expiration_ns(&self) -> UnixNanos {
-        self.expiration_ns
+    fn py_expiration_ns(&self) -> u64 {
+        self.expiration_ns.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "currency")]
     fn py_currency(&self) -> Currency {
         self.currency
     }
@@ -209,22 +206,22 @@
     #[pyo3(name = "size_precision")]
     fn py_size_precision(&self) -> u8 {
         self.size_precision
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "margin_init")]
     fn py_margin_init(&self) -> Decimal {
         self.margin_init
     }
@@ -251,28 +248,28 @@
     fn py_to_dict(&self, py: Python<'_>) -> PyResult<PyObject> {
         let dict = PyDict::new(py);
         dict.set_item("type", stringify!(FuturesContract))?;
         dict.set_item("id", self.id.to_string())?;
         dict.set_item("raw_symbol", self.raw_symbol.to_string())?;
         dict.set_item("asset_class", self.asset_class.to_string())?;
         dict.set_item("underlying", self.underlying.to_string())?;
-        dict.set_item("activation_ns", self.activation_ns.to_u64())?;
-        dict.set_item("expiration_ns", self.expiration_ns.to_u64())?;
+        dict.set_item("activation_ns", self.activation_ns.as_u64())?;
+        dict.set_item("expiration_ns", self.expiration_ns.as_u64())?;
         dict.set_item("currency", self.currency.code.to_string())?;
         dict.set_item("price_precision", self.price_precision)?;
         dict.set_item("price_increment", self.price_increment.to_string())?;
         dict.set_item("size_increment", self.size_increment.to_string())?;
         dict.set_item("size_precision", self.size_precision)?;
         dict.set_item("multiplier", self.multiplier.to_string())?;
         dict.set_item("lot_size", self.lot_size.to_string())?;
         dict.set_item("margin_init", self.margin_init.to_string())?;
         dict.set_item("margin_maint", self.margin_maint.to_string())?;
         dict.set_item("info", PyDict::new(py))?;
-        dict.set_item("ts_event", self.ts_event)?;
-        dict.set_item("ts_init", self.ts_init)?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         match self.max_quantity {
             Some(value) => dict.set_item("max_quantity", value.to_string())?,
             None => dict.set_item("max_quantity", py.None())?,
         }
         match self.min_quantity {
             Some(value) => dict.set_item("min_quantity", value.to_string())?,
             None => dict.set_item("min_quantity", py.None())?,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/futures_spread.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/options_spread.rs`

 * *Files 3% similar despite different names*

```diff
@@ -14,48 +14,45 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::hash_map::DefaultHasher,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::{
-    python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
-};
+use nautilus_core::python::{serialization::from_dict_pyo3, to_pyvalue_err};
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::{prelude::ToPrimitive, Decimal};
+use rust_decimal::Decimal;
 use ustr::Ustr;
 
 use crate::{
     enums::AssetClass,
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
-    instruments::futures_spread::FuturesSpread,
+    instruments::options_spread::OptionsSpread,
     types::{currency::Currency, price::Price, quantity::Quantity},
 };
 
 #[pymethods]
-impl FuturesSpread {
+impl OptionsSpread {
     #[allow(clippy::too_many_arguments)]
     #[new]
     fn py_new(
         id: InstrumentId,
         raw_symbol: Symbol,
         asset_class: AssetClass,
         underlying: String,
         strategy_type: String,
-        activation_ns: UnixNanos,
-        expiration_ns: UnixNanos,
+        activation_ns: u64,
+        expiration_ns: u64,
         currency: Currency,
         price_precision: u8,
         price_increment: Price,
         multiplier: Quantity,
         lot_size: Quantity,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         margin_init: Option<Decimal>,
         margin_maint: Option<Decimal>,
         max_quantity: Option<Quantity>,
         min_quantity: Option<Quantity>,
         max_price: Option<Price>,
         min_price: Option<Price>,
         exchange: Option<String>,
@@ -63,29 +60,29 @@
         Self::new(
             id,
             raw_symbol,
             asset_class,
             exchange.map(|e| Ustr::from(&e)),
             underlying.into(),
             strategy_type.into(),
-            activation_ns,
-            expiration_ns,
+            activation_ns.into(),
+            expiration_ns.into(),
             currency,
             price_precision,
             price_increment,
             multiplier,
             lot_size,
+            margin_init,
+            margin_maint,
             max_quantity,
             min_quantity,
             max_price,
             min_price,
-            margin_init,
-            margin_maint,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
@@ -98,15 +95,15 @@
         self.hash(&mut hasher);
         hasher.finish() as isize
     }
 
     #[getter]
     #[pyo3(name = "instrument_type")]
     fn py_instrument_type(&self) -> &str {
-        stringify!(FuturesSpread)
+        stringify!(OptionsSpread)
     }
 
     #[getter]
     #[pyo3(name = "id")]
     fn py_id(&self) -> InstrumentId {
         self.id
     }
@@ -133,28 +130,28 @@
     #[pyo3(name = "underlying")]
     fn py_underlying(&self) -> &str {
         self.underlying.as_str()
     }
 
     #[getter]
     #[pyo3(name = "strategy_type")]
-    fn py_strategy_type(&self) -> &str {
+    fn py_option_kind(&self) -> &str {
         self.strategy_type.as_str()
     }
 
     #[getter]
     #[pyo3(name = "activation_ns")]
-    fn py_activation_ns(&self) -> UnixNanos {
-        self.activation_ns
+    fn py_activation_ns(&self) -> u64 {
+        self.activation_ns.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "expiration_ns")]
-    fn py_expiration_ns(&self) -> UnixNanos {
-        self.expiration_ns
+    fn py_expiration_ns(&self) -> u64 {
+        self.expiration_ns.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "currency")]
     fn py_currency(&self) -> Currency {
         self.currency
     }
@@ -235,53 +232,53 @@
     #[pyo3(name = "info")]
     fn py_info(&self, py: Python<'_>) -> PyResult<PyObject> {
         Ok(PyDict::new(py).into())
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
     fn py_to_dict(&self, py: Python<'_>) -> PyResult<PyObject> {
         let dict = PyDict::new(py);
-        dict.set_item("type", stringify!(FuturesSpread))?;
+        dict.set_item("type", stringify!(OptionsSpread))?;
         dict.set_item("id", self.id.to_string())?;
         dict.set_item("raw_symbol", self.raw_symbol.to_string())?;
         dict.set_item("asset_class", self.asset_class.to_string())?;
         dict.set_item("underlying", self.underlying.to_string())?;
         dict.set_item("strategy_type", self.strategy_type.to_string())?;
-        dict.set_item("activation_ns", self.activation_ns.to_u64())?;
-        dict.set_item("expiration_ns", self.expiration_ns.to_u64())?;
+        dict.set_item("activation_ns", self.activation_ns.as_u64())?;
+        dict.set_item("expiration_ns", self.expiration_ns.as_u64())?;
         dict.set_item("currency", self.currency.code.to_string())?;
         dict.set_item("price_precision", self.price_precision)?;
         dict.set_item("price_increment", self.price_increment.to_string())?;
         dict.set_item("size_increment", self.size_increment.to_string())?;
         dict.set_item("size_precision", self.size_precision)?;
         dict.set_item("multiplier", self.multiplier.to_string())?;
         dict.set_item("lot_size", self.lot_size.to_string())?;
         dict.set_item("margin_init", self.margin_init.to_string())?;
         dict.set_item("margin_maint", self.margin_maint.to_string())?;
         dict.set_item("info", PyDict::new(py))?;
-        dict.set_item("ts_event", self.ts_event)?;
-        dict.set_item("ts_init", self.ts_init)?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         match self.max_quantity {
             Some(value) => dict.set_item("max_quantity", value.to_string())?,
             None => dict.set_item("max_quantity", py.None())?,
         }
         match self.min_quantity {
             Some(value) => dict.set_item("min_quantity", value.to_string())?,
             None => dict.set_item("min_quantity", py.None())?,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/ffi/orderbook/mod.rs`

 * *Files 13% similar despite different names*

```diff
@@ -9,15 +9,9 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod crypto_future;
-pub mod crypto_perpetual;
-pub mod currency_pair;
-pub mod equity;
-pub mod futures_contract;
-pub mod futures_spread;
-pub mod options_contract;
-pub mod options_spread;
+pub mod book;
+pub mod level;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/options_contract.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/options_contract.rs`

 * *Files 4% similar despite different names*

```diff
@@ -14,20 +14,17 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::hash_map::DefaultHasher,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::{
-    python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
-};
+use nautilus_core::python::{serialization::from_dict_pyo3, to_pyvalue_err};
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::{prelude::ToPrimitive, Decimal};
+use rust_decimal::Decimal;
 use ustr::Ustr;
 
 use crate::{
     enums::{AssetClass, OptionKind},
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     instruments::options_contract::OptionsContract,
     types::{currency::Currency, price::Price, quantity::Quantity},
@@ -39,24 +36,24 @@
     #[new]
     fn py_new(
         id: InstrumentId,
         raw_symbol: Symbol,
         asset_class: AssetClass,
         underlying: String,
         option_kind: OptionKind,
-        activation_ns: UnixNanos,
-        expiration_ns: UnixNanos,
+        activation_ns: u64,
+        expiration_ns: u64,
         strike_price: Price,
         currency: Currency,
         price_precision: u8,
         price_increment: Price,
         multiplier: Quantity,
         lot_size: Quantity,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
+        ts_event: u64,
+        ts_init: u64,
         margin_init: Option<Decimal>,
         margin_maint: Option<Decimal>,
         max_quantity: Option<Quantity>,
         min_quantity: Option<Quantity>,
         max_price: Option<Price>,
         min_price: Option<Price>,
         exchange: Option<String>,
@@ -64,30 +61,30 @@
         Self::new(
             id,
             raw_symbol,
             asset_class,
             exchange.map(|e| Ustr::from(&e)),
             underlying.into(),
             option_kind,
-            activation_ns,
-            expiration_ns,
+            activation_ns.into(),
+            expiration_ns.into(),
             strike_price,
             currency,
             price_precision,
             price_increment,
             multiplier,
             lot_size,
             max_quantity,
             min_quantity,
             max_price,
             min_price,
             margin_init,
             margin_maint,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
@@ -141,22 +138,22 @@
     #[pyo3(name = "option_kind")]
     fn py_option_kind(&self) -> OptionKind {
         self.option_kind
     }
 
     #[getter]
     #[pyo3(name = "activation_ns")]
-    fn py_activation_ns(&self) -> UnixNanos {
-        self.activation_ns
+    fn py_activation_ns(&self) -> u64 {
+        self.activation_ns.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "expiration_ns")]
-    fn py_expiration_ns(&self) -> UnixNanos {
-        self.expiration_ns
+    fn py_expiration_ns(&self) -> u64 {
+        self.expiration_ns.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "strike_price")]
     fn py_strike_price(&self) -> Price {
         self.strike_price
     }
@@ -243,22 +240,22 @@
     #[pyo3(name = "info")]
     fn py_info(&self, py: Python<'_>) -> PyResult<PyObject> {
         Ok(PyDict::new(py).into())
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
@@ -268,29 +265,29 @@
         let dict = PyDict::new(py);
         dict.set_item("type", stringify!(OptionsContract))?;
         dict.set_item("id", self.id.to_string())?;
         dict.set_item("raw_symbol", self.raw_symbol.to_string())?;
         dict.set_item("asset_class", self.asset_class.to_string())?;
         dict.set_item("underlying", self.underlying.to_string())?;
         dict.set_item("option_kind", self.option_kind.to_string())?;
-        dict.set_item("activation_ns", self.activation_ns.to_u64())?;
-        dict.set_item("expiration_ns", self.expiration_ns.to_u64())?;
+        dict.set_item("activation_ns", self.activation_ns.as_u64())?;
+        dict.set_item("expiration_ns", self.expiration_ns.as_u64())?;
         dict.set_item("strike_price", self.strike_price.to_string())?;
         dict.set_item("currency", self.currency.code.to_string())?;
         dict.set_item("price_precision", self.price_precision)?;
         dict.set_item("price_increment", self.price_increment.to_string())?;
         dict.set_item("size_increment", self.size_increment.to_string())?;
         dict.set_item("size_precision", self.size_precision)?;
         dict.set_item("multiplier", self.multiplier.to_string())?;
         dict.set_item("lot_size", self.lot_size.to_string())?;
         dict.set_item("margin_init", self.margin_init.to_string())?;
         dict.set_item("margin_maint", self.margin_maint.to_string())?;
         dict.set_item("info", PyDict::new(py))?;
-        dict.set_item("ts_event", self.ts_event)?;
-        dict.set_item("ts_init", self.ts_init)?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         match self.max_quantity {
             Some(value) => dict.set_item("max_quantity", value.to_string())?,
             None => dict.set_item("max_quantity", py.None())?,
         }
         match self.min_quantity {
             Some(value) => dict.set_item("min_quantity", value.to_string())?,
             None => dict.set_item("min_quantity", py.None())?,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/instruments/options_spread.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/instruments/crypto_future.rs`

 * *Files 27% similar despite different names*

```diff
@@ -14,99 +14,102 @@
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::hash_map::DefaultHasher,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::{
-    python::{serialization::from_dict_pyo3, to_pyvalue_err},
-    time::UnixNanos,
-};
+use nautilus_core::python::{serialization::from_dict_pyo3, to_pyvalue_err};
 use pyo3::{basic::CompareOp, prelude::*, types::PyDict};
-use rust_decimal::{prelude::ToPrimitive, Decimal};
-use ustr::Ustr;
+use rust_decimal::Decimal;
 
 use crate::{
-    enums::AssetClass,
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
-    instruments::options_spread::OptionsSpread,
-    types::{currency::Currency, price::Price, quantity::Quantity},
+    instruments::crypto_future::CryptoFuture,
+    types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
 };
 
 #[pymethods]
-impl OptionsSpread {
+impl CryptoFuture {
     #[allow(clippy::too_many_arguments)]
     #[new]
     fn py_new(
         id: InstrumentId,
         raw_symbol: Symbol,
-        asset_class: AssetClass,
-        underlying: String,
-        strategy_type: String,
-        activation_ns: UnixNanos,
-        expiration_ns: UnixNanos,
-        currency: Currency,
+        underlying: Currency,
+        quote_currency: Currency,
+        settlement_currency: Currency,
+        is_inverse: bool,
+        activation_ns: u64,
+        expiration_ns: u64,
         price_precision: u8,
+        size_precision: u8,
         price_increment: Price,
-        multiplier: Quantity,
-        lot_size: Quantity,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
-        margin_init: Option<Decimal>,
-        margin_maint: Option<Decimal>,
+        size_increment: Quantity,
+        maker_fee: Decimal,
+        taker_fee: Decimal,
+        margin_init: Decimal,
+        margin_maint: Decimal,
+        ts_event: u64,
+        ts_init: u64,
+        lot_size: Option<Quantity>,
         max_quantity: Option<Quantity>,
         min_quantity: Option<Quantity>,
+        max_notional: Option<Money>,
+        min_notional: Option<Money>,
         max_price: Option<Price>,
         min_price: Option<Price>,
-        exchange: Option<String>,
     ) -> PyResult<Self> {
         Self::new(
             id,
             raw_symbol,
-            asset_class,
-            exchange.map(|e| Ustr::from(&e)),
-            underlying.into(),
-            strategy_type.into(),
-            activation_ns,
-            expiration_ns,
-            currency,
+            underlying,
+            quote_currency,
+            settlement_currency,
+            is_inverse,
+            activation_ns.into(),
+            expiration_ns.into(),
             price_precision,
+            size_precision,
             price_increment,
-            multiplier,
-            lot_size,
+            size_increment,
+            maker_fee,
+            taker_fee,
             margin_init,
             margin_maint,
+            lot_size,
             max_quantity,
             min_quantity,
+            max_notional,
+            min_notional,
             max_price,
             min_price,
-            ts_event,
-            ts_init,
+            ts_event.into(),
+            ts_init.into(),
         )
         .map_err(to_pyvalue_err)
     }
 
+    fn __hash__(&self) -> isize {
+        let mut hasher = DefaultHasher::new();
+        self.hash(&mut hasher);
+        hasher.finish() as isize
+    }
+
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
             _ => panic!("Not implemented"),
         }
     }
 
-    fn __hash__(&self) -> isize {
-        let mut hasher = DefaultHasher::new();
-        self.hash(&mut hasher);
-        hasher.finish() as isize
-    }
-
     #[getter]
     #[pyo3(name = "instrument_type")]
     fn py_instrument_type(&self) -> &str {
-        stringify!(OptionsSpread)
+        stringify!(CryptoFuture)
     }
 
     #[getter]
     #[pyo3(name = "id")]
     fn py_id(&self) -> InstrumentId {
         self.id
     }
@@ -114,89 +117,77 @@
     #[getter]
     #[pyo3(name = "raw_symbol")]
     fn py_raw_symbol(&self) -> Symbol {
         self.raw_symbol
     }
 
     #[getter]
-    #[pyo3(name = "asset_class")]
-    fn py_asset_class(&self) -> AssetClass {
-        self.asset_class
+    #[pyo3(name = "underlying")]
+    fn py_underlying(&self) -> Currency {
+        self.underlying
     }
 
     #[getter]
-    #[pyo3(name = "exchange")]
-    fn py_exchange(&self) -> Option<String> {
-        self.exchange.map(|e| e.to_string())
+    #[pyo3(name = "quote_currency")]
+    fn py_quote_currency(&self) -> Currency {
+        self.quote_currency
     }
 
     #[getter]
-    #[pyo3(name = "underlying")]
-    fn py_underlying(&self) -> &str {
-        self.underlying.as_str()
+    #[pyo3(name = "settlement_currency")]
+    fn py_settlement_currency(&self) -> Currency {
+        self.settlement_currency
     }
 
     #[getter]
-    #[pyo3(name = "strategy_type")]
-    fn py_option_kind(&self) -> &str {
-        self.strategy_type.as_str()
+    #[pyo3(name = "is_inverse")]
+    fn py_is_inverse(&self) -> bool {
+        self.is_inverse
     }
 
     #[getter]
     #[pyo3(name = "activation_ns")]
-    fn py_activation_ns(&self) -> UnixNanos {
-        self.activation_ns
+    fn py_activation_ns(&self) -> u64 {
+        self.activation_ns.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "expiration_ns")]
-    fn py_expiration_ns(&self) -> UnixNanos {
-        self.expiration_ns
-    }
-
-    #[getter]
-    #[pyo3(name = "currency")]
-    fn py_currency(&self) -> Currency {
-        self.currency
+    fn py_expiration_ns(&self) -> u64 {
+        self.expiration_ns.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "price_precision")]
     fn py_price_precision(&self) -> u8 {
         self.price_precision
     }
 
     #[getter]
+    #[pyo3(name = "size_precision")]
+    fn py_size_precision(&self) -> u8 {
+        self.size_precision
+    }
+
+    #[getter]
     #[pyo3(name = "price_increment")]
     fn py_price_increment(&self) -> Price {
         self.price_increment
     }
 
     #[getter]
     #[pyo3(name = "size_increment")]
     fn py_size_increment(&self) -> Quantity {
         self.size_increment
     }
 
     #[getter]
-    #[pyo3(name = "size_precision")]
-    fn py_size_precision(&self) -> u8 {
-        self.size_precision
-    }
-
-    #[getter]
-    #[pyo3(name = "multiplier")]
-    fn py_multiplier(&self) -> Quantity {
-        self.multiplier
-    }
-
-    #[getter]
     #[pyo3(name = "lot_size")]
-    fn py_lot_size(&self) -> Quantity {
-        self.lot_size
+    fn py_lot_size(&self) -> Option<Quantity> {
+        Some(self.lot_size)
     }
 
     #[getter]
     #[pyo3(name = "max_quantity")]
     fn py_max_quantity(&self) -> Option<Quantity> {
         self.max_quantity
     }
@@ -204,14 +195,26 @@
     #[getter]
     #[pyo3(name = "min_quantity")]
     fn py_min_quantity(&self) -> Option<Quantity> {
         self.min_quantity
     }
 
     #[getter]
+    #[pyo3(name = "max_notional")]
+    fn py_max_notional(&self) -> Option<Money> {
+        self.max_notional
+    }
+
+    #[getter]
+    #[pyo3(name = "min_notional")]
+    fn py_min_notional(&self) -> Option<Money> {
+        self.min_notional
+    }
+
+    #[getter]
     #[pyo3(name = "max_price")]
     fn py_max_price(&self) -> Option<Price> {
         self.max_price
     }
 
     #[getter]
     #[pyo3(name = "min_price")]
@@ -228,76 +231,96 @@
     #[getter]
     #[pyo3(name = "margin_maint")]
     fn py_margin_maint(&self) -> Decimal {
         self.margin_maint
     }
 
     #[getter]
+    #[pyo3(name = "maker_fee")]
+    fn py_maker_fee(&self) -> Decimal {
+        self.maker_fee
+    }
+
+    #[getter]
+    #[pyo3(name = "taker_fee")]
+    fn py_taker_fee(&self) -> Decimal {
+        self.taker_fee
+    }
+
+    #[getter]
     #[pyo3(name = "info")]
     fn py_info(&self, py: Python<'_>) -> PyResult<PyObject> {
         Ok(PyDict::new(py).into())
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_event
+    fn py_ts_event(&self) -> u64 {
+        self.ts_event.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[staticmethod]
     #[pyo3(name = "from_dict")]
     fn py_from_dict(py: Python<'_>, values: Py<PyDict>) -> PyResult<Self> {
         from_dict_pyo3(py, values)
     }
 
     #[pyo3(name = "to_dict")]
     fn py_to_dict(&self, py: Python<'_>) -> PyResult<PyObject> {
         let dict = PyDict::new(py);
-        dict.set_item("type", stringify!(OptionsSpread))?;
+        dict.set_item("type", stringify!(CryptoFuture))?;
         dict.set_item("id", self.id.to_string())?;
         dict.set_item("raw_symbol", self.raw_symbol.to_string())?;
-        dict.set_item("asset_class", self.asset_class.to_string())?;
-        dict.set_item("underlying", self.underlying.to_string())?;
-        dict.set_item("strategy_type", self.strategy_type.to_string())?;
-        dict.set_item("activation_ns", self.activation_ns.to_u64())?;
-        dict.set_item("expiration_ns", self.expiration_ns.to_u64())?;
-        dict.set_item("currency", self.currency.code.to_string())?;
+        dict.set_item("underlying", self.underlying.code.to_string())?;
+        dict.set_item("quote_currency", self.quote_currency.code.to_string())?;
+        dict.set_item(
+            "settlement_currency",
+            self.settlement_currency.code.to_string(),
+        )?;
+        dict.set_item("is_inverse", self.is_inverse)?;
+        dict.set_item("activation_ns", self.activation_ns.as_u64())?;
+        dict.set_item("expiration_ns", self.expiration_ns.as_u64())?;
         dict.set_item("price_precision", self.price_precision)?;
+        dict.set_item("size_precision", self.size_precision)?;
         dict.set_item("price_increment", self.price_increment.to_string())?;
         dict.set_item("size_increment", self.size_increment.to_string())?;
-        dict.set_item("size_precision", self.size_precision)?;
-        dict.set_item("multiplier", self.multiplier.to_string())?;
-        dict.set_item("lot_size", self.lot_size.to_string())?;
         dict.set_item("margin_init", self.margin_init.to_string())?;
         dict.set_item("margin_maint", self.margin_maint.to_string())?;
+        dict.set_item("lot_size", self.lot_size.to_string())?;
         dict.set_item("info", PyDict::new(py))?;
-        dict.set_item("ts_event", self.ts_event)?;
-        dict.set_item("ts_init", self.ts_init)?;
+        dict.set_item("maker_fee", self.maker_fee.to_string())?;
+        dict.set_item("taker_fee", self.taker_fee.to_string())?;
+        dict.set_item("ts_event", self.ts_event.as_u64())?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
         match self.max_quantity {
             Some(value) => dict.set_item("max_quantity", value.to_string())?,
             None => dict.set_item("max_quantity", py.None())?,
         }
         match self.min_quantity {
             Some(value) => dict.set_item("min_quantity", value.to_string())?,
             None => dict.set_item("min_quantity", py.None())?,
         }
+        match self.max_notional {
+            Some(value) => dict.set_item("max_notional", value.to_string())?,
+            None => dict.set_item("max_notional", py.None())?,
+        }
+        match self.min_notional {
+            Some(value) => dict.set_item("min_notional", value.to_string())?,
+            None => dict.set_item("min_notional", py.None())?,
+        }
         match self.max_price {
             Some(value) => dict.set_item("max_price", value.to_string())?,
             None => dict.set_item("max_price", py.None())?,
         }
         match self.min_price {
             Some(value) => dict.set_item("min_price", value.to_string())?,
             None => dict.set_item("min_price", py.None())?,
         }
-        match self.exchange {
-            Some(value) => dict.set_item("exchange", value.to_string())?,
-            None => dict.set_item("exchange", py.None())?,
-        }
         Ok(dict.into())
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/macros.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/macros.rs`

 * *Files 14% similar despite different names*

```diff
@@ -24,21 +24,21 @@
                     Ok(instance) => Ok(instance),
                     Err(e) => Err(to_pyvalue_err(e)),
                 }
             }
 
             fn __setstate__(&mut self, py: Python, state: PyObject) -> PyResult<()> {
                 let value: (&PyString,) = state.extract(py)?;
-                let value_str: String = value.0.extract()?;
-                self.value = Ustr::from_str(&value_str).map_err(to_pyvalue_err)?;
+                let value: &str = value.0.extract()?;
+                self.set_inner(value);
                 Ok(())
             }
 
             fn __getstate__(&self, py: Python) -> PyResult<PyObject> {
-                Ok((self.value.to_string(),).to_object(py))
+                Ok((self.to_string(),).to_object(py))
             }
 
             fn __reduce__(&self, py: Python) -> PyResult<PyObject> {
                 let safe_constructor = py.get_type::<Self>().getattr("_safe_constructor")?;
                 let state = self.__getstate__(py)?;
                 Ok((safe_constructor, PyTuple::empty(py), state).to_object(py))
             }
@@ -56,30 +56,30 @@
                     CompareOp::Gt => self.gt(other).into_py(py),
                     CompareOp::Le => self.le(other).into_py(py),
                     CompareOp::Lt => self.lt(other).into_py(py),
                 }
             }
 
             fn __hash__(&self) -> isize {
-                self.value.precomputed_hash() as isize
+                self.inner().precomputed_hash() as isize
             }
 
             fn __str__(&self) -> &'static str {
-                self.value.as_str()
+                self.inner().as_str()
             }
 
             fn __repr__(&self) -> String {
                 format!(
                     "{}('{}')",
                     stringify!($ty).split("::").last().unwrap_or(""),
-                    self.value
+                    self.as_str()
                 )
             }
 
             #[getter]
             #[pyo3(name = "value")]
             fn py_value(&self) -> String {
-                self.value.to_string()
+                self.to_string()
             }
         }
     };
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/mod.rs`

 * *Files 3% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+#![allow(warnings)] // non-local `impl` definition, temporary allow until pyo3 upgrade
+
 use pyo3::prelude::*;
 
 pub mod common;
 pub mod data;
 pub mod enums;
 pub mod events;
 pub mod identifiers;
@@ -103,17 +105,24 @@
     m.add_class::<crate::instruments::equity::Equity>()?;
     m.add_class::<crate::instruments::futures_contract::FuturesContract>()?;
     m.add_class::<crate::instruments::futures_spread::FuturesSpread>()?;
     m.add_class::<crate::instruments::options_contract::OptionsContract>()?;
     m.add_class::<crate::instruments::options_spread::OptionsSpread>()?;
     m.add_class::<crate::instruments::synthetic::SyntheticInstrument>()?;
     // Order book
-    m.add_class::<crate::orderbook::book_mbo::OrderBookMbo>()?;
-    m.add_class::<crate::orderbook::book_mbp::OrderBookMbp>()?;
+    m.add_class::<crate::orderbook::book::OrderBook>()?;
     m.add_class::<crate::orderbook::level::Level>()?;
+    m.add_function(wrap_pyfunction!(
+        crate::python::orderbook::book::py_update_book_with_quote_tick,
+        m
+    )?)?;
+    m.add_function(wrap_pyfunction!(
+        crate::python::orderbook::book::py_update_book_with_trade_tick,
+        m
+    )?)?;
     // Events - order
     m.add_class::<crate::events::order::denied::OrderDenied>()?;
     m.add_class::<crate::events::order::filled::OrderFilled>()?;
     m.add_class::<crate::events::order::initialized::OrderInitialized>()?;
     m.add_class::<crate::events::order::rejected::OrderRejected>()?;
     m.add_class::<crate::events::order::triggered::OrderTriggered>()?;
     m.add_class::<crate::events::order::submitted::OrderSubmitted>()?;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/orderbook/book_mbo.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/orderbook/book.rs`

 * *Files 19% similar despite different names*

```diff
@@ -9,32 +9,38 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_core::{python::to_pyruntime_err, time::UnixNanos};
+use nautilus_core::python::{to_pyruntime_err, to_pyvalue_err};
 use pyo3::prelude::*;
 
 use crate::{
     data::{
         delta::OrderBookDelta, deltas::OrderBookDeltas, depth::OrderBookDepth10, order::BookOrder,
+        quote::QuoteTick, trade::TradeTick,
     },
     enums::{BookType, OrderSide},
     identifiers::instrument_id::InstrumentId,
-    orderbook::{book_mbo::OrderBookMbo, level::Level},
+    orderbook::{
+        aggregation::{update_book_with_quote_tick, update_book_with_trade_tick},
+        analysis::book_check_integrity,
+        book::OrderBook,
+        level::Level,
+    },
     types::{price::Price, quantity::Quantity},
 };
 
 #[pymethods]
-impl OrderBookMbo {
+impl OrderBook {
     #[new]
-    fn py_new(instrument_id: InstrumentId) -> Self {
-        Self::new(instrument_id)
+    fn py_new(book_type: BookType, instrument_id: InstrumentId) -> Self {
+        Self::new(book_type, instrument_id)
     }
 
     fn __str__(&self) -> String {
         // TODO: Return debug string for now
         format!("{self:?}")
     }
 
@@ -47,80 +53,86 @@
     fn py_instrument_id(&self) -> InstrumentId {
         self.instrument_id
     }
 
     #[getter]
     #[pyo3(name = "book_type")]
     fn py_book_type(&self) -> BookType {
-        BookType::L3_MBO
+        self.book_type
     }
 
     #[getter]
     #[pyo3(name = "sequence")]
     fn py_sequence(&self) -> u64 {
         self.sequence
     }
 
     #[getter]
     #[pyo3(name = "ts_event")]
-    fn py_ts_event(&self) -> UnixNanos {
-        self.ts_last
+    fn py_ts_event(&self) -> u64 {
+        self.ts_last.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_last
+    fn py_ts_init(&self) -> u64 {
+        self.ts_last.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "ts_last")]
-    fn py_ts_last(&self) -> UnixNanos {
-        self.ts_last
+    fn py_ts_last(&self) -> u64 {
+        self.ts_last.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "count")]
     fn py_count(&self) -> u64 {
         self.count
     }
 
     #[pyo3(name = "reset")]
     fn py_reset(&mut self) {
         self.reset();
     }
 
-    #[pyo3(signature = (order, ts_event, sequence=0))]
+    #[pyo3(signature = (order, flags, sequence, ts_event))]
+    #[pyo3(name = "add")]
+    fn py_add(&mut self, order: BookOrder, flags: u8, sequence: u64, ts_event: u64) {
+        self.add(order, flags, sequence, ts_event.into());
+    }
+
+    #[pyo3(signature = (order, flags, sequence, ts_event))]
     #[pyo3(name = "update")]
-    fn py_update(&mut self, order: BookOrder, ts_event: UnixNanos, sequence: u64) {
-        self.update(order, ts_event, sequence);
+    fn py_update(&mut self, order: BookOrder, flags: u8, sequence: u64, ts_event: u64) {
+        self.update(order, flags, sequence, ts_event.into());
     }
 
-    #[pyo3(signature = (order, ts_event, sequence=0))]
+    #[pyo3(signature = (order, flags, sequence, ts_event))]
     #[pyo3(name = "delete")]
-    fn py_delete(&mut self, order: BookOrder, ts_event: UnixNanos, sequence: u64) {
-        self.delete(order, ts_event, sequence);
+    fn py_delete(&mut self, order: BookOrder, flags: u8, sequence: u64, ts_event: u64) {
+        self.delete(order, flags, sequence, ts_event.into());
     }
 
-    #[pyo3(signature = (ts_event, sequence=0))]
+    #[pyo3(signature = (sequence, ts_event))]
     #[pyo3(name = "clear")]
-    fn py_clear(&mut self, ts_event: UnixNanos, sequence: u64) {
-        self.clear(ts_event, sequence);
+    fn py_clear(&mut self, sequence: u64, ts_event: u64) {
+        self.clear(sequence, ts_event.into());
     }
 
-    #[pyo3(signature = (ts_event, sequence=0))]
+    #[pyo3(signature = (sequence, ts_event))]
     #[pyo3(name = "clear_bids")]
-    fn py_clear_bids(&mut self, ts_event: UnixNanos, sequence: u64) {
-        self.clear_bids(ts_event, sequence);
+    fn py_clear_bids(&mut self, sequence: u64, ts_event: u64) {
+        self.clear_bids(sequence, ts_event.into());
     }
 
-    #[pyo3(signature = (ts_event, sequence=0))]
+    #[pyo3(signature = (sequence, ts_event))]
     #[pyo3(name = "clear_asks")]
-    fn py_clear_asks(&mut self, ts_event: UnixNanos, sequence: u64) {
-        self.clear_asks(ts_event, sequence);
+    fn py_clear_asks(&mut self, sequence: u64, ts_event: u64) {
+        self.clear_asks(sequence, ts_event.into());
     }
 
     #[pyo3(name = "apply_delta")]
     fn py_apply_delta(&mut self, delta: OrderBookDelta) {
         self.apply_delta(delta);
     }
 
@@ -132,15 +144,15 @@
     #[pyo3(name = "apply_depth")]
     fn py_apply_depth(&mut self, depth: OrderBookDepth10) {
         self.apply_depth(depth);
     }
 
     #[pyo3(name = "check_integrity")]
     fn py_check_integrity(&mut self) -> PyResult<()> {
-        self.check_integrity().map_err(to_pyruntime_err)
+        book_check_integrity(self).map_err(to_pyruntime_err)
     }
 
     #[pyo3(name = "bids")]
     fn py_bids(&self) -> Vec<Level> {
         // TODO: Improve efficiency
         self.bids().map(|level_ref| (*level_ref).clone()).collect()
     }
@@ -197,7 +209,19 @@
     }
 
     #[pyo3(name = "pprint")]
     fn py_pprint(&self, num_levels: usize) -> String {
         self.pprint(num_levels)
     }
 }
+
+#[pyfunction()]
+#[pyo3(name = "update_book_with_quote_tick")]
+pub fn py_update_book_with_quote_tick(book: &mut OrderBook, quote: &QuoteTick) -> PyResult<()> {
+    update_book_with_quote_tick(book, quote).map_err(to_pyvalue_err)
+}
+
+#[pyfunction()]
+#[pyo3(name = "update_book_with_trade_tick")]
+pub fn py_update_book_with_trade_tick(book: &mut OrderBook, trade: &TradeTick) -> PyResult<()> {
+    update_book_with_trade_tick(book, trade).map_err(to_pyvalue_err)
+}
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/orderbook/level.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/orderbook/level.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/orderbook/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/lib.rs`

 * *Files 6% similar despite different names*

```diff
@@ -9,10 +9,13 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod book_mbo;
-pub mod book_mbp;
-pub mod level;
+pub mod arrow;
+pub mod backend;
+pub mod db;
+
+#[cfg(feature = "python")]
+pub mod python;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/orders/limit.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/orders/limit.rs`

 * *Files 2% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::collections::HashMap;
 
-use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use nautilus_core::{nanos::UnixNanos, uuid::UUID4};
 use pyo3::{
     basic::CompareOp,
     prelude::*,
     types::{PyDict, PyList},
 };
 use ustr::Ustr;
 
@@ -53,16 +53,16 @@
         quantity: Quantity,
         price: Price,
         time_in_force: TimeInForce,
         post_only: bool,
         reduce_only: bool,
         quote_quantity: bool,
         init_id: UUID4,
-        ts_init: UnixNanos,
-        expire_time: Option<UnixNanos>,
+        ts_init: u64,
+        expire_time: Option<u64>,
         display_qty: Option<Quantity>,
         emulation_trigger: Option<TriggerType>,
         trigger_instrument_id: Option<InstrumentId>,
         contingency_type: Option<ContingencyType>,
         order_list_id: Option<OrderListId>,
         linked_order_ids: Option<Vec<ClientOrderId>>,
         parent_order_id: Option<ClientOrderId>,
@@ -77,15 +77,15 @@
             strategy_id,
             instrument_id,
             client_order_id,
             order_side,
             quantity,
             price,
             time_in_force,
-            expire_time,
+            expire_time.map(UnixNanos::from),
             post_only,
             reduce_only,
             quote_quantity,
             display_qty,
             emulation_trigger,
             trigger_instrument_id,
             contingency_type,
@@ -93,15 +93,15 @@
             linked_order_ids,
             parent_order_id,
             exec_algorithm_id,
             exec_algorithm_params,
             exec_spawn_id,
             tags.map(|s| Ustr::from(&s)),
             init_id,
-            ts_init,
+            ts_init.into(),
         )
         .unwrap())
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
         match op {
             CompareOp::Eq => self.eq(other).into_py(py),
@@ -164,16 +164,16 @@
     #[pyo3(name = "price")]
     fn py_price(&self) -> Price {
         self.price
     }
 
     #[getter]
     #[pyo3(name = "expire_time")]
-    fn py_expire_time(&self) -> Option<UnixNanos> {
-        self.expire_time
+    fn py_expire_time(&self) -> Option<u64> {
+        self.expire_time.map(std::convert::Into::into)
     }
 
     #[getter]
     #[pyo3(name = "status")]
     fn py_status(&self) -> OrderStatus {
         self.status
     }
@@ -330,16 +330,16 @@
     #[pyo3(name = "emulation_trigger")]
     fn py_emulation_trigger(&self) -> Option<TriggerType> {
         self.emulation_trigger
     }
 
     #[getter]
     #[pyo3(name = "expire_time_ns")]
-    fn py_expire_time_ns(&self) -> Option<UnixNanos> {
-        self.expire_time
+    fn py_expire_time_ns(&self) -> Option<u64> {
+        self.expire_time.map(std::convert::Into::into)
     }
 
     #[getter]
     #[pyo3(name = "exec_spawn_id")]
     fn py_exec_spawn_id(&self) -> Option<ClientOrderId> {
         self.exec_spawn_id
     }
@@ -354,16 +354,16 @@
     #[pyo3(name = "display_qty")]
     fn py_display_qty(&self) -> Option<Quantity> {
         self.display_qty
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[staticmethod]
     #[pyo3(name = "opposite_side")]
     fn py_opposite_side(side: OrderSide) -> OrderSide {
         OrderCore::opposite_side(side)
     }
@@ -400,15 +400,15 @@
             .get_item("time_in_force")?
             .unwrap()
             .extract::<&str>()?
             .parse::<TimeInForce>()
             .unwrap();
         let expire_time_ns = dict
             .get_item("expire_time_ns")
-            .map(|x| x.and_then(|inner| inner.extract::<UnixNanos>().ok()))?;
+            .map(|x| x.and_then(|inner| inner.extract::<u64>().ok()))?;
         let is_post_only = dict.get_item("is_post_only")?.unwrap().extract::<bool>()?;
         let is_reduce_only = dict
             .get_item("is_reduce_only")?
             .unwrap()
             .extract::<bool>()?;
         let is_quote_quantity = dict
             .get_item("is_quote_quantity")?
@@ -506,25 +506,25 @@
                 }
             })
         })?;
         let init_id = dict
             .get_item("init_id")
             .map(|x| x.and_then(|inner| inner.extract::<&str>().unwrap().parse::<UUID4>().ok()))?
             .unwrap();
-        let ts_init = dict.get_item("ts_init")?.unwrap().extract::<UnixNanos>()?;
+        let ts_init = dict.get_item("ts_init")?.unwrap().extract::<u64>()?;
         let limit_order = Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             order_side,
             quantity,
             price,
             time_in_force,
-            expire_time_ns,
+            expire_time_ns.map(UnixNanos::from),
             is_post_only,
             is_reduce_only,
             is_quote_quantity,
             display_qty,
             emulation_trigger,
             trigger_instrument_id,
             contingency_type,
@@ -532,15 +532,15 @@
             linked_order_ids,
             parent_order_id,
             exec_algorithm_id,
             exec_algorithm_params,
             exec_spawn_id,
             tags,
             init_id,
-            ts_init,
+            ts_init.into(),
         )
         .unwrap();
         Ok(limit_order)
     }
 
     #[pyo3(name = "to_dict")]
     fn py_to_dict(&self, py: Python<'_>) -> PyResult<PyObject> {
@@ -551,22 +551,25 @@
         dict.set_item("client_order_id", self.client_order_id.to_string())?;
         dict.set_item("side", self.side.to_string())?;
         dict.set_item("type", self.order_type.to_string())?;
         dict.set_item("quantity", self.quantity.to_string())?;
         dict.set_item("price", self.price.to_string())?;
         dict.set_item("status", self.status.to_string())?;
         dict.set_item("time_in_force", self.time_in_force.to_string())?;
-        dict.set_item("expire_time_ns", self.expire_time)?;
+        dict.set_item(
+            "expire_time_ns",
+            self.expire_time.filter(|&t| t != 0).map(|t| t.as_u64()),
+        )?;
         dict.set_item("is_post_only", self.is_post_only)?;
         dict.set_item("is_reduce_only", self.is_reduce_only)?;
         dict.set_item("is_quote_quantity", self.is_quote_quantity)?;
         dict.set_item("filled_qty", self.filled_qty.to_string())?;
         dict.set_item("init_id", self.init_id.to_string())?;
-        dict.set_item("ts_init", self.ts_init)?;
-        dict.set_item("ts_last", self.ts_last)?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
+        dict.set_item("ts_last", self.ts_last.as_u64())?;
         let commissions_dict = PyDict::new(py);
         for (key, value) in &self.commissions {
             commissions_dict.set_item(key.code.to_string(), value.to_string())?;
         }
         dict.set_item("commissions", commissions_dict)?;
         self.venue_order_id.map_or_else(
             || dict.set_item("venue_order_id", py.None()),
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/orders/market.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/orders/market.rs`

 * *Files 0% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::collections::HashMap;
 
-use nautilus_core::{python::to_pyvalue_err, time::UnixNanos, uuid::UUID4};
+use nautilus_core::{python::to_pyvalue_err, uuid::UUID4};
 use pyo3::{
     basic::CompareOp,
     pymethods,
     types::{PyDict, PyList},
     IntoPy, Py, PyAny, PyObject, PyResult, Python,
 };
 use rust_decimal::Decimal;
@@ -47,45 +47,46 @@
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         order_side: OrderSide,
         quantity: Quantity,
         init_id: UUID4,
-        ts_init: UnixNanos,
+        ts_init: u64,
         time_in_force: TimeInForce,
         reduce_only: bool,
         quote_quantity: bool,
         contingency_type: Option<ContingencyType>,
         order_list_id: Option<OrderListId>,
         linked_order_ids: Option<Vec<ClientOrderId>>,
         parent_order_id: Option<ClientOrderId>,
         exec_algorithm_id: Option<ExecAlgorithmId>,
         exec_algorithm_params: Option<HashMap<String, String>>,
         exec_spawn_id: Option<ClientOrderId>,
         tags: Option<String>,
     ) -> PyResult<Self> {
+        let exec_algorithm_params = exec_algorithm_params.map(str_hashmap_to_ustr);
         Self::new(
             trader_id,
             strategy_id,
             instrument_id,
             client_order_id,
             order_side,
             quantity,
             time_in_force,
             init_id,
-            ts_init,
+            ts_init.into(),
             reduce_only,
             quote_quantity,
             contingency_type,
             order_list_id,
             linked_order_ids,
             parent_order_id,
             exec_algorithm_id,
-            exec_algorithm_params.map(str_hashmap_to_ustr),
+            exec_algorithm_params,
             exec_spawn_id,
             tags.map(|s| Ustr::from(&s)),
         )
         .map_err(to_pyvalue_err)
     }
 
     fn __richcmp__(&self, other: &Self, op: CompareOp, py: Python<'_>) -> Py<PyAny> {
@@ -152,16 +153,16 @@
     #[pyo3(name = "init_id")]
     fn py_init_id(&self) -> UUID4 {
         self.init_id
     }
 
     #[getter]
     #[pyo3(name = "ts_init")]
-    fn py_ts_init(&self) -> UnixNanos {
-        self.ts_init
+    fn py_ts_init(&self) -> u64 {
+        self.ts_init.as_u64()
     }
 
     #[getter]
     #[pyo3(name = "client_order_id")]
     fn py_client_order_id(&self) -> ClientOrderId {
         self.client_order_id
     }
@@ -284,16 +285,16 @@
         dict.set_item("quantity", self.quantity.to_string())?;
         dict.set_item("status", self.status.to_string())?;
         dict.set_item("time_in_force", self.time_in_force.to_string())?;
         dict.set_item("is_reduce_only", self.is_reduce_only)?;
         dict.set_item("is_quote_quantity", self.is_quote_quantity)?;
         dict.set_item("filled_qty", self.filled_qty.to_string())?;
         dict.set_item("init_id", self.init_id.to_string())?;
-        dict.set_item("ts_init", self.ts_init)?;
-        dict.set_item("ts_last", self.ts_last)?;
+        dict.set_item("ts_init", self.ts_init.as_u64())?;
+        dict.set_item("ts_last", self.ts_last.as_u64())?;
         let commissions_dict = PyDict::new(py);
         for (key, value) in &self.commissions {
             commissions_dict.set_item(key.code.to_string(), value.to_string())?;
         }
         dict.set_item("commissions", commissions_dict)?;
         self.venue_order_id.map_or_else(
             || dict.set_item("venue_order_id", py.None()),
@@ -403,15 +404,15 @@
             .extract::<&str>()?
             .parse::<TimeInForce>()
             .unwrap();
         let init_id = dict
             .get_item("init_id")
             .map(|x| x.and_then(|inner| inner.extract::<&str>().unwrap().parse::<UUID4>().ok()))?
             .unwrap();
-        let ts_init = dict.get_item("ts_init")?.unwrap().extract::<UnixNanos>()?;
+        let ts_init = dict.get_item("ts_init")?.unwrap().extract::<u64>()?;
         let is_reduce_only = dict
             .get_item("is_reduce_only")?
             .unwrap()
             .extract::<bool>()?;
         let is_quote_quantity = dict
             .get_item("is_quote_quantity")?
             .unwrap()
@@ -497,15 +498,15 @@
             strategy_id,
             instrument_id,
             client_order_id,
             order_side,
             quantity,
             time_in_force,
             init_id,
-            ts_init,
+            ts_init.into(),
             is_reduce_only,
             is_quote_quantity,
             contingency_type,
             order_list_id,
             linked_order_ids,
             parent_order_id,
             exec_algorithm_id,
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/orders/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/orderbook/mod.rs`

 * *Files 3% similar despite different names*

```diff
@@ -9,9 +9,9 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod limit;
-pub mod market;
+pub mod book;
+pub mod level;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/types/balance.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/types/balance.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/types/currency.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/types/currency.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/types/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/types/mod.rs`

 * *Files 7% similar despite different names*

```diff
@@ -11,10 +11,13 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 pub mod balance;
 pub mod currency;
+pub mod fixed;
 pub mod money;
 pub mod price;
 pub mod quantity;
+#[cfg(feature = "stubs")]
+pub mod stubs;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/types/money.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/types/money.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/types/price.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/types/price.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/python/types/quantity.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/python/types/quantity.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/stubs.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/stubs.rs`

 * *Files 8% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 use rust_decimal::prelude::ToPrimitive;
 
 use crate::{
     data::order::BookOrder,
     enums::{LiquiditySide, OrderSide},
     identifiers::instrument_id::InstrumentId,
     instruments::{currency_pair::CurrencyPair, stubs::audusd_sim, Instrument},
-    orderbook::book_mbp::OrderBookMbp,
+    orderbook::book::OrderBook,
     orders::{
         market::MarketOrder,
         stubs::{TestOrderEventStubs, TestOrderStubs},
     },
     position::Position,
     types::{money::Money, price::Price, quantity::Quantity},
 };
@@ -98,15 +98,15 @@
         None,
         None,
     );
     Position::new(audusd_sim, order_filled).unwrap()
 }
 
 #[must_use]
-pub fn stub_order_book_mbp_appl_xnas() -> OrderBookMbp {
+pub fn stub_order_book_mbp_appl_xnas() -> OrderBook {
     stub_order_book_mbp(
         InstrumentId::from("AAPL.XNAS"),
         101.0,
         100.0,
         100.0,
         100.0,
         2,
@@ -126,16 +126,16 @@
     top_ask_size: f64,
     top_bid_size: f64,
     price_precision: u8,
     price_increment: f64,
     size_precision: u8,
     size_increment: f64,
     num_levels: usize,
-) -> OrderBookMbp {
-    let mut book = OrderBookMbp::new(instrument_id, false);
+) -> OrderBook {
+    let mut book = OrderBook::new(crate::enums::BookType::L2_MBP, instrument_id);
 
     // Generate bids
     for i in 0..num_levels {
         let price = Price::new(
             price_increment.mul_add(-(i as f64), top_bid_price),
             price_precision,
         )
@@ -147,15 +147,15 @@
         .unwrap();
         let order = BookOrder::new(
             OrderSide::Buy,
             price,
             size,
             0, // order_id not applicable for MBP (market by price) books
         );
-        book.add(order, 0, 1);
+        book.add(order, 0, 1, 2.into());
     }
 
     // Generate asks
     for i in 0..num_levels {
         let price = Price::new(
             price_increment.mul_add(i as f64, top_ask_price),
             price_precision,
@@ -168,12 +168,12 @@
         .unwrap();
         let order = BookOrder::new(
             OrderSide::Sell,
             price,
             size,
             0, // order_id not applicable for MBP (market by price) books
         );
-        book.add(order, 0, 1);
+        book.add(order, 0, 1, 2.into());
     }
 
     book
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/types/balance.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/types/balance.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/types/currency.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/types/currency.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/types/fixed.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/types/fixed.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/types/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/python/backend/mod.rs`

 * *Files 11% similar despite different names*

```diff
@@ -9,15 +9,9 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod balance;
-pub mod currency;
-pub mod fixed;
-pub mod money;
-pub mod price;
-pub mod quantity;
-#[cfg(feature = "stubs")]
-pub mod stubs;
+pub mod session;
+pub mod transformer;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/types/money.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/types/money.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/types/price.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/types/price.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/types/quantity.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/types/quantity.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/types/stubs.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/types/stubs.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/model/src/venues.rs` & `nautilus_trader-1.191.0/nautilus_core/model/src/venues.rs`

 * *Files 12% similar despite different names*

```diff
@@ -15,15 +15,14 @@
 
 use std::{
     collections::HashMap,
     sync::{Mutex, OnceLock},
 };
 
 use once_cell::sync::Lazy;
-use ustr::Ustr;
 
 use crate::identifiers::venue::Venue;
 
 static CBCM_LOCK: OnceLock<Venue> = OnceLock::new();
 static GLBX_LOCK: OnceLock<Venue> = OnceLock::new();
 static NYUM_LOCK: OnceLock<Venue> = OnceLock::new();
 static XCBT_LOCK: OnceLock<Venue> = OnceLock::new();
@@ -31,67 +30,51 @@
 static XCME_LOCK: OnceLock<Venue> = OnceLock::new();
 static XFXS_LOCK: OnceLock<Venue> = OnceLock::new();
 static XNYM_LOCK: OnceLock<Venue> = OnceLock::new();
 
 impl Venue {
     #[allow(non_snake_case)]
     pub fn CBCM() -> Self {
-        *CBCM_LOCK.get_or_init(|| Self {
-            value: Ustr::from("CBCM"),
-        })
+        *CBCM_LOCK.get_or_init(|| Self::from("CBCM"))
     }
     #[allow(non_snake_case)]
     pub fn GLBX() -> Self {
-        *GLBX_LOCK.get_or_init(|| Self {
-            value: Ustr::from("GLBX"),
-        })
+        *GLBX_LOCK.get_or_init(|| Self::from("GLBX"))
     }
     #[allow(non_snake_case)]
     pub fn NYUM() -> Self {
-        *NYUM_LOCK.get_or_init(|| Self {
-            value: Ustr::from("NYUM"),
-        })
+        *NYUM_LOCK.get_or_init(|| Self::from("NYUM"))
     }
     #[allow(non_snake_case)]
     pub fn XCBT() -> Self {
-        *XCBT_LOCK.get_or_init(|| Self {
-            value: Ustr::from("XCBT"),
-        })
+        *XCBT_LOCK.get_or_init(|| Self::from("XCBT"))
     }
     #[allow(non_snake_case)]
     pub fn XCEC() -> Self {
-        *XCEC_LOCK.get_or_init(|| Self {
-            value: Ustr::from("XCEC"),
-        })
+        *XCEC_LOCK.get_or_init(|| Self::from("XCEC"))
     }
     #[allow(non_snake_case)]
     pub fn XCME() -> Self {
-        *XCME_LOCK.get_or_init(|| Self {
-            value: Ustr::from("XCME"),
-        })
+        *XCME_LOCK.get_or_init(|| Self::from("XCME"))
     }
     #[allow(non_snake_case)]
     pub fn XFXS() -> Self {
-        *XFXS_LOCK.get_or_init(|| Self {
-            value: Ustr::from("XFXS"),
-        })
+        *XFXS_LOCK.get_or_init(|| Self::from("XFXS"))
     }
     #[allow(non_snake_case)]
     pub fn XNYM() -> Self {
-        *XNYM_LOCK.get_or_init(|| Self {
-            value: Ustr::from("XNYM"),
-        })
+        *XNYM_LOCK.get_or_init(|| Self::from("XNYM"))
     }
 }
 
 pub static VENUE_MAP: Lazy<Mutex<HashMap<&str, Venue>>> = Lazy::new(|| {
     let mut map = HashMap::new();
-    map.insert(Venue::CBCM().value.as_str(), Venue::CBCM());
-    map.insert(Venue::GLBX().value.as_str(), Venue::GLBX());
-    map.insert(Venue::NYUM().value.as_str(), Venue::NYUM());
-    map.insert(Venue::XCBT().value.as_str(), Venue::XCBT());
-    map.insert(Venue::XCEC().value.as_str(), Venue::XCEC());
-    map.insert(Venue::XCME().value.as_str(), Venue::XCME());
-    map.insert(Venue::XFXS().value.as_str(), Venue::XFXS());
-    map.insert(Venue::XNYM().value.as_str(), Venue::XNYM());
+    map.insert(Venue::CBCM().inner().as_str(), Venue::CBCM());
+    map.insert(Venue::GLBX().inner().as_str(), Venue::GLBX());
+    map.insert(Venue::NYUM().inner().as_str(), Venue::NYUM());
+    map.insert(Venue::XCBT().inner().as_str(), Venue::XCBT());
+    map.insert(Venue::XCEC().inner().as_str(), Venue::XCEC());
+    map.insert(Venue::XCME().inner().as_str(), Venue::XCME());
+    map.insert(Venue::XFXS().inner().as_str(), Venue::XFXS());
+    map.insert(Venue::XNYM().inner().as_str(), Venue::XNYM());
     Mutex::new(map)
 });
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/network/Cargo.toml`

 * *Files 3% similar despite different names*

```diff
@@ -17,24 +17,24 @@
 pyo3 = { workspace = true, optional = true }
 pyo3-asyncio = { workspace = true, optional = true }
 tracing = { workspace = true }
 tokio = { workspace = true }
 dashmap = "5.5.3"
 futures-util = "0.3.30"
 http = "1.1.0"
-hyper = "1.2.0"
+hyper = "1.3.1"
 nonzero_ext = "0.3.0"
-reqwest = "0.11.27"
+reqwest = "0.12.4"
 tokio-tungstenite = { path = "./tokio-tungstenite", features = ["rustls-tls-native-roots"] }
 
 [dev-dependencies]
 criterion = { workspace = true }
 serde_json = { workspace = true }
 rstest = { workspace = true }
-axum = "0.7.4"
+axum = "0.7.5"
 tracing-test = "0.2.4"
 
 [features]
 default = ["python"]
 extension-module = [
   "pyo3/extension-module",
   "nautilus-core/extension-module",
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/benches/test_client.rs` & `nautilus_trader-1.191.0/nautilus_core/network/benches/test_client.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/benches/test_server.rs` & `nautilus_trader-1.191.0/nautilus_core/network/benches/test_server.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/src/http.rs` & `nautilus_trader-1.191.0/nautilus_core/network/src/http.rs`

 * *Files 3% similar despite different names*

```diff
@@ -21,14 +21,15 @@
 
 use futures_util::{stream, StreamExt};
 use pyo3::{exceptions::PyException, prelude::*, types::PyBytes};
 use reqwest::{
     header::{HeaderMap, HeaderName},
     Method, Response, Url,
 };
+use tracing::trace;
 
 use crate::ratelimiter::{clock::MonotonicClock, quota::Quota, RateLimiter};
 
 /// Provides a high-performance `HttpClient` for HTTP requests.
 ///
 /// The client is backed by a hyper Client which keeps connections alive and
 /// can be cloned cheaply. The client also has a list of header fields to
@@ -61,31 +62,35 @@
         let request_builder = self.client.request(method, reqwest_url).headers(header_map);
 
         let request = match body {
             Some(b) => request_builder.body(b).build()?,
             None => request_builder.build()?,
         };
 
-        let res = self.client.execute(request).await?;
-        self.to_response(res).await
+        trace!("{request:?}");
+
+        let response = self.client.execute(request).await?;
+        self.to_response(response).await
     }
 
     pub async fn to_response(
         &self,
-        res: Response,
+        response: Response,
     ) -> Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>> {
+        trace!("{response:?}");
+
         let headers: HashMap<String, String> = self
             .header_keys
             .iter()
-            .filter_map(|key| res.headers().get(key).map(|val| (key, val)))
+            .filter_map(|key| response.headers().get(key).map(|val| (key, val)))
             .filter_map(|(key, val)| val.to_str().map(|v| (key, v)).ok())
             .map(|(k, v)| (k.clone(), v.to_owned()))
             .collect();
-        let status = res.status().as_u16();
-        let bytes = res.bytes().await?;
+        let status = response.status().as_u16();
+        let bytes = response.bytes().await?;
 
         Ok(HttpResponse {
             status,
             headers,
             body: bytes.to_vec(),
         })
     }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/src/lib.rs` & `nautilus_trader-1.191.0/nautilus_core/execution/src/lib.rs`

 * *Files 12% similar despite different names*

```diff
@@ -9,15 +9,11 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod http;
-#[allow(dead_code)]
-mod ratelimiter;
-pub mod socket;
-pub mod websocket;
-
-#[cfg(feature = "python")]
-pub mod python;
+pub mod client;
+pub mod engine;
+pub mod matching_core;
+pub mod messages;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/src/python/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/network/src/python/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/src/ratelimiter/clock.rs` & `nautilus_trader-1.191.0/nautilus_core/network/src/ratelimiter/clock.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/src/ratelimiter/gcra.rs` & `nautilus_trader-1.191.0/nautilus_core/network/src/ratelimiter/gcra.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/src/ratelimiter/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/network/src/ratelimiter/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/src/ratelimiter/nanos.rs` & `nautilus_trader-1.191.0/nautilus_core/network/src/ratelimiter/nanos.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/src/ratelimiter/quota.rs` & `nautilus_trader-1.191.0/nautilus_core/network/src/ratelimiter/quota.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/src/socket.rs` & `nautilus_trader-1.191.0/nautilus_core/network/src/socket.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/src/websocket.rs` & `nautilus_trader-1.191.0/nautilus_core/network/src/websocket.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/CHANGELOG.md` & `nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/CHANGELOG.md`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/Cargo.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/LICENSE` & `nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/LICENSE`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/README.md` & `nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/README.md`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/src/compat.rs` & `nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/src/compat.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/src/connect.rs` & `nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/src/connect.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/src/handshake.rs` & `nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/src/handshake.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/src/lib.rs` & `nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/src/lib.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/src/stream.rs` & `nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/src/stream.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/network/tokio-tungstenite/src/tls.rs` & `nautilus_trader-1.191.0/nautilus_core/network/tokio-tungstenite/src/tls.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/persistence/Cargo.toml`

 * *Files 0% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 futures = { workspace = true }
 pyo3 = { workspace = true, optional = true }
 rand = { workspace = true }
 tokio = { workspace = true }
 thiserror = { workspace = true }
 binary-heap-plus = "0.5.0"
 compare = "0.1.0"
-datafusion = { version = "36.0.0", default-features = false, features = ["compression", "regex_expressions", "unicode_expressions", "pyarrow"] }
+datafusion = { version = "37.0.0", default-features = false, features = ["compression", "regex_expressions", "unicode_expressions", "pyarrow"] }
 dotenv = "0.15.0"
 sqlx = { version = "0.7.4", features = ["sqlite", "postgres", "any", "runtime-tokio"] }
 
 [dev-dependencies]
 criterion = { workspace = true }
 rstest = { workspace = true }
 quickcheck = "1"
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/benches/bench_persistence.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/benches/bench_persistence.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/arrow/bar.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/arrow/bar.rs`

 * *Files 2% similar despite different names*

```diff
@@ -88,16 +88,16 @@
 
         for bar in data {
             open_builder.append_value(bar.open.raw);
             high_builder.append_value(bar.high.raw);
             low_builder.append_value(bar.low.raw);
             close_builder.append_value(bar.close.raw);
             volume_builder.append_value(bar.volume.raw);
-            ts_event_builder.append_value(bar.ts_event);
-            ts_init_builder.append_value(bar.ts_init);
+            ts_event_builder.append_value(bar.ts_event.as_u64());
+            ts_init_builder.append_value(bar.ts_init.as_u64());
         }
 
         let open_array = open_builder.finish();
         let high_array = high_builder.finish();
         let low_array = low_builder.finish();
         let close_array = close_builder.finish();
         let volume_array = volume_builder.finish();
@@ -138,16 +138,16 @@
         let result: Result<Vec<Self>, EncodingError> = (0..record_batch.num_rows())
             .map(|i| {
                 let open = Price::from_raw(open_values.value(i), price_precision).unwrap();
                 let high = Price::from_raw(high_values.value(i), price_precision).unwrap();
                 let low = Price::from_raw(low_values.value(i), price_precision).unwrap();
                 let close = Price::from_raw(close_values.value(i), price_precision).unwrap();
                 let volume = Quantity::from_raw(volume_values.value(i), size_precision).unwrap();
-                let ts_event = ts_event_values.value(i);
-                let ts_init = ts_init_values.value(i);
+                let ts_event = ts_event_values.value(i).into();
+                let ts_init = ts_init_values.value(i).into();
 
                 Ok(Self {
                     bar_type,
                     open,
                     high,
                     low,
                     close,
@@ -224,26 +224,26 @@
         let bar1 = Bar::new(
             bar_type,
             Price::from("100.10"),
             Price::from("102.00"),
             Price::from("100.00"),
             Price::from("101.00"),
             Quantity::from(1100),
-            1,
-            3,
+            1.into(),
+            3.into(),
         );
         let bar2 = Bar::new(
             bar_type,
             Price::from("100.00"),
             Price::from("100.00"),
             Price::from("100.00"),
             Price::from("100.10"),
             Quantity::from(1110),
-            2,
-            4,
+            2.into(),
+            4.into(),
         );
 
         let data = vec![bar1, bar2];
         let record_batch = Bar::encode_batch(&metadata, &data).unwrap();
 
         let columns = record_batch.columns();
         let open_values = columns[0].as_any().downcast_ref::<Int64Array>().unwrap();
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/arrow/delta.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/arrow/delta.rs`

 * *Files 1% similar despite different names*

```diff
@@ -98,16 +98,16 @@
             action_builder.append_value(delta.action as u8);
             side_builder.append_value(delta.order.side as u8);
             price_builder.append_value(delta.order.price.raw);
             size_builder.append_value(delta.order.size.raw);
             order_id_builder.append_value(delta.order.order_id);
             flags_builder.append_value(delta.flags);
             sequence_builder.append_value(delta.sequence);
-            ts_event_builder.append_value(delta.ts_event);
-            ts_init_builder.append_value(delta.ts_init);
+            ts_event_builder.append_value(delta.ts_event.as_u64());
+            ts_init_builder.append_value(delta.ts_init.as_u64());
         }
 
         let action_array = action_builder.finish();
         let side_array = side_builder.finish();
         let price_array = price_builder.finish();
         let size_array = size_builder.finish();
         let order_id_array = order_id_builder.finish();
@@ -168,16 +168,16 @@
                     )
                 })?;
                 let price = Price::from_raw(price_values.value(i), price_precision).unwrap();
                 let size = Quantity::from_raw(size_values.value(i), size_precision).unwrap();
                 let order_id = order_id_values.value(i);
                 let flags = flags_values.value(i);
                 let sequence = sequence_values.value(i);
-                let ts_event = ts_event_values.value(i);
-                let ts_init = ts_init_values.value(i);
+                let ts_event = ts_event_values.value(i).into();
+                let ts_init = ts_init_values.value(i).into();
 
                 Ok(Self {
                     instrument_id,
                     action,
                     order: BookOrder {
                         side,
                         price,
@@ -266,31 +266,31 @@
                 side: OrderSide::Buy,
                 price: Price::from("100.10"),
                 size: Quantity::from(100),
                 order_id: 1,
             },
             flags: 0,
             sequence: 1,
-            ts_event: 1,
-            ts_init: 3,
+            ts_event: 1.into(),
+            ts_init: 3.into(),
         };
 
         let delta2 = OrderBookDelta {
             instrument_id,
             action: BookAction::Update,
             order: BookOrder {
                 side: OrderSide::Sell,
                 price: Price::from("101.20"),
                 size: Quantity::from(200),
                 order_id: 2,
             },
             flags: 1,
             sequence: 2,
-            ts_event: 2,
-            ts_init: 4,
+            ts_event: 2.into(),
+            ts_init: 4.into(),
         };
 
         let data = vec![delta1, delta2];
         let record_batch = OrderBookDelta::encode_batch(&metadata, &data).unwrap();
 
         let columns = record_batch.columns();
         let action_values = columns[0].as_any().downcast_ref::<UInt8Array>().unwrap();
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/arrow/depth.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/arrow/depth.rs`

 * *Files 1% similar despite different names*

```diff
@@ -171,16 +171,16 @@
                 ask_size_builders[i].append_value(depth.asks[i].size.raw);
                 bid_count_builders[i].append_value(depth.bid_counts[i]);
                 ask_count_builders[i].append_value(depth.ask_counts[i]);
             }
 
             flags_builder.append_value(depth.flags);
             sequence_builder.append_value(depth.sequence);
-            ts_event_builder.append_value(depth.ts_event);
-            ts_init_builder.append_value(depth.ts_init);
+            ts_event_builder.append_value(depth.ts_event.as_u64());
+            ts_init_builder.append_value(depth.ts_init.as_u64());
         }
 
         let bid_price_arrays = bid_price_builders
             .into_iter()
             .map(|mut b| Arc::new(b.finish()) as Arc<dyn Array>)
             .collect::<Vec<_>>();
         let ask_price_arrays = ask_price_builders
@@ -395,16 +395,16 @@
                     instrument_id,
                     bids,
                     asks,
                     bid_counts: bid_count_arr,
                     ask_counts: ask_count_arr,
                     flags: flags.value(i),
                     sequence: sequence.value(i),
-                    ts_event: ts_event.value(i),
-                    ts_init: ts_init.value(i),
+                    ts_event: ts_event.value(i).into(),
+                    ts_init: ts_init.value(i).into(),
                 })
             })
             .collect();
 
         result
     }
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/arrow/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/arrow/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/arrow/quote.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/arrow/quote.rs`

 * *Files 3% similar despite different names*

```diff
@@ -88,16 +88,16 @@
         let mut ts_init_builder = UInt64Array::builder(data.len());
 
         for quote in data {
             bid_price_builder.append_value(quote.bid_price.raw);
             ask_price_builder.append_value(quote.ask_price.raw);
             bid_size_builder.append_value(quote.bid_size.raw);
             ask_size_builder.append_value(quote.ask_size.raw);
-            ts_event_builder.append_value(quote.ts_event);
-            ts_init_builder.append_value(quote.ts_init);
+            ts_event_builder.append_value(quote.ts_event.as_u64());
+            ts_init_builder.append_value(quote.ts_init.as_u64());
         }
 
         let bid_price_array = bid_price_builder.finish();
         let ask_price_array = ask_price_builder.finish();
         let bid_size_array = bid_size_builder.finish();
         let ask_size_array = ask_size_builder.finish();
         let ts_event_array = ts_event_builder.finish();
@@ -138,16 +138,16 @@
                     Price::from_raw(bid_price_values.value(i), price_precision).unwrap();
                 let ask_price =
                     Price::from_raw(ask_price_values.value(i), price_precision).unwrap();
                 let bid_size =
                     Quantity::from_raw(bid_size_values.value(i), size_precision).unwrap();
                 let ask_size =
                     Quantity::from_raw(ask_size_values.value(i), size_precision).unwrap();
-                let ts_event = ts_event_values.value(i);
-                let ts_init = ts_init_values.value(i);
+                let ts_event = ts_event_values.value(i).into();
+                let ts_init = ts_init_values.value(i).into();
 
                 Ok(Self {
                     instrument_id,
                     bid_price,
                     ask_price,
                     bid_size,
                     ask_size,
@@ -219,26 +219,26 @@
         let instrument_id = InstrumentId::from("AAPL.XNAS");
         let tick1 = QuoteTick {
             instrument_id,
             bid_price: Price::from("100.10"),
             ask_price: Price::from("101.50"),
             bid_size: Quantity::from(1000),
             ask_size: Quantity::from(500),
-            ts_event: 1,
-            ts_init: 3,
+            ts_event: 1.into(),
+            ts_init: 3.into(),
         };
 
         let tick2 = QuoteTick {
             instrument_id,
             bid_price: Price::from("100.75"),
             ask_price: Price::from("100.20"),
             bid_size: Quantity::from(750),
             ask_size: Quantity::from(300),
-            ts_event: 2,
-            ts_init: 4,
+            ts_event: 2.into(),
+            ts_init: 4.into(),
         };
 
         let data = vec![tick1, tick2];
         let metadata: HashMap<String, String> = HashMap::new();
         let record_batch = QuoteTick::encode_batch(&metadata, &data).unwrap();
 
         // Verify the encoded data
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/arrow/trade.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/arrow/trade.rs`

 * *Files 2% similar despite different names*

```diff
@@ -89,16 +89,16 @@
         let mut ts_init_builder = UInt64Array::builder(data.len());
 
         for tick in data {
             price_builder.append_value(tick.price.raw);
             size_builder.append_value(tick.size.raw);
             aggressor_side_builder.append_value(tick.aggressor_side as u8);
             trade_id_builder.append_value(tick.trade_id.to_string());
-            ts_event_builder.append_value(tick.ts_event);
-            ts_init_builder.append_value(tick.ts_init);
+            ts_event_builder.append_value(tick.ts_event.as_u64());
+            ts_init_builder.append_value(tick.ts_init.as_u64());
         }
 
         let price_array = price_builder.finish();
         let size_array = size_builder.finish();
         let aggressor_side_array = aggressor_side_builder.finish();
         let trade_id_array = trade_id_builder.finish();
         let ts_event_array = ts_event_builder.finish();
@@ -143,16 +143,16 @@
                     .ok_or_else(|| {
                         EncodingError::ParseError(
                             stringify!(AggressorSide),
                             format!("Invalid enum value, was {aggressor_side_value}"),
                         )
                     })?;
                 let trade_id = TradeId::from(trade_id_values.value(i));
-                let ts_event = ts_event_values.value(i);
-                let ts_init = ts_init_values.value(i);
+                let ts_event = ts_event_values.value(i).into();
+                let ts_init = ts_init_values.value(i).into();
 
                 Ok(Self {
                     instrument_id,
                     price,
                     size,
                     aggressor_side,
                     trade_id,
@@ -229,26 +229,26 @@
 
         let tick1 = TradeTick {
             instrument_id,
             price: Price::from("100.10"),
             size: Quantity::from(1000),
             aggressor_side: AggressorSide::Buyer,
             trade_id: TradeId::new("1").unwrap(),
-            ts_event: 1,
-            ts_init: 3,
+            ts_event: 1.into(),
+            ts_init: 3.into(),
         };
 
         let tick2 = TradeTick {
             instrument_id,
             price: Price::from("100.50"),
             size: Quantity::from(500),
             aggressor_side: AggressorSide::Seller,
             trade_id: TradeId::new("2").unwrap(),
-            ts_event: 2,
-            ts_init: 4,
+            ts_event: 2.into(),
+            ts_init: 4.into(),
         };
 
         let data = vec![tick1, tick2];
         let record_batch = TradeTick::encode_batch(&metadata, &data).unwrap();
 
         // Verify the encoded data
         let columns = record_batch.columns();
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/backend/mod.rs` & `nautilus_trader-1.191.0/nautilus_trader/adapters/tardis/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,17 +1,17 @@
-// -------------------------------------------------------------------------------------------------
-//  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
-//  https://nautechsystems.io
-//
-//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-//  You may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-// -------------------------------------------------------------------------------------------------
-
-pub mod kmerge_batch;
-pub mod session;
+# -------------------------------------------------------------------------------------------------
+#  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
+#  https://nautechsystems.io
+#
+#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+#  You may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+# -------------------------------------------------------------------------------------------------
+"""
+Provides a data integration for Tardis https://tardis.dev/.
+"""
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/backend/session.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/backend/session.rs`

 * *Files 2% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 
 use compare::Compare;
 use datafusion::{
     error::Result, logical_expr::expr::Sort, physical_plan::SendableRecordBatchStream, prelude::*,
 };
 use futures::StreamExt;
 use nautilus_core::ffi::cvec::CVec;
-use nautilus_model::data::{Data, HasTsInit};
+use nautilus_model::{data::Data, polymorphism::GetTsInit};
 
 use super::kmerge_batch::{EagerStream, ElementBatchIter, KMerge};
 use crate::arrow::{
     DataStreamingError, DecodeDataFromRecordBatch, EncodeToRecordBatch, WriteStream,
 };
 
 #[derive(Debug, Default)]
@@ -37,15 +37,15 @@
 {
     fn compare(
         &self,
         l: &ElementBatchIter<I, Data>,
         r: &ElementBatchIter<I, Data>,
     ) -> std::cmp::Ordering {
         // Max heap ordering must be reversed
-        l.item.get_ts_init().cmp(&r.item.get_ts_init()).reverse()
+        l.item.ts_init().cmp(&r.item.ts_init()).reverse()
     }
 }
 
 pub type QueryResult = KMerge<EagerStream<std::vec::IntoIter<Data>>, Data, TsInitComparator>;
 
 /// Provides a DataFusion session and registers DataFusion queries.
 ///
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/db/database.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/db/database.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/db/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/db/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/db/schema.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/db/schema.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/db/sql.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/db/sql.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/lib.rs` & `nautilus_trader-1.191.0/nautilus_core/accounting/src/account/mod.rs`

 * *Files 7% similar despite different names*

```diff
@@ -9,13 +9,13 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod arrow;
-pub mod backend;
-pub mod db;
+pub mod base;
+pub mod cash;
+pub mod margin;
 
-#[cfg(feature = "python")]
-pub mod python;
+#[cfg(test)]
+pub mod stubs;
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/python/backend/mod.rs` & `nautilus_trader-1.191.0/nautilus_trader/core/data.pxd`

 * *Files 10% similar despite different names*

```diff
@@ -1,17 +1,18 @@
-// -------------------------------------------------------------------------------------------------
-//  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
-//  https://nautechsystems.io
-//
-//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-//  You may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-// -------------------------------------------------------------------------------------------------
+# -------------------------------------------------------------------------------------------------
+#  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
+#  https://nautechsystems.io
+#
+#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+#  You may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+# -------------------------------------------------------------------------------------------------
 
-pub mod session;
-pub mod transformer;
+
+cdef class Data:
+    pass
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/python/backend/session.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/python/backend/session.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/python/backend/transformer.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/python/backend/transformer.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/python/mod.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/python/mod.rs`

 * *Files 22% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+#![allow(warnings)] // non-local `impl` definition, temporary allow until pyo3 upgrade
+
 use pyo3::prelude::*;
 
 pub mod backend;
 pub mod wranglers;
 
 /// Loaded as nautilus_pyo3.persistence
 #[pymodule]
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/python/wranglers/bar.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/python/wranglers/bar.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/python/wranglers/delta.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/python/wranglers/delta.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/python/wranglers/mod.rs` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,19 +1,17 @@
-// -------------------------------------------------------------------------------------------------
-//  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
-//  https://nautechsystems.io
-//
-//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-//  You may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-// -------------------------------------------------------------------------------------------------
-
-pub mod bar;
-pub mod delta;
-pub mod quote;
-pub mod trade;
+# -------------------------------------------------------------------------------------------------
+#  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
+#  https://nautechsystems.io
+#
+#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+#  You may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+# -------------------------------------------------------------------------------------------------
+"""
+Provides an API integration for Interactive Brokers.
+"""
```

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/python/wranglers/quote.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/python/wranglers/quote.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/src/python/wranglers/trade.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/src/python/wranglers/trade.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/tests/test_catalog.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/tests/test_catalog.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/persistence/tests/test_util.rs` & `nautilus_trader-1.191.0/nautilus_core/persistence/tests/test_util.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/pyo3/Cargo.toml` & `nautilus_trader-1.191.0/nautilus_core/pyo3/Cargo.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_core/pyo3/src/lib.rs` & `nautilus_trader-1.191.0/nautilus_core/pyo3/src/lib.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/accounting/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/accounting/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/base.pxd` & `nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/base.pyx` & `nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/base.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/betting.pxd` & `nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/betting.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/betting.pyx` & `nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/betting.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/cash.pxd` & `nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/cash.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/cash.pyx` & `nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/cash.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -145,15 +145,15 @@
 
     cpdef bint is_unleveraged(self, InstrumentId instrument_id):
         return True
 
     cdef void _recalculate_balance(self, Currency currency):
         cdef AccountBalance current_balance = self._balances.get(currency)
         if current_balance is None:
-            # TODO(cs): Temporary pending reimplementation of accounting
+            # TODO: Temporary pending reimplementation of accounting
             print("Cannot recalculate balance when no current balance")
             return
 
         cdef double total_locked = 0.0
 
         cdef Money locked
         for locked in self._balances_locked.values():
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/margin.pxd` & `nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/margin.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/accounts/margin.pyx` & `nautilus_trader-1.191.0/nautilus_trader/accounting/accounts/margin.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -462,15 +462,15 @@
             if margin.currency != currency:
                 continue
             total_margin += margin.initial.as_f64_c()
             total_margin += margin.maintenance.as_f64_c()
 
         cdef double total_free = current_balance.total.as_f64_c() - total_margin
 
-        if total_free <= 0.0:
+        if total_free < 0.0:
             raise AccountMarginExceeded(
                 balance=current_balance.total.as_decimal(),
                 margin=Money(total_margin, currency).as_decimal(),
                 currency=currency,
             )
 
         cdef AccountBalance new_balance = AccountBalance(
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/calculators.pxd` & `nautilus_trader-1.191.0/nautilus_trader/accounting/calculators.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/calculators.pyx` & `nautilus_trader-1.191.0/nautilus_trader/accounting/calculators.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/error.py` & `nautilus_trader-1.191.0/nautilus_trader/accounting/error.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/factory.pxd` & `nautilus_trader-1.191.0/nautilus_trader/accounting/factory.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/factory.pyx` & `nautilus_trader-1.191.0/nautilus_trader/accounting/factory.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/manager.pxd` & `nautilus_trader-1.191.0/nautilus_trader/accounting/manager.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/accounting/manager.pyx` & `nautilus_trader-1.191.0/nautilus_trader/accounting/manager.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -20,16 +20,16 @@
 
 from nautilus_trader.accounting.accounts.base cimport Account
 from nautilus_trader.accounting.accounts.cash cimport CashAccount
 from nautilus_trader.accounting.accounts.margin cimport MarginAccount
 from nautilus_trader.cache.base cimport CacheFacade
 from nautilus_trader.common.component cimport Clock
 from nautilus_trader.common.component cimport Logger
+from nautilus_trader.common.component cimport is_logging_initialized
 from nautilus_trader.core.correctness cimport Condition
-from nautilus_trader.core.rust.common cimport logging_is_initialized
 from nautilus_trader.core.rust.model cimport OrderSide
 from nautilus_trader.core.rust.model cimport PriceType
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.model.identifiers cimport PositionId
 from nautilus_trader.model.instruments.base cimport Instrument
 from nautilus_trader.model.objects cimport AccountBalance
 from nautilus_trader.model.objects cimport Currency
@@ -107,15 +107,15 @@
                 position_id = positions_open[0].id
 
         # Determine any position
         cdef Position position = self._cache.position(position_id)
         # *** position could still be None here ***
 
         cdef list pnls = account.calculate_pnls(instrument, fill, position)
-        if logging_is_initialized():
+        if is_logging_initialized():
             self._log.debug(f"Calculated PnLs: {pnls}")
 
         # Calculate final PnL including commissions
         cdef Money pnl
         if account.base_currency is not None:
             self._update_balance_single_currency(
                 account=account,
@@ -226,15 +226,15 @@
                         side=order.side,
                     )
 
                     if base_xrate == 0.0:
                         self._log.debug(
                             f"Cannot calculate balance locked: "
                             f"insufficient data for "
-                            f"{instrument.get_settlement_currency()}/{account.base_currency}."
+                            f"{instrument.get_settlement_currency()}/{account.base_currency}"
                         )
                         return None  # Cannot calculate
 
                 # Apply base xrate
                 locked = round(locked * base_xrate, currency.get_precision())
 
             # Increment total locked
@@ -314,15 +314,15 @@
                         side=order.side,
                     )
 
                     if base_xrate == 0.0:
                         self._log.debug(
                             f"Cannot calculate initial (order) margin: "
                             f"insufficient data for "
-                            f"{instrument.get_settlement_currency()}/{account.base_currency}."
+                            f"{instrument.get_settlement_currency()}/{account.base_currency}"
                         )
                         return None  # Cannot calculate
 
                 # Apply base xrate
                 margin_init = round(margin_init * base_xrate, currency.get_precision())
 
             # Increment total initial margin
@@ -388,15 +388,15 @@
                 continue
 
             # Calculate margin
             margin_maint = account.calculate_margin_maint(
                 instrument,
                 position.side,
                 position.quantity,
-                instrument.make_price(position.avg_px_open),  # TODO(cs): Temporary pending refactor
+                instrument.make_price(position.avg_px_open),  # TODO: Temporary pending refactor
             ).as_f64_c()
 
             if account.base_currency is not None:
                 if base_xrate == 0.0:
                     # Cache base currency and xrate
                     currency = account.base_currency
                     base_xrate = self._calculate_xrate_to_base(
@@ -405,15 +405,15 @@
                         side=position.entry,
                     )
 
                     if base_xrate == 0.0:
                         self._log.debug(
                             f"Cannot calculate maintenance (position) margin: "
                             f"insufficient data for "
-                            f"{instrument.get_settlement_currency()}/{account.base_currency}."
+                            f"{instrument.get_settlement_currency()}/{account.base_currency}"
                         )
                         return None  # Cannot calculate
 
                 # Apply base xrate
                 margin_maint = round(margin_maint * base_xrate, currency.get_precision())
 
             # Increment total maintenance margin
@@ -448,15 +448,15 @@
                 to_currency=account.base_currency,
                 price_type=PriceType.BID if fill.order_side is OrderSide.SELL else PriceType.ASK,
             )
             if xrate == 0.0:
                 self._log.error(
                     f"Cannot calculate account state: "
                     f"insufficient data for "
-                    f"{fill.commission.currency}/{account.base_currency}."
+                    f"{fill.commission.currency}/{account.base_currency}"
                 )
                 return  # Cannot calculate
 
             # Convert to account base currency
             commission = Money(commission.as_f64_c() * xrate, account.base_currency)
 
         if pnl.currency != account.base_currency:
@@ -466,28 +466,28 @@
                 to_currency=account.base_currency,
                 price_type=PriceType.BID if fill.order_side is OrderSide.SELL else PriceType.ASK,
             )
             if xrate == 0.0:
                 self._log.error(
                     f"Cannot calculate account state: "
                     f"insufficient data for "
-                    f"{pnl.currency}/{account.base_currency}."
+                    f"{pnl.currency}/{account.base_currency}"
                 )
                 return  # Cannot calculate
 
             # Convert to account base currency
             pnl = Money(pnl.as_f64_c() * xrate, account.base_currency)
 
         pnl = pnl.sub(commission)
         if pnl._mem.raw == 0:
             return  # Nothing to adjust
 
         cdef AccountBalance balance = account.balance()
         if balance is None:
-            self._log.error(f"Cannot complete transaction: no balance for {pnl.currency}.")
+            self._log.error(f"Cannot complete transaction: no balance for {pnl.currency}")
             return
 
         # Calculate new balance
         cdef AccountBalance new_balance = AccountBalance(
             total=balance.total.add(pnl),
             locked=balance.locked,
             free=balance.free.add(pnl),
@@ -519,15 +519,15 @@
             currency = pnl.currency
             if commission.currency != currency and commission._mem.raw != 0:
                 balance = account.balance(commission.currency)
                 if balance is None:
                     if commission._mem.raw > 0:
                         self._log.error(
                             f"Cannot complete transaction: no {commission.currency} "
-                            f"balance to deduct a {commission.to_str()} commission from."
+                            f"balance to deduct a {commission.to_str()} commission from"
                         )
                         return
                     else:
                         balance = AccountBalance(
                             total=Money(0, commission.currency),
                             locked=Money(0, commission.currency),
                             free=Money(0, commission.currency),
@@ -542,33 +542,33 @@
                 return  # No adjustment
 
             balance = account.balance(currency)
             if balance is None:
                 if pnl._mem.raw < 0:
                     self._log.error(
                         "Cannot complete transaction: "
-                        f"no {pnl.currency} to deduct a {pnl.to_str()} realized PnL from."
+                        f"no {pnl.currency} to deduct a {pnl.to_str()} realized PnL from"
                     )
                     return
                 new_balance = AccountBalance(
                     total=pnl,
                     locked=Money(0, pnl.currency),
                     free=pnl,
                 )
             else:
                 new_total = balance.total.as_f64_c() + pnl.as_f64_c()
                 new_free = balance.free.as_f64_c() + pnl.as_f64_c()
                 total = Money(new_total, pnl.currency)
                 free = Money(new_free, pnl.currency)
-                if new_total < 0:
+                if new_total < 0.0:
                     raise AccountBalanceNegative(
                         balance=total.as_decimal(),
                         currency=pnl.currency,
                     )
-                if new_free <= 0:
+                if new_free < 0.0:
                     raise AccountMarginExceeded(
                         balance=total.as_decimal(),
                         margin=balance.locked.as_decimal(),
                         currency=pnl.currency,
                     )
 
                 # Calculate new balance
@@ -576,22 +576,22 @@
                     total=total,
                     locked=balance.locked,
                     free=free,
                 )
 
             balances.append(new_balance)
 
-        # TODO(cs): Refactor and consolidate
+        # TODO: Refactor and consolidate
         if not pnls and commission._mem.raw != 0:
             currency = commission.currency
             balance = account.balance(currency)
             if balance is None:
                 self._log.error(
                     "Cannot calculate account state: "
-                    f"no cached balances for {currency}."
+                    f"no cached balances for {currency}"
                 )
                 return
 
             new_balance = AccountBalance(
                 total=Money(balance.total.as_f64_c() - commission.as_f64_c(), currency),
                 locked=balance.locked,
                 free=Money(balance.free.as_f64_c() - commission.as_f64_c(), currency),
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/_template/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/_template/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/_template/core.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/_template/core.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/_template/data.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/_template/data.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/_template/execution.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/_template/execution.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/_template/providers.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/_template/providers.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/client.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/client.py`

 * *Files 1% similar despite different names*

```diff
@@ -71,15 +71,15 @@
     """
 
     def __init__(
         self,
         username: str,
         password: str,
         app_key: str,
-    ):
+    ) -> None:
         # Config
         self.username = username
         self.password = password
         self.app_key = app_key
 
         # Client
         self._client = HttpClient()
@@ -89,15 +89,15 @@
 
     async def _request(self, method: HttpMethod, request: Request) -> HttpResponse:
         url = ENDPOINTS.url_for_request(request)
         headers = self._headers
         body = request.body()
         if isinstance(body, str):
             body = body.encode()
-        self._log.debug(f"[REQ] {method} {url} {body.decode()} ")
+        self._log.debug(f"[REQ] {method} {url} {body.decode()}")
         response: HttpResponse = await self._client.request(
             method,
             url,
             headers=headers,
             body=body,
         )
         if url not in SKIP_LOG_URLS:
@@ -120,41 +120,41 @@
         self._headers.update(
             {
                 "X-Authentication": login_resp.token,
                 "X-Application": login_resp.product,
             },
         )
 
-    def reset_headers(self):
+    def reset_headers(self) -> None:
         self._headers = {
             "Accept": "application/json",
             "Content-Type": "application/x-www-form-urlencoded",
             "User-Agent": nautilus_trader.USER_AGENT,
             "X-Application": self.app_key,
         }
 
-    async def connect(self):
+    async def connect(self) -> None:
         if self.session_token is not None:
-            self._log.warning("Session token exists (already connected), skipping.")
+            self._log.warning("Session token exists (already connected), skipping")
             return
 
         self._log.info("Connecting (Betfair login)")
         request = Login.with_params(username=self.username, password=self.password)
         resp: LoginResponse = await self._post(request)
         if resp.status != LoginStatus.SUCCESS:
             raise RuntimeError(f"Login not successful: {resp.status.value}")
-        self._log.info("Login success.", color=LogColor.GREEN)
+        self._log.info("Login success", color=LogColor.GREEN)
         self.update_headers(login_resp=resp)
 
-    async def disconnect(self):
-        self._log.info("Disconnecting..")
+    async def disconnect(self) -> None:
+        self._log.info("Disconnecting...")
         self.reset_headers()
-        self._log.info("Disconnected.", color=LogColor.GREEN)
+        self._log.info("Disconnected", color=LogColor.GREEN)
 
-    async def keep_alive(self):
+    async def keep_alive(self) -> None:
         """
         Renew authentication.
         """
         resp: KeepAlive.return_type = await self._post(KeepAlive())
         if resp.status == "SUCCESS":
             self.update_headers(resp)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/common.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/common.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/config.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/constants.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/constants.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/data.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/data.py`

 * *Files 1% similar despite different names*

```diff
@@ -103,24 +103,24 @@
     @property
     def instrument_provider(self) -> BetfairInstrumentProvider:
         return self._instrument_provider
 
     async def _connect(self):
         self._log.info("Connecting to BetfairHttpClient...")
         await self._client.connect()
-        self._log.info("BetfairClient login successful.", LogColor.GREEN)
+        self._log.info("BetfairClient login successful", LogColor.GREEN)
 
         # Connect market data socket
         await self._stream.connect()
 
         # Pass any preloaded instruments into the engine
         if self._instrument_provider.count == 0:
             await self._instrument_provider.load_all_async()
         instruments = self._instrument_provider.list_all()
-        self._log.debug(f"Loading {len(instruments)} instruments from provider into cache.")
+        self._log.debug(f"Loading {len(instruments)} instruments from provider into cache")
         for instrument in instruments:
             self._handle_data(instrument)
 
         self._log.debug(
             f"DataEngine has {len(self._cache.instruments(BETFAIR_VENUE))} Betfair instruments",
         )
 
@@ -140,31 +140,31 @@
     async def _post_connect_heartbeat(self):
         for _ in range(3):
             await self._stream.send(msgspec.json.encode({"op": "heartbeat"}))
             await asyncio.sleep(5)
 
     async def _disconnect(self):
         # Close socket
-        self._log.info("Closing streaming socket...")
+        self._log.info("Closing streaming socket")
         await self._stream.disconnect()
 
         # Ensure client closed
-        self._log.info("Closing BetfairClient...")
+        self._log.info("Closing BetfairClient")
         await self._client.disconnect()
 
     def _reset(self):
         if self.is_connected:
-            self._log.error("Cannot reset a connected data client.")
+            self._log.error("Cannot reset a connected data client")
             return
 
         self._subscribed_instrument_ids = set()
 
     def _dispose(self):
         if self.is_connected:
-            self._log.error("Cannot dispose a connected data client.")
+            self._log.error("Cannot dispose a connected data client")
             return
 
     # -- SUBSCRIPTIONS ----------------------------------------------------------------------------
 
     async def _subscribe_order_book_deltas(
         self,
         instrument_id: InstrumentId,
@@ -175,15 +175,15 @@
         PyCondition.not_none(instrument_id, "instrument_id")
 
         instrument: BettingInstrument = self._instrument_provider.find(instrument_id)
 
         if instrument.market_id in self._subscribed_market_ids:
             self._log.warning(
                 f"Already subscribed to market_id: {instrument.market_id} "
-                f"[Instrument: {instrument_id.symbol}] <OrderBook> data.",
+                f"[Instrument: {instrument_id.symbol}] <OrderBook> data",
             )
             return
 
         if self.subscription_status == SubscriptionStatus.SUBSCRIBED:
             self._log.debug("Already subscribed")
             return
 
@@ -197,23 +197,23 @@
             self.subscription_status = SubscriptionStatus.PENDING_STARTUP
         elif self.subscription_status == SubscriptionStatus.PENDING_STARTUP:
             pass
         elif self.subscription_status == SubscriptionStatus.RUNNING:
             self.create_task(self.delayed_subscribe(delay=0))
 
         self._log.info(
-            f"Added market_id {instrument.market_id} for {instrument_id.symbol} <OrderBook> data.",
+            f"Added market_id {instrument.market_id} for {instrument_id.symbol} <OrderBook> data",
         )
 
     async def delayed_subscribe(self, delay=0):
         self._log.debug(f"Scheduling subscribe for delay={delay}")
         await asyncio.sleep(delay)
         self._log.info(f"Sending subscribe for market_ids {self._subscribed_market_ids}")
         await self._stream.send_subscription_message(market_ids=list(self._subscribed_market_ids))
-        self._log.info(f"Added market_ids {self._subscribed_market_ids} for <OrderBook> data.")
+        self._log.info(f"Added market_ids {self._subscribed_market_ids} for <OrderBook> data")
 
     async def _subscribe_ticker(self, instrument_id: InstrumentId) -> None:
         pass  # Subscribed as part of orderbook
 
     async def _subscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:
         pass  # Subscribed as part of orderbook
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/data_types.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/data_types.py`

 * *Files 2% similar despite different names*

```diff
@@ -26,15 +26,15 @@
 from nautilus_trader.model.enums import BookAction
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.objects import Price
 from nautilus_trader.model.objects import Quantity
 from nautilus_trader.serialization.arrow.serializer import make_dict_deserializer
 from nautilus_trader.serialization.arrow.serializer import make_dict_serializer
 from nautilus_trader.serialization.arrow.serializer import register_arrow
-from nautilus_trader.serialization.base import register_serializable_object
+from nautilus_trader.serialization.base import register_serializable_type
 
 
 class SubscriptionStatus(Enum):
     """
     Represents a `Betfair` subscription status.
     """
 
@@ -68,14 +68,16 @@
                     order_id=batch["order_id"].to_pylist()[idx],
                 )
 
             delta = BSPOrderBookDelta(
                 instrument_id=instrument_id,
                 action=action,
                 order=book_order,
+                flags=0,
+                sequence=0,
                 ts_event=batch["ts_event"].to_pylist()[idx],
                 ts_init=batch["ts_init"].to_pylist()[idx],
             )
             data.append(delta)
         return data
 
     @staticmethod
@@ -296,44 +298,44 @@
             "ts_event": self.ts_event,
             "ts_init": self.ts_init,
             "bsp": self.bsp,
         }
 
 
 # Register serialization/parquet BetfairTicker
-register_serializable_object(
+register_serializable_type(
     BetfairTicker,
     BetfairTicker.to_dict,
     BetfairTicker.from_dict,
 )
 
 register_arrow(
     data_cls=BetfairTicker,
     schema=BetfairTicker.schema(),
     encoder=make_dict_serializer(schema=BetfairTicker.schema()),
     decoder=make_dict_deserializer(BetfairTicker),
 )
 
 # Register serialization/parquet BetfairStartingPrice
-register_serializable_object(
+register_serializable_type(
     BetfairStartingPrice,
     BetfairStartingPrice.to_dict,
     BetfairStartingPrice.from_dict,
 )
 
 register_arrow(
     data_cls=BetfairStartingPrice,
     schema=BetfairStartingPrice.schema(),
     encoder=make_dict_serializer(schema=BetfairStartingPrice.schema()),
     decoder=make_dict_deserializer(BetfairStartingPrice),
 )
 
 
 # Register serialization/parquet BSPOrderBookDeltas
-register_serializable_object(
+register_serializable_type(
     BSPOrderBookDelta,
     BSPOrderBookDelta.to_dict,
     BSPOrderBookDelta.from_dict,
 )
 
 register_arrow(
     data_cls=BSPOrderBookDelta,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/execution.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/execution.py`

 * *Files 1% similar despite different names*

```diff
@@ -155,44 +155,44 @@
         return self._instrument_provider
 
     # -- CONNECTION HANDLERS ----------------------------------------------------------------------
 
     async def _connect(self) -> None:
         self._log.info("Connecting to BetfairHttpClient...")
         await self._client.connect()
-        self._log.info("BetfairHttpClient login successful.", LogColor.GREEN)
+        self._log.info("BetfairHttpClient login successful", LogColor.GREEN)
 
         # Start scheduled account state updates
         self.create_task(self.account_state_updates())
 
         # Connections and start-up checks
         aws = [
             self.stream.connect(),
             self.check_account_currency(),
             self.load_venue_id_mapping_from_cache(),
         ]
         await asyncio.gather(*aws)
 
     async def _disconnect(self) -> None:
         # Close socket
-        self._log.info("Closing streaming socket...")
+        self._log.info("Closing streaming socket")
         await self.stream.disconnect()
 
         # Ensure client closed
-        self._log.info("Closing BetfairHttpClient...")
+        self._log.info("Closing BetfairHttpClient")
         await self._client.disconnect()
 
     # -- ERROR HANDLING ---------------------------------------------------------------------------
     async def on_api_exception(self, error: BetfairError) -> None:
         if "INVALID_SESSION_INFORMATION" in error.args[0]:
             # Session is invalid, need to reconnect
-            self._log.warning("Invalid session error, reconnecting..")
+            self._log.warning("Invalid session error, reconnecting...")
             await self._client.disconnect()
             await self._connect()
-            self._log.info("Reconnected.")
+            self._log.info("Reconnected")
 
     # -- ACCOUNT HANDLERS -------------------------------------------------------------------------
 
     async def account_state_updates(self) -> None:
         while True:
             self._log.debug("Requesting account state")
             account_state = await self.request_account_state()
@@ -269,15 +269,15 @@
             instrument_id=instrument.id,
             venue_order_id=venue_order_id,
             client_order_id=self._cache.client_order_id(venue_order_id),
             report_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
         )
 
-        self._log.debug(f"Received {report}.")
+        self._log.debug(f"Received {report}")
         return report
 
     async def generate_order_status_reports(
         self,
         instrument_id: InstrumentId | None = None,
         start: pd.Timestamp | None = None,
         end: pd.Timestamp | None = None,
@@ -349,15 +349,15 @@
 
     async def generate_position_status_reports(
         self,
         instrument_id: InstrumentId | None = None,
         start: pd.Timestamp | None = None,
         end: pd.Timestamp | None = None,
     ) -> list[PositionStatusReport]:
-        self._log.warning("Cannot generate `PositionStatusReports`: not yet implemented.")
+        self._log.warning("Cannot generate `PositionStatusReports`: not yet implemented")
 
         return []
 
     # -- COMMAND HANDLERS -------------------------------------------------------------------------
 
     async def _submit_order(self, command: SubmitOrder) -> None:
         self._log.debug(f"Received submit_order {command}")
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/factories.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/factories.py`

 * *Files 1% similar despite different names*

```diff
@@ -136,15 +136,15 @@
         Create a new Betfair data client.
 
         Parameters
         ----------
         loop : asyncio.AbstractEventLoop
             The event loop for the client.
         name : str
-            The client name.
+            The custom client ID.
         config : dict[str, Any]
             The configuration dictionary.
         msgbus : MessageBus
             The message bus for the client.
         cache : Cache
             The cache for the client.
         clock : LiveClock
@@ -197,15 +197,15 @@
         Create a new Betfair execution client.
 
         Parameters
         ----------
         loop : asyncio.AbstractEventLoop
             The event loop for the client.
         name : str
-            The client name.
+            The custom client ID.
         config : dict[str, Any]
             The configuration for the client.
         msgbus : MessageBus
             The message bus for the client.
         cache : Cache
             The cache for the client.
         clock : LiveClock
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/orderbook.pxd` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/orderbook.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/orderbook.pyx` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/orderbook.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/parsing/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/parsing/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/parsing/common.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/parsing/common.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/parsing/core.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/parsing/core.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/parsing/requests.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/parsing/requests.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/parsing/streaming.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/parsing/streaming.py`

 * *Files 2% similar despite different names*

```diff
@@ -332,42 +332,48 @@
     ), "Incorrect orderbook data found (best) should only be `atb` and `atl`"
 
     deltas: list[OrderBookDelta] = [
         OrderBookDelta(
             instrument_id,
             BookAction.CLEAR,
             NULL_ORDER,
-            ts_event,
-            ts_init,
+            flags=0,
+            sequence=0,
+            ts_event=ts_event,
+            ts_init=ts_init,
         ),
     ]
 
     # Bids are available to back (atb)
     if rc.atb is not None:
         for bid in rc.atb:
             book_order = _price_volume_to_book_order(bid, OrderSide.BUY)
             delta = OrderBookDelta(
                 instrument_id,
                 BookAction.UPDATE if bid.volume > 0.0 else BookAction.DELETE,
                 book_order,
-                ts_event,
-                ts_init,
+                flags=0,
+                sequence=0,
+                ts_event=ts_event,
+                ts_init=ts_init,
             )
             deltas.append(delta)
 
     # Asks are available to back (atl)
     if rc.atl is not None:
         for ask in rc.atl:
             book_order = _price_volume_to_book_order(ask, OrderSide.SELL)
             delta = OrderBookDelta(
                 instrument_id,
                 BookAction.UPDATE if ask.volume > 0.0 else BookAction.DELETE,
                 book_order,
-                ts_event,
-                ts_init,
+                flags=0,
+                sequence=0,
+                ts_event=ts_event,
+                ts_init=ts_init,
             )
             deltas.append(delta)
 
     return OrderBookDeltas(instrument_id, deltas)
 
 
 def runner_change_to_trade_ticks(
@@ -424,30 +430,34 @@
     if rc.atb is not None:
         for bid in rc.atb:
             book_order = _price_volume_to_book_order(bid, OrderSide.BUY)
             delta = OrderBookDelta(
                 instrument_id,
                 BookAction.UPDATE if bid.volume > 0.0 else BookAction.DELETE,
                 book_order,
-                ts_event,
-                ts_init,
+                flags=0,
+                sequence=0,
+                ts_event=ts_event,
+                ts_init=ts_init,
             )
             deltas.append(delta)
 
     # Asks are available to back (atl)
     if rc.atl is not None:
         for ask in rc.atl:
             book_order = _price_volume_to_book_order(ask, OrderSide.SELL)
 
             delta = OrderBookDelta(
                 instrument_id,
                 BookAction.UPDATE if ask.volume > 0.0 else BookAction.DELETE,
                 book_order,
-                ts_event,
-                ts_init,
+                flags=0,
+                sequence=0,
+                ts_event=ts_event,
+                ts_init=ts_init,
             )
             deltas.append(delta)
 
     if not deltas:
         return None
 
     return OrderBookDeltas(instrument_id, deltas)
@@ -498,28 +508,32 @@
     if rc.spb is not None:
         for spb in rc.spb:
             book_order = _price_volume_to_book_order(spb, OrderSide.SELL)
             delta = BSPOrderBookDelta(
                 instrument_id,
                 BookAction.DELETE if spb.volume == 0.0 else BookAction.UPDATE,
                 book_order,
-                ts_event,
-                ts_init,
+                flags=0,
+                sequence=0,
+                ts_event=ts_event,
+                ts_init=ts_init,
             )
             deltas.append(delta)
 
     if rc.spl is not None:
         for spl in rc.spl:
             book_order = _price_volume_to_book_order(spl, OrderSide.BUY)
             delta = BSPOrderBookDelta(
                 instrument_id,
                 BookAction.DELETE if spl.volume == 0.0 else BookAction.UPDATE,
                 book_order,
-                ts_event,
-                ts_init,
+                flags=0,
+                sequence=0,
+                ts_event=ts_event,
+                ts_init=ts_init,
             )
             deltas.append(delta)
 
     return [
         CustomData(DataType(BSPOrderBookDelta, {"instrument_id": instrument_id}), delta)
         for delta in deltas
     ]
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/providers.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/providers.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/betfair/sockets.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/betfair/sockets.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/constants.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/constants.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/data.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/data.py`

 * *Files 2% similar despite different names*

```diff
@@ -27,15 +27,15 @@
 from nautilus_trader.adapters.binance.common.enums import BinanceKlineInterval
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceAggregatedTradeMsg
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceCandlestickMsg
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceDataMsgWrapper
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceOrderBookMsg
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceQuoteMsg
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceTickerMsg
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.common.types import BinanceBar
 from nautilus_trader.adapters.binance.common.types import BinanceTicker
 from nautilus_trader.adapters.binance.config import BinanceDataClientConfig
 from nautilus_trader.adapters.binance.futures.types import BinanceFuturesMarkPriceUpdate
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.http.error import BinanceError
 from nautilus_trader.adapters.binance.http.market import BinanceMarketHttpAPI
@@ -80,31 +80,33 @@
     Provides a data client of common methods for the `Binance` exchange.
 
     Parameters
     ----------
     loop : asyncio.AbstractEventLoop
         The event loop for the client.
     client : BinanceHttpClient
-        The binance HTTP client.
+        The Binance HTTP client.
     market : BinanceMarketHttpAPI
-        The binance Market HTTP API.
+        The Binance Market HTTP API.
     enum_parser : BinanceEnumParser
         The parser for Binance enums.
     msgbus : MessageBus
         The message bus for the client.
     cache : Cache
         The cache for the client.
     clock : LiveClock
         The clock for the client.
     instrument_provider : InstrumentProvider
         The instrument provider.
     account_type : BinanceAccountType
         The account type for the client.
     base_url_ws : str
-        The base URL for the WebSocket client.
+        The base url for the WebSocket client.
+    name : str, optional
+        The custom client ID.
     config : BinanceDataClientConfig
         The configuration for the client.
 
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
 
@@ -118,30 +120,31 @@
         enum_parser: BinanceEnumParser,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         instrument_provider: InstrumentProvider,
         account_type: BinanceAccountType,
         base_url_ws: str,
+        name: str | None,
         config: BinanceDataClientConfig,
     ) -> None:
         super().__init__(
             loop=loop,
-            client_id=ClientId(BINANCE_VENUE.value),
+            client_id=ClientId(name or BINANCE_VENUE.value),
             venue=BINANCE_VENUE,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             instrument_provider=instrument_provider,
         )
 
         # Configuration
         self._binance_account_type = account_type
         self._use_agg_trade_ticks = config.use_agg_trade_ticks
-        self._log.info(f"Account type: {self._binance_account_type.value}.", LogColor.BLUE)
+        self._log.info(f"Account type: {self._binance_account_type.value}", LogColor.BLUE)
         self._log.info(f"{config.use_agg_trade_ticks=}", LogColor.BLUE)
 
         self._update_instrument_interval: int = 60 * 60  # Once per hour (hardcode)
         self._update_instruments_task: asyncio.Task | None = None
 
         self._connect_websockets_delay: float = 0.0  # Delay for bulk subscriptions to come in
         self._connect_websockets_task: asyncio.Task | None = None
@@ -166,16 +169,16 @@
         self._instrument_ids: dict[str, InstrumentId] = {}
         self._book_depths: dict[InstrumentId, int | None] = {}
         self._book_buffer: dict[
             InstrumentId,
             list[OrderBookDelta | OrderBookDeltas],
         ] = {}
 
-        self._log.info(f"Base URL HTTP {self._http_client.base_url}.", LogColor.BLUE)
-        self._log.info(f"Base URL WebSocket {base_url_ws}.", LogColor.BLUE)
+        self._log.info(f"Base url HTTP {self._http_client.base_url}", LogColor.BLUE)
+        self._log.info(f"Base url WebSocket {base_url_ws}", LogColor.BLUE)
 
         # Register common WebSocket message handlers
         self._ws_handlers = {
             "@bookTicker": self._handle_book_ticker,
             "@ticker": self._handle_ticker,
             "@kline": self._handle_kline,
             "@trade": self._handle_trade,
@@ -216,15 +219,15 @@
     async def _update_instruments(self) -> None:
         while True:
             retries = 0
             while True:
                 try:
                     self._log.debug(
                         f"Scheduled `update_instruments` to run in "
-                        f"{self._update_instrument_interval}s.",
+                        f"{self._update_instrument_interval}s",
                     )
                     await asyncio.sleep(self._update_instrument_interval)
                     await self._instrument_provider.load_all_async()
                     self._send_all_instruments_to_data_engine()
                     break
                 except BinanceError as e:
                     error_code = BinanceErrorCode(e.message["code"])
@@ -232,32 +235,32 @@
 
                     if not self._should_retry(error_code, retries):
                         self._log.error(f"Error updating instruments: {e}")
                         break
 
                     self._log.warning(
                         f"{error_code.name}: retrying update instruments "
-                        f"{retries}/{self._max_retries} in {self._retry_delay}s ...",
+                        f"{retries}/{self._max_retries} in {self._retry_delay}s",
                     )
                     await asyncio.sleep(self._retry_delay)
                 except asyncio.CancelledError:
-                    self._log.debug("Canceled `update_instruments` task.")
+                    self._log.debug("Canceled `update_instruments` task")
                     return
 
     async def _reconnect(self) -> None:
         coros = []
         for instrument_id in self._book_depths:
             coros.append(self._order_book_snapshot_then_deltas(instrument_id))
 
         await asyncio.gather(*coros)
 
     async def _disconnect(self) -> None:
         # Cancel update instruments task
         if self._update_instruments_task:
-            self._log.debug("Canceling `update_instruments` task...")
+            self._log.debug("Canceling `update_instruments` task")
             self._update_instruments_task.cancel()
             self._update_instruments_task = None
 
         await self._ws_client.disconnect()
 
     def _should_retry(self, error_code: BinanceErrorCode, retries: int) -> bool:
         if (
@@ -270,53 +273,53 @@
 
     # -- SUBSCRIPTIONS ----------------------------------------------------------------------------
 
     async def _subscribe(self, data_type: DataType) -> None:
         instrument_id: InstrumentId | None = data_type.metadata.get("instrument_id")
         if instrument_id is None:
             self._log.error(
-                f"Cannot subscribe to `{data_type.type}` no instrument ID in `data_type` metadata.",
+                f"Cannot subscribe to `{data_type.type}` no instrument ID in `data_type` metadata",
             )
             return
 
         if data_type.type == BinanceTicker:
             await self._ws_client.subscribe_ticker(instrument_id.symbol.value)
         elif data_type.type == BinanceFuturesMarkPriceUpdate:
             if not self._binance_account_type.is_futures:
                 self._log.error(
                     f"Cannot subscribe to `BinanceFuturesMarkPriceUpdate` "
-                    f"for {self._binance_account_type.value} account types.",
+                    f"for {self._binance_account_type.value} account types",
                 )
                 return
             await self._ws_client.subscribe_mark_price(instrument_id.symbol.value, speed=1000)
         else:
             self._log.error(
-                f"Cannot subscribe to {data_type.type} (not implemented).",
+                f"Cannot subscribe to {data_type.type} (not implemented)",
             )
 
     async def _unsubscribe(self, data_type: DataType) -> None:
         instrument_id: InstrumentId | None = data_type.metadata.get("instrument_id")
         if instrument_id is None:
             self._log.error(
-                "Cannot subscribe to `BinanceFuturesMarkPriceUpdate` no instrument ID in `data_type` metadata.",
+                "Cannot subscribe to `BinanceFuturesMarkPriceUpdate` no instrument ID in `data_type` metadata",
             )
             return
 
         if data_type.type == BinanceTicker:
             await self._ws_client.unsubscribe_ticker(instrument_id.symbol.value)
         elif data_type.type == BinanceFuturesMarkPriceUpdate:
             if not self._binance_account_type.is_futures:
                 self._log.error(
                     "Cannot unsubscribe from `BinanceFuturesMarkPriceUpdate` "
-                    f"for {self._binance_account_type.value} account types.",
+                    f"for {self._binance_account_type.value} account types",
                 )
                 return
         else:
             self._log.error(
-                f"Cannot unsubscribe from {data_type.type} (not implemented).",
+                f"Cannot unsubscribe from {data_type.type} (not implemented)",
             )
 
     async def _subscribe_instruments(self) -> None:
         pass  # Do nothing further
 
     async def _subscribe_instrument(self, instrument_id: InstrumentId) -> None:
         pass  # Do nothing further
@@ -362,43 +365,43 @@
         update_speed: int | None = None,
         depth: int | None = None,
     ) -> None:
         if book_type == BookType.L3_MBO:
             self._log.error(
                 "Cannot subscribe to order book deltas: "
                 "L3_MBO data is not published by Binance. "
-                "Valid book types are L1_MBP, L2_MBP.",
+                "Valid book types are L1_MBP, L2_MBP",
             )
             return
 
         valid_speeds = [100, 1000]
         if self._binance_account_type.is_futures:
             if update_speed is None:
                 update_speed = 0  # Default 0 ms for futures
             valid_speeds = [0, 100, 250, 500]  # 0ms option for futures exists but not documented?
         elif update_speed is None:
             update_speed = 100  # Default 100ms for spot
         if update_speed not in valid_speeds:
             self._log.error(
                 "Cannot subscribe to order book:"
                 f"invalid `update_speed`, was {update_speed}. "
-                f"Valid update speeds are {valid_speeds} ms.",
+                f"Valid update speeds are {valid_speeds} ms",
             )
             return
 
         if not depth:
             # Reasonable default for full book, which works for Spot and Futures
             depth = 1000
 
         if 0 < depth <= 20:
             if depth not in (5, 10, 20):
                 self._log.error(
                     "Cannot subscribe to order book snapshots: "
                     f"invalid `depth`, was {depth}. "
-                    "Valid depths are 5, 10 or 20.",
+                    "Valid depths are 5, 10 or 20",
                 )
                 return
             await self._ws_client.subscribe_partial_book_depth(
                 symbol=instrument_id.symbol.value,
                 depth=depth,
                 speed=update_speed,
             )
@@ -451,29 +454,29 @@
             await self._ws_client.subscribe_trades(instrument_id.symbol.value)
 
     async def _subscribe_bars(self, bar_type: BarType) -> None:
         PyCondition.true(bar_type.is_externally_aggregated(), "aggregation_source is not EXTERNAL")
 
         if not bar_type.spec.is_time_aggregated():
             self._log.error(
-                f"Cannot subscribe to {bar_type}: only time bars are aggregated by Binance.",
+                f"Cannot subscribe to {bar_type}: only time bars are aggregated by Binance",
             )
             return
 
         resolution = self._enum_parser.parse_nautilus_bar_aggregation(bar_type.spec.aggregation)
         if self._binance_account_type.is_futures and resolution == "s":
             self._log.error(
                 f"Cannot subscribe to {bar_type}. "
-                "Second interval bars are not aggregated by Binance Futures.",
+                "Second interval bars are not aggregated by Binance Futures",
             )
         try:
             interval = BinanceKlineInterval(f"{bar_type.spec.step}{resolution}")
         except ValueError:
             self._log.error(
-                f"Bar interval {bar_type.spec.step}{resolution} not supported by Binance.",
+                f"Bar interval {bar_type.spec.step}{resolution} not supported by Binance",
             )
             return
 
         await self._ws_client.subscribe_bars(
             symbol=bar_type.instrument_id.symbol.value,
             interval=interval.value,
         )
@@ -495,29 +498,29 @@
 
     async def _unsubscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:
         await self._ws_client.unsubscribe_trades(instrument_id.symbol.value)
 
     async def _unsubscribe_bars(self, bar_type: BarType) -> None:
         if not bar_type.spec.is_time_aggregated():
             self._log.error(
-                f"Cannot unsubscribe from {bar_type}: only time bars are aggregated by Binance.",
+                f"Cannot unsubscribe from {bar_type}: only time bars are aggregated by Binance",
             )
             return
 
         resolution = self._enum_parser.parse_nautilus_bar_aggregation(bar_type.spec.aggregation)
         if self._binance_account_type.is_futures and resolution == "s":
             self._log.error(
                 f"Cannot unsubscribe from {bar_type}. "
-                "Second interval bars are not aggregated by Binance Futures.",
+                "Second interval bars are not aggregated by Binance Futures",
             )
         try:
             interval = BinanceKlineInterval(f"{bar_type.spec.step}{resolution}")
         except ValueError:
             self._log.error(
-                f"Bar interval {bar_type.spec.step}{resolution} not supported by Binance.",
+                f"Bar interval {bar_type.spec.step}{resolution} not supported by Binance",
             )
             return
 
         await self._ws_client.unsubscribe_bars(
             symbol=bar_type.instrument_id.symbol.value,
             interval=interval.value,
         )
@@ -529,25 +532,25 @@
         instrument_id: InstrumentId,
         correlation_id: UUID4,
         start: pd.Timestamp | None = None,
         end: pd.Timestamp | None = None,
     ) -> None:
         if start is not None:
             self._log.warning(
-                f"Requesting instrument {instrument_id} with specified `start` which has no effect.",
+                f"Requesting instrument {instrument_id} with specified `start` which has no effect",
             )
 
         if end is not None:
             self._log.warning(
-                f"Requesting instrument {instrument_id} with specified `end` which has no effect.",
+                f"Requesting instrument {instrument_id} with specified `end` which has no effect",
             )
 
         instrument: Instrument | None = self._instrument_provider.find(instrument_id)
         if instrument is None:
-            self._log.error(f"Cannot find instrument for {instrument_id}.")
+            self._log.error(f"Cannot find instrument for {instrument_id}")
             return
 
         data_type = DataType(
             type=Instrument,
             metadata={"instrument_id": instrument_id},
         )
 
@@ -562,15 +565,15 @@
         instrument_id: InstrumentId,
         limit: int,
         correlation_id: UUID4,
         start: pd.Timestamp | None = None,
         end: pd.Timestamp | None = None,
     ) -> None:
         self._log.error(
-            "Cannot request historical quote ticks: not published by Binance.",
+            "Cannot request historical quote ticks: not published by Binance",
         )
 
     async def _request_trade_ticks(
         self,
         instrument_id: InstrumentId,
         limit: int,
         correlation_id: UUID4,
@@ -581,15 +584,15 @@
             limit = 1000
 
         if not self._use_agg_trade_ticks:
             if start is not None or end is not None:
                 self._log.warning(
                     "Trade ticks have been requested with a from/to time range, "
                     f"however the request will be for the most recent {limit}. "
-                    "Consider using aggregated trade ticks (`use_agg_trade_ticks`).",
+                    "Consider using aggregated trade ticks (`use_agg_trade_ticks`)",
                 )
             ticks = await self._http_market.request_trade_ticks(
                 instrument_id=instrument_id,
                 limit=limit,
                 ts_init=self._clock.timestamp_ns(),
             )
         else:
@@ -617,60 +620,60 @@
         correlation_id: UUID4,
         start: pd.Timestamp | None = None,
         end: pd.Timestamp | None = None,
     ) -> None:
         if bar_type.spec.price_type != PriceType.LAST:
             self._log.error(
                 f"Cannot request {bar_type}: "
-                f"only historical bars for LAST price type available from Binance.",
+                f"only historical bars for LAST price type available from Binance",
             )
             return
 
         start_time_ms = None
         if start is not None:
             start_time_ms = secs_to_millis(start.timestamp())
 
         end_time_ms = None
         if end is not None:
             end_time_ms = secs_to_millis(end.timestamp())
 
         if bar_type.is_externally_aggregated() or bar_type.spec.is_time_aggregated():
             if not bar_type.spec.is_time_aggregated():
                 self._log.error(
-                    f"Cannot request {bar_type}: only time bars are aggregated by Binance.",
+                    f"Cannot request {bar_type}: only time bars are aggregated by Binance",
                 )
                 return
 
             resolution = self._enum_parser.parse_nautilus_bar_aggregation(bar_type.spec.aggregation)
             if not self._binance_account_type.is_spot_or_margin and resolution == "s":
                 self._log.error(
                     f"Cannot request {bar_type}: "
-                    "second interval bars are not aggregated by Binance Futures.",
+                    "second interval bars are not aggregated by Binance Futures",
                 )
             try:
                 interval = BinanceKlineInterval(f"{bar_type.spec.step}{resolution}")
             except ValueError:
                 self._log.error(
                     f"Cannot create Binance Kline interval. {bar_type.spec.step}{resolution} "
-                    "not supported.",
+                    "not supported",
                 )
                 return
 
             bars = await self._http_market.request_binance_bars(
                 bar_type=bar_type,
                 interval=interval,
                 start_time=start_time_ms,
                 end_time=end_time_ms,
                 limit=limit if limit > 0 else None,
                 ts_init=self._clock.timestamp_ns(),
             )
 
             if bar_type.is_internally_aggregated():
                 self._log.info(
-                    "Inferred INTERNAL time bars from EXTERNAL time bars.",
+                    "Inferred INTERNAL time bars from EXTERNAL time bars",
                     LogColor.BLUE,
                 )
         else:
             if start and start < self._clock.utc_now() - pd.Timedelta(days=1):
                 bars = await self._aggregate_internal_from_minute_bars(
                     bar_type=bar_type,
                     start_time_ms=start_time_ms,
@@ -694,15 +697,15 @@
         start_time_ms: int | None,
         end_time_ms: int | None,
         limit: int | None,
     ) -> list[Bar]:
         instrument = self._instrument_provider.find(bar_type.instrument_id)
         if instrument is None:
             self._log.error(
-                f"Cannot aggregate internal bars: instrument {bar_type.instrument_id} not found.",
+                f"Cannot aggregate internal bars: instrument {bar_type.instrument_id} not found",
             )
             return []
 
         self._log.info("Requesting 1-MINUTE Binance bars to infer INTERNAL bars...", LogColor.BLUE)
 
         binance_bars = await self._http_market.request_binance_bars(
             bar_type=BarType(
@@ -752,15 +755,15 @@
                 instrument=instrument,
                 aggregator=aggregator,
                 binance_bar=binance_bar,
                 quantize_value=quantize_value,
             )
 
         self._log.info(
-            f"Inferred {len(bars)} {bar_type} bars aggregated from {len(binance_bars)} 1-MINUTE Binance bars.",
+            f"Inferred {len(bars)} {bar_type} bars aggregated from {len(binance_bars)} 1-MINUTE Binance bars",
             LogColor.BLUE,
         )
 
         if limit:
             bars = bars[:limit]
         return bars
 
@@ -836,15 +839,15 @@
         start_time_ms: int | None,
         end_time_ms: int | None,
         limit: int | None,
     ) -> list[Bar]:
         instrument = self._instrument_provider.find(bar_type.instrument_id)
         if instrument is None:
             self._log.error(
-                f"Cannot aggregate internal bars: instrument {bar_type.instrument_id} not found.",
+                f"Cannot aggregate internal bars: instrument {bar_type.instrument_id} not found",
             )
             return []
 
         self._log.info("Requesting aggregated trade ticks to infer INTERNAL bars...", LogColor.BLUE)
 
         ticks = await self._http_market.request_agg_trade_ticks(
             instrument_id=instrument.id,
@@ -880,15 +883,15 @@
                 f"not supported in open-source",  # pragma: no cover (design-time error)
             )
 
         for tick in ticks:
             aggregator.handle_trade_tick(tick)
 
         self._log.info(
-            f"Inferred {len(bars)} {bar_type} bars aggregated from {len(ticks)} trade ticks.",
+            f"Inferred {len(bars)} {bar_type} bars aggregated from {len(ticks)} trade ticks",
             LogColor.BLUE,
         )
 
         if limit:
             bars = bars[:limit]
         return bars
 
@@ -898,28 +901,27 @@
 
         for currency in self._instrument_provider.currencies().values():
             self._cache.add_currency(currency)
 
     def _get_cached_instrument_id(self, symbol: str) -> InstrumentId:
         # Parse instrument ID
         binance_symbol = BinanceSymbol(symbol)
-        assert binance_symbol
         nautilus_symbol: str = binance_symbol.parse_as_nautilus(
             self._binance_account_type,
         )
         instrument_id: InstrumentId | None = self._instrument_ids.get(nautilus_symbol)
         if not instrument_id:
             instrument_id = InstrumentId(Symbol(nautilus_symbol), BINANCE_VENUE)
             self._instrument_ids[nautilus_symbol] = instrument_id
         return instrument_id
 
     # -- WEBSOCKET HANDLERS ---------------------------------------------------------------------------------
 
     def _handle_ws_message(self, raw: bytes) -> None:
-        # TODO(cs): Uncomment for development
+        # TODO: Uncomment for development
         # self._log.info(str(raw), LogColor.CYAN)
         wrapper = self._decoder_data_msg_wrapper.decode(raw)
         if not wrapper.stream:
             # Control message response
             return
         try:
             handled = False
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/enums.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/enums.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/execution.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/execution.py`

 * *Files 2% similar despite different names*

```diff
@@ -21,16 +21,16 @@
 from nautilus_trader.adapters.binance.common.constants import BINANCE_VENUE
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.adapters.binance.common.enums import BinanceEnumParser
 from nautilus_trader.adapters.binance.common.enums import BinanceErrorCode
 from nautilus_trader.adapters.binance.common.enums import BinanceTimeInForce
 from nautilus_trader.adapters.binance.common.schemas.account import BinanceOrder
 from nautilus_trader.adapters.binance.common.schemas.account import BinanceUserTrade
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.common.schemas.user import BinanceListenKey
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.config import BinanceExecClientConfig
 from nautilus_trader.adapters.binance.http.account import BinanceAccountHttpAPI
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.http.error import BinanceClientError
 from nautilus_trader.adapters.binance.http.error import BinanceError
 from nautilus_trader.adapters.binance.http.market import BinanceMarketHttpAPI
 from nautilus_trader.adapters.binance.http.user import BinanceUserDataHttpAPI
@@ -104,14 +104,16 @@
         The clock for the client.
     instrument_provider : BinanceSpotInstrumentProvider
         The instrument provider.
     account_type : BinanceAccountType
         The account type for the client.
     base_url_ws : str
         The base URL for the WebSocket client.
+    name : str, optional
+        The custom client ID.
     config : BinanceExecClientConfig
         The configuration for the client.
 
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
 
@@ -127,44 +129,47 @@
         enum_parser: BinanceEnumParser,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         instrument_provider: InstrumentProvider,
         account_type: BinanceAccountType,
         base_url_ws: str,
+        name: str | None,
         config: BinanceExecClientConfig,
     ) -> None:
         super().__init__(
             loop=loop,
-            client_id=ClientId(BINANCE_VENUE.value),
+            client_id=ClientId(name or BINANCE_VENUE.value),
             venue=BINANCE_VENUE,
             oms_type=OmsType.HEDGING if account_type.is_futures else OmsType.NETTING,
             instrument_provider=instrument_provider,
             account_type=AccountType.CASH if account_type.is_spot else AccountType.MARGIN,
             base_currency=None,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
         )
 
         # Configuration
-        self._binance_account_type = account_type
-        self._use_gtd = config.use_gtd
-        self._use_reduce_only = config.use_reduce_only
-        self._use_position_ids = config.use_position_ids
-        self._treat_expired_as_canceled = config.treat_expired_as_canceled
-        self._log.info(f"Account type: {self._binance_account_type.value}.", LogColor.BLUE)
+        self._binance_account_type: BinanceAccountType = account_type
+        self._use_gtd: bool = config.use_gtd
+        self._use_reduce_only: bool = config.use_reduce_only
+        self._use_position_ids: bool = config.use_position_ids
+        self._treat_expired_as_canceled: bool = config.treat_expired_as_canceled
+        self._max_retries: int = config.max_retries or 0
+        self._retry_delay: float = config.retry_delay or 1.0
+        self._log.info(f"Account type: {self._binance_account_type.value}", LogColor.BLUE)
         self._log.info(f"{config.use_gtd=}", LogColor.BLUE)
         self._log.info(f"{config.use_reduce_only=}", LogColor.BLUE)
         self._log.info(f"{config.use_position_ids=}", LogColor.BLUE)
         self._log.info(f"{config.treat_expired_as_canceled=}", LogColor.BLUE)
         self._log.info(f"{config.max_retries=}", LogColor.BLUE)
         self._log.info(f"{config.retry_delay=}", LogColor.BLUE)
 
-        self._set_account_id(AccountId(f"{BINANCE_VENUE.value}-spot-master"))
+        self._set_account_id(AccountId(f"{name or BINANCE_VENUE.value}-spot-master"))
 
         # Enum parser
         self._enum_parser = enum_parser
 
         # Http API
         self._http_client = client
         self._http_account = account
@@ -181,49 +186,46 @@
             clock=clock,
             handler=self._handle_user_ws_message,
             handler_reconnect=None,
             base_url=base_url_ws,
             loop=self._loop,
         )
 
-        # Hot caches
-        self._instrument_ids: dict[str, InstrumentId] = {}
-        self._generate_order_status_retries: dict[ClientOrderId, int] = {}
-        self._modifying_orders: dict[ClientOrderId, VenueOrderId] = {}
-
         # Order submission method hashmap
         self._submit_order_method = {
             OrderType.MARKET: self._submit_market_order,
             OrderType.LIMIT: self._submit_limit_order,
             OrderType.STOP_LIMIT: self._submit_stop_limit_order,
             OrderType.LIMIT_IF_TOUCHED: self._submit_stop_limit_order,
             OrderType.STOP_MARKET: self._submit_stop_market_order,
             OrderType.MARKET_IF_TOUCHED: self._submit_stop_market_order,
             OrderType.TRAILING_STOP_MARKET: self._submit_trailing_stop_market_order,
         }
 
-        self._recv_window = 5_000
-
         # Retry logic (hard coded for now)
-        self._max_retries: int = config.max_retries or 0
-        self._retry_delay: float = config.retry_delay or 1.0
         self._retry_errors: set[BinanceErrorCode] = {
             BinanceErrorCode.DISCONNECTED,
             BinanceErrorCode.TOO_MANY_REQUESTS,  # Short retry delays may result in bans
             BinanceErrorCode.TIMEOUT,
             BinanceErrorCode.SERVER_BUSY,
             BinanceErrorCode.INVALID_TIMESTAMP,
             BinanceErrorCode.CANCEL_REJECTED,
             BinanceErrorCode.ME_RECVWINDOW_REJECT,
         }
 
+        self._recv_window = 5_000
+
+        # Hot caches
+        self._instrument_ids: dict[str, InstrumentId] = {}
+        self._generate_order_status_retries: dict[ClientOrderId, int] = {}
+        self._modifying_orders: dict[ClientOrderId, VenueOrderId] = {}
         self._order_retries: dict[ClientOrderId, int] = {}
 
-        self._log.info(f"Base URL HTTP {self._http_client.base_url}.", LogColor.BLUE)
-        self._log.info(f"Base URL WebSocket {base_url_ws}.", LogColor.BLUE)
+        self._log.info(f"Base url HTTP {self._http_client.base_url}", LogColor.BLUE)
+        self._log.info(f"Base url WebSocket {base_url_ws}", LogColor.BLUE)
 
     @property
     def use_position_ids(self) -> bool:
         """
         Whether a `position_id` will be assigned to order events generated by the
         client.
 
@@ -258,18 +260,18 @@
             response: BinanceListenKey = await self._http_user.create_listen_key()
         except BinanceError as e:
             self._log.exception(f"Error on connect: {e.message}", e)
             return
 
         # Check Binance-Nautilus clock sync
         server_time: int = await self._http_market.request_server_time()
-        self._log.info(f"Binance server time {server_time} UNIX (ms).")
+        self._log.info(f"Binance server time {server_time} UNIX (ms)")
 
         nautilus_time: int = self._clock.timestamp_ms()
-        self._log.info(f"Nautilus clock time {nautilus_time} UNIX (ms).")
+        self._log.info(f"Nautilus clock time {nautilus_time} UNIX (ms)")
 
         # Setup WebSocket listen key
         self._listen_key = response.listenKey
         self._log.info(f"Listen key {self._listen_key}")
         self._ping_listen_keys_task = self.create_task(self._ping_listen_keys())
 
         # Connect WebSocket client
@@ -287,17 +289,17 @@
                     f"{self._ping_listen_keys_interval}s",
                 )
                 await asyncio.sleep(self._ping_listen_keys_interval)
                 if self._listen_key:
                     self._log.debug(f"Pinging WebSocket listen key {self._listen_key}")
                     try:
                         await self._http_user.keepalive_listen_key(listen_key=self._listen_key)
-                    except BinanceClientError as ex:
+                    except BinanceClientError as e:
                         # We may see this if an old listen key was used for the ping
-                        self._log.error(f"Error pinging listen key: {ex}")
+                        self._log.error(f"Error pinging listen key: {e}")
         except asyncio.CancelledError:
             self._log.debug("Canceled `ping_listen_keys` task")
 
     async def _disconnect(self) -> None:
         # Cancel tasks
         if self._ping_listen_keys_task:
             self._log.debug("Canceling `ping_listen_keys` task")
@@ -320,22 +322,22 @@
         )
 
         retries = self._generate_order_status_retries.get(client_order_id, 0)
         if retries > 3:
             self._log.error(
                 f"Reached maximum retries 3/3 for generating OrderStatusReport for "
                 f"{repr(client_order_id) if client_order_id else ''} "
-                f"{repr(venue_order_id) if venue_order_id else ''}...",
+                f"{repr(venue_order_id) if venue_order_id else ''}",
             )
             return None
 
         self._log.info(
             f"Generating OrderStatusReport for "
             f"{repr(client_order_id) if client_order_id else ''} "
-            f"{repr(venue_order_id) if venue_order_id else ''}...",
+            f"{repr(venue_order_id) if venue_order_id else ''}",
         )
 
         try:
             if venue_order_id:
                 binance_order = await self._http_account.query_order(
                     symbol=instrument_id.symbol.value,
                     order_id=int(venue_order_id.value),
@@ -350,19 +352,19 @@
         except BinanceError as e:
             retries += 1
             self._log.error(
                 f"Cannot generate order status report for {client_order_id!r}: {e.message}. Retry {retries}/3",
             )
             self._generate_order_status_retries[client_order_id] = retries
             if not client_order_id:
-                self._log.warning("Cannot retry without a client order ID.")
+                self._log.warning("Cannot retry without a client order ID")
             else:
                 order: Order | None = self._cache.order(client_order_id)
                 if order is None:
-                    self._log.warning("Order not found in cache.")
+                    self._log.warning("Order not found in cache")
                     return None
                 elif order.is_closed:
                     return None  # Nothing else to do
 
                 if retries >= 3:
                     # Order will no longer be considered in-flight once this event is applied.
                     # We could pop the value out of the hashmap here, but better to leave it in
@@ -376,28 +378,28 @@
                     )
             return None  # Error now handled
 
         if not binance_order or (binance_order.origQty and Decimal(binance_order.origQty) == 0):
             # Cannot proceed to generating report
             self._log.error(
                 f"Cannot generate `OrderStatusReport` for {client_order_id=!r}, {venue_order_id=!r}: "
-                "order not found.",
+                "order not found",
             )
             return None
 
         report: OrderStatusReport = binance_order.parse_to_order_status_report(
             account_id=self.account_id,
             instrument_id=self._get_cached_instrument_id(binance_order.symbol),
             report_id=UUID4(),
             enum_parser=self._enum_parser,
             treat_expired_as_canceled=self._treat_expired_as_canceled,
             ts_init=self._clock.timestamp_ns(),
         )
 
-        self._log.debug(f"Received {report}.")
+        self._log.debug(f"Received {report}")
         return report
 
     def _get_cache_active_symbols(self) -> set[str]:
         # Check cache for all active symbols
         open_orders: list[Order] = self._cache.orders_open(venue=self.venue)
         open_positions: list[Position] = self._cache.positions_open(venue=self.venue)
         active_symbols: set[str] = set()
@@ -466,20 +468,20 @@
                 account_id=self.account_id,
                 instrument_id=self._get_cached_instrument_id(order.symbol),
                 report_id=UUID4(),
                 enum_parser=self._enum_parser,
                 treat_expired_as_canceled=self._treat_expired_as_canceled,
                 ts_init=self._clock.timestamp_ns(),
             )
-            self._log.debug(f"Received {reports}.")
+            self._log.debug(f"Received {reports}")
             reports.append(report)
 
         len_reports = len(reports)
         plural = "" if len_reports == 1 else "s"
-        self._log.info(f"Received {len(reports)} OrderStatusReport{plural}.")
+        self._log.info(f"Received {len(reports)} OrderStatusReport{plural}")
 
         return reports
 
     async def generate_fill_reports(
         self,
         instrument_id: InstrumentId | None = None,
         venue_order_id: VenueOrderId | None = None,
@@ -505,32 +507,32 @@
             self._log.exception(f"Cannot generate FillReport: {e.message}", e)
             return []
 
         # Parse all Binance trades
         reports: list[FillReport] = []
         for trade in binance_trades:
             if trade.symbol is None:
-                self._log.warning(f"No symbol for trade {trade}.")
+                self._log.warning(f"No symbol for trade {trade}")
                 continue
             report = trade.parse_to_fill_report(
                 account_id=self.account_id,
                 instrument_id=self._get_cached_instrument_id(trade.symbol),
                 report_id=UUID4(),
                 ts_init=self._clock.timestamp_ns(),
                 use_position_ids=self._use_position_ids,
             )
-            self._log.debug(f"Received {report}.")
+            self._log.debug(f"Received {report}")
             reports.append(report)
 
         # Confirm sorting in ascending order
         reports = sorted(reports, key=lambda x: x.trade_id)
 
         len_reports = len(reports)
         plural = "" if len_reports == 1 else "s"
-        self._log.info(f"Received {len(reports)} FillReport{plural}.")
+        self._log.info(f"Received {len(reports)} FillReport{plural}")
 
         return reports
 
     async def generate_position_status_reports(
         self,
         instrument_id: InstrumentId | None = None,
         start: pd.Timestamp | None = None,
@@ -543,15 +545,15 @@
             reports = await self._get_binance_position_status_reports(symbol)
         except BinanceError as e:
             self._log.exception(f"Cannot generate PositionStatusReport: {e.message}", e)
             return []
 
         len_reports = len(reports)
         plural = "" if len_reports == 1 else "s"
-        self._log.info(f"Received {len(reports)} PositionStatusReport{plural}.")
+        self._log.info(f"Received {len(reports)} PositionStatusReport{plural}")
 
         return reports
 
     # -- COMMAND HANDLERS -------------------------------------------------------------------------
 
     def _check_order_validity(self, order: Order) -> None:
         # Implement in child class
@@ -567,15 +569,15 @@
         return True
 
     def _determine_time_in_force(self, order: Order) -> BinanceTimeInForce:
         time_in_force = self._enum_parser.parse_internal_time_in_force(order.time_in_force)
         if time_in_force == TimeInForce.GTD and not self._use_gtd:
             time_in_force = TimeInForce.GTC
             self._log.info(
-                f"Converted GTD `time_in_force` to GTC for {order.client_order_id}.",
+                f"Converted GTD `time_in_force` to GTC for {order.client_order_id}",
                 LogColor.BLUE,
             )
         return time_in_force
 
     def _determine_good_till_date(
         self,
         order: Order,
@@ -583,15 +585,15 @@
     ) -> int | None:
         if time_in_force is None or time_in_force != BinanceTimeInForce.GTD:
             return None
 
         good_till_date = nanos_to_millis(order.expire_time_ns) if order.expire_time_ns else None
         if self._binance_account_type.is_spot_or_margin:
             good_till_date = None
-            self._log.warning("Cannot set GTD time in force with `expiry_time` for Binance Spot.")
+            self._log.warning("Cannot set GTD time in force with `expiry_time` for Binance Spot")
         return good_till_date
 
     def _determine_reduce_only(self, order: Order) -> bool:
         return order.is_reduce_only if self._use_reduce_only else False
 
     def _determine_reduce_only_str(self, order: Order) -> str | None:
         if self._binance_account_type.is_futures:
@@ -599,20 +601,20 @@
         return None
 
     async def _submit_order(self, command: SubmitOrder) -> None:
         await self._submit_order_inner(command.order)
 
     async def _submit_order_inner(self, order: Order) -> None:
         if order.is_closed:
-            self._log.warning(f"Cannot submit already closed order {order}.")
+            self._log.warning(f"Cannot submit already closed order {order}")
             return
 
         # Check validity
         self._check_order_validity(order)
-        self._log.debug(f"Submitting {order}.")
+        self._log.debug(f"Submitting {order}")
 
         # Generate event here to ensure correct ordering of events
         self.generate_order_submitted(
             strategy_id=order.strategy_id,
             instrument_id=order.instrument_id,
             client_order_id=order.client_order_id,
             ts_event=self._clock.timestamp_ns(),
@@ -639,15 +641,15 @@
                         reason=str(e.message),
                         ts_event=self._clock.timestamp_ns(),
                     )
                     break
 
                 self._log.warning(
                     f"{error_code.name}: retrying {order.client_order_id!r} "
-                    f"{retries}/{self._max_retries} in {self._retry_delay}s ...",
+                    f"{retries}/{self._max_retries} in {self._retry_delay}s",
                 )
                 await asyncio.sleep(self._retry_delay)
 
     async def _submit_market_order(self, order: MarketOrder) -> None:
         await self._http_account.new_order(
             symbol=order.instrument_id.symbol.value,
             side=self._enum_parser.parse_internal_order_side(order.side),
@@ -716,29 +718,29 @@
                 strategy_id=order.strategy_id,
                 instrument_id=order.instrument_id,
                 client_order_id=order.client_order_id,
                 ts_event=self._clock.timestamp_ns(),
             )
 
         for order in command.order_list.orders:
-            if order.linked_order_ids:  # TODO(cs): Implement
-                self._log.warning(f"Cannot yet handle OCO conditional orders, {order}.")
+            if order.linked_order_ids:  # TODO: Implement
+                self._log.warning(f"Cannot yet handle OCO conditional orders, {order}")
             await self._submit_order_inner(order)
 
     async def _submit_stop_market_order(self, order: StopMarketOrder) -> None:
         if self._binance_account_type.is_spot_or_margin:
             working_type = None
         elif order.trigger_type in (TriggerType.DEFAULT, TriggerType.LAST_TRADE):
             working_type = "CONTRACT_PRICE"
         elif order.trigger_type == TriggerType.MARK_PRICE:
             working_type = "MARK_PRICE"
         else:
             self._log.error(
                 f"Cannot submit order: invalid `order.trigger_type`, was "
-                f"{trigger_type_to_str(order.trigger_price)}. {order}",
+                f"{trigger_type_to_str(order.trigger_price)}, {order}",
             )
             return
 
         time_in_force = self._determine_time_in_force(order)
         await self._http_account.new_order(
             symbol=order.instrument_id.symbol.value,
             side=self._enum_parser.parse_internal_order_side(order.side),
@@ -757,22 +759,22 @@
         if order.trigger_type in (TriggerType.DEFAULT, TriggerType.LAST_TRADE):
             working_type = "CONTRACT_PRICE"
         elif order.trigger_type == TriggerType.MARK_PRICE:
             working_type = "MARK_PRICE"
         else:
             self._log.error(
                 f"Cannot submit order: invalid `order.trigger_type`, was "
-                f"{trigger_type_to_str(order.trigger_price)}. {order}",
+                f"{trigger_type_to_str(order.trigger_price)}, {order}",
             )
             return
 
         if order.trailing_offset_type != TrailingOffsetType.BASIS_POINTS:
             self._log.error(
                 f"Cannot submit order: invalid `order.trailing_offset_type`, was "
-                f"{trailing_offset_type_to_str(order.trailing_offset_type)} (use `BASIS_POINTS`). "
+                f"{trailing_offset_type_to_str(order.trailing_offset_type)} (use `BASIS_POINTS`), "
                 f"{order}",
             )
             return
 
         # Ensure activation price
         activation_price: Price | None = order.trigger_price
         if not activation_price:
@@ -817,27 +819,27 @@
             instrument_id = InstrumentId(Symbol(nautilus_symbol), BINANCE_VENUE)
             self._instrument_ids[nautilus_symbol] = instrument_id
         return instrument_id
 
     async def _modify_order(self, command: ModifyOrder) -> None:
         if self._binance_account_type.is_spot_or_margin:
             self._log.error(
-                "Cannot modify order: only supported for `USDT_FUTURE` and `COIN_FUTURE` account types.",
+                "Cannot modify order: only supported for `USDT_FUTURE` and `COIN_FUTURE` account types",
             )
             return
 
         order: Order | None = self._cache.order(command.client_order_id)
         if order is None:
-            self._log.error(f"{command.client_order_id!r} not found to modify.")
+            self._log.error(f"{command.client_order_id!r} not found to modify")
             return
 
         if order.order_type != OrderType.LIMIT:
             self._log.error(
                 "Cannot modify order: "
-                f"only LIMIT orders supported by the venue (was {order.type_string()}).",
+                f"only LIMIT orders supported by the venue (was {order.type_string()})",
             )
             return
 
         while True:
             try:
                 await self._http_account.modify_order(
                     symbol=order.instrument_id.symbol.value,
@@ -855,15 +857,15 @@
                 self._order_retries[command.client_order_id] = retries
 
                 if not self._should_retry(error_code, retries):
                     break
 
                 self._log.warning(
                     f"{error_code.name}: retrying {command.client_order_id!r} "
-                    f"{retries}/{self._max_retries} in {self._retry_delay}s ...",
+                    f"{retries}/{self._max_retries} in {self._retry_delay}s",
                 )
                 await asyncio.sleep(self._retry_delay)
 
     async def _cancel_order(self, command: CancelOrder) -> None:
         while True:
             try:
                 await self._cancel_order_single(
@@ -880,26 +882,23 @@
                 self._order_retries[command.client_order_id] = retries
 
                 if not self._should_retry(error_code, retries):
                     break
 
                 self._log.warning(
                     f"{error_code.name}: retrying {command.client_order_id!r} "
-                    f"{retries}/{self._max_retries} in {self._retry_delay}s ...",
+                    f"{retries}/{self._max_retries} in {self._retry_delay}s",
                 )
                 await asyncio.sleep(self._retry_delay)
 
     async def _cancel_all_orders(self, command: CancelAllOrders) -> None:
         open_orders_strategy: list[Order] = self._cache.orders_open(
             instrument_id=command.instrument_id,
             strategy_id=command.strategy_id,
         )
-        for order in open_orders_strategy:
-            if order.is_pending_cancel:
-                continue  # Already pending cancel
 
         # Check total orders for instrument
         open_orders_total_count = self._cache.orders_open_count(
             instrument_id=command.instrument_id,
         )
 
         try:
@@ -913,48 +912,48 @@
                         instrument_id=order.instrument_id,
                         client_order_id=order.client_order_id,
                         venue_order_id=order.venue_order_id,
                     )
         except BinanceError as e:
             if "Unknown order sent" in e.message:
                 self._log.info(
-                    "No open orders to cancel according to Binance.",
+                    "No open orders to cancel according to Binance",
                     LogColor.GREEN,
                 )
             else:
                 self._log.exception(f"Cannot cancel open orders: {e.message}", e)
 
     async def _cancel_order_single(
         self,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         venue_order_id: VenueOrderId | None,
     ) -> None:
         order: Order | None = self._cache.order(client_order_id)
         if order is None:
-            self._log.error(f"{client_order_id!r} not found to cancel.")
+            self._log.error(f"{client_order_id!r} not found to cancel")
             return
 
         if order.is_closed:
             self._log.warning(
                 f"CancelOrder command for {client_order_id!r} when order already {order.status_string()} "
-                "(will not send to exchange).",
+                "(will not send to exchange)",
             )
             return
 
         try:
             await self._http_account.cancel_order(
                 symbol=instrument_id.symbol.value,
                 order_id=int(venue_order_id.value) if venue_order_id else None,
                 orig_client_order_id=client_order_id.value if client_order_id else None,
             )
         except BinanceError as e:
             error_code = BinanceErrorCode(e.message["code"])
             if error_code == BinanceErrorCode.CANCEL_REJECTED:
-                self._log.warning(f"Cancel rejected: {e.message}.")
+                self._log.warning(f"Cancel rejected: {e.message}")
             else:
                 self._log.exception(
                     f"Cannot cancel order "
                     f"{client_order_id!r}, "
                     f"{venue_order_id!r}: "
                     f"{e.message}",
                     e,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/schemas/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/schemas/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/schemas/account.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/schemas/account.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/schemas/market.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/schemas/market.py`

 * *Files 1% similar despite different names*

```diff
@@ -149,17 +149,18 @@
 
         deltas = [OrderBookDelta.clear(instrument_id, ts_init, ts_init, self.lastUpdateId)]
         deltas += [
             OrderBookDelta(
                 instrument_id,
                 BookAction.ADD,
                 o,
-                ts_init,
-                ts_init,
+                flags=0,
                 sequence=self.lastUpdateId or 0,
+                ts_event=ts_init,  # No event timestamp
+                ts_init=ts_init,
             )
             for o in bids + asks
         ]
         return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 class BinanceTrade(msgspec.Struct, frozen=True):
@@ -260,15 +261,15 @@
             low=Price.from_str(self.low),
             close=Price.from_str(self.close),
             volume=Quantity.from_str(self.volume),
             quote_volume=Decimal(self.asset_volume),
             count=self.trades_count,
             taker_buy_base_volume=Decimal(self.taker_base_volume),
             taker_buy_quote_volume=Decimal(self.taker_quote_volume),
-            ts_event=millis_to_nanos(self.open_time),
+            ts_event=millis_to_nanos(self.close_time),
             ts_init=ts_init,
         )
 
 
 class BinanceTicker24hr(msgspec.Struct, frozen=True):
     """
     Schema of single Binance 24hr ticker (FULL/MINI).
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/schemas/symbol.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/http/user.py`

 * *Files 20% similar despite different names*

```diff
@@ -9,56 +9,40 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import json
 
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
+from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
+from nautilus_trader.adapters.binance.http.user import BinanceUserDataHttpAPI
 
 
-################################################################################
-# HTTP responses
-################################################################################
-
-
-class BinanceSymbol(str):
+class BinanceSpotUserDataHttpAPI(BinanceUserDataHttpAPI):
     """
-    Binance compatible symbol.
-    """
-
-    def __new__(cls, symbol: str | None):
-        if symbol is not None:
-            # Format the string on construction to be Binance compatible
-            return super().__new__(
-                cls,
-                symbol.upper().replace(" ", "").replace("/", "").replace("-PERP", ""),
-            )
-
-    def parse_as_nautilus(self, account_type: BinanceAccountType) -> str:
-        if account_type.is_spot_or_margin:
-            return str(self)
-
-        # Parse Futures symbol
-        if self[-1].isdigit():
-            return str(self)  # Deliverable
-        if self.endswith("_PERP"):
-            return str(self).replace("_", "-")
-        else:
-            return str(self) + "-PERP"
+    Provides access to the `Binance Spot/Margin` User Data HTTP REST API.
 
+    Parameters
+    ----------
+    client : BinanceHttpClient
+        The Binance REST API client.
+    account_type : BinanceAccountType
+        The Binance account type, used to select the endpoint.
 
-class BinanceSymbols(str):
-    """
-    Binance compatible list of symbols.
     """
 
-    def __new__(cls, symbols: list[str] | None):
-        if symbols is not None:
-            binance_symbols: list[BinanceSymbol] = [BinanceSymbol(symbol) for symbol in symbols]
-            return super().__new__(cls, json.dumps(binance_symbols).replace(" ", ""))
-
-    def parse_str_to_list(self) -> list[BinanceSymbol]:
-        binance_symbols: list[BinanceSymbol] = json.loads(self)
-        return binance_symbols
+    def __init__(
+        self,
+        client: BinanceHttpClient,
+        account_type: BinanceAccountType = BinanceAccountType.SPOT,
+    ):
+        super().__init__(
+            client=client,
+            account_type=account_type,
+        )
+
+        if not account_type.is_spot_or_margin:
+            raise RuntimeError(  # pragma: no cover (design-time error)
+                f"`BinanceAccountType` not SPOT, MARGIN or ISOLATED_MARGIN, was {account_type}",  # pragma: no cover (design-time error)
+            )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/schemas/user.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/schemas/user.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/common/types.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/types.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/config.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/config.py`

 * *Files 5% similar despite different names*

```diff
@@ -83,15 +83,15 @@
         The WebSocket client custom endpoint override.
     us : bool, default False
         If client is connecting to Binance US.
     testnet : bool, default False
         If the client is connecting to a Binance testnet.
     use_gtd : bool, default True
         If GTD orders will use the Binance GTD TIF option.
-        If False then GTD time in force will be remapped to GTC (this is useful if manageing GTD
+        If False then GTD time in force will be remapped to GTC (this is useful if managing GTD
         orders locally).
     use_reduce_only : bool, default True
         If the `reduce_only` execution instruction on orders is sent through to the exchange.
         If True then will assign the value on orders sent to the exchange, otherwise will always be False.
     use_position_ids: bool, default True
         If Binance Futures hedging position IDs should be used.
         If False then order event `position_id`(s) from the execution client will be `None`, which
@@ -110,14 +110,13 @@
     api_key: str | None = None
     api_secret: str | None = None
     account_type: BinanceAccountType = BinanceAccountType.SPOT
     base_url_http: str | None = None
     base_url_ws: str | None = None
     us: bool = False
     testnet: bool = False
-    clock_sync_interval_secs: int = 0
     use_gtd: bool = True
     use_reduce_only: bool = True
     use_position_ids: bool = True
     treat_expired_as_canceled: bool = False
     max_retries: PositiveInt | None = None
     retry_delay: PositiveFloat | None = None
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/factories.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/factories.py`

 * *Files 22% similar despite different names*

```diff
@@ -12,25 +12,28 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import asyncio
 from functools import lru_cache
 
+from nautilus_trader.adapters.binance.common.credentials import get_api_key
+from nautilus_trader.adapters.binance.common.credentials import get_api_secret
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
+from nautilus_trader.adapters.binance.common.urls import get_http_base_url
+from nautilus_trader.adapters.binance.common.urls import get_ws_base_url
 from nautilus_trader.adapters.binance.config import BinanceDataClientConfig
 from nautilus_trader.adapters.binance.config import BinanceExecClientConfig
 from nautilus_trader.adapters.binance.futures.data import BinanceFuturesDataClient
 from nautilus_trader.adapters.binance.futures.execution import BinanceFuturesExecutionClient
 from nautilus_trader.adapters.binance.futures.providers import BinanceFuturesInstrumentProvider
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.spot.data import BinanceSpotDataClient
 from nautilus_trader.adapters.binance.spot.execution import BinanceSpotExecutionClient
 from nautilus_trader.adapters.binance.spot.providers import BinanceSpotInstrumentProvider
-from nautilus_trader.adapters.env import get_env_key
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.component import LiveClock
 from nautilus_trader.common.component import MessageBus
 from nautilus_trader.config import InstrumentProviderConfig
 from nautilus_trader.core.nautilus_pyo3 import Quota
 from nautilus_trader.live.factories import LiveDataClientFactory
 from nautilus_trader.live.factories import LiveExecClientFactory
@@ -75,17 +78,17 @@
     Returns
     -------
     BinanceHttpClient
 
     """
     global BINANCE_HTTP_CLIENTS
 
-    key = key or _get_api_key(account_type, is_testnet)
-    secret = secret or _get_api_secret(account_type, is_testnet)
-    default_http_base_url = _get_http_base_url(account_type, is_testnet, is_us)
+    key = key or get_api_key(account_type, is_testnet)
+    secret = secret or get_api_secret(account_type, is_testnet)
+    default_http_base_url = get_http_base_url(account_type, is_testnet, is_us)
 
     # Setup rate limit quotas
     if account_type.is_spot:
         # Spot
         ratelimiter_default_quota = Quota.rate_per_minute(6000)
         ratelimiter_quotas: list[tuple[str, Quota]] = [
             ("order", Quota.rate_per_minute(3000)),
@@ -95,15 +98,15 @@
         # Futures
         ratelimiter_default_quota = Quota.rate_per_minute(2400)
         ratelimiter_quotas = [
             ("order", Quota.rate_per_minute(1200)),
             ("allOrders", Quota.rate_per_minute(int(1200 / 20))),
         ]
 
-    client_key: str = "|".join((key, secret))
+    client_key: str = "|".join((account_type.value, key, secret))
     if client_key not in BINANCE_HTTP_CLIENTS:
         client = BinanceHttpClient(
             clock=clock,
             key=key,
             secret=secret,
             base_url=base_url or default_http_base_url,
             ratelimiter_quotas=ratelimiter_quotas,
@@ -207,15 +210,15 @@
         Create a new Binance data client.
 
         Parameters
         ----------
         loop : asyncio.AbstractEventLoop
             The event loop for the client.
         name : str
-            The client name.
+            The custom client ID.
         config : BinanceDataClientConfig
             The client configuration.
         msgbus : MessageBus
             The message bus for the client.
         cache : Cache
             The cache for the client.
         clock : LiveClock
@@ -238,15 +241,15 @@
             key=config.api_key,
             secret=config.api_secret,
             base_url=config.base_url_http,
             is_testnet=config.testnet,
             is_us=config.us,
         )
 
-        default_base_url_ws: str = _get_ws_base_url(
+        default_base_url_ws: str = get_ws_base_url(
             account_type=config.account_type,
             is_testnet=config.testnet,
             is_us=config.us,
         )
 
         provider: BinanceSpotInstrumentProvider | BinanceFuturesInstrumentProvider
         if config.account_type.is_spot_or_margin:
@@ -264,14 +267,15 @@
                 client=client,
                 msgbus=msgbus,
                 cache=cache,
                 clock=clock,
                 instrument_provider=provider,
                 account_type=config.account_type,
                 base_url_ws=config.base_url_ws or default_base_url_ws,
+                name=name,
                 config=config,
             )
         else:
             # Get instrument provider singleton
             provider = get_cached_binance_futures_instrument_provider(
                 client=client,
                 clock=clock,
@@ -284,14 +288,15 @@
                 client=client,
                 msgbus=msgbus,
                 cache=cache,
                 clock=clock,
                 instrument_provider=provider,
                 account_type=config.account_type,
                 base_url_ws=config.base_url_ws or default_base_url_ws,
+                name=name,
                 config=config,
             )
 
 
 class BinanceLiveExecClientFactory(LiveExecClientFactory):
     """
     Provides a `Binance` live execution client factory.
@@ -310,15 +315,15 @@
         Create a new Binance execution client.
 
         Parameters
         ----------
         loop : asyncio.AbstractEventLoop
             The event loop for the client.
         name : str
-            The client name.
+            The custom client ID.
         config : BinanceExecClientConfig
             The configuration for the client.
         msgbus : MessageBus
             The message bus for the client.
         cache : Cache
             The cache for the client.
         clock : LiveClock
@@ -341,15 +346,15 @@
             key=config.api_key,
             secret=config.api_secret,
             base_url=config.base_url_http,
             is_testnet=config.testnet,
             is_us=config.us,
         )
 
-        default_base_url_ws: str = _get_ws_base_url(
+        default_base_url_ws: str = get_ws_base_url(
             account_type=config.account_type,
             is_testnet=config.testnet,
             is_us=config.us,
         )
 
         provider: BinanceSpotInstrumentProvider | BinanceFuturesInstrumentProvider
         if config.account_type.is_spot or config.account_type.is_margin:
@@ -367,14 +372,15 @@
                 client=client,
                 msgbus=msgbus,
                 cache=cache,
                 clock=clock,
                 instrument_provider=provider,
                 base_url_ws=config.base_url_ws or default_base_url_ws,
                 account_type=config.account_type,
+                name=name,
                 config=config,
             )
         else:
             # Get instrument provider singleton
             provider = get_cached_binance_futures_instrument_provider(
                 client=client,
                 clock=clock,
@@ -387,93 +393,10 @@
                 client=client,
                 msgbus=msgbus,
                 cache=cache,
                 clock=clock,
                 instrument_provider=provider,
                 base_url_ws=config.base_url_ws or default_base_url_ws,
                 account_type=config.account_type,
+                name=name,
                 config=config,
             )
-
-
-def _get_api_key(account_type: BinanceAccountType, is_testnet: bool) -> str:
-    if is_testnet:
-        if account_type.is_spot_or_margin:
-            return get_env_key("BINANCE_TESTNET_API_KEY")
-        else:
-            return get_env_key("BINANCE_FUTURES_TESTNET_API_KEY")
-
-    if account_type.is_spot_or_margin:
-        return get_env_key("BINANCE_API_KEY")
-    else:
-        return get_env_key("BINANCE_FUTURES_API_KEY")
-
-
-def _get_api_secret(account_type: BinanceAccountType, is_testnet: bool) -> str:
-    if is_testnet:
-        if account_type.is_spot_or_margin:
-            return get_env_key("BINANCE_TESTNET_API_SECRET")
-        else:
-            return get_env_key("BINANCE_FUTURES_TESTNET_API_SECRET")
-
-    if account_type.is_spot_or_margin:
-        return get_env_key("BINANCE_API_SECRET")
-    else:
-        return get_env_key("BINANCE_FUTURES_API_SECRET")
-
-
-def _get_http_base_url(account_type: BinanceAccountType, is_testnet: bool, is_us: bool) -> str:
-    # Testnet base URLs
-    if is_testnet:
-        if account_type.is_spot_or_margin:
-            return "https://testnet.binance.vision"
-        elif account_type == BinanceAccountType.USDT_FUTURE:
-            return "https://testnet.binancefuture.com"
-        elif account_type == BinanceAccountType.COIN_FUTURE:
-            return "https://testnet.binancefuture.com"
-        else:
-            raise RuntimeError(  # pragma: no cover (design-time error)
-                f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover
-            )
-
-    # Live base URLs
-    top_level_domain: str = "us" if is_us else "com"
-    if account_type.is_spot:
-        return f"https://api.binance.{top_level_domain}"
-    elif account_type.is_margin:
-        return f"https://sapi.binance.{top_level_domain}"
-    elif account_type == BinanceAccountType.USDT_FUTURE:
-        return f"https://fapi.binance.{top_level_domain}"
-    elif account_type == BinanceAccountType.COIN_FUTURE:
-        return f"https://dapi.binance.{top_level_domain}"
-    else:
-        raise RuntimeError(  # pragma: no cover (design-time error)
-            f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover
-        )
-
-
-def _get_ws_base_url(account_type: BinanceAccountType, is_testnet: bool, is_us: bool) -> str:
-    # Testnet base URLs
-    if is_testnet:
-        if account_type.is_spot_or_margin:
-            return "wss://testnet.binance.vision"
-        elif account_type == BinanceAccountType.USDT_FUTURE:
-            return "wss://stream.binancefuture.com"
-        elif account_type == BinanceAccountType.COIN_FUTURE:
-            raise ValueError("no testnet for COIN-M futures")
-        else:
-            raise RuntimeError(  # pragma: no cover (design-time error)
-                f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover
-            )
-
-    # Live base URLs
-    top_level_domain: str = "us" if is_us else "com"
-    if account_type.is_spot_or_margin:
-        return f"wss://stream.binance.{top_level_domain}:9443"
-    elif account_type == BinanceAccountType.USDT_FUTURE:
-        return f"wss://fstream.binance.{top_level_domain}"
-    elif account_type == BinanceAccountType.COIN_FUTURE:
-        return f"wss://dstream.binance.{top_level_domain}"
-    else:
-        raise RuntimeError(
-            f"invalid `BinanceAccountType`, was {account_type}",
-        )  # pragma: no cover (design-time error)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/data.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/data.py`

 * *Files 2% similar despite different names*

```diff
@@ -55,32 +55,35 @@
         The cache for the client.
     clock : LiveClock
         The clock for the client.
     instrument_provider : InstrumentProvider
         The instrument provider.
     base_url_ws : str
         The base URL for the WebSocket client.
-    account_type : BinanceAccountType
-        The account type for the client.
     config : BinanceDataClientConfig
         The configuration for the client.
+    account_type : BinanceAccountType, default 'USDT_FUTURE'
+        The account type for the client.
+    name : str, optional
+        The custom client ID.
 
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client: BinanceHttpClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         instrument_provider: InstrumentProvider,
         base_url_ws: str,
         config: BinanceDataClientConfig,
         account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
+        name: str | None = None,
     ):
         PyCondition.true(
             account_type.is_futures,
             "account_type was not USDT_FUTURE or COIN_FUTURE",
         )
 
         # Futures HTTP API
@@ -97,14 +100,15 @@
             enum_parser=self._futures_enum_parser,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             instrument_provider=instrument_provider,
             account_type=account_type,
             base_url_ws=base_url_ws,
+            name=name,
             config=config,
         )
 
         # Register additional futures websocket handlers
         self._ws_handlers["@markPrice"] = self._handle_mark_price
 
         # Websocket msgspec decoders
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/enums.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/enums.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/execution.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/execution.py`

 * *Files 2% similar despite different names*

```diff
@@ -68,32 +68,35 @@
         The cache for the client.
     clock : LiveClock
         The clock for the client.
     instrument_provider : BinanceFuturesInstrumentProvider
         The instrument provider.
     base_url_ws : str
         The base URL for the WebSocket client.
-    account_type : BinanceAccountType
-        The account type for the client.
     config : BinanceExecClientConfig
         The configuration for the client.
+    account_type : BinanceAccountType, default 'USDT_FUTURE'
+        The account type for the client.
+    name : str, optional
+        The custom client ID.
 
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client: BinanceHttpClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         instrument_provider: BinanceFuturesInstrumentProvider,
         base_url_ws: str,
         config: BinanceExecClientConfig,
         account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
+        name: str | None = None,
     ):
         PyCondition.true(
             account_type.is_futures,
             "account_type was not USDT_FUTURE or COIN_FUTURE",
         )
 
         # Futures HTTP API
@@ -114,14 +117,15 @@
             enum_parser=self._futures_enum_parser,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             instrument_provider=instrument_provider,
             account_type=account_type,
             base_url_ws=base_url_ws,
+            name=name,
             config=config,
         )
 
         # Register additional futures websocket user data event handlers
         self._futures_user_ws_handlers = {
             BinanceFuturesEventType.ACCOUNT_UPDATE: self._handle_account_update,
             BinanceFuturesEventType.ORDER_TRADE_UPDATE: self._handle_order_trade_update,
@@ -140,18 +144,18 @@
         )
 
     async def _update_account_state(self) -> None:
         account_info: BinanceFuturesAccountInfo = (
             await self._futures_http_account.query_futures_account_info(recv_window=str(5000))
         )
         if account_info.canTrade:
-            self._log.info("Binance API key authenticated.", LogColor.GREEN)
-            self._log.info(f"API key {self._http_client.api_key} has trading permissions.")
+            self._log.info("Binance API key authenticated", LogColor.GREEN)
+            self._log.info(f"API key {self._http_client.api_key} has trading permissions")
         else:
-            self._log.error("Binance API key does not have trading permissions.")
+            self._log.error("Binance API key does not have trading permissions")
         self.generate_account_state(
             balances=account_info.parse_to_account_balances(),
             margins=account_info.parse_to_margin_balances(),
             reported=True,
             ts_event=millis_to_nanos(account_info.updateTime),
         )
         while self.get_account() is None:
@@ -181,15 +185,15 @@
             report = position.parse_to_position_status_report(
                 account_id=self.account_id,
                 instrument_id=self._get_cached_instrument_id(position.symbol),
                 report_id=UUID4(),
                 enum_parser=self._futures_enum_parser,
                 ts_init=self._clock.timestamp_ns(),
             )
-            self._log.debug(f"Received {report}.")
+            self._log.debug(f"Received {report}")
             reports.append(report)
         return reports
 
     async def _get_binance_active_position_symbols(
         self,
         symbol: str | None = None,
     ) -> set[str]:
@@ -217,46 +221,46 @@
             return
         # Check time in force valid
         if order.time_in_force not in self._futures_enum_parser.futures_valid_time_in_force:
             self._log.error(
                 f"Cannot submit order: "
                 f"{time_in_force_to_str(order.time_in_force)} "
                 f"not supported by the exchange. "
-                f"Use any of {[time_in_force_to_str(t) for t in self._futures_enum_parser.futures_valid_time_in_force]}.",
+                f"Use any of {[time_in_force_to_str(t) for t in self._futures_enum_parser.futures_valid_time_in_force]}",
             )
             return
         # Check post-only
         if order.is_post_only and order.order_type != OrderType.LIMIT:
             self._log.error(
                 f"Cannot submit order: {order_type_to_str(order.order_type)} `post_only` order. "
-                "Only LIMIT `post_only` orders supported by the Binance exchange for FUTURES accounts.",
+                "Only LIMIT `post_only` orders supported by the Binance exchange for FUTURES accounts",
             )
             return
 
     async def _batch_cancel_orders(self, command: BatchCancelOrders) -> None:
         # TODO: Iterate batches of 10 order cancels, also validate order is not already closed
         try:
             await self._futures_http_account.cancel_multiple_orders(
                 symbol=command.instrument_id.symbol.value,
                 client_order_ids=[c.client_order_id.value for c in command.cancels],
             )
         except BinanceError as e:
             error_code = BinanceErrorCode(e.message["code"])
             if error_code == BinanceErrorCode.CANCEL_REJECTED:
-                self._log.warning(f"Cancel rejected: {e.message}.")
+                self._log.warning(f"Cancel rejected: {e.message}")
             else:
                 self._log.exception(
                     f"Cannot cancel multiple orders: {e.message}",
                     e,
                 )
 
     # -- WEBSOCKET EVENT HANDLERS --------------------------------------------------------------------
 
     def _handle_user_ws_message(self, raw: bytes) -> None:
-        # TODO(cs): Uncomment for development
+        # TODO: Uncomment for development
         # self._log.info(str(json.dumps(msgspec.json.decode(raw), indent=4)), color=LogColor.MAGENTA)
         wrapper = self._decoder_futures_user_msg_wrapper.decode(raw)
         if not wrapper.stream or not wrapper.data:
             # Control message response
             return
         try:
             self._futures_user_ws_handlers[wrapper.data.e](raw)
@@ -268,14 +272,14 @@
         account_update.data.handle_account_update(self)
 
     def _handle_order_trade_update(self, raw: bytes) -> None:
         order_update = self._decoder_futures_order_update_wrapper.decode(raw)
         order_update.data.o.handle_order_trade_update(self)
 
     def _handle_margin_call(self, raw: bytes) -> None:
-        self._log.warning("MARGIN CALL received.")  # Implement
+        self._log.warning("MARGIN CALL received")  # Implement
 
     def _handle_account_config_update(self, raw: bytes) -> None:
-        self._log.info("Account config updated.", LogColor.BLUE)  # Implement
+        self._log.info("Account config updated", LogColor.BLUE)  # Implement
 
     def _handle_listen_key_expired(self, raw: bytes) -> None:
-        self._log.warning("Listen key expired.")  # Implement
+        self._log.warning("Listen key expired")  # Implement
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/http/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/http/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/http/account.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/http/account.py`

 * *Files 1% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 
 import msgspec
 
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.adapters.binance.common.enums import BinanceSecurityType
 from nautilus_trader.adapters.binance.common.schemas.account import BinanceOrder
 from nautilus_trader.adapters.binance.common.schemas.account import BinanceStatusCode
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.futures.schemas.account import BinanceFuturesAccountInfo
 from nautilus_trader.adapters.binance.futures.schemas.account import BinanceFuturesDualSidePosition
 from nautilus_trader.adapters.binance.futures.schemas.account import BinanceFuturesPositionRisk
 from nautilus_trader.adapters.binance.http.account import BinanceAccountHttpAPI
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.http.endpoint import BinanceHttpEndpoint
 from nautilus_trader.common.component import LiveClock
@@ -99,22 +99,22 @@
 
         """
 
         timestamp: str
         dualSidePosition: str
         recvWindow: str | None = None
 
-    async def get(self, parameters: GetParameters) -> BinanceFuturesDualSidePosition:
+    async def get(self, params: GetParameters) -> BinanceFuturesDualSidePosition:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._get_resp_decoder.decode(raw)
 
-    async def post(self, parameters: PostParameters) -> BinanceStatusCode:
+    async def post(self, params: PostParameters) -> BinanceStatusCode:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._post_resp_decoder.decode(raw)
 
 
 class BinanceFuturesAllOpenOrdersHttp(BinanceHttpEndpoint):
     """
     Endpoint of all open FUTURES orders.
 
@@ -159,17 +159,17 @@
 
         """
 
         timestamp: str
         symbol: BinanceSymbol
         recvWindow: str | None = None
 
-    async def delete(self, parameters: DeleteParameters) -> BinanceStatusCode:
+    async def delete(self, params: DeleteParameters) -> BinanceStatusCode:
         method_type = HttpMethod.DELETE
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._delete_resp_decoder.decode(raw)
 
 
 class BinanceFuturesCancelMultipleOrdersHttp(BinanceHttpEndpoint):
     """
     Endpoint of cancel multiple FUTURES orders.
 
@@ -219,17 +219,17 @@
 
         timestamp: str
         symbol: BinanceSymbol
         orderIdList: str | None = None
         origClientOrderIdList: str | None = None
         recvWindow: str | None = None
 
-    async def delete(self, parameters: DeleteParameters) -> list[BinanceOrder]:
+    async def delete(self, params: DeleteParameters) -> list[BinanceOrder]:
         method_type = HttpMethod.DELETE
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._delete_resp_decoder.decode(raw)
 
 
 class BinanceFuturesAccountHttp(BinanceHttpEndpoint):
     """
     Endpoint of current FUTURES account information.
 
@@ -271,17 +271,17 @@
             The response receive window for the request (cannot be greater than 60000).
 
         """
 
         timestamp: str
         recvWindow: str | None = None
 
-    async def get(self, parameters: GetParameters) -> BinanceFuturesAccountInfo:
+    async def get(self, params: GetParameters) -> BinanceFuturesAccountInfo:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._resp_decoder.decode(raw)
 
 
 class BinanceFuturesPositionRiskHttp(BinanceHttpEndpoint):
     """
     Endpoint of information of all FUTURES positions.
 
@@ -326,17 +326,17 @@
 
         """
 
         timestamp: str
         symbol: BinanceSymbol | None = None
         recvWindow: str | None = None
 
-    async def get(self, parameters: GetParameters) -> list[BinanceFuturesPositionRisk]:
+    async def get(self, params: GetParameters) -> list[BinanceFuturesPositionRisk]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceFuturesAccountHttpAPI(BinanceAccountHttpAPI):
     """
     Provides access to the `Binance Futures` Account/Trade HTTP REST API.
 
@@ -391,30 +391,30 @@
         self,
         recv_window: str | None = None,
     ) -> BinanceFuturesDualSidePosition:
         """
         Check Binance Futures hedge mode (dualSidePosition).
         """
         return await self._endpoint_futures_position_mode.get(
-            parameters=self._endpoint_futures_position_mode.GetParameters(
+            params=self._endpoint_futures_position_mode.GetParameters(
                 timestamp=self._timestamp(),
                 recvWindow=recv_window,
             ),
         )
 
     async def set_futures_hedge_mode(
         self,
         dual_side_position: bool,
         recv_window: str | None = None,
     ) -> BinanceStatusCode:
         """
         Set Binance Futures hedge mode (dualSidePosition).
         """
         return await self._endpoint_futures_position_mode.post(
-            parameters=self._endpoint_futures_position_mode.PostParameters(
+            params=self._endpoint_futures_position_mode.PostParameters(
                 timestamp=self._timestamp(),
                 dualSidePosition=str(dual_side_position).lower(),
                 recvWindow=recv_window,
             ),
         )
 
     async def cancel_all_open_orders(
@@ -425,15 +425,15 @@
         """
         Delete all Futures open orders.
 
         Returns whether successful.
 
         """
         response = await self._endpoint_futures_all_open_orders.delete(
-            parameters=self._endpoint_futures_all_open_orders.DeleteParameters(
+            params=self._endpoint_futures_all_open_orders.DeleteParameters(
                 timestamp=self._timestamp(),
                 symbol=BinanceSymbol(symbol),
                 recvWindow=recv_window,
             ),
         )
         return response.code == 200
 
@@ -447,15 +447,15 @@
         Delete multiple Futures orders.
 
         Returns whether successful.
 
         """
         stringified_client_order_ids = str(client_order_ids).replace(" ", "").replace("'", '"')
         await self._endpoint_futures_cancel_multiple_orders.delete(
-            parameters=self._endpoint_futures_cancel_multiple_orders.DeleteParameters(
+            params=self._endpoint_futures_cancel_multiple_orders.DeleteParameters(
                 timestamp=self._timestamp(),
                 symbol=BinanceSymbol(symbol),
                 origClientOrderIdList=stringified_client_order_ids,
                 recvWindow=recv_window,
             ),
         )
         return True
@@ -464,28 +464,28 @@
         self,
         recv_window: str | None = None,
     ) -> BinanceFuturesAccountInfo:
         """
         Check Binance Futures account information.
         """
         return await self._endpoint_futures_account.get(
-            parameters=self._endpoint_futures_account.GetParameters(
+            params=self._endpoint_futures_account.GetParameters(
                 timestamp=self._timestamp(),
                 recvWindow=recv_window,
             ),
         )
 
     async def query_futures_position_risk(
         self,
         symbol: str | None = None,
         recv_window: str | None = None,
     ) -> list[BinanceFuturesPositionRisk]:
         """
         Check all Futures position's info for a symbol.
         """
         return await self._endpoint_futures_position_risk.get(
-            parameters=self._endpoint_futures_position_risk.GetParameters(
+            params=self._endpoint_futures_position_risk.GetParameters(
                 timestamp=self._timestamp(),
-                symbol=BinanceSymbol(symbol),
+                symbol=BinanceSymbol(symbol) if symbol else None,
                 recvWindow=recv_window,
             ),
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/http/market.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/http/market.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/http/user.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/http/user.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/http/wallet.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/http/wallet.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 # -------------------------------------------------------------------------------------------------
 
 
 import msgspec
 
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.adapters.binance.common.enums import BinanceSecurityType
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.futures.schemas.wallet import BinanceFuturesCommissionRate
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.http.endpoint import BinanceHttpEndpoint
 from nautilus_trader.common.component import LiveClock
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
@@ -70,17 +70,17 @@
 
         """
 
         timestamp: str
         symbol: BinanceSymbol
         recvWindow: str | None = None
 
-    async def get(self, parameters: GetParameters) -> BinanceFuturesCommissionRate:
+    async def get(self, params: GetParameters) -> BinanceFuturesCommissionRate:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceFuturesWalletHttpAPI:
     """
     Provides access to the `Binance Futures` Wallet HTTP REST API.
 
@@ -126,14 +126,14 @@
         symbol: str,
         recv_window: str | None = None,
     ) -> BinanceFuturesCommissionRate:
         """
         Get Futures commission rates for a given symbol.
         """
         rate = await self._endpoint_futures_commission_rate.get(
-            parameters=self._endpoint_futures_commission_rate.GetParameters(
+            params=self._endpoint_futures_commission_rate.GetParameters(
                 timestamp=self._timestamp(),
                 symbol=BinanceSymbol(symbol),
                 recvWindow=recv_window,
             ),
         )
         return rate
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/providers.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/providers.py`

 * *Files 1% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 import msgspec
 import pandas as pd
 
 from nautilus_trader.adapters.binance.common.constants import BINANCE_VENUE
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.adapters.binance.common.enums import BinanceSymbolFilterType
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceSymbolFilter
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.futures.enums import BinanceFuturesContractStatus
 from nautilus_trader.adapters.binance.futures.enums import BinanceFuturesContractType
 from nautilus_trader.adapters.binance.futures.http.account import BinanceFuturesAccountHttpAPI
 from nautilus_trader.adapters.binance.futures.http.market import BinanceFuturesMarketHttpAPI
 from nautilus_trader.adapters.binance.futures.http.wallet import BinanceFuturesWalletHttpAPI
 from nautilus_trader.adapters.binance.futures.schemas.account import BinanceFuturesFeeRates
 from nautilus_trader.adapters.binance.futures.schemas.account import BinanceFuturesPositionRisk
@@ -330,14 +330,15 @@
 
                 instrument = CryptoFuture(
                     instrument_id=instrument_id,
                     raw_symbol=raw_symbol,
                     underlying=base_currency,
                     quote_currency=quote_currency,
                     settlement_currency=settlement_currency,
+                    is_inverse=False,  # No inverse instruments trade on Binance
                     activation_ns=activation.value,
                     expiration_ns=expiration.value,
                     price_precision=price_precision,
                     size_precision=size_precision,
                     price_increment=price_increment,
                     size_increment=size_increment,
                     max_quantity=max_quantity,
@@ -362,8 +363,8 @@
 
             self.add_currency(currency=instrument.quote_currency)
             self.add(instrument=instrument)
 
             self._log.debug(f"Added instrument {instrument.id}.")
         except ValueError as e:
             if self._log_warnings:
-                self._log.warning(f"Unable to parse instrument {symbol_info.symbol}, {e}.")
+                self._log.warning(f"Unable to parse instrument {symbol_info.symbol}: {e}.")
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/schemas/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/schemas/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/schemas/account.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/schemas/account.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/schemas/market.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/schemas/market.py`

 * *Files 1% similar despite different names*

```diff
@@ -80,24 +80,24 @@
     orderTypes: list[BinanceOrderType]
     timeInForce: list[BinanceTimeInForce]
 
     def parse_to_base_currency(self):
         return Currency(
             code=self.baseAsset,
             precision=self.baseAssetPrecision,
-            iso4217=0,  # Currently undetermined for crypto assets
+            iso4217=0,  # Currently unspecified for crypto assets
             name=self.baseAsset,
             currency_type=CurrencyType.CRYPTO,
         )
 
     def parse_to_quote_currency(self):
         return Currency(
             code=self.quoteAsset,
             precision=self.quotePrecision,
-            iso4217=0,  # Currently undetermined for crypto assets
+            iso4217=0,  # Currently unspecified for crypto assets
             name=self.quoteAsset,
             currency_type=CurrencyType.CRYPTO,
         )
 
 
 class BinanceFuturesExchangeInfo(msgspec.Struct, kw_only=True, frozen=True):
     """
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/schemas/user.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/schemas/user.py`

 * *Files 0% similar despite different names*

```diff
@@ -106,15 +106,15 @@
     wb: str  # Wallet Balance
     cw: str  # Cross Wallet Balance
     bc: str  # Balance Change except PnL and Commission
 
     def parse_to_account_balance(self) -> AccountBalance:
         currency = Currency.from_str(self.a)
         free = Decimal(self.wb)
-        locked = Decimal(0)  # TODO(cs): Pending refactoring of accounting
+        locked = Decimal(0)  # TODO: Pending refactoring of accounting
         total: Decimal = free + locked
 
         return AccountBalance(
             total=Money(total, currency),
             locked=Money(locked, currency),
             free=Money(free, currency),
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/schemas/wallet.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/schemas/wallet.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/futures/types.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/futures/types.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/account.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/account.py`

 * *Files 2% similar despite different names*

```diff
@@ -20,15 +20,15 @@
 from nautilus_trader.adapters.binance.common.enums import BinanceNewOrderRespType
 from nautilus_trader.adapters.binance.common.enums import BinanceOrderSide
 from nautilus_trader.adapters.binance.common.enums import BinanceOrderType
 from nautilus_trader.adapters.binance.common.enums import BinanceSecurityType
 from nautilus_trader.adapters.binance.common.enums import BinanceTimeInForce
 from nautilus_trader.adapters.binance.common.schemas.account import BinanceOrder
 from nautilus_trader.adapters.binance.common.schemas.account import BinanceUserTrade
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.http.endpoint import BinanceHttpEndpoint
 from nautilus_trader.common.component import LiveClock
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
@@ -265,32 +265,32 @@
         quantity: str
         price: str
         timestamp: str
         orderId: int | None = None
         origClientOrderId: str | None = None
         recvWindow: str | None = None
 
-    async def get(self, parameters: GetDeleteParameters) -> BinanceOrder:
+    async def get(self, params: GetDeleteParameters) -> BinanceOrder:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._resp_decoder.decode(raw)
 
-    async def delete(self, parameters: GetDeleteParameters) -> BinanceOrder:
+    async def delete(self, params: GetDeleteParameters) -> BinanceOrder:
         method_type = HttpMethod.DELETE
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._resp_decoder.decode(raw)
 
-    async def post(self, parameters: PostParameters) -> BinanceOrder:
+    async def post(self, params: PostParameters) -> BinanceOrder:
         method_type = HttpMethod.POST
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._resp_decoder.decode(raw)
 
-    async def put(self, parameters: PutParameters) -> BinanceOrder:
+    async def put(self, params: PutParameters) -> BinanceOrder:
         method_type = HttpMethod.PUT
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._resp_decoder.decode(raw)
 
 
 class BinanceAllOrdersHttp(BinanceHttpEndpoint):
     """
     Endpoint of all account orders, active, cancelled or filled.
 
@@ -351,17 +351,17 @@
         timestamp: str
         orderId: int | None = None
         startTime: int | None = None
         endTime: int | None = None
         limit: int | None = None
         recvWindow: str | None = None
 
-    async def get(self, parameters: GetParameters) -> list[BinanceOrder]:
+    async def get(self, params: GetParameters) -> list[BinanceOrder]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceOpenOrdersHttp(BinanceHttpEndpoint):
     """
     Endpoint of all open orders on a symbol.
 
@@ -415,17 +415,17 @@
 
         """
 
         timestamp: str
         symbol: BinanceSymbol | None = None
         recvWindow: str | None = None
 
-    async def get(self, parameters: GetParameters) -> list[BinanceOrder]:
+    async def get(self, params: GetParameters) -> list[BinanceOrder]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceUserTradesHttp(BinanceHttpEndpoint):
     """
     Endpoint of trades for a specific account and symbol.
 
@@ -488,17 +488,17 @@
         orderId: int | None = None
         startTime: int | None = None
         endTime: int | None = None
         fromId: int | None = None
         limit: int | None = None
         recvWindow: str | None = None
 
-    async def _get(self, parameters: GetParameters) -> list[BinanceUserTrade]:
+    async def _get(self, params: GetParameters) -> list[BinanceUserTrade]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceAccountHttpAPI:
     """
     Provides access to the Binance Account/Trade HTTP REST API.
 
@@ -562,15 +562,15 @@
         Check an order status.
         """
         if order_id is None and orig_client_order_id is None:
             raise RuntimeError(
                 "Either orderId or origClientOrderId must be sent.",
             )
         binance_order = await self._endpoint_order.get(
-            parameters=self._endpoint_order.GetDeleteParameters(
+            params=self._endpoint_order.GetDeleteParameters(
                 symbol=BinanceSymbol(symbol),
                 timestamp=self._timestamp(),
                 orderId=order_id,
                 origClientOrderId=orig_client_order_id,
                 recvWindow=recv_window,
             ),
         )
@@ -595,15 +595,15 @@
         Cancel an active order.
         """
         if order_id is None and orig_client_order_id is None:
             raise RuntimeError(
                 "Either orderId or origClientOrderId must be sent.",
             )
         binance_order = await self._endpoint_order.delete(
-            parameters=self._endpoint_order.GetDeleteParameters(
+            params=self._endpoint_order.GetDeleteParameters(
                 symbol=BinanceSymbol(symbol),
                 timestamp=self._timestamp(),
                 orderId=order_id,
                 origClientOrderId=orig_client_order_id,
                 recvWindow=recv_window,
             ),
         )
@@ -634,15 +634,15 @@
         new_order_resp_type: BinanceNewOrderRespType | None = None,
         recv_window: str | None = None,
     ) -> BinanceOrder:
         """
         Send in a new order to Binance.
         """
         binance_order = await self._endpoint_order.post(
-            parameters=self._endpoint_order.PostParameters(
+            params=self._endpoint_order.PostParameters(
                 symbol=BinanceSymbol(symbol),
                 timestamp=self._timestamp(),
                 side=side,
                 type=order_type,
                 timeInForce=time_in_force,
                 quantity=quantity,
                 quoteOrderQty=quote_order_qty,
@@ -676,15 +676,15 @@
         orig_client_order_id: str | None = None,
         recv_window: str | None = None,
     ) -> BinanceOrder:
         """
         Modify a LIMIT order with Binance.
         """
         binance_order = await self._endpoint_order.put(
-            parameters=self._endpoint_order.PutParameters(
+            params=self._endpoint_order.PutParameters(
                 symbol=BinanceSymbol(symbol),
                 timestamp=self._timestamp(),
                 orderId=order_id,
                 origClientOrderId=orig_client_order_id,
                 side=side,
                 quantity=quantity,
                 price=price,
@@ -702,15 +702,15 @@
         limit: int | None = None,
         recv_window: str | None = None,
     ) -> list[BinanceOrder]:
         """
         Query all orders, active or filled.
         """
         return await self._endpoint_all_orders.get(
-            parameters=self._endpoint_all_orders.GetParameters(
+            params=self._endpoint_all_orders.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 timestamp=self._timestamp(),
                 orderId=order_id,
                 startTime=start_time,
                 endTime=end_time,
                 limit=limit,
                 recvWindow=recv_window,
@@ -722,16 +722,16 @@
         symbol: str | None = None,
         recv_window: str | None = None,
     ) -> list[BinanceOrder]:
         """
         Query open orders.
         """
         return await self._endpoint_open_orders.get(
-            parameters=self._endpoint_open_orders.GetParameters(
-                symbol=BinanceSymbol(symbol),
+            params=self._endpoint_open_orders.GetParameters(
+                symbol=BinanceSymbol(symbol) if symbol else None,
                 timestamp=self._timestamp(),
                 recvWindow=recv_window,
             ),
         )
 
     async def query_user_trades(
         self,
@@ -747,15 +747,15 @@
         Query user's trade history for a symbol, with provided filters.
         """
         if (order_id or from_id) is not None and (start_time or end_time) is not None:
             raise RuntimeError(
                 "Cannot specify both order_id/from_id AND start_time/end_time parameters.",
             )
         return await self._endpoint_user_trades._get(
-            parameters=self._endpoint_user_trades.GetParameters(
+            params=self._endpoint_user_trades.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 timestamp=self._timestamp(),
                 orderId=order_id,
                 startTime=start_time,
                 endTime=end_time,
                 fromId=from_id,
                 limit=limit,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/client.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/client.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/endpoint.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/endpoint.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,16 +14,16 @@
 # -------------------------------------------------------------------------------------------------
 
 from typing import Any
 
 import msgspec
 
 from nautilus_trader.adapters.binance.common.enums import BinanceSecurityType
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbols
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbols
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
 def enc_hook(obj: Any) -> Any:
     if isinstance(obj, BinanceSymbol):
         return str(obj)  # serialize BinanceSymbol as string.
@@ -64,18 +64,18 @@
             BinanceSecurityType.MARGIN: self.client.sign_request,
             BinanceSecurityType.USER_DATA: self.client.sign_request,
         }
 
     async def _method(
         self,
         method_type: HttpMethod,
-        parameters: Any,
+        params: Any,
         ratelimiter_keys: list[str] | None = None,
     ) -> bytes:
-        payload: dict = self.decoder.decode(self.encoder.encode(parameters))
+        payload: dict = self.decoder.decode(self.encoder.encode(params))
         if self.methods_desc[method_type] is None:
             raise RuntimeError(
                 f"{method_type.name} not available for {self.url_path}",
             )
         raw: bytes = await self._method_request[self.methods_desc[method_type]](
             http_method=method_type,
             url_path=self.url_path,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/error.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/error.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/market.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/market.py`

 * *Files 2% similar despite different names*

```diff
@@ -25,16 +25,16 @@
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceDepth
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceKline
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceTicker24hr
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceTickerBook
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceTickerPrice
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceTime
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceTrade
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbols
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbols
 from nautilus_trader.adapters.binance.common.types import BinanceBar
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.http.endpoint import BinanceHttpEndpoint
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.datetime import nanos_to_millis
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 from nautilus_trader.model.data import BarType
@@ -164,17 +164,17 @@
                 Valid limits:[5, 10, 20, 50, 100, 500, 1000].
 
         """
 
         symbol: BinanceSymbol
         limit: int | None = None
 
-    async def get(self, parameters: GetParameters) -> BinanceDepth:
+    async def get(self, params: GetParameters) -> BinanceDepth:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceTradesHttp(BinanceHttpEndpoint):
     """
     Endpoint of recent market trades.
 
@@ -218,17 +218,17 @@
             The limit for the response. Default 500; max 1000.
 
         """
 
         symbol: BinanceSymbol
         limit: int | None = None
 
-    async def get(self, parameters: GetParameters) -> list[BinanceTrade]:
+    async def get(self, params: GetParameters) -> list[BinanceTrade]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceHistoricalTradesHttp(BinanceHttpEndpoint):
     """
     Endpoint of older market historical trades.
 
@@ -275,17 +275,17 @@
 
         """
 
         symbol: BinanceSymbol
         limit: int | None = None
         fromId: int | None = None
 
-    async def get(self, parameters: GetParameters) -> list[BinanceTrade]:
+    async def get(self, params: GetParameters) -> list[BinanceTrade]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceAggTradesHttp(BinanceHttpEndpoint):
     """
     Endpoint of compressed and aggregated market trades. Market trades that fill in
     100ms with the same price and same taking side will have the quantity aggregated.
@@ -339,17 +339,17 @@
 
         symbol: BinanceSymbol
         limit: int | None = None
         fromId: int | None = None
         startTime: int | None = None
         endTime: int | None = None
 
-    async def get(self, parameters: GetParameters) -> list[BinanceAggTrade]:
+    async def get(self, params: GetParameters) -> list[BinanceAggTrade]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceKlinesHttp(BinanceHttpEndpoint):
     """
     Endpoint of Kline/candlestick bars for a symbol. Klines are uniquely identified by
     their open time.
@@ -403,17 +403,17 @@
 
         symbol: BinanceSymbol
         interval: BinanceKlineInterval
         limit: int | None = None
         startTime: int | None = None
         endTime: int | None = None
 
-    async def get(self, parameters: GetParameters) -> list[BinanceKline]:
+    async def get(self, params: GetParameters) -> list[BinanceKline]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceTicker24hrHttp(BinanceHttpEndpoint):
     """
     Endpoint of 24-hour rolling window price change statistics.
 
@@ -469,18 +469,18 @@
 
         """
 
         symbol: BinanceSymbol | None = None
         symbols: BinanceSymbols | None = None  # SPOT/MARGIN only
         type: str | None = None  # SPOT/MARIN only
 
-    async def _get(self, parameters: GetParameters) -> list[BinanceTicker24hr]:
+    async def _get(self, params: GetParameters) -> list[BinanceTicker24hr]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
-        if parameters.symbol is not None:
+        raw = await self._method(method_type, params)
+        if params.symbol is not None:
             return [self._get_obj_resp_decoder.decode(raw)]
         else:
             return self._get_arr_resp_decoder.decode(raw)
 
 
 class BinanceTickerPriceHttp(BinanceHttpEndpoint):
     """
@@ -529,18 +529,18 @@
             List of trading pairs. When given, endpoint will return a list of BinanceTickerPrice.
 
         """
 
         symbol: BinanceSymbol | None = None
         symbols: BinanceSymbols | None = None  # SPOT/MARGIN only
 
-    async def _get(self, parameters: GetParameters) -> list[BinanceTickerPrice]:
+    async def _get(self, params: GetParameters) -> list[BinanceTickerPrice]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
-        if parameters.symbol is not None:
+        raw = await self._method(method_type, params)
+        if params.symbol is not None:
             return [self._get_obj_resp_decoder.decode(raw)]
         else:
             return self._get_arr_resp_decoder.decode(raw)
 
 
 class BinanceTickerBookHttp(BinanceHttpEndpoint):
     """
@@ -589,18 +589,18 @@
             List of trading pairs. When given, endpoint will return a list of BinanceTickerBook.
 
         """
 
         symbol: BinanceSymbol | None = None
         symbols: BinanceSymbols | None = None  # SPOT/MARGIN only
 
-    async def _get(self, parameters: GetParameters) -> list[BinanceTickerBook]:
+    async def _get(self, params: GetParameters) -> list[BinanceTickerBook]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
-        if parameters.symbol is not None:
+        raw = await self._method(method_type, params)
+        if params.symbol is not None:
             return [self._get_obj_resp_decoder.decode(raw)]
         else:
             return self._get_arr_resp_decoder.decode(raw)
 
 
 class BinanceMarketHttpAPI:
     """
@@ -668,15 +668,15 @@
         symbol: str,
         limit: int | None = None,
     ) -> BinanceDepth:
         """
         Query order book depth for a symbol.
         """
         return await self._endpoint_depth.get(
-            parameters=self._endpoint_depth.GetParameters(
+            params=self._endpoint_depth.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 limit=limit,
             ),
         )
 
     async def request_order_book_snapshot(
         self,
@@ -698,15 +698,15 @@
         symbol: str,
         limit: int | None = None,
     ) -> list[BinanceTrade]:
         """
         Query trades for symbol.
         """
         return await self._endpoint_trades.get(
-            parameters=self._endpoint_trades.GetParameters(
+            params=self._endpoint_trades.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 limit=limit,
             ),
         )
 
     async def request_trade_ticks(
         self,
@@ -734,15 +734,15 @@
         end_time: int | None = None,
         from_id: int | None = None,
     ) -> list[BinanceAggTrade]:
         """
         Query aggregated trades for symbol.
         """
         return await self._endpoint_agg_trades.get(
-            parameters=self._endpoint_agg_trades.GetParameters(
+            params=self._endpoint_agg_trades.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 limit=limit,
                 startTime=start_time,
                 endTime=end_time,
                 fromId=from_id,
             ),
         )
@@ -837,15 +837,15 @@
         limit: int | None = None,
         from_id: int | None = None,
     ) -> list[BinanceTrade]:
         """
         Query historical trades for symbol.
         """
         return await self._endpoint_historical_trades.get(
-            parameters=self._endpoint_historical_trades.GetParameters(
+            params=self._endpoint_historical_trades.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 limit=limit,
                 fromId=from_id,
             ),
         )
 
     async def request_historical_trade_ticks(
@@ -879,15 +879,15 @@
         start_time: int | None = None,
         end_time: int | None = None,
     ) -> list[BinanceKline]:
         """
         Query klines for a symbol over an interval.
         """
         return await self._endpoint_klines.get(
-            parameters=self._endpoint_klines.GetParameters(
+            params=self._endpoint_klines.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 interval=interval,
                 limit=limit,
                 startTime=start_time,
                 endTime=end_time,
             ),
         )
@@ -944,17 +944,17 @@
         Query 24hr ticker for symbol or symbols.
         """
         if symbol is not None and symbols is not None:
             raise RuntimeError(
                 "Cannot specify both symbol and symbols parameters.",
             )
         return await self._endpoint_ticker_24hr._get(
-            parameters=self._endpoint_ticker_24hr.GetParameters(
-                symbol=BinanceSymbol(symbol),
-                symbols=BinanceSymbols(symbols),
+            params=self._endpoint_ticker_24hr.GetParameters(
+                symbol=BinanceSymbol(symbol) if symbol else None,
+                symbols=BinanceSymbols(symbols) if symbols else None,
                 type=response_type,
             ),
         )
 
     async def query_ticker_price(
         self,
         symbol: str | None = None,
@@ -964,17 +964,17 @@
         Query price ticker for symbol or symbols.
         """
         if symbol is not None and symbols is not None:
             raise RuntimeError(
                 "Cannot specify both symbol and symbols parameters.",
             )
         return await self._endpoint_ticker_price._get(
-            parameters=self._endpoint_ticker_price.GetParameters(
-                symbol=BinanceSymbol(symbol),
-                symbols=BinanceSymbols(symbols),
+            params=self._endpoint_ticker_price.GetParameters(
+                symbol=BinanceSymbol(symbol) if symbol else None,
+                symbols=BinanceSymbols(symbols) if symbols else None,
             ),
         )
 
     async def query_ticker_book(
         self,
         symbol: str | None = None,
         symbols: list[str] | None = None,
@@ -983,12 +983,12 @@
         Query book ticker for symbol or symbols.
         """
         if symbol is not None and symbols is not None:
             raise RuntimeError(
                 "Cannot specify both symbol and symbols parameters.",
             )
         return await self._endpoint_ticker_book._get(
-            parameters=self._endpoint_ticker_book.GetParameters(
-                symbol=BinanceSymbol(symbol),
-                symbols=BinanceSymbols(symbols),
+            params=self._endpoint_ticker_book.GetParameters(
+                symbol=BinanceSymbol(symbol) if symbol else None,
+                symbols=BinanceSymbols(symbols) if symbols else None,
             ),
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/http/user.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/http/user.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,16 +14,16 @@
 # -------------------------------------------------------------------------------------------------
 
 
 import msgspec
 
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.adapters.binance.common.enums import BinanceSecurityType
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.common.schemas.user import BinanceListenKey
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.http.endpoint import BinanceHttpEndpoint
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
 class BinanceListenKeyHttp(BinanceHttpEndpoint):
@@ -101,27 +101,27 @@
             The listen key to manage. Only required for SPOT/MARGIN accounts!
 
         """
 
         symbol: BinanceSymbol | None = None  # MARGIN_ISOLATED only, mandatory
         listenKey: str | None = None  # SPOT/MARGIN only, mandatory
 
-    async def _post(self, parameters: PostParameters | None = None) -> BinanceListenKey:
+    async def _post(self, params: PostParameters | None = None) -> BinanceListenKey:
         method_type = HttpMethod.POST
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._post_resp_decoder.decode(raw)
 
-    async def _put(self, parameters: PutDeleteParameters | None = None) -> dict:
+    async def _put(self, params: PutDeleteParameters | None = None) -> dict:
         method_type = HttpMethod.PUT
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._put_resp_decoder.decode(raw)
 
-    async def _delete(self, parameters: PutDeleteParameters | None = None) -> dict:
+    async def _delete(self, params: PutDeleteParameters | None = None) -> dict:
         method_type = HttpMethod.DELETE
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._delete_resp_decoder.decode(raw)
 
 
 class BinanceUserDataHttpAPI:
     """
     Provides access to the `Binance` User HTTP REST API.
 
@@ -173,42 +173,42 @@
         self,
         symbol: str | None = None,
     ) -> BinanceListenKey:
         """
         Create Binance ListenKey.
         """
         key = await self._endpoint_listenkey._post(
-            parameters=self._endpoint_listenkey.PostParameters(
-                symbol=BinanceSymbol(symbol),
+            params=self._endpoint_listenkey.PostParameters(
+                symbol=BinanceSymbol(symbol) if symbol else None,
             ),
         )
         return key
 
     async def keepalive_listen_key(
         self,
         symbol: str | None = None,
         listen_key: str | None = None,
     ):
         """
         Ping/Keepalive Binance ListenKey.
         """
         await self._endpoint_listenkey._put(
-            parameters=self._endpoint_listenkey.PutDeleteParameters(
-                symbol=BinanceSymbol(symbol),
+            params=self._endpoint_listenkey.PutDeleteParameters(
+                symbol=BinanceSymbol(symbol) if symbol else None,
                 listenKey=listen_key,
             ),
         )
 
     async def delete_listen_key(
         self,
         symbol: str | None = None,
         listen_key: str | None = None,
     ):
         """
         Delete Binance ListenKey.
         """
         await self._endpoint_listenkey._delete(
-            parameters=self._endpoint_listenkey.PutDeleteParameters(
-                symbol=BinanceSymbol(symbol),
+            params=self._endpoint_listenkey.PutDeleteParameters(
+                symbol=BinanceSymbol(symbol) if symbol else None,
                 listenKey=listen_key,
             ),
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/data.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/data.py`

 * *Files 6% similar despite different names*

```diff
@@ -52,32 +52,35 @@
         The cache for the client.
     clock : LiveClock
         The clock for the client.
     instrument_provider : InstrumentProvider
         The instrument provider.
     base_url_ws : str
         The base URL for the WebSocket client.
-    account_type : BinanceAccountType
-        The account type for the client.
     config : BinanceDataClientConfig
         The configuration for the client.
+    account_type : BinanceAccountType, default 'SPOT'
+        The account type for the client.
+    name : str, optional
+        The custom client ID.
 
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client: BinanceHttpClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         instrument_provider: InstrumentProvider,
         base_url_ws: str,
         config: BinanceDataClientConfig,
         account_type: BinanceAccountType = BinanceAccountType.SPOT,
+        name: str | None = None,
     ):
         PyCondition.true(
             account_type.is_spot_or_margin,
             "account_type was not SPOT, MARGIN or ISOLATED_MARGIN",
         )
 
         # Spot HTTP API
@@ -93,14 +96,15 @@
             enum_parser=self._spot_enum_parser,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             instrument_provider=instrument_provider,
             account_type=account_type,
             base_url_ws=base_url_ws,
+            name=name,
             config=config,
         )
 
         # Websocket msgspec decoders
         self._decoder_spot_trade = msgspec.json.Decoder(BinanceSpotTradeMsg)
         self._decoder_spot_order_book_partial_depth = msgspec.json.Decoder(
             BinanceSpotOrderBookPartialDepthMsg,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/enums.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/enums.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/execution.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/execution.py`

 * *Files 2% similar despite different names*

```diff
@@ -61,32 +61,35 @@
         The cache for the client.
     clock : LiveClock
         The clock for the client.
     instrument_provider : BinanceSpotInstrumentProvider
         The instrument provider.
     base_url_ws : str
         The base URL for the WebSocket client.
-    account_type : BinanceAccountType
-        The account type for the client.
     config : BinanceExecClientConfig
         The configuration for the client.
+    account_type : BinanceAccountType, default 'SPOT'
+        The account type for the client.
+    name : str, optional
+        The custom client ID.
 
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client: BinanceHttpClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         instrument_provider: BinanceSpotInstrumentProvider,
         base_url_ws: str,
         config: BinanceExecClientConfig,
         account_type: BinanceAccountType = BinanceAccountType.SPOT,
+        name: str | None = None,
     ):
         PyCondition.true(
             account_type.is_spot_or_margin,
             "account_type was not SPOT, MARGIN or ISOLATED_MARGIN",
         )
 
         # Spot HTTP API
@@ -107,14 +110,15 @@
             enum_parser=self._spot_enum_parser,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             instrument_provider=instrument_provider,
             account_type=account_type,
             base_url_ws=base_url_ws,
+            name=name,
             config=config,
         )
 
         # Register spot websocket user data event handlers
         self._spot_user_ws_handlers = {
             BinanceSpotEventType.outboundAccountPosition: self._handle_account_update,
             BinanceSpotEventType.executionReport: self._handle_execution_report,
@@ -135,17 +139,17 @@
         account_info: BinanceSpotAccountInfo = (
             await self._spot_http_account.query_spot_account_info(
                 recv_window=str(5000),
             )
         )
         if account_info.canTrade:
             self._log.info("Binance API key authenticated.", LogColor.GREEN)
-            self._log.info(f"API key {self._http_client.api_key} has trading permissions.")
+            self._log.info(f"API key {self._http_client.api_key} has trading permissions")
         else:
-            self._log.error("Binance API key does not have trading permissions.")
+            self._log.error("Binance API key does not have trading permissions")
         self.generate_account_state(
             balances=account_info.parse_to_account_balances(),
             margins=[],
             reported=True,
             ts_event=millis_to_nanos(account_info.updateTime),
         )
         while self.get_account() is None:
@@ -180,35 +184,35 @@
             return
         # Check time in force valid
         if order.time_in_force not in self._spot_enum_parser.spot_valid_time_in_force:
             self._log.error(
                 f"Cannot submit order: "
                 f"{time_in_force_to_str(order.time_in_force)} "
                 f"not supported by the Binance Spot/Margin exchange. "
-                f"Use any of {[time_in_force_to_str(t) for t in self._spot_enum_parser.spot_valid_time_in_force]}.",
+                f"Use any of {[time_in_force_to_str(t) for t in self._spot_enum_parser.spot_valid_time_in_force]}",
             )
             return
         # Check post-only
         if order.order_type == OrderType.STOP_LIMIT and order.is_post_only:
             self._log.error(
                 "Cannot submit order: "
                 "STOP_LIMIT `post_only` orders not supported by the Binance Spot/Margin exchange. "
-                "This order may become a liquidity TAKER.",
+                "This order may become a liquidity TAKER",
             )
             return
 
     async def _batch_cancel_orders(self, command: BatchCancelOrders) -> None:
         self._log.error(
-            "Cannot batch cancel orders: not supported by the Binance Spot/Margin exchange. ",
+            "Cannot batch cancel orders: not supported by the Binance Spot/Margin exchange",
         )
 
     # -- WEBSOCKET EVENT HANDLERS --------------------------------------------------------------------
 
     def _handle_user_ws_message(self, raw: bytes) -> None:
-        # TODO(cs): Uncomment for development
+        # TODO: Uncomment for development
         # self._log.info(str(json.dumps(msgspec.json.decode(raw), indent=4)), color=LogColor.MAGENTA)
         wrapper = self._decoder_spot_user_msg_wrapper.decode(raw)
         try:
             self._spot_user_ws_handlers[wrapper.data.e](raw)
         except Exception as e:
             self._log.exception(f"Error on handling {raw!r}", e)
 
@@ -217,11 +221,11 @@
         account_msg.data.handle_account_update(self)
 
     def _handle_execution_report(self, raw: bytes) -> None:
         order_msg = self._decoder_spot_order_update_wrapper.decode(raw)
         order_msg.data.handle_execution_report(self)
 
     def _handle_list_status(self, raw: bytes) -> None:
-        self._log.warning("List status (OCO) received.")  # Implement
+        self._log.warning("List status (OCO) received")  # Implement
 
     def _handle_balance_update(self, raw: bytes) -> None:
         self.create_task(self._update_account_state())
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/http/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/http/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/http/account.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/http/account.py`

 * *Files 5% similar despite different names*

```diff
@@ -19,15 +19,15 @@
 
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.adapters.binance.common.enums import BinanceNewOrderRespType
 from nautilus_trader.adapters.binance.common.enums import BinanceOrderSide
 from nautilus_trader.adapters.binance.common.enums import BinanceSecurityType
 from nautilus_trader.adapters.binance.common.enums import BinanceTimeInForce
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceRateLimit
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.http.account import BinanceAccountHttpAPI
 from nautilus_trader.adapters.binance.http.account import BinanceOpenOrdersHttp
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.http.endpoint import BinanceHttpEndpoint
 from nautilus_trader.adapters.binance.spot.schemas.account import BinanceSpotAccountInfo
 from nautilus_trader.adapters.binance.spot.schemas.account import BinanceSpotOrderOco
 from nautilus_trader.common.component import LiveClock
@@ -85,17 +85,17 @@
 
         """
 
         timestamp: str
         symbol: BinanceSymbol
         recvWindow: str | None = None
 
-    async def _delete(self, parameters: DeleteParameters) -> list[dict[str, Any]]:
+    async def _delete(self, params: DeleteParameters) -> list[dict[str, Any]]:
         method_type = HttpMethod.DELETE
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._delete_resp_decoder.decode(raw)
 
 
 class BinanceSpotOrderOcoHttp(BinanceHttpEndpoint):
     """
     Endpoint for creating SPOT/MARGIN OCO orders.
 
@@ -195,17 +195,17 @@
         stopStrategyType: int | None = None
         stopLimitPrice: str | None = None
         stopIcebergQty: str | None = None
         stopLimitTimeInForce: BinanceTimeInForce | None = None
         newOrderRespType: BinanceNewOrderRespType | None = None
         recvWindow: str | None = None
 
-    async def _post(self, parameters: PostParameters) -> BinanceSpotOrderOco:
+    async def _post(self, params: PostParameters) -> BinanceSpotOrderOco:
         method_type = HttpMethod.POST
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._resp_decoder.decode(raw)
 
 
 class BinanceSpotOrderListHttp(BinanceHttpEndpoint):
     """
     Endpoint for querying and deleting SPOT/MARGIN OCO orders.
 
@@ -289,22 +289,22 @@
         timestamp: str
         symbol: BinanceSymbol
         orderListId: str | None = None
         listClientOrderId: str | None = None
         newClientOrderId: str | None = None
         recvWindow: str | None = None
 
-    async def get(self, parameters: GetParameters) -> BinanceSpotOrderOco:
+    async def get(self, params: GetParameters) -> BinanceSpotOrderOco:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._resp_decoder.decode(raw)
 
-    async def delete(self, parameters: DeleteParameters) -> BinanceSpotOrderOco:
+    async def delete(self, params: DeleteParameters) -> BinanceSpotOrderOco:
         method_type = HttpMethod.DELETE
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._resp_decoder.decode(raw)
 
 
 class BinanceSpotAllOrderListHttp(BinanceHttpEndpoint):
     """
     Endpoint for querying all SPOT/MARGIN OCO orders.
 
@@ -362,17 +362,17 @@
         timestamp: str
         fromId: int | None = None
         startTime: int | None = None
         endTime: int | None = None
         limit: int | None = None
         recvWindow: str | None = None
 
-    async def get(self, parameters: GetParameters) -> list[BinanceSpotOrderOco]:
+    async def get(self, params: GetParameters) -> list[BinanceSpotOrderOco]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._resp_decoder.decode(raw)
 
 
 class BinanceSpotOpenOrderListHttp(BinanceHttpEndpoint):
     """
     Endpoint for querying all SPOT/MARGIN OPEN OCO orders.
 
@@ -412,17 +412,17 @@
             The response receive window for the request (cannot be greater than 60000).
 
         """
 
         timestamp: str
         recvWindow: str | None = None
 
-    async def get(self, parameters: GetParameters) -> list[BinanceSpotOrderOco]:
+    async def get(self, params: GetParameters) -> list[BinanceSpotOrderOco]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._resp_decoder.decode(raw)
 
 
 class BinanceSpotAccountHttp(BinanceHttpEndpoint):
     """
     Endpoint of current SPOT/MARGIN account information.
 
@@ -462,17 +462,17 @@
             The response receive window for the request (cannot be greater than 60000).
 
         """
 
         timestamp: str
         recvWindow: str | None = None
 
-    async def get(self, parameters: GetParameters) -> BinanceSpotAccountInfo:
+    async def get(self, params: GetParameters) -> BinanceSpotAccountInfo:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._resp_decoder.decode(raw)
 
 
 class BinanceSpotOrderRateLimitHttp(BinanceHttpEndpoint):
     """
     Endpoint of current SPOT/MARGIN order count usage for all intervals.
 
@@ -512,17 +512,17 @@
             The response receive window for the request (cannot be greater than 60000).
 
         """
 
         timestamp: str
         recvWindow: str | None = None
 
-    async def get(self, parameters: GetParameters) -> list[BinanceRateLimit]:
+    async def get(self, params: GetParameters) -> list[BinanceRateLimit]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._resp_decoder.decode(raw)
 
 
 class BinanceSpotAccountHttpAPI(BinanceAccountHttpAPI):
     """
     Provides access to the `Binance Spot/Margin` Account/Trade HTTP REST API.
 
@@ -599,15 +599,15 @@
                 "stopLimitPrice cannot be provided without stopLimitTimeInForce.",
             )
         if stop_limit_time_in_force == BinanceTimeInForce.GTX:
             raise RuntimeError(
                 "stopLimitTimeInForce, Good Till Crossing (GTX) not supported.",
             )
         return await self._endpoint_spot_order_oco._post(
-            parameters=self._endpoint_spot_order_oco.PostParameters(
+            params=self._endpoint_spot_order_oco.PostParameters(
                 symbol=BinanceSymbol(symbol),
                 timestamp=self._timestamp(),
                 side=side,
                 quantity=quantity,
                 price=price,
                 stopPrice=stop_price,
                 listClientOrderId=list_client_order_id,
@@ -637,15 +637,15 @@
         Check single spot OCO order information.
         """
         if order_list_id is None and orig_client_order_id is None:
             raise RuntimeError(
                 "Either orderListId or origClientOrderId must be provided.",
             )
         return await self._endpoint_spot_order_list.get(
-            parameters=self._endpoint_spot_order_list.GetParameters(
+            params=self._endpoint_spot_order_list.GetParameters(
                 timestamp=self._timestamp(),
                 orderListId=order_list_id,
                 origClientOrderId=orig_client_order_id,
                 recvWindow=recv_window,
             ),
         )
 
@@ -657,15 +657,15 @@
         """
         Cancel all active orders on a symbol, including OCO.
 
         Returns whether successful.
 
         """
         await self._endpoint_spot_open_orders._delete(
-            parameters=self._endpoint_spot_open_orders.DeleteParameters(
+            params=self._endpoint_spot_open_orders.DeleteParameters(
                 timestamp=self._timestamp(),
                 symbol=BinanceSymbol(symbol),
                 recvWindow=recv_window,
             ),
         )
         return True
 
@@ -681,15 +681,15 @@
         Delete spot OCO order from Binance.
         """
         if order_list_id is None and list_client_order_id is None:
             raise RuntimeError(
                 "Either orderListId or listClientOrderId must be provided.",
             )
         return await self._endpoint_spot_order_list.delete(
-            parameters=self._endpoint_spot_order_list.DeleteParameters(
+            params=self._endpoint_spot_order_list.DeleteParameters(
                 timestamp=self._timestamp(),
                 symbol=BinanceSymbol(symbol),
                 orderListId=order_list_id,
                 listClientOrderId=list_client_order_id,
                 newClientOrderId=new_client_order_id,
                 recvWindow=recv_window,
             ),
@@ -707,15 +707,15 @@
         Check all spot OCO orders' information, matching provided filter parameters.
         """
         if from_id is not None and (start_time or end_time) is not None:
             raise RuntimeError(
                 "Cannot specify both fromId and a startTime/endTime.",
             )
         return await self._endpoint_spot_all_order_list.get(
-            parameters=self._endpoint_spot_all_order_list.GetParameters(
+            params=self._endpoint_spot_all_order_list.GetParameters(
                 timestamp=self._timestamp(),
                 fromId=from_id,
                 startTime=start_time,
                 endTime=end_time,
                 limit=limit,
                 recvWindow=recv_window,
             ),
@@ -725,40 +725,40 @@
         self,
         recv_window: str | None = None,
     ) -> list[BinanceSpotOrderOco]:
         """
         Check all OPEN spot OCO orders' information.
         """
         return await self._endpoint_spot_open_order_list.get(
-            parameters=self._endpoint_spot_open_order_list.GetParameters(
+            params=self._endpoint_spot_open_order_list.GetParameters(
                 timestamp=self._timestamp(),
                 recvWindow=recv_window,
             ),
         )
 
     async def query_spot_account_info(
         self,
         recv_window: str | None = None,
     ) -> BinanceSpotAccountInfo:
         """
         Check SPOT/MARGIN Binance account information.
         """
         return await self._endpoint_spot_account.get(
-            parameters=self._endpoint_spot_account.GetParameters(
+            params=self._endpoint_spot_account.GetParameters(
                 timestamp=self._timestamp(),
                 recvWindow=recv_window,
             ),
         )
 
     async def query_spot_order_rate_limit(
         self,
         recv_window: str | None = None,
     ) -> list[BinanceRateLimit]:
         """
         Check SPOT/MARGIN order count/rateLimit.
         """
         return await self._endpoint_spot_order_rate_limit.get(
-            parameters=self._endpoint_spot_order_rate_limit.GetParameters(
+            params=self._endpoint_spot_order_rate_limit.GetParameters(
                 timestamp=self._timestamp(),
                 recvWindow=recv_window,
             ),
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/http/market.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/http/market.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,21 +9,20 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-
 import msgspec
 
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.adapters.binance.common.enums import BinanceSecurityType
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbols
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbols
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.http.endpoint import BinanceHttpEndpoint
 from nautilus_trader.adapters.binance.http.market import BinanceMarketHttpAPI
 from nautilus_trader.adapters.binance.spot.enums import BinanceSpotPermissions
 from nautilus_trader.adapters.binance.spot.schemas.market import BinanceSpotAvgPrice
 from nautilus_trader.adapters.binance.spot.schemas.market import BinanceSpotExchangeInfo
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
@@ -72,17 +71,17 @@
 
         """
 
         symbol: BinanceSymbol | None = None
         symbols: BinanceSymbols | None = None
         permissions: BinanceSpotPermissions | None = None
 
-    async def get(self, parameters: GetParameters | None = None) -> BinanceSpotExchangeInfo:
+    async def get(self, params: GetParameters | None = None) -> BinanceSpotExchangeInfo:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceSpotAvgPriceHttp(BinanceHttpEndpoint):
     """
     Endpoint of current average price of a symbol.
 
@@ -119,17 +118,17 @@
         symbol : BinanceSymbol
             Specify trading pair to get average price for.
 
         """
 
         symbol: BinanceSymbol = None
 
-    async def get(self, parameters: GetParameters) -> BinanceSpotAvgPrice:
+    async def get(self, params: GetParameters) -> BinanceSpotAvgPrice:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceSpotMarketHttpAPI(BinanceMarketHttpAPI):
     """
     Provides access to the `Binance Spot` Market HTTP REST API.
 
@@ -168,23 +167,23 @@
     ) -> BinanceSpotExchangeInfo:
         """
         Check Binance Spot exchange information.
         """
         if symbol and symbols:
             raise ValueError("`symbol` and `symbols` cannot be sent together")
         return await self._endpoint_spot_exchange_info.get(
-            parameters=self._endpoint_spot_exchange_info.GetParameters(
-                symbol=BinanceSymbol(symbol),
-                symbols=BinanceSymbols(symbols),
+            params=self._endpoint_spot_exchange_info.GetParameters(
+                symbol=BinanceSymbol(symbol) if symbol else None,
+                symbols=BinanceSymbols(symbols) if symbols else None,
                 permissions=permissions,
             ),
         )
 
     async def query_spot_average_price(self, symbol: str) -> BinanceSpotAvgPrice:
         """
         Check average price for a provided symbol on the Spot exchange.
         """
         return await self._endpoint_spot_average_price.get(
-            parameters=self._endpoint_spot_average_price.GetParameters(
+            params=self._endpoint_spot_average_price.GetParameters(
                 symbol=BinanceSymbol(symbol),
             ),
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/http/user.py` & `nautilus_trader-1.191.0/nautilus_trader/indicators/psl.pxd`

 * *Files 26% similar despite different names*

```diff
@@ -9,40 +9,24 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from nautilus_trader.indicators.average.moving_average cimport MovingAverage
+from nautilus_trader.indicators.base.indicator cimport Indicator
 
-from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
-from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
-from nautilus_trader.adapters.binance.http.user import BinanceUserDataHttpAPI
 
+cdef class PsychologicalLine(Indicator):
+    cdef MovingAverage _ma
 
-class BinanceSpotUserDataHttpAPI(BinanceUserDataHttpAPI):
-    """
-    Provides access to the `Binance Spot/Margin` User Data HTTP REST API.
+    cdef readonly int period
+    """The window period.\n\n:returns: `int`"""
+    cdef readonly double _diff
+    """The current difference.\n\n:returns: `double`"""
+    cdef readonly double _previous_close
+    """The previous close price.\n\n:returns: `double`"""
+    cdef readonly double value
+    """The current  value.\n\n:returns: `double`"""
 
-    Parameters
-    ----------
-    client : BinanceHttpClient
-        The Binance REST API client.
-    account_type : BinanceAccountType
-        The Binance account type, used to select the endpoint.
-
-    """
-
-    def __init__(
-        self,
-        client: BinanceHttpClient,
-        account_type: BinanceAccountType = BinanceAccountType.SPOT,
-    ):
-        super().__init__(
-            client=client,
-            account_type=account_type,
-        )
-
-        if not account_type.is_spot_or_margin:
-            raise RuntimeError(  # pragma: no cover (design-time error)
-                f"`BinanceAccountType` not SPOT, MARGIN or ISOLATED_MARGIN, was {account_type}",  # pragma: no cover (design-time error)
-            )
+    cpdef void update_raw(self, double close)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/http/wallet.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/http/wallet.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 # -------------------------------------------------------------------------------------------------
 
 
 import msgspec
 
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.adapters.binance.common.enums import BinanceSecurityType
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.http.endpoint import BinanceHttpEndpoint
 from nautilus_trader.adapters.binance.spot.schemas.wallet import BinanceSpotTradeFee
 from nautilus_trader.common.component import LiveClock
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
@@ -69,18 +69,18 @@
 
         """
 
         timestamp: str
         symbol: BinanceSymbol | None = None
         recvWindow: str | None = None
 
-    async def get(self, parameters: GetParameters) -> list[BinanceSpotTradeFee]:
+    async def get(self, params: GetParameters) -> list[BinanceSpotTradeFee]:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
-        if parameters.symbol is not None:
+        raw = await self._method(method_type, params)
+        if params.symbol is not None:
             return [self._get_obj_resp_decoder.decode(raw)]
         else:
             return self._get_arr_resp_decoder.decode(raw)
 
 
 class BinanceSpotWalletHttpAPI:
     """
@@ -118,14 +118,14 @@
 
     async def query_spot_trade_fees(
         self,
         symbol: str | None = None,
         recv_window: str | None = None,
     ) -> list[BinanceSpotTradeFee]:
         fees = await self._endpoint_spot_trade_fee.get(
-            parameters=self._endpoint_spot_trade_fee.GetParameters(
+            params=self._endpoint_spot_trade_fee.GetParameters(
                 timestamp=self._timestamp(),
                 symbol=BinanceSymbol(symbol) if symbol is not None else None,
                 recvWindow=recv_window,
             ),
         )
         return fees
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/providers.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/providers.py`

 * *Files 1% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 
 import msgspec
 
 from nautilus_trader.adapters.binance.common.constants import BINANCE_VENUE
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.adapters.binance.common.enums import BinanceSymbolFilterType
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceSymbolFilter
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.http.error import BinanceClientError
 from nautilus_trader.adapters.binance.spot.http.market import BinanceSpotMarketHttpAPI
 from nautilus_trader.adapters.binance.spot.http.wallet import BinanceSpotWalletHttpAPI
 from nautilus_trader.adapters.binance.spot.schemas.market import BinanceSpotSymbolInfo
 from nautilus_trader.adapters.binance.spot.schemas.wallet import BinanceSpotTradeFee
 from nautilus_trader.common.component import LiveClock
@@ -307,8 +307,8 @@
             self.add_currency(currency=instrument.base_currency)
             self.add_currency(currency=instrument.quote_currency)
             self.add(instrument=instrument)
 
             self._log.debug(f"Added instrument {instrument.id}.")
         except ValueError as e:
             if self._log_warnings:
-                self._log.warning(f"Unable to parse instrument {symbol_info.symbol}, {e}.")
+                self._log.warning(f"Unable to parse instrument {symbol_info.symbol}: {e}.")
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/schemas/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/schemas/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/schemas/account.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/schemas/account.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/schemas/market.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/schemas/market.py`

 * *Files 2% similar despite different names*

```diff
@@ -63,24 +63,24 @@
     filters: list[BinanceSymbolFilter]
     permissions: list[str]
 
     def parse_to_base_asset(self):
         return Currency(
             code=self.baseAsset,
             precision=self.baseAssetPrecision,
-            iso4217=0,  # Currently undetermined for crypto assets
+            iso4217=0,  # Currently unspecified for crypto assets
             name=self.baseAsset,
             currency_type=CurrencyType.CRYPTO,
         )
 
     def parse_to_quote_asset(self):
         return Currency(
             code=self.quoteAsset,
             precision=self.quoteAssetPrecision,
-            iso4217=0,  # Currently undetermined for crypto assets
+            iso4217=0,  # Currently unspecified for crypto assets
             name=self.quoteAsset,
             currency_type=CurrencyType.CRYPTO,
         )
 
 
 class BinanceSpotExchangeInfo(msgspec.Struct, frozen=True):
     """
@@ -134,17 +134,18 @@
 
         deltas = [OrderBookDelta.clear(instrument_id, ts_init, ts_init, self.lastUpdateId)]
         deltas += [
             OrderBookDelta(
                 instrument_id,
                 BookAction.ADD,
                 o,
-                ts_init,
-                ts_init,
+                flags=0,
                 sequence=self.lastUpdateId,
+                ts_event=ts_init,  # No event timestamp
+                ts_init=ts_init,
             )
             for o in bids + asks
         ]
         return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 class BinanceSpotOrderBookPartialDepthMsg(msgspec.Struct):
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/schemas/user.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/schemas/user.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/spot/schemas/wallet.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/spot/schemas/wallet.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/websocket/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/websocket/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/binance/websocket/client.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/websocket/client.py`

 * *Files 6% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 
 import asyncio
 import json
 from collections.abc import Awaitable
 from collections.abc import Callable
 from typing import Any
 
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
+from nautilus_trader.adapters.binance.common.symbol import BinanceSymbol
 from nautilus_trader.common.component import LiveClock
 from nautilus_trader.common.component import Logger
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.core.nautilus_pyo3 import WebSocketClient
 from nautilus_trader.core.nautilus_pyo3 import WebSocketConfig
 
 
@@ -63,15 +63,15 @@
 
         self._base_url: str = base_url
         self._handler: Callable[[bytes], None] = handler
         self._handler_reconnect: Callable[..., Awaitable[None]] | None = handler_reconnect
         self._loop = loop
 
         self._streams: list[str] = []
-        self._inner: WebSocketClient | None = None
+        self._client: WebSocketClient | None = None
         self._is_connecting = False
         self._msg_id: int = 0
 
     @property
     def url(self) -> str:
         """
         Return the server URL being used by the client.
@@ -108,15 +108,15 @@
         return bool(self._streams)
 
     async def connect(self) -> None:
         """
         Connect a websocket client to the server.
         """
         if not self._streams:
-            self._log.error("Cannot connect: no streams for initial connection.")
+            self._log.error("Cannot connect: no streams for initial connection")
             return
 
         # Binance expects at least one stream for the initial connection
         initial_stream = self._streams[0]
         ws_url = self._base_url + f"/stream?streams={initial_stream}"
 
         self._log.debug(f"Connecting to {ws_url}...")
@@ -126,64 +126,64 @@
             url=ws_url,
             handler=self._handler,
             heartbeat=60,
             headers=[],
             ping_handler=self._handle_ping,
         )
 
-        self._inner = await WebSocketClient.connect(
+        self._client = await WebSocketClient.connect(
             config=config,
             post_reconnection=self.reconnect,
         )
         self._is_connecting = False
-        self._log.info(f"Connected to {self._base_url}.", LogColor.BLUE)
-        self._log.info(f"Subscribed to {initial_stream}.", LogColor.BLUE)
+        self._log.info(f"Connected to {self._base_url}", LogColor.BLUE)
+        self._log.debug(f"Subscribed to {initial_stream}")
 
     def _handle_ping(self, raw: bytes) -> None:
         self._loop.create_task(self.send_pong(raw))
 
     async def send_pong(self, raw: bytes) -> None:
         """
         Send the given raw payload to the server as a PONG message.
         """
-        if self._inner is None:
+        if self._client is None:
             return
 
-        await self._inner.send_pong(raw)
+        await self._client.send_pong(raw)
 
     # TODO: Temporarily synch
     def reconnect(self) -> None:
         """
         Reconnect the client to the server and resubscribe to all streams.
         """
         if not self._streams:
-            self._log.error("Cannot reconnect: no streams for initial connection.")
+            self._log.error("Cannot reconnect: no streams for initial connection")
             return
 
-        self._log.warning(f"Reconnected to {self._base_url}.")
+        self._log.warning(f"Reconnected to {self._base_url}")
 
         # Re-subscribe to all streams
         self._loop.create_task(self._subscribe_all())
 
-        if self._handler_reconnect is not None:
+        if self._handler_reconnect:
             self._loop.create_task(self._handler_reconnect())  # type: ignore
 
     async def disconnect(self) -> None:
         """
         Disconnect the client from the server.
         """
-        if self._inner is None:
-            self._log.warning("Cannot disconnect: not connected.")
+        if self._client is None:
+            self._log.warning("Cannot disconnect: not connected")
             return
 
         self._log.debug("Disconnecting...")
-        await self._inner.disconnect()
-        self._inner = None
+        await self._client.disconnect()
+        self._client = None  # Dispose (will go out of scope)
 
-        self._log.info("Disconnected.")
+        self._log.info(f"Disconnected from {self._base_url}", LogColor.BLUE)
 
     async def subscribe_listen_key(self, listen_key: str) -> None:
         """
         Subscribe to user data stream.
         """
         await self._subscribe(listen_key)
 
@@ -459,61 +459,61 @@
             stream = "!markPrice@arr"
         else:
             stream = f"{BinanceSymbol(symbol).lower()}@markPrice@{int(speed / 1000)}s"
         await self._unsubscribe(stream)
 
     async def _subscribe(self, stream: str) -> None:
         if stream in self._streams:
-            self._log.warning(f"Cannot subscribe to {stream}: already subscribed.")
+            self._log.warning(f"Cannot subscribe to {stream}: already subscribed")
             return  # Already subscribed
 
         self._streams.append(stream)
 
-        while self._is_connecting and not self._inner:
+        while self._is_connecting and not self._client:
             await asyncio.sleep(0.01)
 
-        if self._inner is None:
+        if self._client is None:
             # Make initial connection
             await self.connect()
             return
 
         message = self._create_subscribe_msg(streams=[stream])
         self._log.debug(f"SENDING: {message}")
 
-        await self._inner.send_text(json.dumps(message))
-        self._log.info(f"Subscribed to {stream}.", LogColor.BLUE)
+        await self._client.send_text(json.dumps(message))
+        self._log.debug(f"Subscribed to {stream}")
 
     async def _subscribe_all(self) -> None:
-        if self._inner is None:
-            self._log.error("Cannot subscribe all: no connected.")
+        if self._client is None:
+            self._log.error("Cannot subscribe all: no connected")
             return
 
         message = self._create_subscribe_msg(streams=self._streams)
         self._log.debug(f"SENDING: {message}")
 
-        await self._inner.send_text(json.dumps(message))
+        await self._client.send_text(json.dumps(message))
         for stream in self._streams:
-            self._log.info(f"Subscribed to {stream}.", LogColor.BLUE)
+            self._log.debug(f"Subscribed to {stream}")
 
     async def _unsubscribe(self, stream: str) -> None:
         if stream not in self._streams:
-            self._log.warning(f"Cannot unsubscribe from {stream}: never subscribed.")
+            self._log.warning(f"Cannot unsubscribe from {stream}: never subscribed")
             return  # Not subscribed
 
         self._streams.remove(stream)
 
-        if self._inner is None:
-            self._log.error(f"Cannot unsubscribe from {stream}: not connected.")
+        if self._client is None:
+            self._log.error(f"Cannot unsubscribe from {stream}: not connected")
             return
 
         message = self._create_unsubscribe_msg(streams=[stream])
         self._log.debug(f"SENDING: {message}")
 
-        await self._inner.send_text(json.dumps(message))
-        self._log.info(f"Unsubscribed from {stream}.", LogColor.BLUE)
+        await self._client.send_text(json.dumps(message))
+        self._log.debug(f"Unsubscribed from {stream}")
 
     def _create_subscribe_msg(self, streams: list[str]) -> dict[str, Any]:
         message = {
             "method": "SUBSCRIBE",
             "params": streams,
             "id": self._msg_id,
         }
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/common/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/common/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/common/constants.py` & `nautilus_trader-1.191.0/nautilus_trader/backtest/data_client.pxd`

 * *Files 13% similar despite different names*

```diff
@@ -9,11 +9,17 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.model.identifiers import Venue
+from nautilus_trader.data.client cimport DataClient
+from nautilus_trader.data.client cimport MarketDataClient
 
 
-BYBIT_VENUE = Venue("BYBIT")
+cdef class BacktestDataClient(DataClient):
+    pass
+
+
+cdef class BacktestMarketDataClient(MarketDataClient):
+    pass
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/common/enums.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/common/enums.py`

 * *Files 4% similar despite different names*

```diff
@@ -19,40 +19,85 @@
 from nautilus_trader.core.nautilus_pyo3 import PositionSide
 from nautilus_trader.model.data import BarType
 from nautilus_trader.model.enums import BarAggregation
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import OrderStatus
 from nautilus_trader.model.enums import OrderType
 from nautilus_trader.model.enums import TimeInForce
+from nautilus_trader.model.enums import time_in_force_to_str
 
 
 def raise_error(error):
     raise error
 
 
 @unique
 class BybitPositionIdx(Enum):
-    # one-way mode position
+    # One-way mode position
     ONE_WAY = 0
-    # buy side of hedge-mode position
+    # Buy side of hedge-mode position
     BUY_HEDGE = 1
-    # sell side of hedge-mode position
+    # Sell side of hedge-mode position
     SELL_HEDGE = 2
 
 
 @unique
+class BybitAccountType(Enum):
+    UNIFIED = "UNIFIED"
+
+
+@unique
+class BybitProductType(Enum):
+    SPOT = "spot"
+    LINEAR = "linear"
+    INVERSE = "inverse"
+    OPTION = "option"
+
+    @property
+    def is_spot(self) -> bool:
+        return self == BybitProductType.SPOT
+
+    @property
+    def is_linear(self) -> bool:
+        return self == BybitProductType.LINEAR
+
+    @property
+    def is_inverse(self) -> bool:
+        return self == BybitProductType.INVERSE
+
+    @property
+    def is_option(self) -> bool:
+        return self == BybitProductType.OPTION
+
+
+@unique
+class BybitContractType(Enum):
+    LINEAR_PERPETUAL = "LinearPerpetual"
+    LINEAR_FUTURE = "LinearFutures"
+    INVERSE_PERPETUAL = "InversePerpetual"
+    INVERSE_FUTURE = "InverseFutures"
+
+
+@unique
+class BybitOptionType(Enum):
+    CALL = "Call"
+    PUT = "Put"
+
+
+@unique
 class BybitPositionSide(Enum):
     BUY = "Buy"
     SELL = "Sell"
 
     def parse_to_position_side(self) -> PositionSide:
         if self == BybitPositionSide.BUY:
             return PositionSide.LONG
         elif self == BybitPositionSide.SELL:
             return PositionSide.SHORT
+        raise RuntimeError(f"invalid position side, was {self}")
 
 
 @unique
 class BybitKlineInterval(Enum):
     MINUTE_1 = "1"
     MINUTE_3 = "3"
     MINUTE_5 = "5"
@@ -89,59 +134,60 @@
     SELL = "Sell"
 
 
 @unique
 class BybitOrderType(Enum):
     MARKET = "Market"
     LIMIT = "Limit"
-    UNKNOWN = "Unknown"
+    UNKNOWN = "UNKNOWN"  # Used when execution type is Funding
+
+
+@unique
+class BybitStopOrderType(Enum):
+    NONE = ""  # Default
+    UNKNOWN = "UNKNOWN"  # Classic account value
+    TAKE_PROFIT = "TakeProfit"
+    STOP_LOSS = "StopLoss"
+    TRAILING_STOP = "TrailingStop"
+    STOP = "Stop"
+    PARTIAL_TAKE_PROFIT = "PartialTakeProfit"
+    PARTIAL_STOP_LOSS = "PartialStopLoss"
+    TPSL_ORDER = "tpslOrder"
+    OCO_ORDER = "OcoOrder"  # Spot only
+    MM_RATE_CLOSE = "MmRateClose"
+    BIDIRECTIONAL_TPSL_ORDER = "BidirectionalTpslOrder"
 
 
 @unique
 class BybitTriggerType(Enum):
+    NONE = ""  # Default
     LAST_PRICE = "LastPrice"
     INDEX_PRICE = "IndexPrice"
     MARK_PRICE = "MarkPrice"
 
 
 @unique
 class BybitTimeInForce(Enum):
     GTC = "GTC"
     IOC = "IOC"
     FOK = "FOK"
     POST_ONLY = "PostOnly"
 
 
 @unique
-class BybitAccountType(Enum):
-    UNIFIED = "UNIFIED"
-
-
-@unique
-class BybitInstrumentType(Enum):
-    SPOT = "spot"
-    LINEAR = "linear"
-    INVERSE = "inverse"
-    OPTION = "option"
-
-    @property
-    def is_spot_or_margin(self) -> bool:
-        return self in [BybitInstrumentType.SPOT]
-
-    @property
-    def is_spot(self) -> bool:
-        return self in [BybitInstrumentType.SPOT]
-
-
-@unique
-class BybitContractType(Enum):
-    INVERSE_PERPETUAL = "InversePerpetual"
-    LINEAR_PERPETUAL = "LinearPerpetual"
-    LINEAR_FUTURE = "LinearFutures"
-    INVERSE_FUTURE = "InverseFutures"
+class BybitExecType(Enum):
+    TRADE = "Trade"
+    ADL_TRADE = "AdlTrade"  # Auto-Deleveraging
+    FUNDING = "Funding"  # Funding fee
+    BUST_TRADE = "BustTrade"  # Liquidation
+    DELIVERY = "Delivery"  # Delivery
+    SETTLE = "Settle"  # Settle Inverse futures settlement
+    BLOCK_TRADE = "BlockTrade"
+    MOVE_POSITION = "MovePosition"
+    UNKNOWN = "UNKNOWN"  # Classic account value (cannot be used to query)
 
 
 @unique
 class BybitTransactionType(Enum):
     # Assets that transferred into Unified wallet
     TRANSFER_IN = "TRANSFER_IN"
     # Assets that transferred out of Unified wallet
@@ -149,14 +195,23 @@
     TRADE = "TRADE"
     SETTLEMENT = "SETTLEMENT"
     DELIVERY = "DELIVERY"
     LIQUIDATION = "LIQUIDATION"
     AIRDROP = "AIRDRP"
 
 
+@unique
+class BybitEndpointType(Enum):
+    NONE = "NONE"
+    ASSET = "ASSET"
+    MARKET = "MARKET"
+    ACCOUNT = "ACCOUNT"
+    TRADE = "TRADE"
+
+
 def check_dict_keys(key, data):
     try:
         return data[key]
     except KeyError:
         raise RuntimeError(
             f"Unrecognized Bybit {key} not found in {data}",
         )
@@ -240,14 +295,17 @@
 
     def parse_nautilus_order_status(self, order_status: OrderStatus) -> BybitOrderStatus:
         return check_dict_keys(order_status, self.nautilus_to_bybit_order_status)
 
     def parse_bybit_time_in_force(self, time_in_force: BybitTimeInForce) -> TimeInForce:
         return check_dict_keys(time_in_force, self.bybit_to_nautilus_time_in_force)
 
+    def parse_nautuilus_time_in_force(self, time_in_force: TimeInForce) -> BybitTimeInForce:
+        return check_dict_keys(time_in_force, self.nautilus_to_bybit_time_in_force)
+
     def parse_bybit_order_side(self, order_side: BybitOrderSide) -> OrderSide:
         return check_dict_keys(order_side, self.bybit_to_nautilus_order_side)
 
     def parse_nautilus_order_side(self, order_side: OrderSide) -> BybitOrderSide:
         return check_dict_keys(order_side, self.nautilus_to_bybit_order_side)
 
     def parse_bybit_order_type(self, order_type: BybitOrderType) -> OrderType:
@@ -257,15 +315,15 @@
         return check_dict_keys(order_type, self.nautilus_to_bybit_order_type)
 
     def parse_nautilus_time_in_force(self, time_in_force: TimeInForce) -> BybitTimeInForce:
         try:
             return self.nautilus_to_bybit_time_in_force[time_in_force]
         except KeyError:
             raise RuntimeError(
-                f"unrecognized Bybit time in force, was {time_in_force}",  # pragma: no cover
+                f"unrecognized Bybit time in force, was {time_in_force_to_str(time_in_force)}",  # pragma: no cover
             )
 
     def parse_bybit_kline(self, bar_type: BarType) -> BybitKlineInterval:
         try:
             aggregation = bar_type.spec.aggregation
             interval = int(bar_type.spec.step)
             if aggregation in self.aggregation_kline_mapping:
@@ -275,15 +333,7 @@
                 raise ValueError(
                     f"Bybit incorrect aggregation {aggregation}",  # pragma: no cover
                 )
         except KeyError:
             raise RuntimeError(
                 f"unrecognized Bybit bar type, was {bar_type}",  # pragma: no cover
             )
-
-
-@unique
-class BybitEndpointType(Enum):
-    NONE = "NONE"
-    MARKET = "MARKET"
-    ACCOUNT = "ACCOUNT"
-    TRADE = "TRADE"
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/common/error.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/common/error.py`

 * *Files 13% similar despite different names*

```diff
@@ -29,12 +29,12 @@
     code = 33004
     message = "Your api key has expired."
 
     def __init__(self):
         super().__init__(self.code, self.message)
 
 
-def raise_bybit_error(code):
+def raise_bybit_error(code: int, message: str | None) -> None:
     if code == BybitKeyExpiredError.code:
         raise BybitKeyExpiredError
     else:
-        raise BybitError(code, "Unknown bybit error")
+        raise BybitError(code, f"Unknown Bybit error: {code=}, {message=}")
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/config.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/signal_strategy.py`

 * *Files 24% similar despite different names*

```diff
@@ -10,43 +10,64 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 
-from nautilus_trader.adapters.bybit.common.enums import BybitInstrumentType
-from nautilus_trader.config import LiveDataClientConfig
-from nautilus_trader.config import LiveExecClientConfig
-from nautilus_trader.config import PositiveFloat
-from nautilus_trader.config import PositiveInt
+from nautilus_trader.config import StrategyConfig
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
+from nautilus_trader.model.identifiers import InstrumentId
+from nautilus_trader.model.instruments import Instrument
+from nautilus_trader.trading.strategy import Strategy
 
 
-class BybitDataClientConfig(LiveDataClientConfig, frozen=True):
+# *** THIS IS A TEST STRATEGY ***
+
+
+class SignalStrategyConfig(StrategyConfig, frozen=True):
     """
-    Configuration for ``BybitDataClient`` instances.
+    Configuration for ``SignalStrategy`` instances.
     """
 
-    api_key: str | None = None
-    api_secret: str | None = None
-    instrument_types: list[BybitInstrumentType] = []
-    base_url_http: str | None = None
-    testnet: bool = False
+    instrument_id: InstrumentId
 
 
-class BybitExecClientConfig(LiveExecClientConfig, frozen=True):
+class SignalStrategy(Strategy):
     """
-    Configuration for ``BybitExecutionClient`` instances.
+    A strategy that simply emits a signal counter (FOR TESTING PURPOSES ONLY).
+
+    Parameters
+    ----------
+    config : OrderbookImbalanceConfig
+        The configuration for the instance.
+
     """
 
-    api_key: str | None = None
-    api_secret: str | None = None
-    instrument_types: list[BybitInstrumentType] = []
-    base_url_http: str | None = None
-    base_url_ws: str | None = None
-    testnet: bool = False
-    clock_sync_interval_secs: int = 0
-    use_reduce_only: bool = True
-    use_position_ids: bool = True
-    treat_expired_as_canceled: bool = False
-    max_retries: PositiveInt | None = None
-    retry_delay: PositiveFloat | None = None
+    def __init__(self, config: SignalStrategyConfig) -> None:
+        super().__init__(config)
+        self.instrument_id = self.config.instrument_id
+        self.instrument: Instrument | None = None
+        self.counter = 0
+
+    def on_start(self) -> None:
+        """
+        Actions to be performed on strategy start.
+        """
+        self.instrument = self.cache.instrument(self.instrument_id)
+        self.subscribe_trade_ticks(instrument_id=self.instrument_id)
+        self.subscribe_quote_ticks(instrument_id=self.instrument_id)
+
+    def on_quote_tick(self, tick: QuoteTick) -> None:
+        """
+        Actions to be performed when the strategy is running and receives a quote tick.
+        """
+        self.counter += 1
+        self.publish_signal(name="counter", value=self.counter, ts_event=tick.ts_event)
+
+    def on_trade_tick(self, tick: TradeTick) -> None:
+        """
+        Actions to be performed when the strategy is running and receives a trade tick.
+        """
+        self.counter += 1
+        self.publish_signal(name="counter", value=self.counter, ts_event=tick.ts_event)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/data.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/data.py`

 * *Files 26% similar despite different names*

```diff
@@ -10,245 +10,264 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import asyncio
+from operator import attrgetter
+from typing import Any
 
-import msgspec
 import pandas as pd
 
-from nautilus_trader.adapters.bybit.common.constants import BYBIT_VENUE
-from nautilus_trader.adapters.bybit.common.enums import BybitEnumParser
-from nautilus_trader.adapters.bybit.common.enums import BybitInstrumentType
-from nautilus_trader.adapters.bybit.config import BybitDataClientConfig
-from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
-from nautilus_trader.adapters.bybit.http.market import BybitMarketHttpAPI
-from nautilus_trader.adapters.bybit.schemas.market.ticker import BybitTickerData
-from nautilus_trader.adapters.bybit.schemas.symbol import BybitSymbol
-from nautilus_trader.adapters.bybit.schemas.ws import BybitWsMessageGeneral
-from nautilus_trader.adapters.bybit.schemas.ws import decoder_ws_ticker
-from nautilus_trader.adapters.bybit.schemas.ws import decoder_ws_trade
-from nautilus_trader.adapters.bybit.utils import get_api_key
-from nautilus_trader.adapters.bybit.utils import get_api_secret
-from nautilus_trader.adapters.bybit.websocket.client import BybitWebsocketClient
+# fmt: off
+from nautilus_trader.adapters.interactive_brokers.client import InteractiveBrokersClient
+from nautilus_trader.adapters.interactive_brokers.common import IB_VENUE
+from nautilus_trader.adapters.interactive_brokers.common import IBContract
+from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersDataClientConfig
+from nautilus_trader.adapters.interactive_brokers.parsing.data import timedelta_to_duration_str
+from nautilus_trader.adapters.interactive_brokers.providers import InteractiveBrokersInstrumentProvider
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.component import LiveClock
 from nautilus_trader.common.component import MessageBus
-from nautilus_trader.common.providers import InstrumentProvider
-from nautilus_trader.core.datetime import secs_to_millis
-from nautilus_trader.core.message import Request
-from nautilus_trader.core.nautilus_pyo3 import Symbol
 from nautilus_trader.core.uuid import UUID4
-from nautilus_trader.data.messages import DataResponse
 from nautilus_trader.live.data_client import LiveMarketDataClient
 from nautilus_trader.model.data import Bar
 from nautilus_trader.model.data import BarType
-from nautilus_trader.model.data import CustomData
 from nautilus_trader.model.data import DataType
+from nautilus_trader.model.data import QuoteTick
 from nautilus_trader.model.data import TradeTick
-from nautilus_trader.model.enums import PriceType
+from nautilus_trader.model.enums import BookType
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import Venue
-from nautilus_trader.model.instruments import Instrument
+from nautilus_trader.model.instruments.currency_pair import CurrencyPair
 
 
-class BybitDataClient(LiveMarketDataClient):
+# fmt: on
+
+
+class InteractiveBrokersDataClient(LiveMarketDataClient):
+    """
+    Provides a data client for the InteractiveBrokers exchange by using the `Gateway` to
+    stream market data.
+
+    Parameters
+    ----------
+    loop : asyncio.AbstractEventLoop
+        The event loop for the client.
+    client : InteractiveBrokersClient
+        The nautilus InteractiveBrokersClient using ibapi.
+    msgbus : MessageBus
+        The message bus for the client.
+    cache : Cache
+        The cache for the client.
+    clock : LiveClock
+        The clock for the client.
+    instrument_provider : InteractiveBrokersInstrumentProvider
+        The instrument provider.
+    ibg_client_id : int
+        Client ID used to connect TWS/Gateway.
+    config : InteractiveBrokersDataClientConfig
+        Configuration for the client.
+    name : str, optional
+        The custom client ID.
+
+    """
+
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
-        client: BybitHttpClient,
+        client: InteractiveBrokersClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
-        instrument_provider: InstrumentProvider,
-        instrument_types: list[BybitInstrumentType],
-        ws_urls: dict[BybitInstrumentType, str],
-        config: BybitDataClientConfig,
+        instrument_provider: InteractiveBrokersInstrumentProvider,
+        ibg_client_id: int,
+        config: InteractiveBrokersDataClientConfig,
+        name: str | None = None,
     ) -> None:
-        self._instrument_types = instrument_types
-        self._enum_parser = BybitEnumParser()
         super().__init__(
             loop=loop,
-            client_id=ClientId(BYBIT_VENUE.value),
-            venue=BYBIT_VENUE,
+            client_id=ClientId(name or f"{IB_VENUE.value}-{ibg_client_id:03d}"),
+            venue=None,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             instrument_provider=instrument_provider,
+            config=config,
         )
+        self._client = client
+        self._handle_revised_bars = config.handle_revised_bars
+        self._use_regular_trading_hours = config.use_regular_trading_hours
+        self._market_data_type = config.market_data_type
+
+    @property
+    def instrument_provider(self) -> InteractiveBrokersInstrumentProvider:
+        return self._instrument_provider  # type: ignore
+
+    async def _connect(self):
+        # Connect client
+        await self._client.wait_until_ready()
+        self._client.registered_nautilus_clients.add(self.id)
+
+        # Set Market Data Type
+        await self._client.set_market_data_type(self._market_data_type)
+
+        # Load instruments based on config
+        await self.instrument_provider.initialize()
+        for instrument in self._instrument_provider.list_all():
+            self._handle_data(instrument)
 
-        # Hot cache
-        self._instrument_ids: dict[str, InstrumentId] = {}
+    async def _disconnect(self):
+        self._client.registered_nautilus_clients.remove(self.id)
+        if self._client.is_running and self._client.registered_nautilus_clients == set():
+            self._client.stop()
 
-        # HTTP API
-        self._http_market = BybitMarketHttpAPI(
-            client=client,
-            clock=clock,
+    async def _subscribe(self, data_type: DataType) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_subscribe` coroutine",  # pragma: no cover
+        )
+
+    async def _subscribe_instruments(self) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_subscribe_instruments` coroutine",  # pragma: no cover
         )
 
-        # WebSocket API
-        self._ws_clients: dict[BybitInstrumentType, BybitWebsocketClient] = {}
-        for instrument_type in instrument_types:
-            self._ws_clients[instrument_type] = BybitWebsocketClient(
-                clock=clock,
-                handler=lambda x: self._handle_ws_message(instrument_type, x),
-                base_url=ws_urls[instrument_type],
-                api_key=config.api_key or get_api_key(config.testnet),
-                api_secret=config.api_secret or get_api_secret(config.testnet),
-            )
-
-            # web socket decoders
-            self._decoders = {
-                "trade": decoder_ws_trade(),
-                "ticker": decoder_ws_ticker(instrument_type),
-            }
-            self._decoder_ws_msg_general = msgspec.json.Decoder(BybitWsMessageGeneral)
-
-        self._update_instrument_interval: int = 60 * 60  # Once per hour (hardcode)
-        self._update_instruments_task: asyncio.Task | None = None
-
-        # Register custom endpoint for fetching tickers
-        self._msgbus.register(
-            endpoint="bybit.data.tickers",
-            handler=self.complete_fetch_tickers_task,
+    async def _subscribe_instrument(self, instrument_id: InstrumentId) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_subscribe_instrument` coroutine",  # pragma: no cover
         )
 
-    async def fetch_send_tickers(
+    async def _subscribe_order_book_deltas(
         self,
-        id: UUID4,
-        instrument_type: BybitInstrumentType,
-        symbol: str,
-    ):
-        tickers = await self._http_market.fetch_tickers(
-            instrument_type=instrument_type,
-            symbol=symbol,
-        )
-        data = DataResponse(
-            client_id=ClientId(BYBIT_VENUE.value),
-            venue=BYBIT_VENUE,
-            data_type=DataType(CustomData),
-            data=tickers,
-            correlation_id=id,
-            response_id=UUID4(),
-            ts_init=self._clock.timestamp_ns(),
-        )
-        self._msgbus.response(data)
-
-    def complete_fetch_tickers_task(self, request: Request):
-        # extract symbol from metadat
-        if "symbol" not in request.metadata:
-            raise ValueError("Symbol not in request metadata")
-        symbol = request.metadata["symbol"]
-        if not isinstance(symbol, Symbol):
-            raise ValueError(
-                f"Parameter symbol in request metadata object is not of type Symbol, got {type(symbol)}",
-            )
-        bybit_symbol = BybitSymbol(symbol.value)
-        self._loop.create_task(
-            self.fetch_send_tickers(
-                request.id,
-                bybit_symbol.instrument_type,
-                bybit_symbol.raw_symbol,
-            ),
-        )
-
-    async def _connect(self) -> None:
-        self._log.info("Initializing instruments...")
-        await self._instrument_provider.initialize()
-
-        self._send_all_instruments_to_data_engine()
-        self._update_instruments_task = self.create_task(self._update_instruments())
-        self._log.info("Initializing websocket connections.")
-        for instrument_type, ws_client in self._ws_clients.items():
-            await ws_client.connect()
-        self._log.info("Data client connected.")
+        instrument_id: InstrumentId,
+        book_type: BookType,
+        depth: int | None = None,
+        kwargs: dict[str, Any] | None = None,
+    ) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_subscribe_order_book_deltas` coroutine",  # pragma: no cover
+        )
 
-    def _send_all_instruments_to_data_engine(self) -> None:
-        for instrument in self._instrument_provider.get_all().values():
-            self._handle_data(instrument)
+    async def _subscribe_order_book_snapshots(
+        self,
+        instrument_id: InstrumentId,
+        book_type: BookType,
+        depth: int | None = None,
+        kwargs: dict[str, Any] | None = None,
+    ) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_subscribe_order_book_snapshots` coroutine",  # pragma: no cover
+        )
 
-        for currency in self._instrument_provider.currencies().values():
-            self._cache.add_currency(currency)
+    async def _subscribe_quote_ticks(self, instrument_id: InstrumentId) -> None:
+        if not (instrument := self._cache.instrument(instrument_id)):
+            self._log.error(
+                f"Cannot subscribe to QuoteTicks for {instrument_id}, Instrument not found.",
+            )
+            return
 
-    async def _update_instruments(self) -> None:
-        try:
-            while True:
-                self._log.debug(
-                    f"Scheduled `update_instruments` to run in "
-                    f"{self._update_instrument_interval}s.",
-                )
-                await asyncio.sleep(self._update_instrument_interval)
-                await self._instrument_provider.load_all_async()
-                self._send_all_instruments_to_data_engine()
-        except asyncio.CancelledError:
-            self._log.debug("Canceled `update_instruments` task.")
+        await self._client.subscribe_ticks(
+            instrument_id=instrument_id,
+            contract=IBContract(**instrument.info["contract"]),
+            tick_type="BidAsk",
+        )
 
     async def _subscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:
-        symbol = BybitSymbol(instrument_id.symbol.value)
-        ws_client = self._ws_clients[symbol.instrument_type]
-        await ws_client.subscribe_trades(symbol.raw_symbol)
-        self._log.info(f"Subscribed to trade ticks for {instrument_id}.")
-
-    # async def _subscribe_ticker(self, instrument_id: InstrumentId) -> None:
-    #     symbol = BybitSymbol(instrument_id.symbol.value)
-    #     ws_client = self._ws_clients[symbol.instrument_type]
-    #     await ws_client.subscribe_tickers(symbol.raw_symbol)
-    #     self._log.info(f"Subscribed to ticker for {instrument_id}.")
-
-    def _handle_ws_message(self, instrument_type: BybitInstrumentType, raw: bytes) -> None:
-        try:
-            ws_message = self._decoder_ws_msg_general.decode(raw)
-            if ws_message.success is False:
-                self._log.error(f"Error in ws_message: {ws_message.ret_msg}")
-                return
-            ## check if there is topic, if not discard it
-            if ws_message.topic:
-                self._topic_check(instrument_type, ws_message.topic, raw)
-        except Exception as e:
-            decoded_raw = raw.decode("utf-8")
-            raise RuntimeError(f"Unknown websocket message type: {decoded_raw}") from e
-
-    def _handle_trade(self, instrument_type: BybitInstrumentType, raw: bytes) -> None:
-        try:
-            msg = self._decoders["trade"].decode(raw)
-            for trade in msg.data:
-                symbol = trade.s + f"-{instrument_type.value.upper()}"
-                instrument_id: InstrumentId = self._get_cached_instrument_id(symbol)
-                trade_tick: TradeTick = trade.parse_to_trade_tick(
-                    instrument_id,
-                    self._clock.timestamp_ns(),
-                )
-                self._handle_data(trade_tick)
-        except Exception as e:
-            print("error in handle trade", e)
-            decoded_raw = raw.decode("utf-8")
-            self._log.error(f"Failed to parse trade tick: {decoded_raw}")
-
-    def _handle_ticker(self, instrument_type: BybitInstrumentType, raw: bytes) -> None:
-        try:
-            self._decoders["ticker"].decode(raw)
-        except Exception:
-            print("failed to parse ticker ", raw)
-
-    def _topic_check(self, instrument_type: BybitInstrumentType, topic: str, raw: bytes) -> None:
-        if "publicTrade" in topic:
-            self._handle_trade(instrument_type, raw)
-        elif "tickers" in topic:
-            self._handle_ticker(instrument_type, raw)
+        if not (instrument := self._cache.instrument(instrument_id)):
+            self._log.error(
+                f"Cannot subscribe to TradeTicks for {instrument_id}, Instrument not found.",
+            )
+            return
+
+        if isinstance(instrument, CurrencyPair):
+            self._log.error(
+                "InteractiveBrokers doesn't support Trade Ticks for CurrencyPair.",
+            )
+            return
+
+        await self._client.subscribe_ticks(
+            instrument_id=instrument_id,
+            contract=IBContract(**instrument.info["contract"]),
+            tick_type="AllLast",
+        )
+
+    async def _subscribe_bars(self, bar_type: BarType) -> None:
+        if not (instrument := self._cache.instrument(bar_type.instrument_id)):
+            self._log.error(f"Cannot subscribe to {bar_type}, Instrument not found.")
+            return
+
+        if bar_type.spec.timedelta.total_seconds() == 5:
+            await self._client.subscribe_realtime_bars(
+                bar_type=bar_type,
+                contract=IBContract(**instrument.info["contract"]),
+                use_rth=self._use_regular_trading_hours,
+            )
+        else:
+            await self._client.subscribe_historical_bars(
+                bar_type=bar_type,
+                contract=IBContract(**instrument.info["contract"]),
+                use_rth=self._use_regular_trading_hours,
+                handle_revised_bars=self._handle_revised_bars,
+            )
+
+    async def _subscribe_instrument_status(self, instrument_id: InstrumentId) -> None:
+        pass  # Subscribed as part of orderbook
+
+    async def _subscribe_instrument_close(self, instrument_id: InstrumentId) -> None:
+        pass  # Subscribed as part of orderbook
+
+    async def _unsubscribe(self, data_type: DataType) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_unsubscribe` coroutine",  # pragma: no cover
+        )
+
+    async def _unsubscribe_instruments(self) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_unsubscribe_instruments` coroutine",  # pragma: no cover
+        )
+
+    async def _unsubscribe_instrument(self, instrument_id: InstrumentId) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_unsubscribe_instrument` coroutine",  # pragma: no cover
+        )
+
+    async def _unsubscribe_order_book_deltas(self, instrument_id: InstrumentId) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_unsubscribe_order_book_deltas` coroutine",  # pragma: no cover
+        )
+
+    async def _unsubscribe_order_book_snapshots(self, instrument_id: InstrumentId) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_unsubscribe_order_book_snapshots` coroutine",  # pragma: no cover
+        )
+
+    async def _unsubscribe_quote_ticks(self, instrument_id: InstrumentId) -> None:
+        await self._client.unsubscribe_ticks(instrument_id, "BidAsk")
+
+    async def _unsubscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:
+        await self._client.unsubscribe_ticks(instrument_id, "AllLast")
+
+    async def _unsubscribe_bars(self, bar_type: BarType) -> None:
+        if bar_type.spec.timedelta == 5:
+            await self._client.unsubscribe_realtime_bars(bar_type)
         else:
-            self._log.error(f"Unknown websocket message topic: {topic} in Bybit")
+            await self._client.unsubscribe_historical_bars(bar_type)
 
-    def _get_cached_instrument_id(self, symbol: str) -> InstrumentId:
-        # Parse instrument ID
-        bybit_symbol = BybitSymbol(symbol)
-        nautilus_instrument_id: InstrumentId = bybit_symbol.parse_as_nautilus()
-        return nautilus_instrument_id
+    async def _unsubscribe_instrument_status(self, instrument_id: InstrumentId) -> None:
+        pass  # Subscribed as part of orderbook
+
+    async def _unsubscribe_instrument_close(self, instrument_id: InstrumentId) -> None:
+        pass  # Subscribed as part of orderbook
+
+    async def _request(self, data_type: DataType, correlation_id: UUID4) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_request` coroutine",  # pragma: no cover
+        )
 
     async def _request_instrument(
         self,
         instrument_id: InstrumentId,
         correlation_id: UUID4,
         start: pd.Timestamp | None = None,
         end: pd.Timestamp | None = None,
@@ -259,148 +278,177 @@
             )
 
         if end is not None:
             self._log.warning(
                 f"Requesting instrument {instrument_id} with specified `end` which has no effect.",
             )
 
-        instrument: Instrument | None = self._instrument_provider.find(instrument_id)
-        if instrument is None:
-            self._log.error(f"Cannot find instrument for {instrument_id}.")
-            return
-        data_type = DataType(
-            type=Instrument,
-            metadata={"instrument_id": instrument_id},
-        )
-        self._handle_data_response(
-            data_type=data_type,
-            data=instrument,
-            correlation_id=correlation_id,
-        )
+        await self.instrument_provider.load_async(instrument_id)
+        if instrument := self.instrument_provider.find(instrument_id):
+            self._handle_data(instrument)
+        else:
+            self._log.warning(f"{instrument_id} not available.")
+            return
+        self._handle_instrument(instrument, correlation_id)
 
     async def _request_instruments(
         self,
         venue: Venue,
         correlation_id: UUID4,
         start: pd.Timestamp | None = None,
         end: pd.Timestamp | None = None,
     ) -> None:
-        if start is not None:
-            self._log.warning(
-                f"Requesting instruments for {venue} with specified `start` which has no effect.",
-            )
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_request_instruments` coroutine",  # pragma: no cover
+        )
 
-        if end is not None:
-            self._log.warning(
-                f"Requesting instruments for {venue} with specified `end` which has no effect.",
+    async def _request_quote_ticks(
+        self,
+        instrument_id: InstrumentId,
+        limit: int,
+        correlation_id: UUID4,
+        start: pd.Timestamp | None = None,
+        end: pd.Timestamp | None = None,
+    ) -> None:
+        if not (instrument := self._cache.instrument(instrument_id)):
+            self._log.error(
+                f"Cannot request QuoteTicks for {instrument_id}, Instrument not found.",
             )
+            return
 
-        all_instruments = self._instrument_provider.get_all()
-        target_instruments = []
-        for instrument in all_instruments.values():
-            if instrument.venue == venue:
-                target_instruments.append(instrument)
-        data_type = DataType(
-            type=Instrument,
-            metadata={"venue": venue},
-        )
-        self._handle_data_response(
-            data_type=data_type,
-            data=target_instruments,
-            correlation_id=correlation_id,
+        ticks = await self._handle_ticks_request(
+            IBContract(**instrument.info["contract"]),
+            "BID_ASK",
+            limit,
+            start,
+            end,
         )
+        if not ticks:
+            self._log.warning(f"QuoteTicks not received for {instrument_id}")
+            return
 
-    async def _request_bars(
+        self._handle_quote_ticks(instrument_id, ticks, correlation_id)
+
+    async def _request_trade_ticks(
         self,
-        bar_type: BarType,
+        instrument_id: InstrumentId,
         limit: int,
         correlation_id: UUID4,
         start: pd.Timestamp | None = None,
         end: pd.Timestamp | None = None,
     ) -> None:
-        if limit == 0 or limit > 1000:
-            limit = 1000
+        if not (instrument := self._cache.instrument(instrument_id)):
+            self._log.error(
+                f"Cannot request TradeTicks for {instrument_id}, Instrument not found.",
+            )
+            return
 
-        if bar_type.is_internally_aggregated():
+        if isinstance(instrument, CurrencyPair):
             self._log.error(
-                f"Cannot request {bar_type}: "
-                f"only historical bars with EXTERNAL aggregation available from Bybit.",
+                "InteractiveBrokers doesn't support Trade Ticks for CurrencyPair.",
             )
             return
 
-        if not bar_type.spec.is_time_aggregated():
+        ticks = await self._handle_ticks_request(
+            IBContract(**instrument.info["contract"]),
+            "TRADES",
+            limit,
+            start,
+            end,
+        )
+        if not ticks:
+            self._log.warning(f"TradeTicks not received for {instrument_id}")
+            return
+
+        self._handle_trade_ticks(instrument_id, ticks, correlation_id)
+
+    async def _handle_ticks_request(
+        self,
+        contract: IBContract,
+        tick_type: str,
+        limit: int,
+        start: pd.Timestamp | None = None,
+        end: pd.Timestamp | None = None,
+    ) -> list[QuoteTick | TradeTick]:
+        if not start:
+            limit = self._cache.tick_capacity
+
+        if not end:
+            end = pd.Timestamp.utcnow()
+
+        ticks: list[QuoteTick | TradeTick] = []
+        while (start and end > start) or (len(ticks) < limit > 0):
+            await self._client.wait_until_ready()
+            ticks_part = await self._client.get_historical_ticks(
+                contract,
+                tick_type,
+                end_date_time=end,
+                use_rth=self._use_regular_trading_hours,
+            )
+            if not ticks_part:
+                break
+            end = pd.Timestamp(min(ticks_part, key=attrgetter("ts_init")).ts_init, tz="UTC")
+            ticks.extend(ticks_part)
+
+        ticks.sort(key=lambda x: x.ts_init)
+        return ticks
+
+    async def _request_bars(
+        self,
+        bar_type: BarType,
+        limit: int,
+        correlation_id: UUID4,
+        start: pd.Timestamp | None = None,
+        end: pd.Timestamp | None = None,
+    ) -> None:
+        if not (instrument := self._cache.instrument(bar_type.instrument_id)):
             self._log.error(
-                f"Cannot request {bar_type}: only time bars are aggregated by Bybit.",
+                f"Cannot request {bar_type}, Instrument not found.",
             )
             return
 
-        if bar_type.spec.price_type != PriceType.LAST:
+        if not bar_type.spec.is_time_aggregated():
             self._log.error(
-                f"Cannot request {bar_type}: "
-                f"only historical bars for LAST price type available from Binance.",
+                f"Cannot request {bar_type}: only time bars are aggregated by InteractiveBrokers.",
             )
             return
 
-        bybit_interval = self._enum_parser.parse_bybit_kline(bar_type)
-        start_time_ms = None
-        if start is not None:
-            start_time_ms = secs_to_millis(start.timestamp())
+        if not start and limit == 0:
+            limit = 1000
 
-        end_time_ms = None
-        if end is not None:
-            end_time_ms = secs_to_millis(end.timestamp())
-        bars = await self._http_market.request_bybit_bars(
-            # TODO fixing instrument here so that mypy passes,need to determine how to get instrument type from bar
-            instrument_type=BybitInstrumentType.SPOT,
-            bar_type=bar_type,
-            interval=bybit_interval,
-            start=start_time_ms,
-            end=end_time_ms,
-            limit=limit,
-            ts_init=self._clock.timestamp_ns(),
-        )
-        partial: Bar = bars.pop()
-        self._handle_bars(bar_type, bars, partial, correlation_id)
-
-    async def _disconnect(self) -> None:
-        if self._update_instruments_task:
-            self._log.debug("Cancelling `update_instruments` task.")
-            self._update_instruments_task.cancel()
-            self._update_instruments_task = None
-        for instrument_type, ws_client in self._ws_clients.items():
-            await ws_client.disconnect()
-
-    async def _handle_ticker_data_request(self, symbol: Symbol, correlation_id: UUID4) -> None:
-        bybit_symbol = BybitSymbol(symbol.value)
-        bybit_tickers = await self._http_market.fetch_tickers(
-            instrument_type=bybit_symbol.instrument_type,
-            symbol=bybit_symbol.raw_symbol,
-        )
-        data_type = DataType(
-            type=BybitTickerData,
-            metadata={"symbol": symbol},
-        )
-        result = []
-        for ticker in bybit_tickers:
-            ticker_data: BybitTickerData = BybitTickerData(
-                symbol=ticker.symbol,
-                bid1Price=ticker.bid1Price,
-                bid1Size=ticker.bid1Size,
-                ask1Price=ticker.ask1Price,
-                ask1Size=ticker.ask1Size,
-                lastPrice=ticker.lastPrice,
-                highPrice24h=ticker.highPrice24h,
-                lowPrice24h=ticker.lowPrice24h,
-                turnover24h=ticker.turnover24h,
-                volume24h=ticker.volume24h,
-            )
-            result.append(ticker_data)
-        self._handle_data_response(
-            data_type,
-            result,
-            correlation_id,
-        )
+        if not end:
+            end = pd.Timestamp.utcnow()
 
-    async def _request(self, data_type: DataType, correlation_id: UUID4) -> None:
-        if data_type.type == BybitTickerData:
-            symbol = data_type.metadata["symbol"]
-            await self._handle_ticker_data_request(symbol, correlation_id)
+        if start:
+            duration = end - start
+            duration_str = timedelta_to_duration_str(duration)
+        else:
+            duration_str = "7 D" if bar_type.spec.timedelta.total_seconds() >= 60 else "1 D"
+
+        bars: list[Bar] = []
+        while (start and end > start) or (len(bars) < limit > 0):
+            bars_part: list[Bar] = await self._client.get_historical_bars(
+                bar_type=bar_type,
+                contract=IBContract(**instrument.info["contract"]),
+                use_rth=self._use_regular_trading_hours,
+                end_date_time=end,
+                duration=duration_str,
+            )
+            bars.extend(bars_part)
+            if not bars_part or start:
+                break
+            end = pd.Timestamp(min(bars, key=attrgetter("ts_event")).ts_event, tz="UTC")
+
+        if bars:
+            bars = list(set(bars))
+            bars.sort(key=lambda x: x.ts_init)
+            self._handle_bars(bar_type, bars, bars[0], correlation_id)
+            status_msg = {"id": correlation_id, "status": "Success"}
+        else:
+            self._log.warning(f"Bar Data not received for {bar_type}")
+            status_msg = {"id": correlation_id, "status": "Failed"}
+
+        # Publish Status event
+        self._msgbus.publish(
+            topic=f"requests.{correlation_id}",
+            msg=status_msg,
+        )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/account/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/account/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/account/fee_rate.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/account/wallet_balance.py`

 * *Files 10% similar despite different names*

```diff
@@ -12,41 +12,41 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import msgspec
 
 from nautilus_trader.adapters.bybit.common.enums import BybitEndpointType
-from nautilus_trader.adapters.bybit.common.enums import BybitInstrumentType
 from nautilus_trader.adapters.bybit.endpoints.endpoint import BybitHttpEndpoint
 from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
-from nautilus_trader.adapters.bybit.schemas.account.fee_rate import BybitFeeRateResponse
+from nautilus_trader.adapters.bybit.schemas.account.balance import BybitWalletBalanceResponse
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
-class BybitFeeRateGetParameters(msgspec.Struct, omit_defaults=True, frozen=False):
-    category: BybitInstrumentType | None = None
-    symbol: str | None = None
-    baseCoin: str | None = None
+class BybitWalletBalanceGetParams(msgspec.Struct, omit_defaults=True, frozen=True):
+    accountType: str | None = None
+    coin: str | None = None
 
 
-class BybitFeeRateEndpoint(BybitHttpEndpoint):
+class BybitWalletBalanceEndpoint(BybitHttpEndpoint):
     def __init__(
         self,
         client: BybitHttpClient,
         base_endpoint: str,
     ) -> None:
         self.http_method = HttpMethod.GET
-        url_path = base_endpoint + "/account/fee-rate"
+        url_path = base_endpoint + "/account/wallet-balance"
         super().__init__(
             client=client,
             endpoint_type=BybitEndpointType.ACCOUNT,
             url_path=url_path,
         )
-        self._get_resp_decoder = msgspec.json.Decoder(BybitFeeRateResponse)
+        self._get_resp_decoder = msgspec.json.Decoder(BybitWalletBalanceResponse)
 
-    async def get(self, parameters: BybitFeeRateGetParameters) -> BybitFeeRateResponse:
-        raw = await self._method(self.http_method, parameters)
+    async def get(self, params: BybitWalletBalanceGetParams) -> BybitWalletBalanceResponse:
+        raw = await self._method(self.http_method, params)
         try:
             return self._get_resp_decoder.decode(raw)
         except Exception as e:
-            raise RuntimeError(f"Failed to decode response fee rate response: {raw!s}") from e
+            raise RuntimeError(
+                f"Failed to decode response from {self.url_path}: {raw.decode()}",
+            ) from e
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/account/position_info.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/open_orders.py`

 * *Files 12% similar despite different names*

```diff
@@ -12,44 +12,46 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import msgspec
 
 from nautilus_trader.adapters.bybit.common.enums import BybitEndpointType
+from nautilus_trader.adapters.bybit.common.enums import BybitProductType
 from nautilus_trader.adapters.bybit.endpoints.endpoint import BybitHttpEndpoint
 from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
-from nautilus_trader.adapters.bybit.schemas.position import BybitPositionResponseStruct
-from nautilus_trader.adapters.bybit.schemas.symbol import BybitSymbol
+from nautilus_trader.adapters.bybit.schemas.order import BybitOpenOrdersResponseStruct
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
-class PositionInfoGetParameters(msgspec.Struct, omit_defaults=True, frozen=False):
-    category: str | None = None
-    symbol: BybitSymbol | None = None
+class BybitOpenOrdersGetParams(msgspec.Struct, omit_defaults=True, frozen=True):
+    category: BybitProductType
+    symbol: str | None = None
+    baseCoin: str | None = None
     settleCoin: str | None = None
+    orderId: str | None = None
+    orderLinkId: str | None = None
 
 
-class BybitPositionInfoEndpoint(BybitHttpEndpoint):
+class BybitOpenOrdersEndpoint(BybitHttpEndpoint):
     def __init__(
         self,
         client: BybitHttpClient,
         base_endpoint: str,
     ) -> None:
-        url_path = base_endpoint + "/position/list"
+        url_path = base_endpoint + "/order/realtime"
         super().__init__(
             client=client,
-            endpoint_type=BybitEndpointType.ACCOUNT,
+            endpoint_type=BybitEndpointType.TRADE,
             url_path=url_path,
         )
-        self._get_resp_decoder = msgspec.json.Decoder(BybitPositionResponseStruct)
+        self._get_resp_decoder = msgspec.json.Decoder(BybitOpenOrdersResponseStruct)
 
-    async def get(self, parameters: PositionInfoGetParameters) -> BybitPositionResponseStruct:
+    async def get(self, params: BybitOpenOrdersGetParams) -> BybitOpenOrdersResponseStruct:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         try:
             return self._get_resp_decoder.decode(raw)
         except Exception as e:
-            decoded_raw = raw.decode("utf-8")
             raise RuntimeError(
-                f"Failed to decode response position info response: {decoded_raw}",
+                f"Failed to decode response from {self.url_path}: {raw.decode()}",
             ) from e
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/account/wallet_balance.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/trade_history.py`

 * *Files 18% similar despite different names*

```diff
@@ -12,42 +12,51 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import msgspec
 
 from nautilus_trader.adapters.bybit.common.enums import BybitEndpointType
+from nautilus_trader.adapters.bybit.common.enums import BybitExecType
+from nautilus_trader.adapters.bybit.common.enums import BybitProductType
 from nautilus_trader.adapters.bybit.endpoints.endpoint import BybitHttpEndpoint
 from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
-from nautilus_trader.adapters.bybit.schemas.account.balance import BybitWalletBalanceResponse
+from nautilus_trader.adapters.bybit.schemas.trade import BybitTradeHistoryResponseStruct
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
-class BybitWalletBalanceGetParameters(msgspec.Struct, omit_defaults=True, frozen=False):
-    accountType: str | None = None
-    coin: str | None = None
+class BybitTradeHistoryGetParams(msgspec.Struct, omit_defaults=True, frozen=True):
+    category: BybitProductType
+    symbol: str | None = None
+    baseCoin: str | None = None
+    orderId: str | None = None
+    orderLinkId: str | None = None
+    startTime: int | None = None
+    endtime: int | None = None
+    execType: BybitExecType | None = None
+    limit: int | None = None
+    cursor: str | None = None
 
 
-class BybitWalletBalanceEndpoint(BybitHttpEndpoint):
+class BybitTradeHistoryEndpoint(BybitHttpEndpoint):
     def __init__(
         self,
         client: BybitHttpClient,
         base_endpoint: str,
     ) -> None:
-        self.http_method = HttpMethod.GET
-        url_path = base_endpoint + "/account/wallet-balance"
+        url_path = base_endpoint + "/execution/list"
         super().__init__(
             client=client,
-            endpoint_type=BybitEndpointType.ACCOUNT,
+            endpoint_type=BybitEndpointType.TRADE,
             url_path=url_path,
         )
-        self._get_resp_decoder = msgspec.json.Decoder(BybitWalletBalanceResponse)
+        self._get_resp_decoder = msgspec.json.Decoder(BybitTradeHistoryResponseStruct)
 
-    async def get(self, parameters: BybitWalletBalanceGetParameters) -> BybitWalletBalanceResponse:
-        raw = await self._method(self.http_method, parameters)
+    async def get(self, params: BybitTradeHistoryGetParams) -> BybitTradeHistoryResponseStruct:
+        method_type = HttpMethod.GET
+        raw = await self._method(method_type, params)
         try:
             return self._get_resp_decoder.decode(raw)
         except Exception as e:
-            decoded_raw = raw.decode("utf-8")
             raise RuntimeError(
-                f"Failed to decode response wallet balance response: {decoded_raw}",
+                f"Failed to decode response from {self.url_path}: {raw.decode()}",
             ) from e
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/asset/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/asset/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/endpoint.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/endpoint.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,16 +14,16 @@
 # -------------------------------------------------------------------------------------------------
 
 from typing import Any
 
 import msgspec
 
 from nautilus_trader.adapters.bybit.common.enums import BybitEndpointType
+from nautilus_trader.adapters.bybit.common.symbol import BybitSymbol
 from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
-from nautilus_trader.adapters.bybit.schemas.symbol import BybitSymbol
 
 
 def enc_hook(obj: Any) -> Any:
     if isinstance(obj, BybitSymbol):
         return str(obj)
     else:
         raise TypeError(f"Objects of type {type(obj)} are not supported")
@@ -42,25 +42,26 @@
 
         self.decoder = msgspec.json.Decoder()
         self.encoder = msgspec.json.Encoder(enc_hook=enc_hook)
 
         self._method_request: dict[BybitEndpointType, Any] = {
             BybitEndpointType.NONE: self.client.send_request,
             BybitEndpointType.MARKET: self.client.send_request,
+            BybitEndpointType.ASSET: self.client.sign_request,
             BybitEndpointType.ACCOUNT: self.client.sign_request,
             BybitEndpointType.TRADE: self.client.sign_request,
         }
 
     async def _method(
         self,
         method_type: Any,
-        parameters: Any | None = None,
+        params: Any | None = None,
         ratelimiter_keys: Any | None = None,
     ) -> bytes:
-        payload: dict = self.decoder.decode(self.encoder.encode(parameters))
+        payload: dict = self.decoder.decode(self.encoder.encode(params))
         method_call = self._method_request[self.endpoint_type]
         raw: bytes = await method_call(
             http_method=method_type,
             url_path=self.url_path,
             payload=payload,
             ratelimiter_keys=ratelimiter_keys,
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/market/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/market/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/market/instruments_info.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/market/instruments_info.py`

 * *Files 8% similar despite different names*

```diff
@@ -12,25 +12,26 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import msgspec
 
 from nautilus_trader.adapters.bybit.common.enums import BybitEndpointType
-from nautilus_trader.adapters.bybit.common.enums import BybitInstrumentType
+from nautilus_trader.adapters.bybit.common.enums import BybitProductType
 from nautilus_trader.adapters.bybit.endpoints.endpoint import BybitHttpEndpoint
 from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
+from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrumentsInverseResponse
 from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrumentsLinearResponse
 from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrumentsOptionResponse
 from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrumentsSpotResponse
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
-class BybitInstrumentsInfoGetParameters(msgspec.Struct, omit_defaults=True, frozen=False):
-    category: BybitInstrumentType | None = None
+class BybitInstrumentsInfoGetParams(msgspec.Struct, omit_defaults=True, frozen=True):
+    category: BybitProductType | None = None
     symbol: str | None = None
     status: str | None = None
 
 
 class BybitInstrumentsInfoEndpoint(BybitHttpEndpoint):
     def __init__(
         self,
@@ -39,31 +40,39 @@
     ) -> None:
         url_path = base_endpoint + "instruments-info"
         super().__init__(
             client=client,
             endpoint_type=BybitEndpointType.MARKET,
             url_path=url_path,
         )
+        self._response_decoder_instrument_spot = msgspec.json.Decoder(BybitInstrumentsSpotResponse)
         self._response_decoder_instrument_linear = msgspec.json.Decoder(
             BybitInstrumentsLinearResponse,
         )
-        self._response_decoder_instrument_spot = msgspec.json.Decoder(BybitInstrumentsSpotResponse)
+        self._response_decoder_instrument_inverse = msgspec.json.Decoder(
+            BybitInstrumentsInverseResponse,
+        )
         self._response_decoder_instrument_option = msgspec.json.Decoder(
             BybitInstrumentsOptionResponse,
         )
 
     async def get(
         self,
-        parameters: BybitInstrumentsInfoGetParameters,
-    ) -> BybitInstrumentsLinearResponse | (
-        BybitInstrumentsSpotResponse | BybitInstrumentsOptionResponse
+        params: BybitInstrumentsInfoGetParams,
+    ) -> (
+        BybitInstrumentsSpotResponse
+        | BybitInstrumentsLinearResponse
+        | BybitInstrumentsInverseResponse
+        | BybitInstrumentsOptionResponse
     ):
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
-        if parameters.category == BybitInstrumentType.LINEAR:
-            return self._response_decoder_instrument_linear.decode(raw)
-        elif parameters.category == BybitInstrumentType.SPOT:
+        raw = await self._method(method_type, params)
+        if params.category == BybitProductType.SPOT:
             return self._response_decoder_instrument_spot.decode(raw)
-        elif parameters.category == BybitInstrumentType.OPTION:
+        elif params.category == BybitProductType.LINEAR:
+            return self._response_decoder_instrument_linear.decode(raw)
+        elif params.category == BybitProductType.INVERSE:
+            return self._response_decoder_instrument_inverse.decode(raw)
+        elif params.category == BybitProductType.OPTION:
             return self._response_decoder_instrument_option.decode(raw)
         else:
-            raise ValueError("Invalid account type")
+            raise ValueError(f"Invalid product type, was {params.category}")
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/market/klines.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/market/klines.py`

 * *Files 15% similar despite different names*

```diff
@@ -19,15 +19,15 @@
 from nautilus_trader.adapters.bybit.common.enums import BybitKlineInterval
 from nautilus_trader.adapters.bybit.endpoints.endpoint import BybitHttpEndpoint
 from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
 from nautilus_trader.adapters.bybit.schemas.market.kline import BybitKlinesResponse
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
-class BybitKlinesGetParameters(msgspec.Struct, omit_defaults=True, frozen=False):
+class BybitKlinesGetParams(msgspec.Struct, omit_defaults=True, frozen=True):
     category: str
     symbol: str
     interval: BybitKlineInterval
     start: int | None = None
     end: int | None = None
     limit: int | None = None
 
@@ -44,12 +44,12 @@
             endpoint_type=BybitEndpointType.MARKET,
             url_path=url_path,
         )
         self._response_decoder = msgspec.json.Decoder(BybitKlinesResponse)
 
     async def get(
         self,
-        parameters: BybitKlinesGetParameters,
+        params: BybitKlinesGetParams,
     ) -> BybitKlinesResponse:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         return self._response_decoder.decode(raw)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/market/server_time.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/market/server_time.py`

 * *Files 12% similar despite different names*

```diff
@@ -38,11 +38,10 @@
 
     async def get(self) -> BybitServerTimeResponse:
         method_type = HttpMethod.GET
         raw = await self._method(method_type)
         try:
             return self._get_resp_decoder.decode(raw)
         except Exception as e:
-            decoder_raw = raw.decode("utf-8")
             raise RuntimeError(
-                f"Failed to decode response server time response: {decoder_raw}",
+                f"Failed to decode response from {self.url_path}: {raw.decode()}",
             ) from e
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/market/tickers.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/market/tickers.py`

 * *Files 16% similar despite different names*

```diff
@@ -12,28 +12,28 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import msgspec
 
 from nautilus_trader.adapters.bybit.common.enums import BybitEndpointType
-from nautilus_trader.adapters.bybit.common.enums import BybitInstrumentType
+from nautilus_trader.adapters.bybit.common.enums import BybitProductType
 from nautilus_trader.adapters.bybit.endpoints.endpoint import BybitHttpEndpoint
 from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
 from nautilus_trader.adapters.bybit.schemas.market.ticker import BybitTickersLinearResponse
 from nautilus_trader.adapters.bybit.schemas.market.ticker import BybitTickersOptionResponse
 from nautilus_trader.adapters.bybit.schemas.market.ticker import BybitTickersResponse
 from nautilus_trader.adapters.bybit.schemas.market.ticker import BybitTickersSpotResponse
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
-class BybitTickersGetParameters(msgspec.Struct, omit_defaults=True, frozen=False):
-    category: BybitInstrumentType = None
-    symbol: str = None
-    baseCoin: str = None
+class BybitTickersGetParams(msgspec.Struct, omit_defaults=True, frozen=True):
+    category: BybitProductType | None = None
+    symbol: str | None = None
+    baseCoin: str | None = None
 
 
 class BybitTickersEndpoint(BybitHttpEndpoint):
     def __init__(
         self,
         client: BybitHttpClient,
         base_endpoint: str,
@@ -44,26 +44,26 @@
             endpoint_type=BybitEndpointType.MARKET,
             url_path=url_path,
         )
         self._response_decoder_linear = msgspec.json.Decoder(BybitTickersLinearResponse)
         self._response_decoder_option = msgspec.json.Decoder(BybitTickersOptionResponse)
         self._response_decoder_spot = msgspec.json.Decoder(BybitTickersSpotResponse)
 
-    async def get(self, params: BybitTickersGetParameters) -> BybitTickersResponse:
+    async def get(self, params: BybitTickersGetParams) -> BybitTickersResponse:
         method_type = HttpMethod.GET
         raw = await self._method(method_type, params)
         try:
-            if params.category == BybitInstrumentType.LINEAR:
+            if params.category == BybitProductType.SPOT:
+                return self._response_decoder_spot.decode(raw)
+            elif params.category in (BybitProductType.LINEAR, BybitProductType.INVERSE):
                 return self._response_decoder_linear.decode(raw)
-            elif params.category == BybitInstrumentType.OPTION:
+            elif params.category == BybitProductType.OPTION:
                 return self._response_decoder_option.decode(raw)
-            elif params.category == BybitInstrumentType.SPOT:
-                return self._response_decoder_spot.decode(raw)
             else:
                 raise RuntimeError(
-                    f"Unsupported instrument type: {params.category}",
+                    f"Unsupported product type: {params.category}",
                 )
         except Exception as e:
             decoder_raw = raw.decode("utf-8")
             raise RuntimeError(
                 f"Failed to decode Bybit tickers response: {decoder_raw}",
             ) from e
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/trade/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/trade/cancel_all_orders.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/market/trades.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,45 +14,40 @@
 # -------------------------------------------------------------------------------------------------
 
 import msgspec
 
 from nautilus_trader.adapters.bybit.common.enums import BybitEndpointType
 from nautilus_trader.adapters.bybit.endpoints.endpoint import BybitHttpEndpoint
 from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
-from nautilus_trader.adapters.bybit.schemas.order import BybitCancelAllOrdersResponse
+from nautilus_trader.adapters.bybit.schemas.market.trades import BybitTradesResponse
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
-class BybitCancelAllOrdersPostParameters(msgspec.Struct, omit_defaults=True, frozen=False):
+class BybitTradesGetParams(msgspec.Struct, omit_defaults=True, frozen=True):
     category: str
-    symbol: str | None = None
+    symbol: str
     baseCoin: str | None = None
-    settleCoin: str | None = None
+    optionType: str | None = None
+    limit: int | None = None
 
 
-class BybitCancelAllOrdersEndpoint(BybitHttpEndpoint):
+class BybitTradesEndpoint(BybitHttpEndpoint):
     def __init__(
         self,
         client: BybitHttpClient,
         base_endpoint: str,
     ) -> None:
-        url_path = base_endpoint + "order/cancel-all"
+        url_path = base_endpoint + "recent-trade"
         super().__init__(
             client=client,
-            endpoint_type=BybitEndpointType.TRADE,
+            endpoint_type=BybitEndpointType.MARKET,
             url_path=url_path,
         )
-        self._resp_decoder = msgspec.json.Decoder(BybitCancelAllOrdersResponse)
+        self._response_decoder = msgspec.json.Decoder(BybitTradesResponse)
 
-    async def post(
+    async def get(
         self,
-        parameters: BybitCancelAllOrdersPostParameters,
-    ) -> BybitCancelAllOrdersResponse:
-        method_type = HttpMethod.POST
-        raw = await self._method(method_type, parameters)
-        try:
-            return self._resp_decoder.decode(raw)
-        except Exception as e:
-            decoded_raw = raw.decode("utf-8")  # Decoding the bytes object
-            raise RuntimeError(
-                f"Failed to decode response cancel all orders response: {decoded_raw}",
-            ) from e
+        params: BybitTradesGetParams,
+    ) -> BybitTradesResponse:
+        method_type = HttpMethod.GET
+        raw = await self._method(method_type, params)
+        return self._response_decoder.decode(raw)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/trade/open_orders.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/account/position_info.py`

 * *Files 18% similar despite different names*

```diff
@@ -12,44 +12,45 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import msgspec
 
 from nautilus_trader.adapters.bybit.common.enums import BybitEndpointType
-from nautilus_trader.adapters.bybit.common.enums import BybitInstrumentType
 from nautilus_trader.adapters.bybit.endpoints.endpoint import BybitHttpEndpoint
 from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
-from nautilus_trader.adapters.bybit.schemas.order import BybitOpenOrdersResponseStruct
+from nautilus_trader.adapters.bybit.schemas.position import BybitPositionResponseStruct
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
-class BybitOpenOrdersGetParameters(msgspec.Struct, omit_defaults=True, frozen=False):
-    category: BybitInstrumentType | None = None
+class PositionInfoGetParams(msgspec.Struct, omit_defaults=True, frozen=True):
+    category: str | None = None
     symbol: str | None = None
     baseCoin: str | None = None
     settleCoin: str | None = None
-    orderId: str | None = None
-    orderLinkId: str | None = None
+    limit: int | None = None
+    cursor: str | None = None
 
 
-class BybitOpenOrdersHttp(BybitHttpEndpoint):
+class BybitPositionInfoEndpoint(BybitHttpEndpoint):
     def __init__(
         self,
         client: BybitHttpClient,
         base_endpoint: str,
     ) -> None:
-        url_path = base_endpoint + "/order/realtime"
+        url_path = base_endpoint + "/position/list"
         super().__init__(
             client=client,
-            endpoint_type=BybitEndpointType.TRADE,
+            endpoint_type=BybitEndpointType.ACCOUNT,
             url_path=url_path,
         )
-        self._get_resp_decoder = msgspec.json.Decoder(BybitOpenOrdersResponseStruct)
+        self._get_resp_decoder = msgspec.json.Decoder(BybitPositionResponseStruct)
 
-    async def get(self, parameters: BybitOpenOrdersGetParameters) -> BybitOpenOrdersResponseStruct:
+    async def get(self, params: PositionInfoGetParams) -> BybitPositionResponseStruct:
         method_type = HttpMethod.GET
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         try:
             return self._get_resp_decoder.decode(raw)
-        except Exception:
-            raise RuntimeError(f"Failed to decode response open orders response: {raw!s}")
+        except Exception as e:
+            raise RuntimeError(
+                f"Failed to decode response from {self.url_path}: {raw.decode()}",
+            ) from e
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/endpoints/trade/place_order.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/endpoints/trade/batch_place_order.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,50 +14,62 @@
 # -------------------------------------------------------------------------------------------------
 
 import msgspec
 
 from nautilus_trader.adapters.bybit.common.enums import BybitEndpointType
 from nautilus_trader.adapters.bybit.common.enums import BybitOrderSide
 from nautilus_trader.adapters.bybit.common.enums import BybitOrderType
+from nautilus_trader.adapters.bybit.common.enums import BybitProductType
 from nautilus_trader.adapters.bybit.common.enums import BybitTimeInForce
 from nautilus_trader.adapters.bybit.common.enums import BybitTriggerType
 from nautilus_trader.adapters.bybit.endpoints.endpoint import BybitHttpEndpoint
 from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
-from nautilus_trader.adapters.bybit.schemas.order import BybitPlaceOrderResponse
+from nautilus_trader.adapters.bybit.schemas.order import BybitBatchPlaceOrderResponse
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 
 
-class BybitPlaceOrderGetParameters(msgspec.Struct, omit_defaults=True, frozen=False):
-    category: str
+class BybitBatchPlaceOrder(msgspec.Struct, omit_defaults=True, frozen=True):
     symbol: str
     side: BybitOrderSide
+    orderType: BybitOrderType
     qty: str
-    orderType: BybitOrderType | None = None
+    isLeverage: str | None = None
+    marketUnit: str | None = None
     price: str | None = None
-    trigger_direction: int | None = None  # TODO type this
-    trigger_price: str | None = None
-    trigger_by: BybitTriggerType | None = None
+    orderFilter: str | None = None
+    triggerDirection: int | None = None  # TODO type this
+    triggerPrice: str | None = None
+    triggerBy: BybitTriggerType | None = None
+    orderIv: str | None = None
     timeInForce: BybitTimeInForce | None = None
+    positionIdx: int | None = None
     orderLinkId: str | None = None
 
 
-class BybitPlaceOrderEndpoint(BybitHttpEndpoint):
+class BybitBatchPlaceOrderPostParams(msgspec.Struct, omit_defaults=True, frozen=True):
+    category: BybitProductType
+    request: list[BybitBatchPlaceOrder]
+
+
+class BybitBatchPlaceOrderEndpoint(BybitHttpEndpoint):
     def __init__(
         self,
         client: BybitHttpClient,
         base_endpoint: str,
     ) -> None:
-        url_path = base_endpoint + "order/create"
+        url_path = base_endpoint + "/order/create-batch"
         super().__init__(
             client=client,
             endpoint_type=BybitEndpointType.TRADE,
             url_path=url_path,
         )
-        self._resp_decoder = msgspec.json.Decoder(BybitPlaceOrderResponse)
+        self._resp_decoder = msgspec.json.Decoder(BybitBatchPlaceOrderResponse)
 
-    async def post(self, parameters: BybitPlaceOrderGetParameters) -> BybitPlaceOrderResponse:
+    async def post(self, params: BybitBatchPlaceOrderPostParams) -> BybitBatchPlaceOrderResponse:
         method_type = HttpMethod.POST
-        raw = await self._method(method_type, parameters)
+        raw = await self._method(method_type, params)
         try:
             return self._resp_decoder.decode(raw)
-        except Exception:
-            raise RuntimeError("Failed to decode response place order response.")
+        except Exception as e:
+            raise RuntimeError(
+                f"Failed to decode response from {self.url_path}: {raw.decode()}",
+            ) from e
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/execution.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/client.py`

 * *Files 24% similar despite different names*

```diff
@@ -10,500 +10,666 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import asyncio
-
-import msgspec
-import pandas as pd
-
-from nautilus_trader.adapters.bybit.common.constants import BYBIT_VENUE
-from nautilus_trader.adapters.bybit.common.enums import BybitEnumParser
-from nautilus_trader.adapters.bybit.common.enums import BybitInstrumentType
-from nautilus_trader.adapters.bybit.config import BybitExecClientConfig
-from nautilus_trader.adapters.bybit.http.account import BybitAccountHttpAPI
-from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
-from nautilus_trader.adapters.bybit.http.errors import BybitError
-from nautilus_trader.adapters.bybit.schemas.common import BybitWsSubscriptionMsg
-from nautilus_trader.adapters.bybit.schemas.symbol import BybitSymbol
-from nautilus_trader.adapters.bybit.schemas.ws import BybitWsAccountExecution
-from nautilus_trader.adapters.bybit.schemas.ws import BybitWsAccountExecutionMsg
-from nautilus_trader.adapters.bybit.schemas.ws import BybitWsAccountOrderMsg
-from nautilus_trader.adapters.bybit.schemas.ws import BybitWsAccountPositionMsg
-from nautilus_trader.adapters.bybit.schemas.ws import BybitWsMessageGeneral
-from nautilus_trader.adapters.bybit.utils import get_api_key
-from nautilus_trader.adapters.bybit.utils import get_api_secret
-from nautilus_trader.adapters.bybit.websocket.client import BybitWebsocketClient
+import functools
+import os
+from collections.abc import Callable
+from collections.abc import Coroutine
+from inspect import iscoroutinefunction
+from typing import Any
+
+from ibapi import comm
+from ibapi.client import EClient
+from ibapi.commission_report import CommissionReport
+from ibapi.common import MAX_MSG_LEN
+from ibapi.common import NO_VALID_ID
+from ibapi.common import BarData
+from ibapi.errors import BAD_LENGTH
+from ibapi.execution import Execution
+from ibapi.utils import current_fn_name
+
+# fmt: off
+from nautilus_trader.adapters.interactive_brokers.client.account import InteractiveBrokersClientAccountMixin
+from nautilus_trader.adapters.interactive_brokers.client.common import AccountOrderRef
+from nautilus_trader.adapters.interactive_brokers.client.common import Request
+from nautilus_trader.adapters.interactive_brokers.client.common import Requests
+from nautilus_trader.adapters.interactive_brokers.client.common import Subscriptions
+from nautilus_trader.adapters.interactive_brokers.client.connection import InteractiveBrokersClientConnectionMixin
+from nautilus_trader.adapters.interactive_brokers.client.contract import InteractiveBrokersClientContractMixin
+from nautilus_trader.adapters.interactive_brokers.client.error import InteractiveBrokersClientErrorMixin
+from nautilus_trader.adapters.interactive_brokers.client.market_data import InteractiveBrokersClientMarketDataMixin
+from nautilus_trader.adapters.interactive_brokers.client.order import InteractiveBrokersClientOrderMixin
+from nautilus_trader.adapters.interactive_brokers.client.wrapper import InteractiveBrokersEWrapper
+from nautilus_trader.adapters.interactive_brokers.common import IB_VENUE
 from nautilus_trader.cache.cache import Cache
+from nautilus_trader.common.component import Component
 from nautilus_trader.common.component import LiveClock
 from nautilus_trader.common.component import MessageBus
-from nautilus_trader.common.providers import InstrumentProvider
-from nautilus_trader.core.correctness import PyCondition
-from nautilus_trader.core.datetime import millis_to_nanos
-from nautilus_trader.core.rust.common import LogColor
-from nautilus_trader.core.rust.model import TimeInForce
-from nautilus_trader.core.uuid import UUID4
-from nautilus_trader.execution.messages import CancelAllOrders
-from nautilus_trader.execution.messages import SubmitOrder
-from nautilus_trader.execution.reports import FillReport
-from nautilus_trader.execution.reports import OrderStatusReport
-from nautilus_trader.execution.reports import PositionStatusReport
-from nautilus_trader.live.execution_client import LiveExecutionClient
-from nautilus_trader.model.enums import AccountType
-from nautilus_trader.model.enums import OmsType
-from nautilus_trader.model.enums import OrderStatus
-from nautilus_trader.model.enums import OrderType
-from nautilus_trader.model.identifiers import AccountId
+from nautilus_trader.common.enums import LogColor
 from nautilus_trader.model.identifiers import ClientId
-from nautilus_trader.model.identifiers import ClientOrderId
-from nautilus_trader.model.identifiers import InstrumentId
-from nautilus_trader.model.identifiers import TradeId
-from nautilus_trader.model.identifiers import VenueOrderId
-from nautilus_trader.model.objects import Money
-from nautilus_trader.model.objects import Price
-from nautilus_trader.model.objects import Quantity
-from nautilus_trader.model.orders import LimitOrder
-from nautilus_trader.model.orders import MarketOrder
-from nautilus_trader.model.orders import Order
-from nautilus_trader.model.position import Position
 
 
-class BybitExecutionClient(LiveExecutionClient):
+# fmt: on
+
+
+class InteractiveBrokersClient(
+    Component,
+    InteractiveBrokersClientConnectionMixin,
+    InteractiveBrokersClientAccountMixin,
+    InteractiveBrokersClientMarketDataMixin,
+    InteractiveBrokersClientOrderMixin,
+    InteractiveBrokersClientContractMixin,
+    InteractiveBrokersClientErrorMixin,
+):
+    """
+    A client component that interfaces with the Interactive Brokers TWS or Gateway.
+
+    This class integrates various mixins to provide functionality for connection
+    management, account management, market data, and order processing with
+    Interactive Brokers. It inherits from both `Component` and `EWrapper` to provide
+    event-driven responses and custom component behavior.
+
+    """
+
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
-        client: BybitHttpClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
-        instrument_provider: InstrumentProvider,
-        instrument_types: list[BybitInstrumentType],
-        base_url_ws: str,
-        config: BybitExecClientConfig,
+        host: str = "127.0.0.1",
+        port: int = 7497,
+        client_id: int = 1,
     ) -> None:
         super().__init__(
-            loop=loop,
-            client_id=ClientId(BYBIT_VENUE.value),
-            venue=BYBIT_VENUE,
-            oms_type=OmsType.NETTING,
-            instrument_provider=instrument_provider,
-            account_type=AccountType.CASH,
-            base_currency=None,
-            msgbus=msgbus,
-            cache=cache,
             clock=clock,
+            component_id=ClientId(f"{IB_VENUE.value}-{client_id:03d}"),
+            component_name=f"{type(self).__name__}-{client_id:03d}",
+            msgbus=msgbus,
         )
-        # Configuration
-        self._use_position_ids = config.use_position_ids
 
-        self._log.info(f"Account type: ${self.account_type}", LogColor.BLUE)
-        self._instrument_types = instrument_types
-        self._enum_parser = BybitEnumParser()
-
-        account_id = AccountId(f"{BYBIT_VENUE.value}-UNIFIED")
-        self._set_account_id(account_id)
+        # Config
+        self._loop = loop
+        self._cache = cache
+        self._host = host
+        self._port = port
+        self._client_id = client_id
+
+        # TWS API
+        self._eclient: EClient = EClient(
+            wrapper=InteractiveBrokersEWrapper(
+                nautilus_logger=self._log,
+                client=self,
+            ),
+        )
+
+        # EClient Overrides
+        self._eclient.sendMsg = self.sendMsg
+        self._eclient.logRequest = self.logRequest
+
+        # Tasks
+        self._connection_watchdog_task: asyncio.Task | None = None
+        self._tws_incoming_msg_reader_task: asyncio.Task | None = None
+        self._internal_msg_queue_processor_task: asyncio.Task | None = None
+        self._internal_msg_queue: asyncio.Queue = asyncio.Queue()
+        self._msg_handler_processor_task: asyncio.Task | None = None
+        self._msg_handler_task_queue: asyncio.Queue = asyncio.Queue()
+
+        # Event flags
+        self._is_client_ready: asyncio.Event = asyncio.Event()
+        self._is_ib_connected: asyncio.Event = asyncio.Event()
 
         # Hot caches
-        self._instrument_ids: dict[str, InstrumentId] = {}
-        self._generate_order_status_retries: dict[ClientOrderId, int] = {}
+        self.registered_nautilus_clients: set = set()
+        self._event_subscriptions: dict[str, Callable] = {}
 
-        # WebSocket API
-        self._ws_client = BybitWebsocketClient(
-            clock=clock,
-            handler=self._handle_ws_message,
-            base_url=base_url_ws,
-            is_private=True,
-            api_key=config.api_key or get_api_key(config.testnet),
-            api_secret=config.api_secret or get_api_secret(config.testnet),
-        )
+        # Subscriptions
+        self._requests = Requests()
+        self._subscriptions = Subscriptions()
+
+        # AccountMixin
+        self._account_ids: set[str] = set()
+
+        # ConnectionMixin
+        self._reconnect_attempts: int = 0
+        self._max_reconnect_attempts: int = int(os.getenv("IB_MAX_RECONNECT_ATTEMPTS", 0))
+        self._indefinite_reconnect: bool = False if self._max_reconnect_attempts else True
+        self._reconnect_delay: int = 5  # seconds
+
+        # MarketDataMixin
+        self._bar_type_to_last_bar: dict[str, BarData | None] = {}
+
+        # OrderMixin
+        self._exec_id_details: dict[
+            str,
+            dict[str, Execution | (CommissionReport | str)],
+        ] = {}
+        self._order_id_to_order_ref: dict[int, AccountOrderRef] = {}
+        self._next_valid_order_id: int = -1
+
+        # Start client
+        self._request_id_seq: int = 10000
+
+    def _start(self) -> None:
+        """
+        Start the client.
+
+        This method is called when the client is first initialized and when the client
+        is reset. It sets up the client and starts the connection watchdog, incoming
+        message reader, and internal message queue processing tasks.
+
+        """
+        self._log.info(f"Starting InteractiveBrokersClient ({self._client_id})...")
+        if not self._loop.is_running():
+            self._log.warning("Started when loop is not running.")
+            self._loop.run_until_complete(self._startup())
+        else:
+            self._create_task(self._startup())
 
-        # Http API
-        self._http_account = BybitAccountHttpAPI(
-            client=client,
-            clock=clock,
-        )
+    async def _startup(self):
+        try:
+            self._log.info(f"Starting InteractiveBrokersClient ({self._client_id})...")
+            await self._connect()
+            self._start_tws_incoming_msg_reader()
+            self._start_internal_msg_queue_processor()
+            self._eclient.startApi()
+            # TWS/Gateway will send a managedAccounts message upon successful connection,
+            # which will set the `_is_ib_connected` event. This typically takes a few
+            # seconds, so we wait for it here.
+            await asyncio.wait_for(self._is_ib_connected.wait(), 15)
+            self._start_connection_watchdog()
+            self._is_client_ready.set()
+        except asyncio.TimeoutError:
+            self._log.error("Client failed to initialize. Connection timeout.")
+            self._stop()
+        except Exception as e:
+            self._log.exception("Unhandled exception in client startup", e)
+            self._stop()
 
-        # Order submission
-        self._submit_order_methods = {
-            OrderType.MARKET: self._submit_market_order,
-            OrderType.LIMIT: self._submit_limit_order,
-        }
-        self._order_retries: dict[ClientOrderId, int] = {}
-
-        # decoders
-        self._decoder_ws_msg_general = msgspec.json.Decoder(BybitWsMessageGeneral)
-        self._decoder_ws_subscription = msgspec.json.Decoder(BybitWsSubscriptionMsg)
-        self._decoder_ws_account_order_update = msgspec.json.Decoder(BybitWsAccountOrderMsg)
-        self._decoder_ws_account_execution_update = msgspec.json.Decoder(
-            BybitWsAccountExecutionMsg,
-        )
-        self._decoder_ws_account_position_update = msgspec.json.Decoder(
-            BybitWsAccountPositionMsg,
-        )
+    def _start_tws_incoming_msg_reader(self) -> None:
+        """
+        Start the incoming message reader task.
+        """
+        if self._tws_incoming_msg_reader_task:
+            self._tws_incoming_msg_reader_task.cancel()
+        self._tws_incoming_msg_reader_task = self._create_task(
+            self._run_tws_incoming_msg_reader(),
+        )
+
+    def _start_internal_msg_queue_processor(self) -> None:
+        """
+        Start the internal message queue processing task.
+        """
+        if self._internal_msg_queue_processor_task:
+            self._internal_msg_queue_processor_task.cancel()
+        self._internal_msg_queue_processor_task = self._create_task(
+            self._run_internal_msg_queue_processor(),
+        )
+        if self._msg_handler_processor_task:
+            self._msg_handler_processor_task.cancel()
+        self._msg_handler_processor_task = self._create_task(
+            self._run_msg_handler_processor(),
+        )
+
+    def _start_connection_watchdog(self) -> None:
+        """
+        Start the connection watchdog task.
+        """
+        if self._connection_watchdog_task:
+            self._connection_watchdog_task.cancel()
+        self._connection_watchdog_task = self._create_task(
+            self._run_connection_watchdog(),
+        )
+
+    def _stop(self) -> None:
+        """
+        Stop the client and cancel running tasks.
+        """
+        self._log.info(f"Stopping InteractiveBrokersClient ({self._client_id})...")
+        # Cancel tasks
+        tasks = [
+            self._connection_watchdog_task,
+            self._tws_incoming_msg_reader_task,
+            self._internal_msg_queue_processor_task,
+            self._msg_handler_processor_task,
+        ]
+        for task in tasks:
+            if task and not task.cancelled():
+                task.cancel()
+
+        self._eclient.disconnect()
+        self._is_client_ready.clear()
+        self._account_ids = set()
+        for client in self.registered_nautilus_clients:
+            self._log.warning(f"Client {client} disconnected.")
+        self.registered_nautilus_clients = set()
+
+    def _reset(self) -> None:
+        """
+        Restart the client.
+        """
+        self._log.info(f"Resetting InteractiveBrokersClient ({self._client_id})...")
+        self._stop()
+        self._start()
+
+    def _resume(self) -> None:
+        """
+        Resume the client and resubscribe to all subscriptions.
+        """
+        self._log.info(f"Resuming InteractiveBrokersClient ({self._client_id})...")
+        self._is_client_ready.set()
+
+    def _degrade(self) -> None:
+        """
+        Degrade the client when connectivity is lost.
+        """
+        self._log.info(f"Degrading InteractiveBrokersClient ({self._client_id})...")
+        self._is_client_ready.clear()
+        self._account_ids = set()
+
+    async def _resubscribe_all(self) -> None:
+        """
+        Cancel and restart all subscriptions.
+        """
+        self._log.debug("Resubscribing all subscriptions...")
+        for subscription in self._subscriptions.get_all():
+            try:
+                subscription.cancel()
+                if iscoroutinefunction(subscription.handle):
+                    await subscription.handle()
+                else:
+                    await asyncio.to_thread(subscription.handle)
+            except Exception as e:
+                self._log.exception(f"Failed to resubscribe to {subscription}", e)
 
-    async def _connect(self) -> None:
-        # Update account state
-        await self._update_account_state()
-        # Connect to websocket
-        await self._ws_client.connect()
-        # subscribe account updates
-        await self._ws_client.subscribe_executions_update()
-        await self._ws_client.subscribe_orders_update()
+    async def wait_until_ready(self, timeout: int = 300) -> None:
+        """
+        Check if the client is running and ready within a given timeout.
+
+        Parameters
+        ----------
+        timeout : int, default 300
+            Time in seconds to wait for the client to be ready.
 
-    async def generate_order_status_reports(
-        self,
-        instrument_id: InstrumentId | None = None,
-        start: pd.Timestamp | None = None,
-        end: pd.Timestamp | None = None,
-        open_only: bool = False,
-    ) -> list[OrderStatusReport]:
-        self._log.info("Requesting OrderStatusReports...")
-        reports: list[OrderStatusReport] = []
+        """
         try:
-            symbol = instrument_id.symbol.value if instrument_id is not None else None
-            # active_symbols = self._get_cache_active_symbols()
-            # active_symbols.update(await self._get_active_position_symbols(symbol))
-            # open_orders: dict[BybitInstrumentType,list[BybitOrder]] = dict()
-            for instr in self._instrument_types:
-                open_orders = await self._http_account.query_open_orders(instr, symbol)
-                for order in open_orders:
-                    symbol = BybitSymbol(order.symbol + f"-{instr.value.upper()}")
-                    report = order.parse_to_order_status_report(
-                        account_id=self.account_id,
-                        instrument_id=symbol.parse_as_nautilus(),
-                        report_id=UUID4(),
-                        enum_parser=self._enum_parser,
-                        ts_init=self._clock.timestamp_ns(),
-                    )
-                    reports.append(report)
-                    self._log.debug(f"Received {report}")
-        except BybitError as e:
-            self._log.error(f"Failed to generate OrderStatusReports: {e}")
-        len_reports = len(reports)
-        plural = "" if len_reports == 1 else "s"
-        self._log.info(f"Received {len(reports)} OrderStatusReport{plural}.")
-        return reports
+            if not self._is_client_ready.is_set():
+                await asyncio.wait_for(self._is_client_ready.wait(), timeout)
+        except asyncio.TimeoutError as e:
+            self._log.error(f"Client is not ready. {e}")
+
+    async def _run_connection_watchdog(self) -> None:
+        """
+        Run a watchdog to monitor and manage the health of the socket connection.
+
+        Continuously checks the connection status, manages client state based on
+        connection health, and handles subscription management in case of network
+        failure or forced IB connection reset.
 
-    async def generate_order_status_report(
-        self,
-        instrument_id: InstrumentId,
-        client_order_id: ClientOrderId | None = None,
-        venue_order_id: VenueOrderId | None = None,
-    ) -> OrderStatusReport | None:
-        PyCondition.false(
-            client_order_id is None and venue_order_id is None,
-            "both `client_order_id` and `venue_order_id` were `None`",
-        )
-        retries = self._generate_order_status_retries.get(client_order_id, 0)
-        if retries > 3:
-            self._log.error(
-                f"Reached maximum retries 3/3 for generating OrderStatusReport for "
-                f"{repr(client_order_id) if client_order_id else ''} "
-                f"{repr(venue_order_id) if venue_order_id else ''}...",
-            )
-            return None
-        self._log.info(
-            f"Generating OrderStatusReport for "
-            f"{repr(client_order_id) if client_order_id else ''} "
-            f"{repr(venue_order_id) if venue_order_id else ''}...",
-        )
+        """
         try:
-            if venue_order_id:
-                bybit_orders = await self._http_account.query_order(
-                    instrument_type=BybitInstrumentType.LINEAR,
-                    symbol=instrument_id.symbol.value,
-                    order_id=venue_order_id.value,
-                )
-                if len(bybit_orders) == 0:
-                    self._log.error(f"Received no order for {venue_order_id}")
-                    return None
-                targetOrder = bybit_orders[0]
-                if len(bybit_orders) > 1:
-                    self._log.warning(f"Received more than one order for {venue_order_id}")
-                    targetOrder = bybit_orders[0]
-
-                order_report = targetOrder.parse_to_order_status_report(
-                    account_id=self.account_id,
-                    instrument_id=self._get_cached_instrument_id(targetOrder.symbol),
-                    report_id=UUID4(),
-                    enum_parser=self._enum_parser,
-                    ts_init=self._clock.timestamp_ns(),
-                )
-                self._log.debug(f"Received {order_report}.")
-                return order_report
-        except BybitError as e:
-            self._log.error(f"Failed to generate OrderStatusReport: {e}")
-        return None
+            while True:
+                await asyncio.sleep(1)
+                if not self._is_ib_connected.is_set() or not self._eclient.isConnected():
+                    self._log.error(
+                        "Connection watchdog detects connection lost.",
+                    )
+                    await self._handle_disconnection()
+        except asyncio.CancelledError:
+            self._log.debug("Client connection watchdog task was canceled.")
+
+    async def _handle_disconnection(self) -> None:
+        """
+        Handle the disconnection of the client from TWS/Gateway.
+        """
+        if self.is_running:
+            self._degrade()
+        if not self._is_ib_connected.is_set():
+            self._log.debug("`_is_ib_connected` unset by `_handle_disconnection`.", LogColor.BLUE)
+            self._is_ib_connected.clear()
+        await asyncio.sleep(5)
+        await self._handle_reconnect()
 
-    async def generate_fill_reports(
-        self,
-        instrument_id: InstrumentId | None = None,
-        venue_order_id: VenueOrderId | None = None,
-        start: pd.Timestamp | None = None,
-        end: pd.Timestamp | None = None,
-    ) -> list[FillReport]:
-        self._log.info("Requesting FillReports...")
-        return []
+        self._resume()
 
-    async def generate_position_status_reports(
+    def _create_task(
         self,
-        instrument_id: InstrumentId | None = None,
-        start: pd.Timestamp | None = None,
-        end: pd.Timestamp | None = None,
-    ) -> list[PositionStatusReport]:
-        self._log.info("Requesting PositionStatusReports...")
-        reports: list[PositionStatusReport] = []
-        for instrument_type in self._instrument_types:
-            positions = await self._http_account.query_position_info(instrument_type)
-            for position in positions:
-                instr: InstrumentId = BybitSymbol(
-                    position.symbol + "-" + instrument_type.value.upper(),
-                ).parse_as_nautilus()
-                position_report = position.parse_to_position_status_report(
-                    account_id=self.account_id,
-                    instrument_id=instr,
-                    report_id=UUID4(),
-                    ts_init=self._clock.timestamp_ns(),
-                )
-                self._log.debug(f"Received {position_report}.")
-                reports.append(position_report)
-        return reports
-
-    def _get_cache_active_symbols(self) -> set[str]:
-        # check in cache for all active orders
-        open_orders: list[Order] = self._cache.orders_open(venue=self.venue)
-        open_positions: list[Position] = self._cache.positions_open(venue=self.venue)
-        active_symbols: set[str] = set()
-        for order in open_orders:
-            active_symbols.add(BybitSymbol(order.instrument_id.symbol.value))
-        for position in open_positions:
-            active_symbols.add(BybitSymbol(position.instrument_id.symbol.value))
-        return active_symbols
-
-    async def _get_active_position_symbols(self, symbol: str | None) -> set[str]:
-        active_symbols: set[str] = set()
-        bybit_positions = await self._http_account.query_position_info(
-            BybitInstrumentType.LINEAR,
-            symbol,
+        coro: Coroutine,
+        log_msg: str | None = None,
+        actions: Callable | None = None,
+        success: str | None = None,
+    ) -> asyncio.Task:
+        """
+        Create an asyncio task with error handling and optional callback actions.
+
+        Parameters
+        ----------
+        coro : Coroutine
+            The coroutine to run.
+        log_msg : str, optional
+            The log message for the task.
+        actions : Callable, optional
+            The actions callback to run when the coroutine is done.
+        success : str, optional
+            The log message to write on actions success.
+
+        Returns
+        -------
+        asyncio.Task
+
+        """
+        log_msg = log_msg or coro.__name__
+        self._log.debug(f"Creating task {log_msg}.")
+        task = self._loop.create_task(
+            coro,
+            name=coro.__name__,
+        )
+        task.add_done_callback(
+            functools.partial(
+                self._on_task_completed,
+                actions,
+                success,
+            ),
         )
-        for position in bybit_positions:
-            active_symbols.add(position.symbol)
-        return active_symbols
-
-    async def _update_account_state(self) -> None:
-        # positions = await self._http_account.query_position_info()
-        [instrument_type_balances, ts_event] = await self._http_account.query_wallet_balance()
-        if instrument_type_balances:
-            self._log.info("Bybit API key authenticated.", LogColor.GREEN)
-            self._log.info(f"API key {self._http_account.client.api_key} has trading permissions.")
-        for balance in instrument_type_balances:
-            balances = balance.parse_to_account_balance()
-            margins = balance.parse_to_margin_balance()
-            try:
-                self.generate_account_state(
-                    balances=balances,
-                    margins=margins,
-                    reported=True,
-                    ts_event=millis_to_nanos(ts_event),
-                )
-            except Exception as e:
-                self._log.error(f"Failed to generate AccountState: {e}")
+        return task
 
-    async def _cancel_all_orders(self, command: CancelAllOrders) -> None:
-        await self._http_account.cancel_all_orders(
-            BybitInstrumentType.LINEAR,
-            command.instrument_id.symbol.value,
-        )
+    def _on_task_completed(
+        self,
+        actions: Callable | None,
+        success: str | None,
+        task: asyncio.Task,
+    ) -> None:
+        """
+        Handle the completion of a task.
 
-    async def _submit_order(self, command: SubmitOrder) -> None:
-        await self._submit_order_inner(command.order)
+        Parameters
+        ----------
+        actions : Callable, optional
+            Callback actions to execute upon task completion.
+        success : str, optional
+            Success log message to display on successful completion of actions.
+        task : asyncio.Task
+            The asyncio Task that has been completed.
 
-    async def _submit_order_inner(self, order: Order) -> None:
-        if order.is_closed:
-            self._log.warning(f"Order {order} is already closed.")
-            return
-        # check validity
-        self._check_order_validity(order)
-        self._log.debug(f"Submitting order {order}")
-
-        # Generate order submitted event, to ensure correct ordering of event
-        self.generate_order_submitted(
-            strategy_id=order.strategy_id,
-            instrument_id=order.instrument_id,
-            client_order_id=order.client_order_id,
-            ts_event=self._clock.timestamp_ns(),
-        )
-        while True:
-            try:
-                await self._submit_order_methods[order.order_type](order)
-                self._order_retries.pop(order.client_order_id, None)
-                break
-            except KeyError:
-                raise RuntimeError(f"unsupported order type, was {order.order_type}")
-            except BybitError:
-                print("BYBIT ERROR")
-
-    def _check_order_validity(self, order: Order) -> None:
-        # check order type valid
-        if order.order_type not in self._enum_parser.valid_order_types:
-            self._log.error(
-                f"Cannot submit order.Order {order} has invalid order type {order.order_type}.Unsupported on bybit.",
-            )
-            return
-        # check time in force valid
-        if order.time_in_force not in self._enum_parser.valid_time_in_force:
-            self._log.error(
-                f"Cannot submit order.Order {order} has invalid time in force {order.time_in_force}.Unsupported on bybit.",
-            )
-            return
-        # check post only
-        if order.is_post_only and order.order_type != OrderType.LIMIT:
+        """
+        if task.exception():
             self._log.error(
-                f"Cannot submit order.Order {order} has invalid post only {order.is_post_only}.Unsupported on bybit.",
+                f"Error on `{task.get_name()}`: " f"{task.exception()!r}",
             )
-            return
-
-    async def _submit_market_order(self, order: MarketOrder) -> None:
-        pass
+        else:
+            if actions:
+                try:
+                    actions()
+                except Exception as e:
+                    self._log.error(
+                        f"Failed triggering action {actions.__name__} on `{task.get_name()}`: "
+                        f"{e!r}",
+                    )
+            if success:
+                self._log.info(success, LogColor.GREEN)
 
-    async def _submit_limit_order(self, order: LimitOrder) -> None:
-        time_in_force = self._enum_parser.parse_nautilus_time_in_force(order.time_in_force)
-        order_side = self._enum_parser.parse_nautilus_order_side(order.side)
-        order_type = self._enum_parser.parse_nautilus_order_type(order.order_type)
-        order = await self._http_account.place_order(
-            instrument_type=BybitInstrumentType.LINEAR,
-            symbol=order.instrument_id.symbol.value,
-            side=order_side,
-            order_type=order_type,
-            time_in_force=time_in_force,
-            quantity=str(order.quantity),
-            price=str(order.price),
-            order_id=str(order.client_order_id),
-        )
+    def subscribe_event(self, name: str, handler: Callable) -> None:
+        """
+        Subscribe a handler function to a named event.
+
+        Parameters
+        ----------
+        name : str
+            The name of the event to subscribe to.
+        handler : Callable
+            The handler function to be called when the event occurs.
+
+        """
+        self._event_subscriptions[name] = handler
+
+    def unsubscribe_event(self, name: str) -> None:
+        """
+        Unsubscribe a handler from a named event.
+
+        Parameters
+        ----------
+        name : str
+            The name of the event to unsubscribe from.
+
+        """
+        self._event_subscriptions.pop(name)
+
+    async def _await_request(self, request: Request, timeout: int) -> Any | None:
+        """
+        Await the completion of a request within a specified timeout.
+
+        Parameters
+        ----------
+        request : Request
+            The request object to await.
+        timeout : int
+            The maximum time to wait for the request to complete, in seconds.
+
+        Returns
+        -------
+        Any | ``None``
+            The result of the request, or None if the request timed out.
 
-    ################################################################################
-    #   WS user handlers
-    ################################################################################
-    def _handle_ws_message(self, raw: bytes) -> None:
+        """
         try:
-            ws_message = self._decoder_ws_msg_general.decode(raw)
-            self._topic_check(ws_message.topic, raw)
-        except Exception as e:
-            ws_message_sub = self._decoder_ws_subscription.decode(raw)
-            if ws_message_sub.success:
-                self._log.info("Success subscribing")
-            else:
-                self._log.error(f"Failed to subscribe. {e!s}")
+            return await asyncio.wait_for(request.future, timeout)
+        except asyncio.TimeoutError as e:
+            self._log.warning(f"Request timed out for {request}. Ending request.")
+            self._end_request(request.req_id, success=False, exception=e)
+            return None
+        except ConnectionError as e:
+            self._log.error(f"Connection error during {request}. Ending request.")
+            self._end_request(request.req_id, success=False, exception=e)
+            return None
 
-    def _topic_check(self, topic: str, raw: bytes) -> None:
-        if "order" in topic:
-            self._handle_account_order_update(raw)
-        elif "execution" in topic:
-            self._handle_account_execution_update(raw)
-        else:
-            self._log.error(f"Unknown websocket message topic: {topic} in Bybit")
+    def _end_request(
+        self,
+        req_id: int,
+        success: bool = True,
+        exception: type | BaseException | None = None,
+    ) -> None:
+        """
+        End a request with a specified result or exception.
 
-    # def _handle_account_position_update(self,raw: bytes):
-    #     try:
-    #         msg = self._decoder_ws_account_position_update.decode(raw)
-    #         for position in msg.data:
-    #             print(position)
-    #     except Exception as e:
-    #         print(e)
+        Parameters
+        ----------
+        req_id : int
+            The request ID to conclude.
+        success : bool, optional
+            Whether the request was successful. Defaults to True.
+        exception : type | BaseException | None, optional
+            An exception to set on request failure. Defaults to None.
+
+        """
+        if not (request := self._requests.get(req_id=req_id)):
+            return
 
-    def _handle_account_execution_update(self, raw: bytes):
+        if not request.future.done():
+            if success:
+                request.future.set_result(request.result)
+            else:
+                request.cancel()
+                if exception:
+                    request.future.set_exception(exception)
+        self._requests.remove(req_id=req_id)
+
+    async def _run_tws_incoming_msg_reader(self) -> None:
+        """
+        Continuously read messages from TWS/Gateway and then put them in the internal
+        message queue for processing.
+        """
+        self._log.debug("Client TWS incoming message reader started.")
+        buf = b""
         try:
-            msg = self._decoder_ws_account_execution_update.decode(raw)
-            for trade in msg.data:
-                print(trade)
-                self._process_execution(trade)
+            while self._eclient.conn and self._eclient.conn.isConnected():
+                data = await asyncio.to_thread(self._eclient.conn.recvMsg)
+                buf += data
+                while buf:
+                    _, msg, buf = comm.read_msg(buf)
+                    self._log.debug(f"Msg buffer received: {buf!s}")
+                    if msg:
+                        # Place msg in the internal queue for processing
+                        self._internal_msg_queue.put_nowait(msg)
+                    else:
+                        self._log.debug("More incoming packets are needed.")
+                        break
+        except asyncio.CancelledError:
+            self._log.debug("Client TWS incoming message reader was cancelled.")
         except Exception as e:
-            print(e)
-            self._log.exception(f"Failed to handle account execution update: {e}", e)
+            self._log.exception("Unhandled exception in Client TWS incoming message reader", e)
+        finally:
+            if self._is_ib_connected.is_set() and not self.is_disposed:
+                self._log.debug(
+                    "`_is_ib_connected` unset by `_run_tws_incoming_msg_reader`.",
+                    LogColor.BLUE,
+                )
+                self._is_ib_connected.clear()
+            self._log.debug("Client TWS incoming message reader stopped.")
 
-    def _process_execution(self, execution: BybitWsAccountExecution):
-        client_order_id = (
-            ClientOrderId(execution.orderLinkId) if execution.orderLinkId is not None else None
+    async def _run_internal_msg_queue_processor(self) -> None:
+        """
+        Continuously process messages from the internal incoming message queue.
+        """
+        self._log.debug(
+            "Client internal message queue processor started.",
         )
-        ts_event = millis_to_nanos(float(execution.execTime))
-        venue_order_id = VenueOrderId(execution.orderId)
-        instrument_id = self._get_cached_instrument_id(execution.symbol)
-        strategy_id = self._cache.strategy_id_for_order(execution.symbol)
-        # check if we can find the instrument
-        if instrument_id is None:
-            raise ValueError(f"Cannot handle ws trade event: instrument {instrument_id} not found")
-        if strategy_id is None:
-            # this is a trade that was not placed by us nautilus
-            print("NOT OUR TRADE")
-            report = OrderStatusReport(
-                account_id=self.account_id,
-                instrument_id=instrument_id,
-                client_order_id=execution.orderLinkId,
-                venue_order_id=venue_order_id,
-                order_side=self._enum_parser.parse_bybit_order_side(execution.side),
-                order_type=self._enum_parser.parse_bybit_order_type(execution.orderType),
-                order_status=OrderStatus.FILLED,
-                time_in_force=TimeInForce.GTC,
-                quantity=Quantity.from_str(execution.execQty),
-                price=Price.from_str(execution.execPrice),
-                filled_qty=Quantity.from_str(execution.execQty),
-                ts_accepted=123,
-                ts_init=123,
-                ts_last=123,
-                report_id=UUID4(),
+        try:
+            while (
+                self._eclient.conn
+                and self._eclient.conn.isConnected()
+                or not self._internal_msg_queue.empty()
+            ):
+                msg = await self._internal_msg_queue.get()
+                if not await self._process_message(msg):
+                    break
+                self._internal_msg_queue.task_done()
+        except asyncio.CancelledError:
+            log_msg = f"Internal message queue processing stopped. (qsize={self._internal_msg_queue.qsize()})."
+            (
+                self._log.warning(log_msg)
+                if not self._internal_msg_queue.empty()
+                else self._log.debug(
+                    log_msg,
+                )
             )
-            self._send_order_status_report(report)
-            return
-        instrument = self._instrument_provider.find(instrument_id=instrument_id)
-        if instrument is None:
-            raise ValueError(f"Cannot handle ws trade event: instrument {instrument_id} not found")
-
-        commission_asset: str | None = instrument.quote_currency
-        commission_amount = Money(execution.execFee, commission_asset)
-        self.generate_order_filled(
-            strategy_id=strategy_id,
-            instrument_id=instrument_id,
-            client_order_id=client_order_id,
-            venue_order_id=venue_order_id,
-            trade_id=TradeId(execution.execId),
-            order_side=self._enum_parser.parse_bybit_order_side(execution.side),
-            order_type=self._enum_parser.parse_bybit_order_type(execution.orderType),
-            last_qty=Quantity(float(execution.leavesQty), instrument.size_precision),
-            last_px=Price(float(execution.execPrice), instrument.price_precision),
-            quote_currency=instrument.quote_currency,
-            commission=commission_amount,
-            ts_event=ts_event,
-        )
+        finally:
+            self._log.debug("Internal message queue processor stopped.")
 
-        if strategy_id is None:
-            self._log.error(f"Cannot find strategy for order {execution.orderLinkId}")
-            return
+    async def _process_message(self, msg: str) -> bool:
+        """
+        Process a single message from TWS/Gateway.
+
+        Parameters
+        ----------
+        msg : str
+            The message to be processed.
+
+        Returns
+        -------
+        bool
+
+        """
+        if len(msg) > MAX_MSG_LEN:
+            await self.process_error(
+                req_id=NO_VALID_ID,
+                error_code=BAD_LENGTH.code(),
+                error_string=f"{BAD_LENGTH.msg()}:{len(msg)}:{msg}",
+            )
+            return False
+        fields: tuple[bytes] = comm.read_fields(msg)
+        self._log.debug(f"Msg received: {msg}")
+        self._log.debug(f"Msg received fields: {fields}")
+
+        # The decoder identifies the message type based on its payload (e.g., open
+        # order, process real-time ticks, etc.) and then calls the corresponding
+        # method from the EWrapper. Many of those methods are overridden in the client
+        # manager and handler classes to support custom processing required for Nautilus.
+        await asyncio.to_thread(self._eclient.decoder.interpret, fields)
+        return True
+
+    async def _run_msg_handler_processor(self):
+        """
+        Asynchronously processes handler tasks from the message handler task queue.
+
+        Continuously retrieves and executes tasks from `msg_handler_task_queue`, which are
+        typically partial functions representing message handling operations received from the ibapi wrapper.
+        The method ensures each task is awaited, thereby executing it. After task execution, it marks
+        the task as done in the queue.
 
-        # get order
-        # get commission
-        # commission_asset: str | None = instrument.quote_currency or Money(execution.execFee, commission_asset)
-
-        self.generate_order_filled(
-            account_id=self.account_id,
-            instrument_id=instrument_id,
-            client_order_id=execution.orderLinkId,
-            venue_order_id=execution.orderId,
-        )
+        This method is designed to run indefinitely until externally cancelled, typically as part
+        of an application shutdown or when the handling context changes requiring a halt in operations.
 
-    def _handle_account_order_update(self, raw: bytes):
+        """
         try:
-            msg = self._decoder_ws_account_order_update.decode(raw)
-            for order in msg.data:
-                print(order)
-                report = order.parse_to_order_status_report(
-                    account_id=self.account_id,
-                    instrument_id=self._get_cached_instrument_id(order.symbol),
-                    enum_parser=self._enum_parser,
+            while True:
+                handler_task = await self._msg_handler_task_queue.get()
+                await handler_task()
+                self._msg_handler_task_queue.task_done()
+        except asyncio.CancelledError:
+            log_msg = (
+                f"Handler task processing stopped. (qsize={self._msg_handler_task_queue.qsize()})."
+            )
+            (
+                self._log.warning(log_msg)
+                if not self._internal_msg_queue.empty()
+                else self._log.debug(
+                    log_msg,
                 )
-                self._send_order_status_report(report)
-        except Exception as e:
-            print(e)
+            )
+        finally:
+            self._log.debug("Handler task processor stopped.")
 
-    async def _disconnect(self) -> None:
-        await self._ws_client.disconnect()
+    def submit_to_msg_handler_queue(self, task: Callable[..., Any]) -> None:
+        """
+        Submit a task to the message handler's queue for processing.
+
+        This method places a callable task into the message handler task queue,
+        ensuring it's scheduled for asynchronous execution according to the queue's
+        order. The operation is non-blocking and immediately returns after queueing the task.
+
+        Parameters
+        ----------
+        task : Callable[..., Any]
+            The task to be queued. This task should be a callable that matches
+            the expected signature for tasks processed by the message handler.
+
+        """
+        self._log.debug(f"Submitting task to message handler queue: {task}")
+        asyncio.run_coroutine_threadsafe(self._msg_handler_task_queue.put(task), self._loop)
+
+    def _next_req_id(self) -> int:
+        """
+        Generate the next sequential request ID.
+
+        Returns
+        -------
+        int
+
+        """
+        new_id = self._request_id_seq
+        self._request_id_seq += 1
+        return new_id
+
+    # -- EClient overrides ------------------------------------------------------------------------
+
+    def sendMsg(self, msg):
+        """
+        Override the logging for ibapi EClient.sendMsg.
+        """
+        full_msg = comm.make_msg(msg)
+        self._log.debug(f"TWS API request sent: function={current_fn_name(1)} msg={full_msg}")
+        self._eclient.conn.sendMsg(full_msg)
+
+    def logRequest(self, fnName, fnParams):
+        """
+        Override the logging for ibapi EClient.logRequest.
+        """
+        if "self" in fnParams:
+            prms = dict(fnParams)
+            del prms["self"]
+        else:
+            prms = fnParams
+        self._log.debug(f"TWS API prepared request: function={fnName} data={prms}")
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/factories.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/factories.py`

 * *Files 19% similar despite different names*

```diff
@@ -11,22 +11,27 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import asyncio
 
-from nautilus_trader.adapters.bybit.common.enums import BybitInstrumentType
+from nautilus_trader.adapters.bybit.common.constants import BYBIT_ALL_PRODUCTS
+from nautilus_trader.adapters.bybit.common.credentials import get_api_key
+from nautilus_trader.adapters.bybit.common.credentials import get_api_secret
+from nautilus_trader.adapters.bybit.common.enums import BybitProductType
+from nautilus_trader.adapters.bybit.common.urls import get_http_base_url
+from nautilus_trader.adapters.bybit.common.urls import get_ws_base_url_private
+from nautilus_trader.adapters.bybit.common.urls import get_ws_base_url_public
 from nautilus_trader.adapters.bybit.config import BybitDataClientConfig
 from nautilus_trader.adapters.bybit.config import BybitExecClientConfig
 from nautilus_trader.adapters.bybit.data import BybitDataClient
 from nautilus_trader.adapters.bybit.execution import BybitExecutionClient
 from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
-from nautilus_trader.adapters.bybit.provider import BybitInstrumentProvider
-from nautilus_trader.adapters.env import get_env_key
+from nautilus_trader.adapters.bybit.providers import BybitInstrumentProvider
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.component import LiveClock
 from nautilus_trader.common.component import MessageBus
 from nautilus_trader.config import InstrumentProviderConfig
 from nautilus_trader.core.nautilus_pyo3 import Quota
 from nautilus_trader.live.factories import LiveDataClientFactory
 from nautilus_trader.live.factories import LiveExecClientFactory
@@ -63,17 +68,17 @@
 
     Returns
     -------
     BinanceHttpClient
 
     """
     global HTTP_CLIENTS
-    key = key or _get_api_key(is_testnet)
-    secret = secret or _get_api_secret(is_testnet)
-    http_base_url = base_url or _get_http_base_url(is_testnet)
+    key = key or get_api_key(is_testnet)
+    secret = secret or get_api_secret(is_testnet)
+    http_base_url = base_url or get_http_base_url(is_testnet)
     client_key: str = "|".join((key, secret))
 
     # Setup rate limit quotas
     # Current rate limit in bybit is 120 requests in any 5-second window,
     # and that is 24 request per second.
     # https://bybit-exchange.github.io/docs/v5/rate-limit
     ratelimiter_default_quota = Quota.rate_per_second(24)
@@ -91,46 +96,46 @@
         HTTP_CLIENTS[client_key] = client
     return HTTP_CLIENTS[client_key]
 
 
 def get_bybit_instrument_provider(
     client: BybitHttpClient,
     clock: LiveClock,
-    instrument_types: list[BybitInstrumentType],
+    product_types: list[BybitProductType],
     config: InstrumentProviderConfig,
 ) -> BybitInstrumentProvider:
     """
     Cache and return a Bybit instrument provider.
 
     If a cached provider with matching key and secret already exists, then that
     cached provider will be returned.
 
     Parameters
     ----------
     client : BybitHttpClient
         The client for the instrument provider.
     clock : LiveClock
         The clock for the instrument provider.
-    instrument_types : list[BybitInstrumentType]
-        List of instruments to load and sync with.
+    product_types : list[BybitProductType]
+        The product types to load.
     is_testnet : bool
         If the provider is for the Spot testnet.
     config : InstrumentProviderConfig
         The configuration for the instrument provider.
 
     Returns
     -------
     BybitInstrumentProvider
 
     """
     return BybitInstrumentProvider(
         client=client,
         config=config,
         clock=clock,
-        instrument_types=instrument_types,
+        product_types=product_types,
     )
 
 
 class BybitLiveDataClientFactory(LiveDataClientFactory):
     """
     Provides a `Bybit` live data client factory.
     """
@@ -148,58 +153,60 @@
         Create a new Bybit data client.
 
         Parameters
         ----------
         loop : asyncio.AbstractEventLoop
             The event loop for the client.
         name : str
-            The client name.
+            The custom client ID.
         config : BybitDataClientConfig
             The client configuration.
         msgbus : MessageBus
             The message bus for the client.
         cache : Cache
             The cache for the client.
         clock: LiveClock
             The clock for the instrument provider.
 
         Returns
         -------
         BybitDataClient
 
         """
+        product_types = config.product_types or BYBIT_ALL_PRODUCTS
         client: BybitHttpClient = get_bybit_http_client(
             clock=clock,
             key=config.api_key,
             secret=config.api_secret,
             base_url=config.base_url_http,
             is_testnet=config.testnet,
         )
         provider = get_bybit_instrument_provider(
             client=client,
             clock=clock,
-            instrument_types=config.instrument_types,
+            product_types=product_types,
             config=config.instrument_provider,
         )
-        ws_base_urls: dict[BybitInstrumentType, str] = {}
-        for instrument_type in config.instrument_types:
-            ws_base_urls[instrument_type] = _get_ws_base_url_public(
-                instrument_type=instrument_type,
+        ws_base_urls: dict[BybitProductType, str] = {}
+        for product_type in product_types:
+            ws_base_urls[product_type] = get_ws_base_url_public(
+                product_type=product_type,
                 is_testnet=config.testnet,
             )
         return BybitDataClient(
             loop=loop,
             client=client,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             instrument_provider=provider,
-            instrument_types=config.instrument_types,
-            ws_urls=ws_base_urls,
+            product_types=product_types,
+            ws_base_urls=ws_base_urls,
             config=config,
+            name=name,
         )
 
 
 class BybitLiveExecClientFactory(LiveExecClientFactory):
     """
     Provides a `Bybit` live execution client factory.
     """
@@ -217,15 +224,15 @@
         Create a new Bybit execution client.
 
         Parameters
         ----------
         loop : asyncio.AbstractEventLoop
             The event loop for the client.
         name : str
-            The client name.
+            The custom client ID.
         config : BybitExecClientConfig
             The client configuration.
         msgbus : MessageBus
             The message bus for the client.
         cache : Cache
             The cache for the client.
         clock : LiveClock
@@ -242,92 +249,23 @@
             secret=config.api_secret,
             base_url=config.base_url_http,
             is_testnet=config.testnet,
         )
         provider = get_bybit_instrument_provider(
             client=client,
             clock=clock,
-            instrument_types=config.instrument_types,
+            product_types=config.product_types or BYBIT_ALL_PRODUCTS,
             config=config.instrument_provider,
         )
-        default_base_url_ws: str = _get_ws_base_url_private(config.testnet)
+        base_url_ws: str = get_ws_base_url_private(config.testnet)
         return BybitExecutionClient(
             loop=loop,
             client=client,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             instrument_provider=provider,
-            instrument_types=config.instrument_types,
-            base_url_ws=config.base_url_ws or default_base_url_ws,
+            product_types=config.product_types or [BybitProductType.SPOT],
+            base_url_ws=config.base_url_ws or base_url_ws,
             config=config,
+            name=name,
         )
-
-
-def _get_api_key(is_testnet: bool) -> str:
-    if is_testnet:
-        key = get_env_key("BYBIT_TESTNET_API_KEY")
-        if not key:
-            raise ValueError(
-                "BYBIT_TESTNET_API_KEY environment variable not set",
-            )
-        return key
-    else:
-        key = get_env_key("BYBIT_API_KEY")
-        if not key:
-            raise ValueError("BYBIT_API_KEY environment variable not set")
-        return key
-
-
-def _get_api_secret(is_testnet: bool) -> str:
-    if is_testnet:
-        secret = get_env_key("BYBIT_TESTNET_API_SECRET")
-        if not secret:
-            raise ValueError(
-                "BYBIT_TESTNET_API_SECRET environment variable not set",
-            )
-        return secret
-    else:
-        secret = get_env_key("BYBIT_API_SECRET")
-        if not secret:
-            raise ValueError("BYBIT_API_SECRET environment variable not set")
-        return secret
-
-
-def _get_http_base_url(is_testnet: bool):
-    if is_testnet:
-        return "https://api-testnet.bybit.com"
-    else:
-        return "https://api.bytick.com"
-
-
-def _get_ws_base_url_public(
-    instrument_type: BybitInstrumentType,
-    is_testnet: bool,
-) -> str:
-    if not is_testnet:
-        if instrument_type == BybitInstrumentType.SPOT:
-            return "wss://stream.bybit.com/v5/public/spot"
-        elif instrument_type == BybitInstrumentType.LINEAR:
-            return "wss://stream.bybit.com/v5/public/linear"
-        elif instrument_type == BybitInstrumentType.INVERSE:
-            return "wss://stream.bybit.com/v5/public/inverse"
-        else:
-            raise RuntimeError(
-                f"invalid `BybitAccountType`, was {instrument_type}",  # pragma: no cover
-            )
-    else:
-        if instrument_type == BybitInstrumentType.SPOT:
-            return "wss://stream-testnet.bybit.com/v5/public/spot"
-        elif instrument_type == BybitInstrumentType.LINEAR:
-            return "wss://stream-testnet.bybit.com/v5/public/linear"
-        elif instrument_type == BybitInstrumentType.INVERSE:
-            return "wss://stream-testnet.bybit.com/v5/public/inverse"
-        else:
-            raise RuntimeError(f"invalid `BybitAccountType`, was {instrument_type}")
-
-
-def _get_ws_base_url_private(is_testnet: bool) -> str:
-    if is_testnet:
-        return "wss://stream-testnet.bybit.com/v5/private"
-    else:
-        return "wss://stream.bybit.com/v5/private"
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/http/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/http/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/http/account.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/http/market.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,170 +9,195 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.adapters.bybit.common.enums import BybitInstrumentType
-from nautilus_trader.adapters.bybit.common.enums import BybitOrderSide
-from nautilus_trader.adapters.bybit.common.enums import BybitOrderType
-from nautilus_trader.adapters.bybit.common.enums import BybitTimeInForce
-from nautilus_trader.adapters.bybit.endpoints.account.fee_rate import BybitFeeRateEndpoint
-from nautilus_trader.adapters.bybit.endpoints.account.fee_rate import BybitFeeRateGetParameters
-from nautilus_trader.adapters.bybit.endpoints.account.position_info import BybitPositionInfoEndpoint
-from nautilus_trader.adapters.bybit.endpoints.account.position_info import PositionInfoGetParameters
+from nautilus_trader.adapters.bybit.common.enums import BybitKlineInterval
+from nautilus_trader.adapters.bybit.common.enums import BybitProductType
+from nautilus_trader.adapters.bybit.common.symbol import BybitSymbol
 
 # fmt: off
-from nautilus_trader.adapters.bybit.endpoints.account.wallet_balance import BybitWalletBalanceEndpoint
-from nautilus_trader.adapters.bybit.endpoints.account.wallet_balance import BybitWalletBalanceGetParameters
-from nautilus_trader.adapters.bybit.endpoints.trade.cancel_all_orders import BybitCancelAllOrdersEndpoint
-from nautilus_trader.adapters.bybit.endpoints.trade.cancel_all_orders import BybitCancelAllOrdersPostParameters
+from nautilus_trader.adapters.bybit.endpoints.market.instruments_info import BybitInstrumentsInfoEndpoint
+from nautilus_trader.adapters.bybit.endpoints.market.instruments_info import BybitInstrumentsInfoGetParams
 
 # fmt: on
-from nautilus_trader.adapters.bybit.endpoints.trade.open_orders import BybitOpenOrdersGetParameters
-from nautilus_trader.adapters.bybit.endpoints.trade.open_orders import BybitOpenOrdersHttp
-from nautilus_trader.adapters.bybit.endpoints.trade.place_order import BybitPlaceOrderEndpoint
-from nautilus_trader.adapters.bybit.endpoints.trade.place_order import BybitPlaceOrderGetParameters
+from nautilus_trader.adapters.bybit.endpoints.market.klines import BybitKlinesEndpoint
+from nautilus_trader.adapters.bybit.endpoints.market.klines import BybitKlinesGetParams
+from nautilus_trader.adapters.bybit.endpoints.market.server_time import BybitServerTimeEndpoint
+from nautilus_trader.adapters.bybit.endpoints.market.tickers import BybitTickersEndpoint
+from nautilus_trader.adapters.bybit.endpoints.market.tickers import BybitTickersGetParams
+from nautilus_trader.adapters.bybit.endpoints.market.trades import BybitTradesEndpoint
+from nautilus_trader.adapters.bybit.endpoints.market.trades import BybitTradesGetParams
 from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
-from nautilus_trader.adapters.bybit.schemas.account.balance import BybitWalletBalance
-from nautilus_trader.adapters.bybit.schemas.account.fee_rate import BybitFeeRate
-from nautilus_trader.adapters.bybit.schemas.order import BybitOrder
-from nautilus_trader.adapters.bybit.schemas.order import BybitPlaceOrder
-from nautilus_trader.adapters.bybit.schemas.position import BybitPositionStruct
-from nautilus_trader.adapters.bybit.schemas.symbol import BybitSymbol
-from nautilus_trader.adapters.bybit.utils import get_category_from_instrument_type
+from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrument
+from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrumentList
+from nautilus_trader.adapters.bybit.schemas.market.kline import BybitKline
+from nautilus_trader.adapters.bybit.schemas.market.server_time import BybitServerTime
+from nautilus_trader.adapters.bybit.schemas.market.ticker import BybitTickerList
+from nautilus_trader.adapters.bybit.schemas.market.trades import BybitTrade
 from nautilus_trader.common.component import LiveClock
 from nautilus_trader.core.correctness import PyCondition
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import TradeTick
+from nautilus_trader.model.identifiers import InstrumentId
 
 
-class BybitAccountHttpAPI:
+class BybitMarketHttpAPI:
     def __init__(
         self,
         client: BybitHttpClient,
         clock: LiveClock,
     ) -> None:
         PyCondition.not_none(client, "client")
         self.client = client
         self._clock = clock
-        self.base_endpoint = "/v5"
-        self.default_settle_coin = "USDT"
+        self.base_endpoint = "/v5/market/"
 
-        # endpoints
-        self._endpoint_fee_rate = BybitFeeRateEndpoint(client, self.base_endpoint)
-        self._endpoint_position_info = BybitPositionInfoEndpoint(client, self.base_endpoint)
-        self._endpoint_open_orders = BybitOpenOrdersHttp(client, self.base_endpoint)
-        self._endpoint_wallet_balance = BybitWalletBalanceEndpoint(client, self.base_endpoint)
-        self._endpoint_order = BybitPlaceOrderEndpoint(client, self.base_endpoint)
-        self._endpoint_cancel_all_orders = BybitCancelAllOrdersEndpoint(client, self.base_endpoint)
+        self._endpoint_instruments = BybitInstrumentsInfoEndpoint(client, self.base_endpoint)
+        self._endpoint_server_time = BybitServerTimeEndpoint(client, self.base_endpoint)
+        self._endpoint_klines = BybitKlinesEndpoint(client, self.base_endpoint)
+        self._endpoint_tickers = BybitTickersEndpoint(client, self.base_endpoint)
+        self._endpoint_trades = BybitTradesEndpoint(client, self.base_endpoint)
 
-    async def fetch_fee_rate(
+    def _get_url(self, url: str) -> str:
+        return self.base_endpoint + url
+
+    async def fetch_tickers(
         self,
-        instrument_type: BybitInstrumentType,
+        product_type: BybitProductType,
         symbol: str | None = None,
         base_coin: str | None = None,
-    ) -> list[BybitFeeRate]:
-        response = await self._endpoint_fee_rate.get(
-            BybitFeeRateGetParameters(
-                category=instrument_type,
+    ) -> BybitTickerList:
+        response = await self._endpoint_tickers.get(
+            BybitTickersGetParams(
+                category=product_type,
                 symbol=symbol,
                 baseCoin=base_coin,
             ),
         )
         return response.result.list
 
-    async def query_position_info(
-        self,
-        instrument_type: BybitInstrumentType,
-        symbol: str | None = None,
-    ) -> list[BybitPositionStruct]:
-        # symbol = 'USD'
-        response = await self._endpoint_position_info.get(
-            PositionInfoGetParameters(
-                symbol=BybitSymbol(symbol) if symbol else None,
-                settleCoin=self.default_settle_coin if symbol is None else None,
-                category=get_category_from_instrument_type(instrument_type),
+    async def fetch_server_time(self) -> BybitServerTime:
+        response = await self._endpoint_server_time.get()
+        return response.result
+
+    async def fetch_instruments(
+        self,
+        product_type: BybitProductType,
+    ) -> BybitInstrumentList:
+        response = await self._endpoint_instruments.get(
+            BybitInstrumentsInfoGetParams(
+                category=product_type,
             ),
         )
         return response.result.list
 
-    # async def close_all_positions(self):
-    #     all_positions = await self.query_position_info()
-    #     for position in all_positions:
-    #         print("Closing position: ")
-
-    async def query_open_orders(
+    async def fetch_instrument(
         self,
-        instrument_type: BybitInstrumentType,
-        symbol: str | None = None,
-    ) -> list[BybitOrder]:
-        response = await self._endpoint_open_orders.get(
-            BybitOpenOrdersGetParameters(
-                category=instrument_type,
-                symbol=BybitSymbol(symbol) if symbol else None,
-                settleCoin=self.default_settle_coin if symbol is None else None,
+        product_type: BybitProductType,
+        symbol: str,
+    ) -> BybitInstrument:
+        response = await self._endpoint_instruments.get(
+            BybitInstrumentsInfoGetParams(
+                category=product_type,
+                symbol=symbol,
             ),
         )
-        return response.result.list
+        return response.result.list[0]
 
-    async def query_order(
+    async def fetch_klines(
         self,
-        instrument_type: BybitInstrumentType,
+        product_type: BybitProductType,
         symbol: str,
-        order_id: str,
-    ) -> list[BybitOrder]:
-        response = await self._endpoint_open_orders.get(
-            BybitOpenOrdersGetParameters(
-                category=instrument_type,
-                symbol=BybitSymbol(symbol) if symbol else None,
-                orderId=order_id,
+        interval: BybitKlineInterval,
+        limit: int | None = None,
+        start: int | None = None,
+        end: int | None = None,
+    ) -> list[BybitKline]:
+        response = await self._endpoint_klines.get(
+            params=BybitKlinesGetParams(
+                category=product_type.value,
+                symbol=symbol,
+                interval=interval,
+                limit=limit,
+                start=start,
+                end=end,
             ),
         )
         return response.result.list
 
-    async def cancel_all_orders(
+    async def fetch_public_trades(
         self,
-        instrument_type: BybitInstrumentType,
+        product_type: BybitProductType,
         symbol: str,
-    ):
-        response = await self._endpoint_cancel_all_orders.post(
-            BybitCancelAllOrdersPostParameters(
-                category=get_category_from_instrument_type(instrument_type),
-                symbol=BybitSymbol(symbol),
+        limit: int | None = None,
+    ) -> list[BybitTrade]:
+        response = await self._endpoint_trades.get(
+            params=BybitTradesGetParams(
+                category=product_type.value,
+                symbol=symbol,
+                limit=limit,
             ),
         )
         return response.result.list
 
-    async def query_wallet_balance(
-        self,
-        coin: str | None = None,
-    ) -> tuple[list[BybitWalletBalance], int]:
-        response = await self._endpoint_wallet_balance.get(
-            BybitWalletBalanceGetParameters(
-                accountType="UNIFIED",
-            ),
-        )
-        return response.result.list, response.time
-
-    async def place_order(
+    async def request_bybit_trades(
         self,
-        instrument_type: BybitInstrumentType,
-        symbol: str,
-        side: BybitOrderSide,
-        order_type: BybitOrderType,
-        time_in_force: BybitTimeInForce | None = None,
-        quantity: str | None = None,
-        price: str | None = None,
-        order_id: str | None = None,
-    ) -> BybitPlaceOrder:
-        result = await self._endpoint_order.post(
-            parameters=BybitPlaceOrderGetParameters(
-                category=get_category_from_instrument_type(instrument_type),
-                symbol=BybitSymbol(symbol),
-                side=side,
-                orderType=order_type,
-                qty=quantity,
-                price=price,
-                orderLinkId=order_id,
-            ),
-        )
-        return result.result
+        instrument_id: InstrumentId,
+        ts_init: int,
+        limit: int = 1000,
+    ) -> list[Bar]:
+        bybit_symbol = BybitSymbol(instrument_id.symbol.value)
+        trades = await self.fetch_public_trades(
+            symbol=bybit_symbol.raw_symbol,
+            product_type=bybit_symbol.product_type,
+            limit=limit,
+        )
+        trade_ticks: list[TradeTick] = [t.parse_to_trade(instrument_id, ts_init) for t in trades]
+        return trade_ticks
+
+    async def request_bybit_bars(
+        self,
+        bar_type: BarType,
+        interval: BybitKlineInterval,
+        ts_init: int,
+        limit: int = 1000,
+        start: int | None = None,
+        end: int | None = None,
+    ) -> list[Bar]:
+        all_bars = []
+        while True:
+            bybit_symbol = BybitSymbol(bar_type.instrument_id.symbol.value)
+            klines = await self.fetch_klines(
+                symbol=bybit_symbol.raw_symbol,
+                product_type=bybit_symbol.product_type,
+                interval=interval,
+                limit=limit,
+                start=start,
+                end=end,
+            )
+            bars: list[Bar] = [kline.parse_to_bar(bar_type, ts_init) for kline in klines]
+            all_bars.extend(bars)
+            if klines:
+                next_start_time = int(klines[-1].startTime) + 1
+            else:
+                break
+            if end is None or ((limit and len(klines) < limit) or next_start_time > end):
+                break
+            start = next_start_time
+        return all_bars
+
+    # async def get_risk_limits(self):
+    #     params = {"category": "linear"}
+    #     try:
+    #         raw: bytes = await self.client.send_request(
+    #             http_method=HttpMethod.GET,
+    #             url_path=self._get_url("risk-limit"),
+    #             payload=params,
+    #         )
+    #         decoded = self._decoder_risk_limit.decode(raw)
+    #         return decoded.result.list
+    #     except Exception as e:
+    #         print(e)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/http/client.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/http/client.py`

 * *Files 12% similar despite different names*

```diff
@@ -11,61 +11,69 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import hashlib
 import hmac
-import urllib
 from typing import Any
+from urllib import parse
 
-import aiohttp
 import msgspec
 
 import nautilus_trader
 from nautilus_trader.adapters.bybit.common.error import raise_bybit_error
 from nautilus_trader.adapters.bybit.http.errors import BybitError
 from nautilus_trader.common.component import LiveClock
 from nautilus_trader.common.component import Logger
 from nautilus_trader.core.nautilus_pyo3 import HttpClient
 from nautilus_trader.core.nautilus_pyo3 import HttpMethod
 from nautilus_trader.core.nautilus_pyo3 import HttpResponse
 from nautilus_trader.core.nautilus_pyo3 import Quota
 
 
-def create_string_from_dict(data):
-    property_strings = []
-
-    for key, value in data.items():
-        property_string = f'"{key}":"{value}"'
-        property_strings.append(property_string)
-
-    result_string = "{" + ",".join(property_strings) + "}"
-    return result_string
-
-
 class ResponseCode(msgspec.Struct):
     retCode: int
 
 
 class BybitHttpClient:
+    """
+    Provides a `Bybit` asynchronous HTTP client.
+
+    Parameters
+    ----------
+    clock : LiveClock
+        The clock for the client.
+    key : str
+        The Bybit API key for requests.
+    secret : str
+        The Bybit API secret for signed requests.
+    base_url : str, optional
+        The base endpoint URL for the client.
+    ratelimiter_quotas : list[tuple[str, Quota]], optional
+        The keyed rate limiter quotas for the client.
+    ratelimiter_quota : Quota, optional
+        The default rate limiter quota for the client.
+
+    """
+
     def __init__(
         self,
         clock: LiveClock,
         api_key: str,
         api_secret: str,
         base_url: str,
         ratelimiter_quotas: list[tuple[str, Quota]] | None = None,
         ratelimiter_default_quota: Quota | None = None,
     ) -> None:
         self._clock: LiveClock = clock
         self._log: Logger = Logger(name=type(self).__name__)
         self._api_key: str = api_key
         self._api_secret: str = api_secret
-        self._recv_window: int = 8000
+        self._recv_window: int = 5000
 
         self._base_url: str = base_url
         self._headers: dict[str, Any] = {
             "Content-Type": "application/json",
             "User-Agent": nautilus_trader.USER_AGENT,
             "X-BAPI-API-KEY": self._api_key,
         }
@@ -89,60 +97,63 @@
         url_path: str,
         payload: dict[str, str] | None = None,
         signature: str | None = None,
         timestamp: str | None = None,
         ratelimiter_keys: list[str] | None = None,
     ) -> bytes | None:
         if payload and http_method == HttpMethod.GET:
-            url_path += "?" + urllib.parse.urlencode(payload)
+            url_path += "?" + parse.urlencode(payload)
             payload = None
         url = self._base_url + url_path
         if signature is not None:
             headers = {
                 **self._headers,
                 "X-BAPI-TIMESTAMP": timestamp,
                 "X-BAPI-SIGN": signature,
                 "X-BAPI-RECV-WINDOW": str(self._recv_window),
             }
         else:
             headers = self._headers
+
+        # Uncomment for development
+        # self._log.info(f"{url_path=}, {payload=}", LogColor.MAGENTA)
+
         response: HttpResponse = await self._client.request(
             http_method,
             url,
             headers,
             msgspec.json.encode(payload) if payload else None,
             ratelimiter_keys,
         )
-        # first check for server error
+        # First check for server error
         if 400 <= response.status < 500:
             message = msgspec.json.decode(response.body) if response.body else None
-            print(str(response.body))
             raise BybitError(
                 status=response.status,
                 message=message,
                 headers=response.headers,
             )
-        # then check for error inside spot response
+        # Then check for error inside response
         response_status = self._decoder_response_code.decode(response.body)
         if response_status.retCode == 0:
             return response.body
         else:
-            raise_bybit_error(response_status.retCode)
+            message = msgspec.json.decode(response.body) if response.body else None
+            raise_bybit_error(response_status.retCode, message)
         return None
 
     async def sign_request(
         self,
         http_method: HttpMethod,
         url_path: str,
         payload: dict[str, str] | None = None,
         ratelimiter_keys: list[str] | None = None,
     ) -> Any:
         if payload is None:
             payload = {}
-        # we need to get timestamp and signature
 
         [timestamp, authed_signature] = (
             self._sign_get_request(payload)
             if http_method == HttpMethod.GET
             else self._sign_post_request(payload)
         )
         return await self.send_request(
@@ -150,33 +161,28 @@
             url_path=url_path,
             payload=payload,
             signature=authed_signature,
             timestamp=timestamp,
             ratelimiter_keys=ratelimiter_keys,
         )
 
-    def _handle_exception(self, error: aiohttp.ClientResponseError):
-        self._log.error(
-            f"Some exception in HTTP request status: {error.status} message:{error.message}",
-        )
-
     def _sign_post_request(self, payload: dict[str, Any]) -> list[str]:
         timestamp = str(self._clock.timestamp_ms())
-        payload_str = create_string_from_dict(payload)
+        payload_str = msgspec.json.encode(payload).decode()
         result = timestamp + self._api_key + str(self._recv_window) + payload_str
         signature = hmac.new(
-            self._api_secret.encode("utf-8"),
-            result.encode("utf-8"),
+            self._api_secret.encode(),
+            result.encode(),
             hashlib.sha256,
         ).hexdigest()
         return [timestamp, signature]
 
     def _sign_get_request(self, payload: dict[str, Any]) -> list[str]:
         timestamp = str(self._clock.timestamp_ms())
-        payload_str = urllib.parse.urlencode(payload)
+        payload_str = parse.urlencode(payload)
         result = timestamp + self._api_key + str(self._recv_window) + payload_str
         signature = hmac.new(
-            self._api_secret.encode("utf-8"),
-            result.encode("utf-8"),
+            self._api_secret.encode(),
+            result.encode(),
             hashlib.sha256,
         ).hexdigest()
         return [timestamp, signature]
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/http/errors.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/http/errors.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/http/market.py` & `nautilus_trader-1.191.0/nautilus_trader/persistence/catalog/base.py`

 * *Files 27% similar despite different names*

```diff
@@ -9,165 +9,186 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.adapters.bybit.common.enums import BybitInstrumentType
-from nautilus_trader.adapters.bybit.common.enums import BybitKlineInterval
+from __future__ import annotations
 
-# fmt: off
-from nautilus_trader.adapters.bybit.endpoints.market.instruments_info import BybitInstrumentsInfoEndpoint
-from nautilus_trader.adapters.bybit.endpoints.market.instruments_info import BybitInstrumentsInfoGetParameters
-
-# fmt: on
-from nautilus_trader.adapters.bybit.endpoints.market.klines import BybitKlinesEndpoint
-from nautilus_trader.adapters.bybit.endpoints.market.klines import BybitKlinesGetParameters
-from nautilus_trader.adapters.bybit.endpoints.market.server_time import BybitServerTimeEndpoint
-from nautilus_trader.adapters.bybit.endpoints.market.tickers import BybitTickersEndpoint
-from nautilus_trader.adapters.bybit.endpoints.market.tickers import BybitTickersGetParameters
-from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
-from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrument
-from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrumentList
-from nautilus_trader.adapters.bybit.schemas.market.kline import BybitKline
-from nautilus_trader.adapters.bybit.schemas.market.server_time import BybitServerTime
-from nautilus_trader.adapters.bybit.schemas.market.ticker import BybitTickerList
-from nautilus_trader.adapters.bybit.schemas.symbol import BybitSymbol
-from nautilus_trader.adapters.bybit.utils import get_category_from_instrument_type
-from nautilus_trader.common.component import LiveClock
-from nautilus_trader.core.correctness import PyCondition
+from abc import ABC
+from abc import ABCMeta
+from abc import abstractmethod
+from typing import Any
+
+from nautilus_trader.core.data import Data
 from nautilus_trader.model.data import Bar
-from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import CustomData
+from nautilus_trader.model.data import DataType
+from nautilus_trader.model.data import InstrumentClose
+from nautilus_trader.model.data import InstrumentStatus
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import OrderBookDepth10
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
+from nautilus_trader.model.instruments import Instrument
+from nautilus_trader.persistence.catalog.singleton import Singleton
+from nautilus_trader.persistence.funcs import CUSTOM_DATA_PREFIX
+
+
+class _CombinedMeta(Singleton, ABCMeta):
+    pass
+
+
+class BaseDataCatalog(ABC, metaclass=_CombinedMeta):
+    """
+    Provides a abstract base class for a queryable data catalog.
+    """
+
+    @classmethod
+    @abstractmethod
+    def from_env(cls) -> BaseDataCatalog:
+        raise NotImplementedError
+
+    @classmethod
+    @abstractmethod
+    def from_uri(cls, uri: str) -> BaseDataCatalog:
+        raise NotImplementedError
+
+    # -- QUERIES -----------------------------------------------------------------------------------
+
+    @abstractmethod
+    def query(
+        self,
+        data_cls: type,
+        instrument_ids: list[str] | None = None,
+        bar_types: list[str] | None = None,
+        **kwargs: Any,
+    ) -> list[Data]:
+        raise NotImplementedError
+
+    def _query_subclasses(
+        self,
+        base_cls: type,
+        instrument_ids: list[str] | None = None,
+        **kwargs: Any,
+    ) -> list[Data]:
+        objects = []
+        for cls in base_cls.__subclasses__():
+            try:
+                objs = self.query(data_cls=cls, instrument_ids=instrument_ids, **kwargs)
+                objects.extend(objs)
+            except AssertionError as e:
+                print(e)
+                continue
+
+        return objects
+
+    def instruments(
+        self,
+        instrument_type: type | None = None,
+        instrument_ids: list[str] | None = None,
+        **kwargs: Any,
+    ) -> list[Instrument]:
+        if instrument_type is not None:
+            assert isinstance(instrument_type, type)
+            base_cls = instrument_type
+        else:
+            base_cls = Instrument
+
+        return self._query_subclasses(
+            base_cls=base_cls,
+            instrument_ids=instrument_ids,
+            instrument_id_column="id",
+            **kwargs,
+        )
 
+    def instrument_status(
+        self,
+        instrument_ids: list[str] | None = None,
+        **kwargs: Any,
+    ) -> list[InstrumentStatus]:
+        return self.query(data_cls=InstrumentStatus, instrument_ids=instrument_ids, **kwargs)
 
-class BybitMarketHttpAPI:
-    def __init__(
+    def instrument_closes(
         self,
-        client: BybitHttpClient,
-        clock: LiveClock,
-    ) -> None:
-        PyCondition.not_none(client, "client")
-        self.client = client
-        self._clock = clock
-        self.base_endpoint = "/v5/market/"
-
-        # endpoints
-        self._endpoint_instruments = BybitInstrumentsInfoEndpoint(
-            client,
-            self.base_endpoint,
-        )
-        self._endpoint_server_time = BybitServerTimeEndpoint(client, self.base_endpoint)
-        self._endpoint_klines = BybitKlinesEndpoint(client, self.base_endpoint)
-        self._endpoint_tickers = BybitTickersEndpoint(client, self.base_endpoint)
-
-    def _get_url(self, url: str) -> str:
-        return self.base_endpoint + url
-
-    async def fetch_tickers(
-        self,
-        instrument_type: BybitInstrumentType,
-        symbol: str | None = None,
-        base_coin: str | None = None,
-    ) -> BybitTickerList:
-        response = await self._endpoint_tickers.get(
-            BybitTickersGetParameters(
-                category=instrument_type,
-                symbol=symbol,
-                baseCoin=base_coin,
-            ),
-        )
-        return response.result.list
+        instrument_ids: list[str] | None = None,
+        **kwargs: Any,
+    ) -> list[InstrumentClose]:
+        return self.query(data_cls=InstrumentClose, instrument_ids=instrument_ids, **kwargs)
 
-    async def fetch_server_time(self) -> BybitServerTime:
-        response = await self._endpoint_server_time.get()
-        return response.result
-
-    async def fetch_instruments(
-        self,
-        instrument_type: BybitInstrumentType,
-    ) -> BybitInstrumentList:
-        response = await self._endpoint_instruments.get(
-            BybitInstrumentsInfoGetParameters(
-                category=instrument_type,
-            ),
-        )
-        return response.result.list
+    def order_book_deltas(
+        self,
+        instrument_ids: list[str] | None = None,
+        **kwargs: Any,
+    ) -> list[OrderBookDelta]:
+        return self.query(data_cls=OrderBookDelta, instrument_ids=instrument_ids, **kwargs)
 
-    async def fetch_instrument(
+    def order_book_depth10(
         self,
-        instrument_type: BybitInstrumentType,
-        symbol: str,
-    ) -> BybitInstrument:
-        response = await self._endpoint_instruments.get(
-            BybitInstrumentsInfoGetParameters(
-                category=instrument_type,
-                symbol=symbol,
-            ),
-        )
-        return response.result.list[0]
+        instrument_ids: list[str] | None = None,
+        **kwargs: Any,
+    ) -> list[OrderBookDepth10]:
+        return self.query(data_cls=OrderBookDepth10, instrument_ids=instrument_ids, **kwargs)
 
-    async def fetch_klines(
+    def quote_ticks(
         self,
-        instrument_type: BybitInstrumentType,
-        symbol: str,
-        interval: BybitKlineInterval,
-        limit: int | None = None,
-        start: int | None = None,
-        end: int | None = None,
-    ) -> list[BybitKline]:
-        response = await self._endpoint_klines.get(
-            parameters=BybitKlinesGetParameters(
-                category=get_category_from_instrument_type(instrument_type),
-                symbol=symbol,
-                interval=interval,
-                limit=limit,
-                start=start,
-                end=end,
-            ),
-        )
-        return response.result.list
+        instrument_ids: list[str] | None = None,
+        **kwargs: Any,
+    ) -> list[QuoteTick]:
+        return self.query(data_cls=QuoteTick, instrument_ids=instrument_ids, **kwargs)
+
+    def trade_ticks(
+        self,
+        instrument_ids: list[str] | None = None,
+        **kwargs: Any,
+    ) -> list[TradeTick]:
+        return self.query(data_cls=TradeTick, instrument_ids=instrument_ids, **kwargs)
 
-    async def request_bybit_bars(
+    def bars(
         self,
-        instrument_type: BybitInstrumentType,
-        bar_type: BarType,
-        interval: BybitKlineInterval,
-        ts_init: int,
-        limit: int = 100,
-        start: int | None = None,
-        end: int | None = None,
+        bar_types: list[str] | None = None,
+        **kwargs: Any,
     ) -> list[Bar]:
-        all_bars = []
-        while True:
-            bybit_symbol: BybitSymbol = BybitSymbol(bar_type.instrument_id.symbol.value)
-            klines = await self.fetch_klines(
-                symbol=bybit_symbol,
-                instrument_type=instrument_type,
-                interval=interval,
-                limit=limit,
-                start=start,
-                end=end,
-            )
-            bars: list[Bar] = [kline.parse_to_bar(bar_type, ts_init) for kline in klines]
-            all_bars.extend(bars)
-            if klines:
-                next_start_time = int(klines[-1].startTime) + 1
-            else:
-                break
-            if end is None or ((limit and len(klines) < limit) or next_start_time > end):
-                break
-            start = next_start_time
-        return all_bars
-
-    # async def get_risk_limits(self):
-    #     params = {"category": "linear"}
-    #     try:
-    #         raw: bytes = await self.client.send_request(
-    #             http_method=HttpMethod.GET,
-    #             url_path=self._get_url("risk-limit"),
-    #             payload=params,
-    #         )
-    #         decoded = self._decoder_risk_limit.decode(raw)
-    #         return decoded.result.list
-    #     except Exception as e:
-    #         print(e)
+        return self.query(data_cls=Bar, bar_types=bar_types, **kwargs)
+
+    def custom_data(
+        self,
+        cls: type,
+        as_nautilus: bool = False,
+        metadata: dict | None = None,
+        **kwargs: Any,
+    ) -> list[CustomData]:
+        data = self.query(data_cls=cls, **kwargs)
+        if as_nautilus:
+            if data is None:
+                return []
+            return [CustomData(data_type=DataType(cls, metadata=metadata), data=d) for d in data]
+        return data
+
+    @abstractmethod
+    def list_data_types(self) -> list[str]:
+        raise NotImplementedError
+
+    def list_generic_data_types(self) -> list[str]:
+        data_types = self.list_data_types()
+        return [
+            n.replace(CUSTOM_DATA_PREFIX, "")
+            for n in data_types
+            if n.startswith(CUSTOM_DATA_PREFIX)
+        ]
+
+    @abstractmethod
+    def list_backtest_runs(self) -> list[str]:
+        raise NotImplementedError
+
+    @abstractmethod
+    def list_live_runs(self) -> list[str]:
+        raise NotImplementedError
+
+    @abstractmethod
+    def read_live_run(self, instance_id: str, **kwargs: Any) -> list[str]:
+        raise NotImplementedError
+
+    @abstractmethod
+    def read_backtest(self, instance_id: str, **kwargs: Any) -> list[str]:
+        raise NotImplementedError
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/http/user.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/http/user.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/provider.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/providers.py`

 * *Files 17% similar despite different names*

```diff
@@ -12,20 +12,23 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import msgspec
 
 from nautilus_trader.adapters.bybit.common.constants import BYBIT_VENUE
-from nautilus_trader.adapters.bybit.common.enums import BybitInstrumentType
+from nautilus_trader.adapters.bybit.common.enums import BybitProductType
+from nautilus_trader.adapters.bybit.common.symbol import BybitSymbol
 from nautilus_trader.adapters.bybit.http.account import BybitAccountHttpAPI
+from nautilus_trader.adapters.bybit.http.asset import BybitAssetHttpAPI
 from nautilus_trader.adapters.bybit.http.client import BybitHttpClient
 from nautilus_trader.adapters.bybit.http.market import BybitMarketHttpAPI
 from nautilus_trader.adapters.bybit.schemas.account.fee_rate import BybitFeeRate
 from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrument
+from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrumentInverse
 from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrumentLinear
 from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrumentList
 from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrumentOption
 from nautilus_trader.adapters.bybit.schemas.instrument import BybitInstrumentSpot
 from nautilus_trader.common.component import LiveClock
 from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.config import InstrumentProviderConfig
@@ -39,32 +42,37 @@
 
     Parameters
     ----------
     client : BybitHttpClient
         The Bybit HTTP client.
     clock : LiveClock
         The clock instance.
-    instrument_types : list[BybitInstrumentType]
-        The instrument types to load.
+    product_types : list[BybitProductType]
+        The product types to load.
     config : InstrumentProviderConfig, optional
         The instrument provider configuration, by default None.
 
     """
 
     def __init__(
         self,
         client: BybitHttpClient,
         clock: LiveClock,
-        instrument_types: list[BybitInstrumentType],
+        product_types: list[BybitProductType],
         config: InstrumentProviderConfig | None = None,
     ) -> None:
         super().__init__(config=config)
         self._clock = clock
         self._client = client
-        self._instrument_types = instrument_types
+        self._product_types = product_types
+
+        self._http_asset = BybitAssetHttpAPI(
+            client=client,
+            clock=clock,
+        )
 
         self._http_market = BybitMarketHttpAPI(
             client=client,
             clock=clock,
         )
         self._http_account = BybitAccountHttpAPI(
             client=client,
@@ -75,133 +83,198 @@
         self._decoder = msgspec.json.Decoder()
         self._encoder = msgspec.json.Encoder()
 
     async def load_all_async(self, filters: dict | None = None) -> None:
         filters_str = "..." if not filters else f" with filters {filters}..."
         self._log.info(f"Loading all instruments{filters_str}")
 
-        instrument_infos: dict[BybitInstrumentType, BybitInstrumentList] = {}
-        fee_rates_infos: dict[BybitInstrumentType, list[BybitFeeRate]] = {}
+        await self._load_coins()
 
-        for instrument_type in self._instrument_types:
-            instrument_infos[instrument_type] = await self._http_market.fetch_instruments(
-                instrument_type,
+        instrument_infos: dict[BybitProductType, BybitInstrumentList] = {}
+        fee_rates: dict[BybitProductType, list[BybitFeeRate]] = {}
+
+        for product_type in self._product_types:
+            instrument_infos[product_type] = await self._http_market.fetch_instruments(
+                product_type,
             )
-            fee_rates_infos[instrument_type] = await self._http_account.fetch_fee_rate(
-                instrument_type,
+            fee_rates[product_type] = await self._http_account.fetch_fee_rate(
+                product_type,
             )
 
-        # risk_limits = await self._http_market.get_risk_limits()
-        for instrument_type in instrument_infos:
-            for instrument in instrument_infos[instrument_type]:
-                ## find target fee rate in list by symbol
+        for product_type in instrument_infos:
+            if product_type == BybitProductType.OPTION:
+                self._log.warning("Options not currently supported")
+                continue
+
+            for instrument in instrument_infos[product_type]:
                 target_fee_rate = next(
-                    (
-                        item
-                        for item in fee_rates_infos[instrument_type]
-                        if item.symbol == instrument.symbol
-                    ),
+                    (item for item in fee_rates[product_type] if item.symbol == instrument.symbol),
                     None,
                 )
                 if target_fee_rate:
                     self._parse_instrument(instrument, target_fee_rate)
                 else:
                     self._log.warning(
-                        f"Unable to find fee rate for instrument {instrument}.",
+                        f"Unable to find fee rate for instrument {instrument}",
                     )
-        self._log.info(f"Loaded {len(self._instruments)} instruments.")
+        self._log.info(f"Loaded {len(self._instruments)} instruments")
 
     async def load_ids_async(
         self,
         instrument_ids: list[InstrumentId],
         filters: dict | None = None,
     ) -> None:
         if not instrument_ids:
-            self._log.info("No instrument IDs given for loading.")
+            self._log.info("No instrument IDs given for loading")
             return
 
+        await self._load_coins()
+
         # Check all instrument IDs
         for instrument_id in instrument_ids:
             PyCondition.equal(instrument_id.venue, BYBIT_VENUE, "instrument_id.venue", "BYBIT")
 
-        filters_str = "..." if not filters else f" with filters {filters}..."
-        self._log.info(f"Loading instruments {instrument_ids}{filters_str}.")
+        instrument_infos: dict[BybitProductType, BybitInstrumentList] = {}
+        fee_rates: dict[BybitProductType, list[BybitFeeRate]] = {}
+
+        for product_type in self._product_types:
+            instrument_infos[product_type] = await self._http_market.fetch_instruments(
+                product_type,
+            )
+            fee_rates[product_type] = await self._http_account.fetch_fee_rate(
+                product_type,
+            )
+
+            filters_str = "..." if not filters else f" with filters {filters}..."
+            self._log.info(f"Loading instruments {instrument_ids}{filters_str}")
+
+            # extract symbol strings and product types
+            for instrument_id in instrument_ids:
+                bybit_symbol = BybitSymbol(instrument_id.symbol.value)
+                instrument = await self._http_market.fetch_instrument(
+                    bybit_symbol.product_type,
+                    bybit_symbol.raw_symbol,
+                )
+                target_fee_rate = next(
+                    (item for item in fee_rates[product_type] if item.symbol == instrument.symbol),
+                    None,
+                )
+                if target_fee_rate:
+                    self._parse_instrument(instrument, target_fee_rate)
+                else:
+                    self._log.warning(
+                        f"Unable to find fee rate for instrument {instrument}",
+                    )
+
+    async def load_async(self, instrument_id: InstrumentId, filters: dict | None = None) -> None:
+        PyCondition.not_none(instrument_id, "instrument_id")
+        await self.load_ids_async([instrument_id], filters)
 
-        # extract symbol strings and instrument types
-        # for instrument_id in instrument_ids:
-        #     bybit_symbol = BybitSymbol(instrument_id.symbol.value)
-        #     instrument = await self._http_market.fetch_instrument(
-        #         bybit_symbol.instrument_type,
-        #         bybit_symbol.raw_symbol,
-        #     )
-        #     self._parse_instrument(instrument)
+    async def _load_coins(self) -> None:
+        coin_infos = await self._http_asset.fetch_coin_info()
+
+        for coin_info in coin_infos:
+            if coin_info.coin == "EVERY":
+                # Has precision 18 (exceeds max 9) and not used for any instrument?
+                continue
+            try:
+                currency = coin_info.parse_to_currency()
+            except ValueError as e:
+                self._log.warning(f"Unable to parse currency {coin_info}: {e}")
+                continue
+
+            self.add_currency(currency)
 
     def _parse_instrument(
         self,
         instrument: BybitInstrument,
         fee_rate: BybitFeeRate,
     ) -> None:
         if isinstance(instrument, BybitInstrumentSpot):
             self._parse_spot_instrument(instrument, fee_rate)
         elif isinstance(instrument, BybitInstrumentLinear):
+            # Perpetual and futures
             self._parse_linear_instrument(instrument, fee_rate)
+        elif isinstance(instrument, BybitInstrumentInverse):
+            # Perpetual and futures (inverse)
+            self._parse_inverse_instrument(instrument, fee_rate)
         elif isinstance(instrument, BybitInstrumentOption):
-            self._parse_option_instrument(instrument)
+            self._parse_option_instrument(instrument, fee_rate)
         else:
-            raise TypeError("Unsupported instrument type in BybitInstrumentProvider")
-
-    async def load_async(self, instrument_id: InstrumentId, filters: dict | None = None) -> None:
-        PyCondition.not_none(instrument_id, "instrument_id")
+            raise TypeError(f"Unsupported Bybit instrument, was {instrument}")
 
     def _parse_spot_instrument(
         self,
         data: BybitInstrumentSpot,
         fee_rate: BybitFeeRate,
     ) -> None:
         try:
-            base_currency = data.parse_to_base_currency()
-            quote_currency = data.parse_to_quote_currency()
+            base_currency = self.currency(data.baseCoin)
+            quote_currency = self.currency(data.quoteCoin)
             ts_event = self._clock.timestamp_ns()
             ts_init = self._clock.timestamp_ns()
             instrument = data.parse_to_instrument(
+                base_currency=base_currency,
+                quote_currency=quote_currency,
                 fee_rate=fee_rate,
                 ts_event=ts_event,
                 ts_init=ts_init,
             )
-            self.add_currency(base_currency)
-            self.add_currency(quote_currency)
             self.add(instrument=instrument)
         except ValueError as e:
             if self._log_warnings:
-                self._log.warning(f"Unable to parse option instrument {data.symbol}, {e}.")
+                self._log.warning(f"Unable to parse option instrument {data.symbol}: {e}")
 
-    def _parse_option_instrument(
+    def _parse_linear_instrument(
         self,
-        instrument: BybitInstrumentOption,
+        data: BybitInstrumentLinear,
+        fee_rate: BybitFeeRate,
     ) -> None:
         try:
-            pass
+            base_currency = self.currency(data.baseCoin)
+            quote_currency = self.currency(data.quoteCoin)
+            ts_event = self._clock.timestamp_ns()
+            ts_init = self._clock.timestamp_ns()
+            instrument = data.parse_to_instrument(
+                base_currency=base_currency,
+                quote_currency=quote_currency,
+                fee_rate=fee_rate,
+                ts_event=ts_event,
+                ts_init=ts_init,
+            )
+            self.add(instrument=instrument)
         except ValueError as e:
             if self._log_warnings:
-                self._log.warning(f"Unable to parse option instrument {instrument.symbol}, {e}.")
+                self._log.warning(f"Unable to parse linear instrument {data.symbol}: {e}")
 
-    def _parse_linear_instrument(
+    def _parse_inverse_instrument(
         self,
-        data: BybitInstrumentLinear,
+        data: BybitInstrumentInverse,
         fee_rate: BybitFeeRate,
     ) -> None:
         try:
-            base_currency = data.parse_to_base_currency()
-            quote_currency = data.parse_to_quote_currency()
+            base_currency = self.currency(data.baseCoin)
+            quote_currency = self.currency(data.quoteCoin)
             ts_event = self._clock.timestamp_ns()
             ts_init = self._clock.timestamp_ns()
             instrument = data.parse_to_instrument(
+                base_currency=base_currency,
+                quote_currency=quote_currency,
                 fee_rate=fee_rate,
                 ts_event=ts_event,
                 ts_init=ts_init,
             )
-            self.add_currency(base_currency)
-            self.add_currency(quote_currency)
             self.add(instrument=instrument)
         except ValueError as e:
             if self._log_warnings:
-                self._log.warning(f"Unable to parse instrument {data.symbol}, {e}.")
+                self._log.warning(f"Unable to parse inverse instrument {data.symbol}: {e}")
+
+    def _parse_option_instrument(
+        self,
+        instrument: BybitInstrumentOption,
+        fee_rate: BybitFeeRate,
+    ) -> None:
+        try:
+            pass
+        except ValueError as e:
+            if self._log_warnings:
+                self._log.warning(f"Unable to parse option instrument {instrument.symbol}: {e}")
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/account/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/account/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/account/balance.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/account/balance.py`

 * *Files 12% similar despite different names*

```diff
@@ -48,19 +48,15 @@
     # Whether the collateral is turned on by the user
     marginCollateral: bool
     coin: str
 
     def parse_to_account_balance(self) -> AccountBalance:
         currency = Currency.from_str(self.coin)
         total = Decimal(self.walletBalance)
-        locked = (
-            Decimal(self.totalPositionIM)
-            + Decimal(self.totalPositionMM)
-            + Decimal(self.totalOrderIM)
-        )
+        locked = Decimal(self.locked)  # TODO: Locked only valid for Spot
         free = total - locked
         return AccountBalance(
             total=Money(total, currency),
             locked=Money(locked, currency),
             free=Money(free, currency),
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/account/fee_rate.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/account/fee_rate.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/common.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/common.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/market/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/asset/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/market/kline.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/market/kline.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/market/risk_limit.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/market/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/market/server_time.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/market/server_time.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/market/ticker.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/market/ticker.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/position.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/position.py`

 * *Files 4% similar despite different names*

```diff
@@ -40,32 +40,32 @@
     leverage: str
     positionBalance: str
     markPrice: str
     liqPrice: str
     bustPrice: str
     positionMM: str
     positionIM: str
-    tpslMode: str
     takeProfit: str
     stopLoss: str
     trailingStop: str
     unrealisedPnl: str
     cumRealisedPnl: str
     createdTime: str
     updatedTime: str
+    tpslMode: str | None = None
 
     def parse_to_position_status_report(
         self,
         account_id: AccountId,
         instrument_id: InstrumentId,
         report_id: UUID4,
         ts_init: int,
     ) -> PositionStatusReport:
         position_side = self.side.parse_to_position_side()
-        size = Quantity.from_str(self.positionValue)
+        size = Quantity.from_str(self.size)
         return PositionStatusReport(
             account_id=account_id,
             instrument_id=instrument_id,
             position_side=position_side,
             quantity=size,
             report_id=report_id,
             ts_init=ts_init,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/schemas/symbol.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/binance/common/symbol.py`

 * *Files 25% similar despite different names*

```diff
@@ -9,49 +9,61 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.adapters.bybit.common.constants import BYBIT_VENUE
-from nautilus_trader.adapters.bybit.common.enums import BybitInstrumentType
-from nautilus_trader.model.identifiers import InstrumentId
-from nautilus_trader.model.identifiers import Symbol
-
-
-class BybitSymbol(str):
-    def __new__(cls, symbol: str | None):
-        if symbol is not None:
-            # check if it contains one dot BTCUSDT-LINEAR for example is the correct
-            # bybit symbol format
-            if (
-                symbol.find("-SPOT") == -1
-                and symbol.find("-LINEAR") == -1
-                and symbol.find("-OPTION") == -1
-            ):
-                raise ValueError(
-                    f"Invalid symbol {symbol}. Does not contain -LINEAR, -SPOT or -OPTION suffix",
-                )
-            return super().__new__(
-                cls,
-                symbol.upper(),
-            )
-
-    @property
-    def raw_symbol(self) -> str:
-        return str(self).split("-")[0]
-
-    @property
-    def instrument_type(self) -> BybitInstrumentType:
-        if "-LINEAR" in self:
-            return BybitInstrumentType.LINEAR
-        elif "-SPOT" in self:
-            return BybitInstrumentType.SPOT
-        elif "-OPTION" in self:
-            return BybitInstrumentType.OPTION
+from __future__ import annotations
+
+import json
+
+from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
+from nautilus_trader.core.correctness import PyCondition
+
+
+################################################################################
+# HTTP responses
+################################################################################
+
+
+class BinanceSymbol(str):
+    """
+    Binance compatible symbol.
+    """
+
+    def __new__(cls, symbol: str) -> BinanceSymbol:  # noqa: PYI034
+        PyCondition.valid_string(symbol, "symbol")
+
+        # Format the string on construction to be Binance compatible
+        return super().__new__(
+            cls,
+            symbol.upper().replace(" ", "").replace("/", "").replace("-PERP", ""),
+        )
+
+    def parse_as_nautilus(self, account_type: BinanceAccountType) -> str:
+        if account_type.is_spot_or_margin:
+            return str(self)
+
+        # Parse Futures symbol
+        if self[-1].isdigit():
+            return str(self)  # Deliverable
+        if self.endswith("_PERP"):
+            return str(self).replace("_", "-")
         else:
-            raise ValueError(f"Unknown instrument type for symbol {self}")
+            return str(self) + "-PERP"
+
+
+class BinanceSymbols(str):
+    """
+    Binance compatible list of symbols.
+    """
+
+    def __new__(cls, symbols: list[str]) -> BinanceSymbols:  # noqa: PYI034
+        PyCondition.not_empty(symbols, "symbols")
+
+        binance_symbols: list[BinanceSymbol] = [BinanceSymbol(symbol) for symbol in symbols]
+        return super().__new__(cls, json.dumps(binance_symbols).replace(" ", ""))
 
-    def parse_as_nautilus(self) -> InstrumentId:
-        instrument = InstrumentId(Symbol(str(self)), BYBIT_VENUE)
-        return instrument
+    def parse_str_to_list(self) -> list[BinanceSymbol]:
+        binance_symbols: list[BinanceSymbol] = json.loads(self)
+        return binance_symbols
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/websocket/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/schemas/market/risk_limit.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/bybit/websocket/client.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/account.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,159 +1,184 @@
 # -------------------------------------------------------------------------------------------------
-#  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
+#  Copyright (C) 2015-2021 Nautech Systems Pty Ltd. All rights reserved.
 #  https://nautechsystems.io
 #
 #  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
 #  You may not use this file except in compliance with the License.
 #  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import hashlib
-import hmac
-import json
-from collections.abc import Callable
+import functools
+from decimal import Decimal
 
-from nautilus_trader.common.component import LiveClock
-from nautilus_trader.common.component import Logger
+from ibapi.account_summary_tags import AccountSummaryTags
+
+from nautilus_trader.adapters.interactive_brokers.client.common import BaseMixin
+from nautilus_trader.adapters.interactive_brokers.client.common import IBPosition
+from nautilus_trader.adapters.interactive_brokers.common import IBContract
 from nautilus_trader.common.enums import LogColor
-from nautilus_trader.core.nautilus_pyo3 import WebSocketClient
-from nautilus_trader.core.nautilus_pyo3 import WebSocketConfig
+from nautilus_trader.model.position import Position
 
 
-class BybitWebsocketClient:
+class InteractiveBrokersClientAccountMixin(BaseMixin):
     """
-    Provides a `Bybit` streaming WebSocket client.
+    Handles various account and position related requests for the
+    InteractiveBrokersClient.
 
     Parameters
     ----------
-    clock : LiveClock
-        The clock instance.
+    client : InteractiveBrokersClient
+        The client instance that will be used to communicate with the TWS API.
 
     """
 
-    def __init__(
+    def accounts(self) -> set[str]:
+        """
+        Return a set of account identifiers managed by this instance.
+
+        Returns
+        -------
+        set[str]
+
+        """
+        return self._account_ids.copy()
+
+    def subscribe_account_summary(self) -> None:
+        """
+        Subscribe to the account summary for all accounts.
+
+        It sends a request to Interactive Brokers to retrieve account summary
+        information.
+
+        """
+        name = "accountSummary"
+        if not (subscription := self._subscriptions.get(name=name)):
+            req_id = self._next_req_id()
+            subscription = self._subscriptions.add(
+                req_id=req_id,
+                name=name,
+                handle=functools.partial(
+                    self._eclient.reqAccountSummary,
+                    reqId=req_id,
+                    groupName="All",
+                    tags=AccountSummaryTags.AllTags,
+                ),
+                cancel=functools.partial(
+                    self._eclient.cancelAccountSummary,
+                    reqId=req_id,
+                ),
+            )
+        # Allow fetching all tags upon request even if already subscribed
+        if not subscription:
+            return None
+        subscription.handle()
+
+    def unsubscribe_account_summary(self, account_id: str) -> None:
+        """
+        Unsubscribe from the account summary for the specified account. This method is
+        not implemented.
+
+        Parameters
+        ----------
+        account_id : str
+            The identifier of the account to unsubscribe from.
+
+        """
+        name = "accountSummary"
+        if subscription := self._subscriptions.get(name=name):
+            self._subscriptions.remove(subscription.req_id)
+            self._eclient.cancelAccountSummary(reqId=subscription.req_id)
+            self._log.debug(f"Unsubscribed from {subscription}")
+        else:
+            self._log.debug(f"Subscription doesn't exist for {name}")
+
+    async def get_positions(self, account_id: str) -> list[Position] | None:
+        """
+        Fetch open positions for a specified account.
+
+        Parameters
+        ----------
+        account_id: str
+            The account identifier for which to fetch positions.
+
+        Returns
+        -------
+        list[Position] | ``None``
+
+        """
+        self._log.debug(f"Requesting Open Positions for {account_id}")
+        name = "OpenPositions"
+        if not (request := self._requests.get(name=name)):
+            request = self._requests.add(
+                req_id=self._next_req_id(),
+                name=name,
+                handle=self._eclient.reqPositions,
+            )
+            if not request:
+                return None
+            request.handle()
+            all_positions = await self._await_request(request, 30)
+        else:
+            all_positions = await self._await_request(request, 30)
+        if not all_positions:
+            return None
+        positions = []
+        for position in all_positions:
+            if position.account_id == account_id:
+                positions.append(position)
+        return positions
+
+    async def process_account_summary(
+        self,
+        *,
+        req_id: int,
+        account_id: str,
+        tag: str,
+        value: str,
+        currency: str,
+    ) -> None:
+        """
+        Receive account information.
+        """
+        name = f"accountSummary-{account_id}"
+        if handler := self._event_subscriptions.get(name, None):
+            handler(tag, value, currency)
+
+    async def process_managed_accounts(self, *, accounts_list: str) -> None:
+        """
+        Receive a comma-separated string with the managed account ids.
+
+        Occurs automatically on initial API client connection.
+
+        """
+        self._account_ids = {a for a in accounts_list.split(",") if a}
+        self._log.debug(f"Managed accounts set: {self._account_ids}")
+        if self._next_valid_order_id >= 0 and not self._is_ib_connected.is_set():
+            self._log.debug("`_is_ib_connected` set by `managedAccounts`.", LogColor.BLUE)
+            self._is_ib_connected.set()
+
+    async def process_position(
         self,
-        clock: LiveClock,
-        base_url: str,
-        handler: Callable[[bytes], None],
-        api_key: str | None = None,
-        api_secret: str | None = None,
-        is_private: bool | None = False,
+        *,
+        account_id: str,
+        contract: IBContract,
+        position: Decimal,
+        avg_cost: float,
     ) -> None:
-        self._clock = clock
-        self._log: Logger = Logger(name=type(self).__name__)
-        self._url: str = base_url
-        self._handler: Callable[[bytes], None] = handler
-        self._client: WebSocketClient | None = None
-        self._is_private = is_private
-        self._api_key = api_key
-        self._api_secret = api_secret
-
-        self._streams_connecting: set[str] = set()
-        self._subscriptions: list[str] = []
-
-    @property
-    def subscriptions(self) -> list[str]:
-        return self._subscriptions
-
-    def has_subscriptions(self, item: str) -> bool:
-        return item in self._subscriptions
-
-    ################################################################################
-    # Public
-    ################################################################################
-
-    async def subscribe_trades(self, symbol: str) -> None:
-        if self._client is None:
-            self._log.warning("Cannot subscribe: not connected.")
-            return
-
-        subscription = f"publicTrade.{symbol}"
-        sub = {"op": "subscribe", "args": [subscription]}
-        await self._client.send_text(json.dumps(sub))
-        self._subscriptions.append(subscription)
-
-    async def subscribe_tickers(self, symbol: str) -> None:
-        if self._client is None:
-            self._log.warning("Cannot subscribe: not connected.")
-            return
-
-        subscription = f"tickers.{symbol}"
-        sub = {"op": "subscribe", "args": [subscription]}
-        await self._client.send_text(json.dumps(sub))
-        self._subscriptions.append(subscription)
-
-    ################################################################################
-    # Private
-    ################################################################################
-    # async def subscribe_account_position_update(self) -> None:
-    #     subsscription = "position"
-    #     sub = {"op": "subscribe", "args": [subsscription]}
-    #     await self._client.send_text(json.dumps(sub))
-    #     self._subscriptions.append(subsscription)
-
-    async def subscribe_orders_update(self) -> None:
-        if self._client is None:
-            self._log.warning("Cannot subscribe: not connected.")
-            return
-
-        subscription = "order"
-        sub = {"op": "subscribe", "args": [subscription]}
-        await self._client.send_text(json.dumps(sub))
-        self._subscriptions.append(subscription)
-
-    async def subscribe_executions_update(self) -> None:
-        if self._client is None:
-            self._log.warning("Cannot subscribe: not connected.")
-            return
-
-        subscription = "execution"
-        sub = {"op": "subscribe", "args": [subscription]}
-        await self._client.send_text(json.dumps(sub))
-        self._subscriptions.append(subscription)
-
-    async def connect(self) -> None:
-        self._log.debug(f"Connecting to {self._url} websocket stream")
-        config = WebSocketConfig(
-            url=self._url,
-            handler=self._handler,
-            heartbeat=20,
-            heartbeat_msg=json.dumps({"op": "ping"}),
-            headers=[],
-        )
-        client = await WebSocketClient.connect(
-            config=config,
-        )
-        self._client = client
-        self._log.info(f"Connected to {self._url}.", LogColor.BLUE)
-        ## authenticate
-        if self._is_private:
-            signature = self._get_signature()
-            self._client.send_text(json.dumps(signature))
-
-    def _get_signature(self):
-        timestamp = self._clock.timestamp_ms() + 1000
-        sign = f"GET/realtime{timestamp}"
-        signature = hmac.new(
-            self._api_secret.encode("utf-8"),
-            sign.encode("utf-8"),
-            hashlib.sha256,
-        ).hexdigest()
-        return {
-            "op": "auth",
-            "args": [self._api_key, timestamp, signature],
-        }
-
-    async def disconnect(self) -> None:
-        if self._client is None:
-            self._log.warning("Cannot disconnect: not connected.")
-            return
-
-        await self._client.send_text(json.dumps({"op": "unsubscribe", "args": self._subscriptions}))
-        await self._client.disconnect()
-        self._log.info(f"Disconnected from {self._url}.", LogColor.BLUE)
+        """
+        Provide the portfolio's open positions.
+        """
+        if request := self._requests.get(name="OpenPositions"):
+            request.result.append(IBPosition(account_id, contract, position, avg_cost))
+
+    async def process_position_end(self) -> None:
+        """
+        Indicate that all the positions have been transmitted.
+        """
+        if request := self._requests.get(name="OpenPositions"):
+            self._end_request(request.req_id)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/databento/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/databento/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/databento/common.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/databento/common.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/databento/config.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/databento/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/databento/constants.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/databento/constants.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/databento/data.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/databento/data.py`

 * *Files 1% similar despite different names*

```diff
@@ -20,15 +20,15 @@
 
 import pandas as pd
 import pytz
 
 from nautilus_trader.adapters.databento.common import databento_schema_from_nautilus_bar_type
 from nautilus_trader.adapters.databento.config import DatabentoDataClientConfig
 from nautilus_trader.adapters.databento.constants import ALL_SYMBOLS
-from nautilus_trader.adapters.databento.constants import DATABENTO_CLIENT_ID
+from nautilus_trader.adapters.databento.constants import DATABENTO
 from nautilus_trader.adapters.databento.constants import PUBLISHERS_PATH
 from nautilus_trader.adapters.databento.enums import DatabentoSchema
 from nautilus_trader.adapters.databento.loaders import DatabentoDataLoader
 from nautilus_trader.adapters.databento.providers import DatabentoInstrumentProvider
 from nautilus_trader.adapters.databento.types import DatabentoImbalance
 from nautilus_trader.adapters.databento.types import DatabentoStatistics
 from nautilus_trader.adapters.databento.types import Dataset
@@ -44,14 +44,15 @@
 from nautilus_trader.model.data import BarType
 from nautilus_trader.model.data import DataType
 from nautilus_trader.model.data import QuoteTick
 from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.data import capsule_to_data
 from nautilus_trader.model.enums import BookType
 from nautilus_trader.model.enums import bar_aggregation_to_str
+from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import Venue
 from nautilus_trader.model.instruments import instruments_from_pyo3
 
 
 class DatabentoDataClient(LiveMarketDataClient):
     """
@@ -74,35 +75,38 @@
         The clock for the client.
     instrument_provder : DatabentoInstrumentProvider
         The instrument provider for the client.
     loader : DatabentoDataLoader, optional
         The loader for the client.
     config : DatabentoDataClientConfig, optional
         The configuration for the client.
+    name : str, optional
+        The custom client ID.
 
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         http_client: nautilus_pyo3.DatabentoHistoricalClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         instrument_provider: DatabentoInstrumentProvider,
         loader: DatabentoDataLoader | None = None,
         config: DatabentoDataClientConfig | None = None,
+        name: str | None = None,
     ) -> None:
         if config is None:
             config = DatabentoDataClientConfig()
         PyCondition.type(config, DatabentoDataClientConfig, "config")
 
         super().__init__(
             loop=loop,
-            client_id=DATABENTO_CLIENT_ID,
+            client_id=ClientId(name or DATABENTO),
             venue=None,  # Not applicable
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             instrument_provider=instrument_provider,
             config=config,
         )
@@ -166,85 +170,85 @@
 
         try:
             if self._timeout_initial_load:
                 await asyncio.wait_for(asyncio.gather(*coros), timeout=self._timeout_initial_load)
             else:
                 await asyncio.gather(*coros)
         except asyncio.TimeoutError:
-            self._log.warning("Timeout waiting for instruments...")
+            self._log.warning("Timeout waiting for instruments")
 
         self._send_all_instruments_to_data_engine()
         self._update_dataset_ranges_task = self.create_task(self._update_dataset_ranges())
 
     async def _disconnect(self) -> None:
         if self._buffer_mbo_subscriptions_task:
-            self._log.debug("Canceling `buffer_mbo_subscriptions` task...")
+            self._log.debug("Canceling `buffer_mbo_subscriptions` task")
             self._buffer_mbo_subscriptions_task.cancel()
             self._buffer_mbo_subscriptions_task = None
 
         # Cancel update dataset ranges task
         if self._update_dataset_ranges_task:
-            self._log.debug("Canceling `update_dataset_ranges` task...")
+            self._log.debug("Canceling `update_dataset_ranges` task")
             self._update_dataset_ranges_task.cancel()
             self._update_dataset_ranges_task = None
 
         # Close all live clients
         for dataset, live_client in self._live_clients.items():
             if not live_client.is_running:
                 continue
-            self._log.info(f"Stopping {dataset} live feed...", LogColor.BLUE)
+            self._log.info(f"Stopping {dataset} live feed", LogColor.BLUE)
             live_client.close()
 
         for dataset, live_client in self._live_clients_mbo.items():
             if not live_client.is_running:
                 continue
-            self._log.info(f"Stopping {dataset} MBO/L3 live feed...", LogColor.BLUE)
+            self._log.info(f"Stopping {dataset} MBO/L3 live feed", LogColor.BLUE)
             live_client.close()
 
         try:
             await asyncio.gather(*self._live_client_futures)
         except asyncio.CancelledError:
             pass  # Expected
 
     async def _update_dataset_ranges(self) -> None:
         while True:
             try:
                 self._log.debug(
                     f"Scheduled `update_instruments` to run in "
-                    f"{self._update_dataset_ranges_interval_seconds}s.",
+                    f"{self._update_dataset_ranges_interval_seconds}s",
                 )
 
                 await asyncio.sleep(self._update_dataset_ranges_interval_seconds)
 
                 tasks = []
                 for dataset in self._dataset_ranges:
                     tasks.append(self._get_dataset_range(dataset))
 
                 await asyncio.gather(*tasks)
             except Exception as e:  # Create specific exception type
                 self._log.error(f"Error updating dataset range: {e}")
             except asyncio.CancelledError:
-                self._log.debug("Canceled `update_dataset_ranges` task.")
+                self._log.debug("Canceled `update_dataset_ranges` task")
                 break
 
     async def _buffer_mbo_subscriptions(self) -> None:
         try:
             self._log.debug("Buffering MBO subscriptions...", LogColor.MAGENTA)
             await asyncio.sleep(self._mbo_subscriptions_delay or 0.0)
             self._is_buffering_mbo_subscriptions = False
 
             coros: list[Coroutine] = []
             for dataset, instrument_ids in self._buffered_mbo_subscriptions.items():
-                self._log.info(f"Starting {dataset} MBO/L3 live feeds...")
+                self._log.info(f"Starting {dataset} MBO/L3 live feeds")
                 coro = self._subscribe_order_book_deltas_batch(instrument_ids)
                 coros.append(coro)
 
             await asyncio.gather(*coros)
         except asyncio.CancelledError:
-            self._log.debug("Canceled `buffer_mbo_subscriptions` task.")
+            self._log.debug("Canceled `buffer_mbo_subscriptions` task")
 
     def _get_live_client(self, dataset: Dataset) -> nautilus_pyo3.DatabentoLiveClient:
         # Retrieve or initialize the 'general' live client for the specified dataset
         live_client = self._live_clients.get(dataset)
 
         if live_client is None:
             live_client = nautilus_pyo3.DatabentoLiveClient(
@@ -272,24 +276,24 @@
 
     async def _check_live_client_started(
         self,
         dataset: Dataset,
         live_client: nautilus_pyo3.DatabentoLiveClient,
     ) -> None:
         if not self._has_subscribed.get(dataset):
-            self._log.debug(f"Starting {dataset} live client...", LogColor.MAGENTA)
+            self._log.debug(f"Starting {dataset} live client", LogColor.MAGENTA)
             future = asyncio.ensure_future(
                 live_client.start(
                     callback=self._handle_msg,
                     callback_pyo3=self._handle_msg_pyo3,  # Imbalance and Statistics messages
                 ),
             )
             self._live_client_futures.add(future)
             self._has_subscribed[dataset] = True
-            self._log.info(f"Started {dataset} live feed.", LogColor.BLUE)
+            self._log.info(f"Started {dataset} live feed", LogColor.BLUE)
 
     def _send_all_instruments_to_data_engine(self) -> None:
         for instrument in self._instrument_provider.get_all().values():
             self._handle_data(instrument)
 
     async def _ensure_subscribed_for_instrument(self, instrument_id: InstrumentId) -> None:
         try:
@@ -299,15 +303,15 @@
             if instrument_id in subscribed_instruments:
                 return
 
             self._instrument_ids[dataset].add(instrument_id)
             await self._subscribe_instrument(instrument_id)
         except asyncio.CancelledError:
             self._log.warning(
-                "`_ensure_subscribed_for_instrument` was canceled while still pending.",
+                "`_ensure_subscribed_for_instrument` was canceled while still pending",
             )
 
     async def _get_dataset_range(
         self,
         dataset: Dataset,
     ) -> tuple[pd.Timestamp | None, pd.Timestamp]:
         # Check and cache dataset available range
@@ -326,21 +330,21 @@
 
             available_start = pd.Timestamp(response["start_date"], tz=pytz.utc)
             available_end = pd.Timestamp(response["end_date"], tz=pytz.utc)
 
             self._dataset_ranges[dataset] = (available_start, available_end)
 
             self._log.info(
-                f"Dataset {dataset} available end {available_end.date()}.",
+                f"Dataset {dataset} available end {available_end.date()}",
                 LogColor.BLUE,
             )
 
             return available_start, available_end
         except asyncio.CancelledError:
-            self._log.warning("`_get_dataset_range` was canceled while still pending.")
+            self._log.warning("`_get_dataset_range` was canceled while still pending")
             return (None, pd.Timestamp.utcnow())
         except Exception as e:  # More specific exception
             self._log.error(f"Error requesting dataset range: {e}")
             return (None, pd.Timestamp.utcnow())
         finally:
             self._dataset_ranges_requested.discard(dataset)
 
@@ -387,29 +391,29 @@
             live_client = self._get_live_client(dataset)
             live_client.subscribe(
                 schema=DatabentoSchema.IMBALANCE.value,
                 symbols=[instrument_id.symbol.value],
             )
             await self._check_live_client_started(dataset, live_client)
         except asyncio.CancelledError:
-            self._log.warning("`_subscribe_imbalance` was canceled while still pending.")
+            self._log.warning("`_subscribe_imbalance` was canceled while still pending")
 
     async def _subscribe_statistics(self, data_type: DataType) -> None:
         try:
             # TODO: Create `DatabentoTimeSeriesParams`
             instrument_id: InstrumentId = data_type.metadata["instrument_id"]
             dataset: Dataset = self._loader.get_dataset_for_venue(instrument_id.venue)
             live_client = self._get_live_client(dataset)
             live_client.subscribe(
                 schema=DatabentoSchema.STATISTICS.value,
                 symbols=[instrument_id.symbol.value],
             )
             await self._check_live_client_started(dataset, live_client)
         except asyncio.CancelledError:
-            self._log.warning("`_subscribe_imbalance` was canceled while still pending.")
+            self._log.warning("`_subscribe_imbalance` was canceled while still pending")
 
     async def _subscribe_instruments(self) -> None:
         # Replace method in child class, for exchange specific data types.
         raise NotImplementedError("Cannot subscribe to all instruments (not currently supported).")
 
     async def _subscribe_instrument(self, instrument_id: InstrumentId) -> None:
         try:
@@ -417,15 +421,15 @@
             live_client = self._get_live_client(dataset)
             live_client.subscribe(
                 schema=DatabentoSchema.DEFINITION.value,
                 symbols=[instrument_id.symbol.value],
             )
             await self._check_live_client_started(dataset, live_client)
         except asyncio.CancelledError:
-            self._log.warning("`_subscribe_instrument` was canceled while still pending.")
+            self._log.warning("`_subscribe_instrument` was canceled while still pending")
 
     async def _subscribe_parent_symbols(
         self,
         dataset: Dataset,
         parent_symbols: set[str],
     ) -> None:
         try:
@@ -433,30 +437,30 @@
             live_client.subscribe(
                 schema=DatabentoSchema.DEFINITION.value,
                 symbols=sorted(parent_symbols),
                 stype_in="parent",
             )
             await self._check_live_client_started(dataset, live_client)
         except asyncio.CancelledError:
-            self._log.warning("`_subscribe_parent_symbols` was canceled while still pending.")
+            self._log.warning("`_subscribe_parent_symbols` was canceled while still pending")
 
     async def _subscribe_instrument_ids(
         self,
         dataset: Dataset,
         instrument_ids: list[InstrumentId],
     ) -> None:
         try:
             live_client = self._get_live_client(dataset)
             live_client.subscribe(
                 schema=DatabentoSchema.DEFINITION.value,
                 symbols=[i.symbol.value for i in instrument_ids],
             )
             await self._check_live_client_started(dataset, live_client)
         except asyncio.CancelledError:
-            self._log.warning("`_subscribe_instrument_ids` was canceled while still pending.")
+            self._log.warning("`_subscribe_instrument_ids` was canceled while still pending")
 
     async def _subscribe_order_book_deltas(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
         depth: int | None = None,
         kwargs: dict | None = None,
@@ -464,75 +468,75 @@
         try:
             if book_type != BookType.L3_MBO:
                 raise NotImplementedError
 
             if depth:  # Can be None or 0 (full depth)
                 self._log.error(
                     f"Cannot subscribe to order book deltas with specific depth of {depth} "
-                    "(do not specify depth when subscribing, must be full depth).",
+                    "(do not specify depth when subscribing, must be full depth)",
                 )
                 return
 
             dataset: Dataset = self._loader.get_dataset_for_venue(instrument_id.venue)
 
             if self._is_buffering_mbo_subscriptions:
                 self._log.debug(
-                    f"Buffering MBO/L3 subscription for {instrument_id}.",
+                    f"Buffering MBO/L3 subscription for {instrument_id}",
                     LogColor.MAGENTA,
                 )
                 self._buffered_mbo_subscriptions[dataset].append(instrument_id)
                 return
 
             if self._live_clients_mbo.get(dataset) is not None:
                 self._log.error(
                     f"Cannot subscribe to order book deltas for {instrument_id}, "
-                    "MBO/L3 feed already started.",
+                    "MBO/L3 feed already started",
                 )
                 return
 
             await self._subscribe_order_book_deltas_batch([instrument_id])
         except asyncio.CancelledError:
-            self._log.warning("`_subscribe_order_book_deltas` was canceled while still pending.")
+            self._log.warning("`_subscribe_order_book_deltas` was canceled while still pending")
 
     async def _subscribe_order_book_deltas_batch(
         self,
         instrument_ids: list[InstrumentId],
     ) -> None:
         try:
             if not instrument_ids:
                 self._log.warning(
-                    "No subscriptions for order book deltas (`instrument_ids` was empty).",
+                    "No subscriptions for order book deltas (`instrument_ids` was empty)",
                 )
                 return
 
             for instrument_id in instrument_ids:
                 if not self._cache.instrument(instrument_id):
                     self._log.error(
                         f"Cannot subscribe to order book deltas for {instrument_id}, "
                         "instrument must be pre-loaded via the `DatabentoDataClientConfig` "
-                        "or a specific subscription on start.",
+                        "or a specific subscription on start",
                     )
                     instrument_ids.remove(instrument_id)
                     continue
 
             if not instrument_ids:
                 return  # No subscribing instrument IDs were loaded in the cache
 
             ids_str = ",".join([i.value for i in instrument_ids])
-            self._log.info(f"Subscribing to MBO/L3 for {ids_str}.", LogColor.BLUE)
+            self._log.info(f"Subscribing to MBO/L3 for {ids_str}", LogColor.BLUE)
 
             dataset: Dataset = self._loader.get_dataset_for_venue(instrument_ids[0].venue)
             live_client = self._get_live_client_mbo(dataset)
 
             # Subscribe from UTC midnight snapshot
             start = self._clock.utc_now().normalize()
 
-            self._log.info(f"Replaying MBO/L3 feeds from {start}.", LogColor.BLUE)
+            self._log.info(f"Replaying MBO/L3 feeds from {start}", LogColor.BLUE)
             self._log.warning(
-                "Replaying MBO/L3 feeds is under development and not considered usable.",
+                "Replaying MBO/L3 feeds is under development and not considered usable",
             )
 
             live_client.subscribe(
                 schema=DatabentoSchema.MBO.value,
                 symbols=[i.symbol.value for i in instrument_ids],
                 start=0,  # Replay from start of weekly session
             )
@@ -546,15 +550,15 @@
                     callback=self._handle_msg,
                     callback_pyo3=self._handle_msg_pyo3,  # Imbalance and Statistics messages
                 ),
             )
             self._live_client_futures.add(future)
         except asyncio.CancelledError:
             self._log.warning(
-                "`_subscribe_order_book_deltas_batch` was canceled while still pending.",
+                "`_subscribe_order_book_deltas_batch` was canceled while still pending",
             )
 
     async def _subscribe_order_book_snapshots(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
         depth: int | None = None,
@@ -566,27 +570,27 @@
             match depth:
                 case 1:
                     schema = DatabentoSchema.MBP_1.value
                 case 10:
                     schema = DatabentoSchema.MBP_10.value
                 case _:
                     self._log.error(
-                        f"Cannot subscribe for order book snapshots of depth {depth}, use either 1 or 10.",
+                        f"Cannot subscribe for order book snapshots of depth {depth}, use either 1 or 10",
                     )
                     return
 
             dataset: Dataset = self._loader.get_dataset_for_venue(instrument_id.venue)
             live_client = self._get_live_client(dataset)
             live_client.subscribe(
                 schema=schema,
                 symbols=[instrument_id.symbol.value],
             )
             await self._check_live_client_started(dataset, live_client)
         except asyncio.CancelledError:
-            self._log.warning("`_subscribe_order_book_snapshots` was canceled while still pending.")
+            self._log.warning("`_subscribe_order_book_snapshots` was canceled while still pending")
 
     async def _subscribe_quote_ticks(self, instrument_id: InstrumentId) -> None:
         try:
             await self._ensure_subscribed_for_instrument(instrument_id)
 
             dataset: Dataset = self._loader.get_dataset_for_venue(instrument_id.venue)
             live_client = self._get_live_client(dataset)
@@ -596,15 +600,15 @@
             )
 
             # Add trade tick subscriptions for instrument (MBP-1 data includes trades)
             self._trade_tick_subscriptions.add(instrument_id)
 
             await self._check_live_client_started(dataset, live_client)
         except asyncio.CancelledError:
-            self._log.warning("`_subscribe_quote_ticks` was canceled while still pending.")
+            self._log.warning("`_subscribe_quote_ticks` was canceled while still pending")
 
     async def _subscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:
         try:
             if instrument_id in self._trade_tick_subscriptions:
                 return  # Already subscribed (this will save on data costs)
 
             await self._ensure_subscribed_for_instrument(instrument_id)
@@ -613,15 +617,15 @@
             live_client = self._get_live_client(dataset)
             live_client.subscribe(
                 schema=DatabentoSchema.TRADES.value,
                 symbols=[instrument_id.symbol.value],
             )
             await self._check_live_client_started(dataset, live_client)
         except asyncio.CancelledError:
-            self._log.warning("`_subscribe_trade_ticks` was canceled while still pending.")
+            self._log.warning("`_subscribe_trade_ticks` was canceled while still pending")
 
     async def _subscribe_bars(self, bar_type: BarType) -> None:
         try:
             dataset: Dataset = self._loader.get_dataset_for_venue(bar_type.instrument_id.venue)
 
             try:
                 schema = databento_schema_from_nautilus_bar_type(bar_type)
@@ -632,15 +636,15 @@
             live_client = self._get_live_client(dataset)
             live_client.subscribe(
                 schema=schema.value,
                 symbols=[bar_type.instrument_id.symbol.value],
             )
             await self._check_live_client_started(dataset, live_client)
         except asyncio.CancelledError:
-            self._log.warning("`_subscribe_bars` was canceled while still pending.")
+            self._log.warning("`_subscribe_bars` was canceled while still pending")
 
     async def _unsubscribe(self, data_type: DataType) -> None:
         raise NotImplementedError(
             f"Cannot unsubscribe from {data_type}, unsubscribing not supported by Databento.",
         )
 
     async def _unsubscribe_instruments(self) -> None:
@@ -833,15 +837,15 @@
         _, available_end = await self._get_dataset_range(dataset)
 
         start = start or available_end - pd.Timedelta(days=1)
         end = end or available_end
 
         if limit > 0:
             self._log.warning(
-                f"Ignoring limit {limit} because its applied from the start (instead of the end).",
+                f"Ignoring limit {limit} because its applied from the start (instead of the end)",
             )
 
         self._log.info(
             f"Requesting {instrument_id} quote ticks: "
             f"dataset={dataset}, start={start}, end={end}",
             LogColor.BLUE,
         )
@@ -873,15 +877,15 @@
         _, available_end = await self._get_dataset_range(dataset)
 
         start = start or available_end - pd.Timedelta(days=1)
         end = end or available_end
 
         if limit > 0:
             self._log.warning(
-                f"Ignoring limit {limit} because its applied from the start (instead of the end).",
+                f"Ignoring limit {limit} because its applied from the start (instead of the end)",
             )
 
         self._log.info(
             f"Requesting {instrument_id} trade ticks: "
             f"dataset={dataset}, start={start}, end={end}",
             LogColor.BLUE,
         )
@@ -913,15 +917,15 @@
         _, available_end = await self._get_dataset_range(dataset)
 
         start = start or available_end - pd.Timedelta(days=1)
         end = end or available_end
 
         if limit > 0:
             self._log.warning(
-                f"Ignoring limit {limit} because its applied from the start (instead of the end).",
+                f"Ignoring limit {limit} because its applied from the start (instead of the end)",
             )
 
         self._log.info(
             f"Requesting {bar_type.instrument_id} 1 {bar_aggregation_to_str(bar_type.spec.aggregation)} bars: "
             f"dataset={dataset}, start={start}, end={end}",
             LogColor.BLUE,
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/databento/enums.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/databento/enums.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/databento/factories.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/databento/factories.py`

 * *Files 0% similar despite different names*

```diff
@@ -173,8 +173,9 @@
             http_client=http_client,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             instrument_provider=provider,
             loader=loader,
             config=config,
+            name=name,
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/databento/loaders.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/databento/loaders.py`

 * *Files 2% similar despite different names*

```diff
@@ -29,17 +29,17 @@
 
 class DatabentoDataLoader:
     """
     Provides a data loader for Databento Binary Encoding (DBN) format data.
 
     Supported schemas:
      - MBO -> `OrderBookDelta`
-     - MBP_1 -> `QuoteTick` + `TradeTick`
+     - MBP_1 -> `(QuoteTick, TradeTick | None)`
      - MBP_10 -> `OrderBookDepth10`
-     - TBBO -> `QuoteTick` + `TradeTick`
+     - TBBO -> `(QuoteTick, TradeTick)`
      - TRADES -> `TradeTick`
      - OHLCV_1S -> `Bar`
      - OHLCV_1M -> `Bar`
      - OHLCV_1H -> `Bar`
      - OHLCV_1D -> `Bar`
      - DEFINITION -> `Instrument`
      - IMBALANCE -> `DatabentoImbalance`
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/databento/providers.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/databento/providers.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/databento/publishers.json` & `nautilus_trader-1.191.0/nautilus_trader/adapters/databento/publishers.json`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/databento/types.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/databento/types.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/env.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/env.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/backtest/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,9 +9,9 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 """
-Provides an API integration for Interactive Brokers.
+The `backtest` subpackage groups components relating to backtesting.
 """
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/client.py` & `nautilus_trader-1.191.0/nautilus_trader/model/position.pyx`

 * *Files 22% similar despite different names*

```diff
@@ -9,609 +9,746 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import asyncio
-import functools
-import os
-from collections.abc import Callable
-from collections.abc import Coroutine
-from inspect import iscoroutinefunction
-from typing import Any
-
-from ibapi import comm
-from ibapi.client import EClient
-from ibapi.commission_report import CommissionReport
-from ibapi.common import MAX_MSG_LEN
-from ibapi.common import NO_VALID_ID
-from ibapi.common import BarData
-from ibapi.errors import BAD_LENGTH
-from ibapi.execution import Execution
-from ibapi.utils import current_fn_name
-
-# fmt: off
-from nautilus_trader.adapters.interactive_brokers.client.account import InteractiveBrokersClientAccountMixin
-from nautilus_trader.adapters.interactive_brokers.client.common import AccountOrderRef
-from nautilus_trader.adapters.interactive_brokers.client.common import Request
-from nautilus_trader.adapters.interactive_brokers.client.common import Requests
-from nautilus_trader.adapters.interactive_brokers.client.common import Subscriptions
-from nautilus_trader.adapters.interactive_brokers.client.connection import InteractiveBrokersClientConnectionMixin
-from nautilus_trader.adapters.interactive_brokers.client.contract import InteractiveBrokersClientContractMixin
-from nautilus_trader.adapters.interactive_brokers.client.error import InteractiveBrokersClientErrorMixin
-from nautilus_trader.adapters.interactive_brokers.client.market_data import InteractiveBrokersClientMarketDataMixin
-from nautilus_trader.adapters.interactive_brokers.client.order import InteractiveBrokersClientOrderMixin
-from nautilus_trader.adapters.interactive_brokers.client.wrapper import InteractiveBrokersEWrapper
-from nautilus_trader.adapters.interactive_brokers.common import IB_VENUE
-from nautilus_trader.cache.cache import Cache
-from nautilus_trader.common.component import Component
-from nautilus_trader.common.component import LiveClock
-from nautilus_trader.common.component import MessageBus
-from nautilus_trader.common.enums import LogColor
-from nautilus_trader.model.identifiers import ClientId
-
-
-# fmt: on
-
-
-class InteractiveBrokersClient(
-    Component,
-    InteractiveBrokersClientConnectionMixin,
-    InteractiveBrokersClientAccountMixin,
-    InteractiveBrokersClientMarketDataMixin,
-    InteractiveBrokersClientOrderMixin,
-    InteractiveBrokersClientContractMixin,
-    InteractiveBrokersClientErrorMixin,
-):
+from decimal import Decimal
+
+from libc.math cimport fabs
+from libc.math cimport fmin
+
+from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.core.rust.model cimport OrderSide
+from nautilus_trader.core.rust.model cimport PositionSide
+from nautilus_trader.model.events.order cimport OrderFilled
+from nautilus_trader.model.functions cimport order_side_to_str
+from nautilus_trader.model.functions cimport position_side_to_str
+from nautilus_trader.model.identifiers cimport TradeId
+from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.objects cimport Price
+from nautilus_trader.model.objects cimport Quantity
+
+
+cdef class Position:
     """
-    A client component that interfaces with the Interactive Brokers TWS or Gateway.
+    Represents a position in a market.
 
-    This class integrates various mixins to provide functionality for connection
-    management, account management, market data, and order processing with
-    Interactive Brokers. It inherits from both `Component` and `EWrapper` to provide
-    event-driven responses and custom component behavior.
+    The position ID may be assigned at the trading venue, or can be system
+    generated depending on a strategies OMS (Order Management System) settings.
 
+    Parameters
+    ----------
+    instrument : Instrument
+        The trading instrument for the position.
+    fill : OrderFilled
+        The order fill event which opened the position.
+
+    Raises
+    ------
+    ValueError
+        If `instrument.id` is not equal to `fill.instrument_id`.
+    ValueError
+        If `event.position_id` is ``None``.
     """
 
     def __init__(
         self,
-        loop: asyncio.AbstractEventLoop,
-        msgbus: MessageBus,
-        cache: Cache,
-        clock: LiveClock,
-        host: str = "127.0.0.1",
-        port: int = 7497,
-        client_id: int = 1,
+        Instrument instrument not None,
+        OrderFilled fill not None,
     ) -> None:
-        super().__init__(
-            clock=clock,
-            component_id=ClientId(f"{IB_VENUE.value}-{client_id:03d}"),
-            component_name=f"{type(self).__name__}-{client_id:03d}",
-            msgbus=msgbus,
-        )
+        Condition.equal(instrument.id, fill.instrument_id, "instrument.id", "fill.instrument_id")
+        Condition.not_none(fill.position_id, "fill.position_id")
 
-        # Config
-        self._loop = loop
-        self._cache = cache
-        self._host = host
-        self._port = port
-        self._client_id = client_id
-
-        # TWS API
-        self._eclient: EClient = EClient(
-            wrapper=InteractiveBrokersEWrapper(
-                nautilus_logger=self._log,
-                client=self,
-            ),
-        )
+        self._events: list[OrderFilled] = []
+        self._trade_ids: list[TradeId] = []
+        self._buy_qty = Quantity.zero_c(precision=instrument.size_precision)
+        self._sell_qty = Quantity.zero_c(precision=instrument.size_precision)
+        self._commissions = {}
+
+        # Identifiers
+        self.trader_id = fill.trader_id
+        self.strategy_id = fill.strategy_id
+        self.instrument_id = fill.instrument_id
+        self.id = fill.position_id
+        self.account_id = fill.account_id
+        self.opening_order_id = fill.client_order_id
+        self.closing_order_id = None
+
+        # Properties
+        self.entry = fill.order_side
+        self.side = Position.side_from_order_side(fill.order_side)
+        self.signed_qty = 0.0
+        self.quantity = Quantity.zero_c(precision=instrument.size_precision)
+        self.peak_qty = Quantity.zero_c(precision=instrument.size_precision)
+        self.ts_init = fill.ts_init
+        self.ts_opened = fill.ts_event
+        self.ts_last = fill.ts_event
+        self.ts_closed = 0
+        self.duration_ns = 0
+        self.avg_px_open = fill.last_px.as_f64_c()
+        self.avg_px_close = 0.0
+        self.price_precision = instrument.price_precision
+        self.size_precision = instrument.size_precision
+        self.multiplier = instrument.multiplier
+        self.is_inverse = instrument.is_inverse
+        self.quote_currency = instrument.quote_currency
+        self.base_currency = instrument.get_base_currency()  # Can be None
+        self.settlement_currency = instrument.get_settlement_currency()
+
+        self.realized_return = 0.0
+        self.realized_pnl = None
+
+        self.apply(fill)
+
+    def __eq__(self, Position other) -> bool:
+        return self.id == other.id
+
+    def __hash__(self) -> int:
+        return hash(self.id)
 
-        # EClient Overrides
-        self._eclient.sendMsg = self.sendMsg
-        self._eclient.logRequest = self.logRequest
-
-        # Tasks
-        self._connection_watchdog_task: asyncio.Task | None = None
-        self._tws_incoming_msg_reader_task: asyncio.Task | None = None
-        self._internal_msg_queue_processor_task: asyncio.Task | None = None
-        self._internal_msg_queue: asyncio.Queue = asyncio.Queue()
-
-        # Event flags
-        self._is_client_ready: asyncio.Event = asyncio.Event()
-        self._is_ib_connected: asyncio.Event = asyncio.Event()
-
-        # Hot caches
-        self.registered_nautilus_clients: set = set()
-        self._event_subscriptions: dict[str, Callable] = {}
-
-        # Subscriptions
-        self._requests = Requests()
-        self._subscriptions = Subscriptions()
-
-        # AccountMixin
-        self._account_ids: set[str] = set()
-
-        # ConnectionMixin
-        self._reconnect_attempts: int = 0
-        self._max_reconnect_attempts: int = int(os.getenv("IB_MAX_RECONNECT_ATTEMPTS", 0))
-        self._indefinite_reconnect: bool = False if self._max_reconnect_attempts else True
-        self._reconnect_delay: int = 5  # seconds
-
-        # MarketDataMixin
-        self._bar_type_to_last_bar: dict[str, BarData | None] = {}
-
-        # OrderMixin
-        self._exec_id_details: dict[
-            str,
-            dict[str, Execution | (CommissionReport | str)],
-        ] = {}
-        self._order_id_to_order_ref: dict[int, AccountOrderRef] = {}
-        self._next_valid_order_id: int = -1
-
-        # Start client
-        self._request_id_seq: int = 10000
-
-    def _start(self) -> None:
-        """
-        Start the client.
-
-        This method is called when the client is first initialized and when the client
-        is reset. It sets up the client and starts the connection watchdog, incoming
-        message reader, and internal message queue processing tasks.
-
-        """
-        if not self._loop.is_running():
-            self._log.warning("Started when loop is not running.")
-
-        self._log.info(f"Starting InteractiveBrokersClient ({self._client_id})...")
-        self._loop.run_until_complete(self._startup())
-        self._is_client_ready.set()
-
-    async def _startup(self):
-        try:
-            self._log.info(f"Starting InteractiveBrokersClient ({self._client_id})...")
-            await self._connect()
-            self._start_tws_incoming_msg_reader()
-            self._start_internal_msg_queue_processor()
-            self._eclient.startApi()
-            # TWS/Gateway will send a managedAccounts message upon successful connection,
-            # which will set the `_is_ib_connected` event. This typically takes a few
-            # seconds, so we wait for it here.
-            await asyncio.wait_for(self._is_ib_connected.wait(), 15)
-            self._start_connection_watchdog()
-            self._is_client_ready.set()
-        except asyncio.TimeoutError:
-            self._log.error("Client failed to initialize. Connection timeout.")
-            self._stop()
-        except Exception as e:
-            self._log.exception("Unhandled exception in client startup", e)
-            self._stop()
-
-    def _start_tws_incoming_msg_reader(self) -> None:
-        """
-        Start the incoming message reader task.
-        """
-        if self._tws_incoming_msg_reader_task:
-            self._tws_incoming_msg_reader_task.cancel()
-        self._tws_incoming_msg_reader_task = self._create_task(
-            self._run_tws_incoming_msg_reader(),
-        )
+    def __repr__(self) -> str:
+        return f"{type(self).__name__}({self.info()}, id={self.id})"
 
-    def _start_internal_msg_queue_processor(self) -> None:
+    cpdef str info(self):
         """
-        Start the internal message queue processing task.
+        Return a summary description of the position.
+
+        Returns
+        -------
+        str
+
         """
-        if self._internal_msg_queue_processor_task:
-            self._internal_msg_queue_processor_task.cancel()
-        self._internal_msg_queue_processor_task = self._create_task(
-            self._run_internal_msg_queue_processor(),
-        )
+        cdef str quantity = " " if self.quantity._mem.raw == 0 else f" {self.quantity.to_str()} "
+        return f"{position_side_to_str(self.side)}{quantity}{self.instrument_id}"
 
-    def _start_connection_watchdog(self) -> None:
+    cpdef dict to_dict(self):
         """
-        Start the connection watchdog task.
+        Return a dictionary representation of this object.
+
+        Returns
+        -------
+        dict[str, object]
+
         """
-        if self._connection_watchdog_task:
-            self._connection_watchdog_task.cancel()
-        self._connection_watchdog_task = self._create_task(
-            self._run_connection_watchdog(),
-        )
+        return {
+            "position_id": self.id.to_str(),
+            "trader_id": self.trader_id.to_str(),
+            "strategy_id": self.strategy_id.to_str(),
+            "instrument_id": self.instrument_id.to_str(),
+            "account_id": self.account_id.to_str(),
+            "opening_order_id": self.opening_order_id.to_str(),
+            "closing_order_id": self.closing_order_id.to_str() if self.closing_order_id is not None else None,
+            "entry": order_side_to_str(self.entry),
+            "side": position_side_to_str(self.side),
+            "signed_qty": self.signed_qty,
+            "quantity": str(self.quantity),
+            "peak_qty": str(self.peak_qty),
+            "ts_opened": self.ts_opened,
+            "ts_last": self.ts_last,
+            "ts_closed": self.ts_closed if self.ts_closed > 0 else None,
+            "duration_ns": self.duration_ns if self.duration_ns > 0 else None,
+            "avg_px_open": str(self.avg_px_open),
+            "avg_px_close": str(self.avg_px_close) if self.avg_px_close > 0 else None,
+            "quote_currency": self.quote_currency.code,
+            "base_currency": self.base_currency.code if self.base_currency is not None else None,
+            "settlement_currency": self.settlement_currency.code,
+            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
+            "realized_return": str(round(self.realized_return, 5)),
+            "realized_pnl": self.realized_pnl.to_str(),
+        }
+
+    cdef list client_order_ids_c(self):
+        # Note the inner set {}
+        return sorted(list({fill.client_order_id for fill in self._events}))
+
+    cdef list venue_order_ids_c(self):
+        # Note the inner set {}
+        return sorted(list({fill.venue_order_id for fill in self._events}))
+
+    cdef list trade_ids_c(self):
+        # Checked for duplicate before appending to events
+        return [fill.trade_id for fill in self._events]
+
+    cdef list events_c(self):
+        return self._events.copy()
+
+    cdef OrderFilled last_event_c(self):
+        return self._events[-1]
+
+    cdef TradeId last_trade_id_c(self):
+        return self._events[-1].trade_id
+
+    cdef int event_count_c(self):
+        return len(self._events)
+
+    cdef bint is_open_c(self):
+        return self.side != PositionSide.FLAT
+
+    cdef bint is_closed_c(self):
+        return self.side == PositionSide.FLAT
+
+    cdef bint is_long_c(self):
+        return self.side == PositionSide.LONG
+
+    cdef bint is_short_c(self):
+        return self.side == PositionSide.SHORT
 
-    def _stop(self) -> None:
+    @property
+    def symbol(self):
         """
-        Stop the client and cancel running tasks.
+        Return the positions ticker symbol.
+
+        Returns
+        -------
+        Symbol
+
+        """
+        return self.instrument_id.symbol
+
+    @property
+    def venue(self):
         """
-        self._log.info(f"Stopping InteractiveBrokersClient ({self._client_id})...")
-        # Cancel tasks
-        tasks = [
-            self._connection_watchdog_task,
-            self._tws_incoming_msg_reader_task,
-            self._internal_msg_queue_processor_task,
-        ]
-        for task in tasks:
-            if task and not task.cancelled():
-                task.cancel()
+        Return the positions trading venue.
+
+        Returns
+        -------
+        Venue
 
-        self._eclient.disconnect()
-        self._is_client_ready.clear()
-        self._account_ids = set()
-        for client in self.registered_nautilus_clients:
-            self._log.warning(f"Client {client} disconnected.")
-        self.registered_nautilus_clients = set()
+        """
+        return self.instrument_id.venue
 
-    def _reset(self) -> None:
+    @property
+    def client_order_ids(self):
         """
-        Restart the client.
+        Return the client order IDs associated with the position.
+
+        Returns
+        -------
+        list[VenueOrderId]
+
+        Notes
+        -----
+        Guaranteed not to contain duplicate IDs.
+
         """
-        self._log.info(f"Resetting InteractiveBrokersClient ({self._client_id})...")
-        self._stop()
-        self._start()
+        return self.client_order_ids_c()
 
-    def _resume(self) -> None:
+    @property
+    def venue_order_ids(self):
         """
-        Resume the client and resubscribe to all subscriptions.
+        Return the venue order IDs associated with the position.
+
+        Returns
+        -------
+        list[VenueOrderId]
+
+        Notes
+        -----
+        Guaranteed not to contain duplicate IDs.
+
         """
-        self._log.info(f"Resuming InteractiveBrokersClient ({self._client_id})...")
-        self._is_client_ready.set()
+        return self.venue_order_ids_c()
 
-    def _degrade(self) -> None:
+    @property
+    def trade_ids(self):
         """
-        Degrade the client when connectivity is lost.
+        Return the trade match IDs associated with the position.
+
+        Returns
+        -------
+        list[TradeId]
+
         """
-        self._log.info(f"Degrading InteractiveBrokersClient ({self._client_id})...")
-        self._is_client_ready.clear()
-        self._account_ids = set()
+        return self.trade_ids_c()
 
-    async def _resubscribe_all(self) -> None:
+    @property
+    def events(self):
         """
-        Cancel and restart all subscriptions.
+        Return the order fill events for the position.
+
+        Returns
+        -------
+        list[Event]
+
         """
-        self._log.debug("Resubscribing all subscriptions...")
-        for subscription in self._subscriptions.get_all():
-            try:
-                subscription.cancel()
-                if iscoroutinefunction(subscription.handle):
-                    await subscription.handle()
-                else:
-                    await asyncio.to_thread(subscription.handle)
-            except Exception as e:
-                self._log.exception(f"Failed to resubscribe to {subscription}", e)
+        return self.events_c()
 
-    async def wait_until_ready(self, timeout: int = 300) -> None:
+    @property
+    def last_event(self):
         """
-        Check if the client is running and ready within a given timeout.
+        Return the last order fill event.
 
-        Parameters
-        ----------
-        timeout : int, default 300
-            Time in seconds to wait for the client to be ready.
+        Returns
+        -------
+        OrderFilled
 
         """
-        try:
-            if not self._is_client_ready.is_set():
-                await asyncio.wait_for(self._is_client_ready.wait(), timeout)
-        except asyncio.TimeoutError as e:
-            self._log.error(f"Client is not ready. {e}")
+        return self.last_event_c()
 
-    async def _run_connection_watchdog(self) -> None:
+    @property
+    def last_trade_id(self):
         """
-        Run a watchdog to monitor and manage the health of the socket connection.
+        Return the last trade match ID for the position.
 
-        Continuously checks the connection status, manages client state based on
-        connection health, and handles subscription management in case of network
-        failure or forced IB connection reset.
+        Returns
+        -------
+        TradeId
 
         """
-        try:
-            while True:
-                await asyncio.sleep(1)
-                if not self._is_ib_connected.is_set() or not self._eclient.isConnected():
-                    self._log.error(
-                        "Connection watchdog detects connection lost.",
-                    )
-                    await self._handle_disconnection()
-        except asyncio.CancelledError:
-            self._log.debug("Client connection watchdog task was canceled.")
+        return self.last_trade_id_c()
 
-    async def _handle_disconnection(self) -> None:
+    @property
+    def event_count(self):
         """
-        Handle the disconnection of the client from TWS/Gateway.
+        Return the count of order fill events applied to the position.
+
+        Returns
+        -------
+        int
+
         """
-        if self.is_running:
-            self._degrade()
-        if not self._is_ib_connected.is_set():
-            self._log.debug("`_is_ib_connected` unset by `_handle_disconnection`.", LogColor.BLUE)
-            self._is_ib_connected.clear()
-        await asyncio.sleep(5)
-        await self._handle_reconnect()
+        return self.event_count_c()
 
-        self._resume()
+    @property
+    def is_open(self):
+        """
+        Return whether the position side is **not** ``FLAT``.
+
+        Returns
+        -------
+        bool
 
-    def _create_task(
-        self,
-        coro: Coroutine,
-        log_msg: str | None = None,
-        actions: Callable | None = None,
-        success: str | None = None,
-    ) -> asyncio.Task:
         """
-        Create an asyncio task with error handling and optional callback actions.
+        return self.is_open_c()
 
-        Parameters
-        ----------
-        coro : Coroutine
-            The coroutine to run.
-        log_msg : str, optional
-            The log message for the task.
-        actions : Callable, optional
-            The actions callback to run when the coroutine is done.
-        success : str, optional
-            The log message to write on actions success.
+    @property
+    def is_closed(self):
+        """
+        Return whether the position side is ``FLAT``.
 
         Returns
         -------
-        asyncio.Task
+        bool
 
         """
-        log_msg = log_msg or coro.__name__
-        self._log.debug(f"Creating task {log_msg}.")
-        task = self._loop.create_task(
-            coro,
-            name=coro.__name__,
-        )
-        task.add_done_callback(
-            functools.partial(
-                self._on_task_completed,
-                actions,
-                success,
-            ),
-        )
-        return task
+        return self.is_closed_c()
 
-    def _on_task_completed(
-        self,
-        actions: Callable | None,
-        success: str | None,
-        task: asyncio.Task,
-    ) -> None:
+    @property
+    def is_long(self):
         """
-        Handle the completion of a task.
+        Return whether the position side is ``LONG``.
 
-        Parameters
-        ----------
-        actions : Callable, optional
-            Callback actions to execute upon task completion.
-        success : str, optional
-            Success log message to display on successful completion of actions.
-        task : asyncio.Task
-            The asyncio Task that has been completed.
+        Returns
+        -------
+        bool
 
         """
-        if task.exception():
-            self._log.error(
-                f"Error on `{task.get_name()}`: " f"{task.exception()!r}",
-            )
+        return self.is_long_c()
+
+    @property
+    def is_short(self):
+        """
+        Return whether the position side is ``SHORT``.
+
+        Returns
+        -------
+        bool
+
+        """
+        return self.is_short_c()
+
+    @staticmethod
+    cdef PositionSide side_from_order_side_c(OrderSide side):
+        if side == OrderSide.BUY:
+            return PositionSide.LONG
+        elif side == OrderSide.SELL:
+            return PositionSide.SHORT
         else:
-            if actions:
-                try:
-                    actions()
-                except Exception as e:
-                    self._log.error(
-                        f"Failed triggering action {actions.__name__} on `{task.get_name()}`: "
-                        f"{e!r}",
-                    )
-            if success:
-                self._log.info(success, LogColor.GREEN)
+            raise ValueError(  # pragma: no cover (design-time error)
+                f"invalid `OrderSide`, was {side}",  # pragma: no cover (design-time error)
+            )
 
-    def subscribe_event(self, name: str, handler: Callable) -> None:
+    @staticmethod
+    def side_from_order_side(OrderSide side):
         """
-        Subscribe a handler function to a named event.
+        Return the position side resulting from the given order side (from ``FLAT``).
 
         Parameters
         ----------
-        name : str
-            The name of the event to subscribe to.
-        handler : Callable
-            The handler function to be called when the event occurs.
+        side : OrderSide {``BUY``, ``SELL``}
+            The order side
+
+        Returns
+        -------
+        PositionSide
 
         """
-        self._event_subscriptions[name] = handler
+        return Position.side_from_order_side_c(side)
 
-    def unsubscribe_event(self, name: str) -> None:
+    cpdef signed_decimal_qty(self):
         """
-        Unsubscribe a handler from a named event.
+        Return a signed decimal representation of the position quantity.
 
-        Parameters
-        ----------
-        name : str
-            The name of the event to unsubscribe from.
+         - If the position is LONG, the value is positive (e.g. Decimal('10.25'))
+         - If the position is SHORT, the value is negative (e.g. Decimal('-10.25'))
+         - If the position is FLAT, the value is zero (e.g. Decimal('0'))
+
+        Returns
+        -------
+        Decimal
 
         """
-        self._event_subscriptions.pop(name)
+        return Decimal(f"{self.signed_qty:.{self.size_precision}f}")
 
-    async def _await_request(self, request: Request, timeout: int) -> Any | None:
+    cpdef bint is_opposite_side(self, OrderSide side):
         """
-        Await the completion of a request within a specified timeout.
+        Return a value indicating whether the given order side is opposite to
+        the current position side.
 
         Parameters
         ----------
-        request : Request
-            The request object to await.
-        timeout : int
-            The maximum time to wait for the request to complete, in seconds.
+        side : OrderSide {``BUY``, ``SELL``}
 
         Returns
         -------
-        Any | ``None``
-            The result of the request, or None if the request timed out.
+        bool
+            True if side is opposite, else False.
 
         """
-        try:
-            return await asyncio.wait_for(request.future, timeout)
-        except asyncio.TimeoutError as e:
-            self._log.warning(f"Request timed out for {request}. Ending request.")
-            self._end_request(request.req_id, success=False, exception=e)
-            return None
-        except ConnectionError as e:
-            self._log.error(f"Connection error during {request}. Ending request.")
-            self._end_request(request.req_id, success=False, exception=e)
-            return None
+        return self.side != Position.side_from_order_side_c(side)
 
-    def _end_request(
-        self,
-        req_id: int,
-        success: bool = True,
-        exception: type | BaseException | None = None,
-    ) -> None:
+    cpdef void apply(self, OrderFilled fill):
         """
-        End a request with a specified result or exception.
+        Applies the given order fill event to the position.
 
         Parameters
         ----------
-        req_id : int
-            The request ID to conclude.
-        success : bool, optional
-            Whether the request was successful. Defaults to True.
-        exception : type | BaseException | None, optional
-            An exception to set on request failure. Defaults to None.
-
-        """
-        if not (request := self._requests.get(req_id=req_id)):
-            return
-
-        if not request.future.done():
-            if success:
-                request.future.set_result(request.result)
-            else:
-                request.cancel()
-                if exception:
-                    request.future.set_exception(exception)
-        self._requests.remove(req_id=req_id)
-
-    async def _run_tws_incoming_msg_reader(self) -> None:
-        """
-        Continuously read messages from TWS/Gateway and then put them in the internal
-        message queue for processing.
-        """
-        self._log.debug("Client TWS incoming message reader started.")
-        buf = b""
-        try:
-            while self._eclient.conn and self._eclient.conn.isConnected():
-                data = await asyncio.to_thread(self._eclient.conn.recvMsg)
-                buf += data
-                while buf:
-                    _, msg, buf = comm.read_msg(buf)
-                    self._log.debug(f"Msg buffer received: {buf!s}")
-                    if msg:
-                        # Place msg in the internal queue for processing
-                        self._internal_msg_queue.put_nowait(msg)
-                    else:
-                        self._log.debug("More incoming packets are needed.")
-                        break
-        except asyncio.CancelledError:
-            self._log.debug("Client TWS incoming message reader was cancelled.")
-        except Exception as e:
-            self._log.exception("Unhandled exception in Client TWS incoming message reader", e)
-        finally:
-            if self._is_ib_connected.is_set() and not self.is_disposed:
-                self._log.debug(
-                    "`_is_ib_connected` unset by `_run_tws_incoming_msg_reader`.",
-                    LogColor.BLUE,
-                )
-                self._is_ib_connected.clear()
-            self._log.debug("Client TWS incoming message reader stopped.")
+        fill : OrderFilled
+            The order fill event to apply.
+
+        Raises
+        ------
+        KeyError
+            If `fill.trade_id` already applied to the position.
+
+        """
+        Condition.not_none(fill, "fill")
+        self._check_duplicate_trade_id(fill)
+
+        if self.side == PositionSide.FLAT:
+            # Reset position
+            self._events.clear()
+            self._trade_ids.clear()
+            self._buy_qty = Quantity.zero_c(precision=self.size_precision)
+            self._sell_qty = Quantity.zero_c(precision=self.size_precision)
+            self._commissions = {}
+            self.opening_order_id = fill.client_order_id
+            self.closing_order_id = None
+            self.peak_qty = Quantity.zero_c(precision=self.size_precision)
+            self.ts_init = fill.ts_init
+            self.ts_opened = fill.ts_event
+            self.ts_closed = 0
+            self.duration_ns = 0
+            self.avg_px_open = fill.last_px.as_f64_c()
+            self.avg_px_close = 0.0
+            self.realized_return = 0.0
+            self.realized_pnl = None
+
+        self._events.append(fill)
+        self._trade_ids.append(fill.trade_id)
+
+        # Calculate cumulative commission
+        cdef Currency currency = fill.commission.currency
+        cdef Money commissions = self._commissions.get(currency)
+        cdef double total_commissions = commissions.as_f64_c() if commissions is not None else 0.0
+        self._commissions[currency] = Money(total_commissions + fill.commission.as_f64_c(), currency)
+
+        # Calculate avg prices, points, return, PnL
+        if fill.order_side == OrderSide.BUY:
+            self._handle_buy_order_fill(fill)
+        elif fill.order_side == OrderSide.SELL:
+            self._handle_sell_order_fill(fill)
+        else:
+            raise ValueError(  # pragma: no cover (design-time error)
+                f"invalid `OrderSide`, was {fill.order_side}",  # pragma: no cover (design-time error)
+            )
+
+        # Set quantities
+        self.quantity = Quantity(abs(self.signed_qty), self.size_precision)
+        if self.quantity._mem.raw > self.peak_qty._mem.raw:
+            self.peak_qty = self.quantity
+
+        # Set state
+        if self.signed_qty > 0.0:
+            self.entry = OrderSide.BUY
+            self.side = PositionSide.LONG
+        elif self.signed_qty < 0.0:
+            self.entry = OrderSide.SELL
+            self.side = PositionSide.SHORT
+        else:
+            self.side = PositionSide.FLAT
+            self.closing_order_id = fill.client_order_id
+            self.ts_closed = fill.ts_event
+            self.duration_ns = self.ts_closed - self.ts_opened
 
-    async def _run_internal_msg_queue_processor(self) -> None:
+        self.ts_last = fill.ts_event
+
+    cpdef Money notional_value(self, Price last):
         """
-        Continuously process messages from the internal incoming message queue.
+        Return the current notional value of the position.
+
+        Parameters
+        ----------
+        last : Price
+            The last close price for the position.
+
+        Returns
+        -------
+        Money
+            In quote currency.
+
         """
-        self._log.debug(
-            "Client internal message queue processor started.",
-        )
-        try:
-            while (
-                self._eclient.conn
-                and self._eclient.conn.isConnected()
-                or not self._internal_msg_queue.empty()
-            ):
-                msg = await self._internal_msg_queue.get()
-                if not self._process_message(msg):
-                    break
-                self._internal_msg_queue.task_done()
-        except asyncio.CancelledError:
-            log_msg = f"Internal message queue processing stopped. (qsize={self._internal_msg_queue.qsize()})."
-            (
-                self._log.warning(log_msg)
-                if not self._internal_msg_queue.empty()
-                else self._log.debug(
-                    log_msg,
-                )
+        Condition.not_none(last, "last")
+
+        if self.is_inverse:
+            return Money(
+                self.quantity.as_f64_c() * self.multiplier.as_f64_c() * (1.0 / last.as_f64_c()),
+                self.base_currency,
+            )
+        else:
+            return Money(
+                self.quantity.as_f64_c() * self.multiplier.as_f64_c() * last.as_f64_c(),
+                self.quote_currency,
             )
-        finally:
-            self._log.debug("Internal message queue processor stopped.")
 
-    def _process_message(self, msg: str) -> bool:
+    cpdef Money calculate_pnl(
+        self,
+        double avg_px_open,
+        double avg_px_close,
+        Quantity quantity,
+    ):
         """
-        Process a single message from TWS/Gateway.
+        Return a calculated PnL.
+
+        Result will be in quote currency for standard instruments, or base
+        currency for inverse instruments.
 
         Parameters
         ----------
-        msg : str
-            The message to be processed.
+        avg_px_open : double
+            The average open price.
+        avg_px_close : double
+            The average close price.
+        quantity : Quantity
+            The quantity for the calculation.
 
         Returns
         -------
-        bool
+        Money
+            In settlement currency.
 
         """
-        if len(msg) > MAX_MSG_LEN:
-            self._eclient.wrapper.error(
-                NO_VALID_ID,
-                BAD_LENGTH.code(),
-                f"{BAD_LENGTH.msg()}:{len(msg)}:{msg}",
-            )
-            return False
-        fields: tuple[bytes] = comm.read_fields(msg)
-        self._log.debug(f"Msg received: {msg}")
-        self._log.debug(f"Msg received fields: {fields}")
-
-        # The decoder identifies the message type based on its payload (e.g., open
-        # order, process real-time ticks, etc.) and then calls the corresponding
-        # method from the EWrapper. Many of those methods are overridden in the client
-        # manager and handler classes to support custom processing required for Nautilus.
-        self._eclient.decoder.interpret(fields)
-        return True
+        cdef double pnl = self._calculate_pnl(
+            avg_px_open=avg_px_open,
+            avg_px_close=avg_px_close,
+            quantity=quantity.as_f64_c(),
+        )
 
-    def _next_req_id(self) -> int:
+        return Money(pnl, self.settlement_currency)
+
+    cpdef Money unrealized_pnl(self, Price last):
         """
-        Generate the next sequential request ID.
+        Return the unrealized PnL from the given last quote tick.
+
+        Result will be in quote currency for standard instruments, or base
+        currency for inverse instruments.
+
+        Parameters
+        ----------
+        last : Price
+            The last price for the calculation.
 
         Returns
         -------
-        int
+        Money
 
         """
-        new_id = self._request_id_seq
-        self._request_id_seq += 1
-        return new_id
+        Condition.not_none(last, "last")
+
+        if self.side == PositionSide.FLAT:
+            return Money(0, self.settlement_currency)
 
-    # -- EClient overrides ------------------------------------------------------------------------
+        cdef double pnl = self._calculate_pnl(
+            avg_px_open=self.avg_px_open,
+            avg_px_close=last.as_f64_c(),
+            quantity=self.quantity.as_f64_c(),
+        )
 
-    def sendMsg(self, msg):
+        return Money(pnl, self.settlement_currency)
+
+    cpdef Money total_pnl(self, Price last):
         """
-        Override the logging for ibapi EClient.sendMsg.
+        Return the total PnL from the given last quote tick.
+
+        Result will be in quote currency for standard instruments, or base
+        currency for inverse instruments.
+
+        Parameters
+        ----------
+        last : Price
+            The last price for the calculation.
+
+        Returns
+        -------
+        Money
+
         """
-        full_msg = comm.make_msg(msg)
-        self._log.debug(f"TWS API request sent: function={current_fn_name(1)} msg={full_msg}")
-        self._eclient.conn.sendMsg(full_msg)
+        Condition.not_none(last, "last")
+
+        cdef double realized_pnl = self.realized_pnl.as_f64_c() if self.realized_pnl is not None else 0.0
+        return Money(realized_pnl + self.unrealized_pnl(last).as_f64_c(), self.settlement_currency)
 
-    def logRequest(self, fnName, fnParams):
+    cpdef list commissions(self):
         """
-        Override the logging for ibapi EClient.logRequest.
+        Return the total commissions generated by the position.
+
+        Returns
+        -------
+        list[Money]
+
         """
-        if "self" in fnParams:
-            prms = dict(fnParams)
-            del prms["self"]
+        return list(self._commissions.values())
+
+    cdef void _check_duplicate_trade_id(self, OrderFilled fill):
+        # Check all previous fills for matching trade ID and composite key
+        cdef:
+            OrderFilled p_fill
+        for p_fill in self._events:
+            if fill.trade_id != p_fill.trade_id:
+                continue
+            if (
+                fill.order_side == p_fill.order_side
+                and fill.last_px == p_fill.last_px
+                and fill.last_qty == p_fill.last_qty
+            ):
+                raise ValueError(f"Duplicate {fill.trade_id!r} in events {fill} {p_fill}")
+
+    cdef void _handle_buy_order_fill(self, OrderFilled fill):
+        # Initialize realized PnL for fill
+        cdef double realized_pnl
+        if fill.commission.currency == self.settlement_currency:
+            realized_pnl = -fill.commission.as_f64_c()
+        else:
+            realized_pnl = 0.0
+
+        cdef double last_px = fill.last_px.as_f64_c()
+        cdef double last_qty = fill.last_qty.as_f64_c()
+        cdef Quantity last_qty_obj = fill.last_qty
+        if self.base_currency is not None and fill.commission.currency == self.base_currency:
+            last_qty_obj = Quantity(last_qty, self.size_precision)
+
+        # LONG POSITION
+        if self.signed_qty > 0:
+            self.avg_px_open = self._calculate_avg_px_open_px(last_px, last_qty)
+        # SHORT POSITION
+        elif self.signed_qty < 0:
+            self.avg_px_close = self._calculate_avg_px_close_px(last_px, last_qty)
+            self.realized_return = self._calculate_return(self.avg_px_open, self.avg_px_close)
+            realized_pnl += self._calculate_pnl(self.avg_px_open, last_px, last_qty)
+
+        if self.realized_pnl is None:
+            self.realized_pnl = Money(realized_pnl, self.settlement_currency)
+        else:
+            self.realized_pnl = Money(self.realized_pnl.as_f64_c() + realized_pnl, self.settlement_currency)
+
+        self._buy_qty.add_assign(last_qty_obj)
+        self.signed_qty += last_qty
+        self.signed_qty = round(self.signed_qty, self.size_precision)
+
+    cdef void _handle_sell_order_fill(self, OrderFilled fill):
+        # Initialize realized PnL for fill
+        cdef double realized_pnl
+        if fill.commission.currency == self.settlement_currency:
+            realized_pnl = -fill.commission.as_f64_c()
+        else:
+            realized_pnl = 0.0
+
+        cdef double last_px = fill.last_px.as_f64_c()
+        cdef double last_qty = fill.last_qty.as_f64_c()
+        cdef Quantity last_qty_obj = fill.last_qty
+        if self.base_currency is not None and fill.commission.currency == self.base_currency:
+            last_qty_obj = Quantity(last_qty, self.size_precision)
+
+        # SHORT POSITION
+        if self.signed_qty < 0:
+            self.avg_px_open = self._calculate_avg_px_open_px(last_px, last_qty)
+        # LONG POSITION
+        elif self.signed_qty > 0:
+            self.avg_px_close = self._calculate_avg_px_close_px(last_px, last_qty)
+            self.realized_return = self._calculate_return(self.avg_px_open, self.avg_px_close)
+            realized_pnl += self._calculate_pnl(self.avg_px_open, last_px, last_qty)
+
+        if self.realized_pnl is None:
+            self.realized_pnl = Money(realized_pnl, self.settlement_currency)
+        else:
+            self.realized_pnl = Money(self.realized_pnl.as_f64_c() + realized_pnl, self.settlement_currency)
+
+        self._sell_qty.add_assign(last_qty_obj)
+        self.signed_qty -= last_qty
+        self.signed_qty = round(self.signed_qty, self.size_precision)
+
+    cdef double _calculate_avg_px_open_px(self, double last_px, double last_qty):
+        return self._calculate_avg_px(self.quantity.as_f64_c(), self.avg_px_open, last_px, last_qty)
+
+    cdef double _calculate_avg_px_close_px(self, double last_px, double last_qty):
+        if not self.avg_px_close:
+            return last_px
+        close_qty = self._sell_qty if self.side == PositionSide.LONG else self._buy_qty
+        return self._calculate_avg_px(close_qty.as_f64_c(), self.avg_px_close, last_px, last_qty)
+
+    cdef double _calculate_avg_px(
+        self,
+        double qty,
+        double avg_px,
+        double last_px,
+        double last_qty,
+    ):
+        cdef double start_cost = avg_px * qty
+        cdef double event_cost = last_px * last_qty
+        return (start_cost + event_cost) / (qty + last_qty)
+
+    cdef double _calculate_points(self, double avg_px_open, double avg_px_close):
+        if self.side == PositionSide.LONG:
+            return avg_px_close - avg_px_open
+        elif self.side == PositionSide.SHORT:
+            return avg_px_open - avg_px_close
+        else:
+            return 0.0  # FLAT
+
+    cdef double _calculate_points_inverse(self, double avg_px_open, double avg_px_close):
+        if self.side == PositionSide.LONG:
+            return (1.0 / avg_px_open) - (1.0 / avg_px_close)
+        elif self.side == PositionSide.SHORT:
+            return (1.0 / avg_px_close) - (1.0 / avg_px_open)
+        else:
+            return 0.0  # FLAT
+
+    cdef double _calculate_return(self, double avg_px_open, double avg_px_close):
+        return self._calculate_points(avg_px_open, avg_px_close) / avg_px_open
+
+    cdef double _calculate_pnl(
+        self,
+        double avg_px_open,
+        double avg_px_close,
+        double quantity,
+    ):
+        # Only book open quantity towards PnL
+        quantity = fmin(quantity, fabs(self.signed_qty))
+
+        if self.is_inverse:
+            # In base currency
+            return quantity * self.multiplier.as_f64_c() * self._calculate_points_inverse(avg_px_open, avg_px_close)
         else:
-            prms = fnParams
-        self._log.debug(f"TWS API prepared request: function={fnName} data={prms}")
+            # In quote currency
+            return quantity * self.multiplier.as_f64_c() * self._calculate_points(avg_px_open, avg_px_close)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/common.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/common.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/connection.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/connection.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/contract.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/contract.py`

 * *Files 2% similar despite different names*

```diff
@@ -135,37 +135,37 @@
                 return None
             request.handle()
             return await self._await_request(request, 20)
         else:
             self._log.info(f"Request already exist for {request}")
             return None
 
-    def process_contract_details(
+    async def process_contract_details(
         self,
         *,
         req_id: int,
         contract_details: ContractDetails,
     ) -> None:
         """
         Receive the full contract's definitions This method will return all
         contracts matching the requested via EClientSocket::reqContractDetails.
         For example, one can obtain the whole option chain with it.
         """
         if not (request := self._requests.get(req_id=req_id)):
             return
         request.result.append(contract_details)
 
-    def process_contract_details_end(self, *, req_id: int) -> None:
+    async def process_contract_details_end(self, *, req_id: int) -> None:
         """
         After all contracts matching the request were returned, this method will mark
         the end of their reception.
         """
         self._end_request(req_id)
 
-    def process_security_definition_option_parameter(
+    async def process_security_definition_option_parameter(
         self,
         *,
         req_id: int,
         exchange: str,
         underlying_con_id: int,
         trading_class: str,
         multiplier: str,
@@ -177,21 +177,21 @@
         reqSecDefOptParams There will be multiple callbacks to
         securityDefinitionOptionParameter if multiple exchanges are specified in
         reqSecDefOptParams.
         """
         if request := self._requests.get(req_id=req_id):
             request.result.append((exchange, expirations))
 
-    def process_security_definition_option_parameter_end(self, *, req_id: int) -> None:
+    async def process_security_definition_option_parameter_end(self, *, req_id: int) -> None:
         """
         Call when all callbacks to securityDefinitionOptionParameter are complete.
         """
         self._end_request(req_id)
 
-    def process_symbol_samples(
+    async def process_symbol_samples(
         self,
         *,
         req_id: int,
         contract_descriptions: list,
     ) -> None:
         """
         Return an array of sample contract descriptions.
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/error.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/error.py`

 * *Files 3% similar despite different names*

```diff
@@ -35,15 +35,15 @@
 
     WARNING_CODES: Final[set[int]] = {1101, 1102, 110, 165, 202, 399, 404, 434, 492, 10167}
     CLIENT_ERRORS: Final[set[int]] = {502, 503, 504, 10038, 10182, 1100, 2110}
     CONNECTIVITY_LOST_CODES: Final[set[int]] = {1100, 1300, 2110}
     CONNECTIVITY_RESTORED_CODES: Final[set[int]] = {1101, 1102}
     ORDER_REJECTION_CODES: Final[set[int]] = {201, 203, 321, 10289, 10293}
 
-    def _log_message(
+    async def _log_message(
         self,
         error_code: int,
         req_id: int,
         error_string: str,
         is_warning: bool,
     ) -> None:
         """
@@ -60,15 +60,15 @@
         is_warning : bool
             Indicates whether the message is a warning or an error.
 
         """
         msg = f"{error_string} (code: {error_code}, {req_id=})."
         self._log.warning(msg) if is_warning else self._log.error(msg)
 
-    def process_error(
+    async def process_error(
         self,
         *,
         req_id: int,
         error_code: int,
         error_string: str,
         advanced_order_reject_json: str = "",
     ) -> None:
@@ -87,23 +87,23 @@
             The error message string.
         advanced_order_reject_json : str
             The JSON string for advanced order rejection.
 
         """
         is_warning = error_code in self.WARNING_CODES or 2100 <= error_code < 2200
         error_string = error_string.replace("\n", " ")
-        self._log_message(error_code, req_id, error_string, is_warning)
+        await self._log_message(error_code, req_id, error_string, is_warning)
 
         if req_id != -1:
             if self._subscriptions.get(req_id=req_id):
-                self._handle_subscription_error(req_id, error_code, error_string)
+                await self._handle_subscription_error(req_id, error_code, error_string)
             elif self._requests.get(req_id=req_id):
-                self._handle_request_error(req_id, error_code, error_string)
+                await self._handle_request_error(req_id, error_code, error_string)
             elif req_id in self._order_id_to_order_ref:
-                self._handle_order_error(req_id, error_code, error_string)
+                await self._handle_order_error(req_id, error_code, error_string)
             else:
                 self._log.warning(f"Unhandled error: {error_code} for req_id {req_id}")
         elif error_code in self.CLIENT_ERRORS or error_code in self.CONNECTIVITY_LOST_CODES:
             if self._is_ib_connected.is_set():
                 self._log.debug(
                     f"`_is_ib_connected` unset by code {error_code} in `_process_error`.",
                     LogColor.BLUE,
@@ -113,15 +113,20 @@
             if not self._is_ib_connected.is_set():
                 self._log.debug(
                     f"`_is_ib_connected` set by code {error_code} in `_process_error`.",
                     LogColor.BLUE,
                 )
                 self._is_ib_connected.set()
 
-    def _handle_subscription_error(self, req_id: int, error_code: int, error_string: str) -> None:
+    async def _handle_subscription_error(
+        self,
+        req_id: int,
+        error_code: int,
+        error_string: str,
+    ) -> None:
         """
         Handle errors specific to data subscriptions. Processes subscription-related
         errors and takes appropriate actions, such as cancelling the subscription or
         clearing flags.
 
         Parameters
         ----------
@@ -154,15 +159,15 @@
                 self._is_ib_connected.clear()
         else:
             # Log unknown subscription errors
             self._log.warning(
                 f"Unknown subscription error: {error_code} for req_id {req_id}",
             )
 
-    def _handle_request_error(self, req_id: int, error_code: int, error_string: str) -> None:
+    async def _handle_request_error(self, req_id: int, error_code: int, error_string: str) -> None:
         """
         Handle errors related to general requests. Logs the error and ends the request
         associated with the given request ID.
 
         Parameters
         ----------
         req_id : int
@@ -173,15 +178,15 @@
             The error message string.
 
         """
         request = self._requests.get(req_id=req_id)
         self._log.warning(f"{error_code}: {error_string}, {request}")
         self._end_request(req_id, success=False)
 
-    def _handle_order_error(self, req_id: int, error_code: int, error_string: str) -> None:
+    async def _handle_order_error(self, req_id: int, error_code: int, error_string: str) -> None:
         """
         Handle errors related to orders. Manages various order-related errors, including
         rejections and cancellations, and logs or forwards them as appropriate.
 
         Parameters
         ----------
         req_id : int
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/market_data.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/market_data.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,14 +14,15 @@
 # -------------------------------------------------------------------------------------------------
 
 import functools
 from collections.abc import Callable
 from decimal import Decimal
 from inspect import iscoroutinefunction
 from typing import Any
+from zoneinfo import ZoneInfo
 
 import pandas as pd
 import pytz
 from ibapi.common import BarData
 from ibapi.common import HistoricalTickLast
 from ibapi.common import MarketDataTypeEnum
 from ibapi.common import TickAttribBidAsk
@@ -318,15 +319,15 @@
         await self._unsubscribe(name, self._eclient.cancelHistoricalData)
 
     async def get_historical_bars(
         self,
         bar_type: BarType,
         contract: IBContract,
         use_rth: bool,
-        end_date_time: str,
+        end_date_time: pd.Timestamp,
         duration: str,
         timeout: int = 60,
     ) -> list[Bar] | None:
         """
         Request and retrieve historical bar data for a specified bar type.
 
         Parameters
@@ -345,26 +346,32 @@
             The maximum time in seconds to wait for the historical data response.
 
         Returns
         -------
         list[Bar] | ``None``
 
         """
-        name = str(bar_type)
+        # Ensure the requested `end_date_time` is in UTC and set formatDate=2 to ensure returned dates are in UTC.
+        if end_date_time.tzinfo is None:
+            end_date_time = end_date_time.replace(tzinfo=ZoneInfo("UTC"))
+        else:
+            end_date_time = end_date_time.astimezone(ZoneInfo("UTC"))
+
+        name = (bar_type, end_date_time)
         if not (request := self._requests.get(name=name)):
             req_id = self._next_req_id()
             bar_size_setting = bar_spec_to_bar_size(bar_type.spec)
             request = self._requests.add(
                 req_id=req_id,
                 name=name,
                 handle=functools.partial(
                     self._eclient.reqHistoricalData,
                     reqId=req_id,
                     contract=contract,
-                    endDateTime=end_date_time,
+                    endDateTime=end_date_time.strftime("%Y%m%d %H:%M:%S %Z"),
                     durationStr=duration,
                     barSizeSetting=bar_size_setting,
                     whatToShow=what_to_show(bar_type),
                     useRTH=use_rth,
                     formatDate=2,
                     keepUpToDate=False,
                     chartOptions=[],
@@ -443,15 +450,15 @@
                 return None
             request.handle()
             return await self._await_request(request, timeout)
         else:
             self._log.info(f"Request already exist for {request}")
             return None
 
-    def _process_bar_data(
+    async def _process_bar_data(
         self,
         bar_type_str: str,
         bar: BarData,
         handle_revised_bars: bool,
         historical: bool | None = False,
     ) -> Bar | None:
         """
@@ -492,27 +499,27 @@
         if not handle_revised_bars:
             if previous_bar and is_new_bar:
                 bar = previous_bar
             else:
                 return None  # Wait for bar to close
 
             if historical:
-                ts_init = self._ib_bar_to_ts_init(bar, bar_type)
+                ts_init = await self._ib_bar_to_ts_init(bar, bar_type)
                 if ts_init >= self._clock.timestamp_ns():
                     return None  # The bar is incomplete
 
         # Process the bar
-        return self._ib_bar_to_nautilus_bar(
+        return await self._ib_bar_to_nautilus_bar(
             bar_type=bar_type,
             bar=bar,
             ts_init=ts_init,
             is_revision=not is_new_bar,
         )
 
-    def _convert_ib_bar_date_to_unix_nanos(self, bar: BarData, bar_type: BarType) -> int:
+    async def _convert_ib_bar_date_to_unix_nanos(self, bar: BarData, bar_type: BarType) -> int:
         """
         Convert the date from BarData to unix nanoseconds.
 
         If the bar type's aggregation is 14, the bar date is always returned in the
         YYYYMMDD format from IB. For all other aggregations, the bar date is returned
         in system time.
 
@@ -532,15 +539,15 @@
             # Day bars are always returned with bar date in YYYYMMDD format
             ts = pd.to_datetime(bar.date, format="%Y%m%d", utc=True)
         else:
             ts = pd.Timestamp.fromtimestamp(int(bar.date), tz=pytz.utc)
 
         return ts.value
 
-    def _ib_bar_to_ts_init(self, bar: BarData, bar_type: BarType) -> int:
+    async def _ib_bar_to_ts_init(self, bar: BarData, bar_type: BarType) -> int:
         """
         Calculate the initialization timestamp for a bar.
 
         This method computes the timestamp at which a bar is initialized, by adjusting
         the provided bar's timestamp based on the bar type's duration. ts_init is set
         to the end of the bar period and not the start.
 
@@ -552,18 +559,18 @@
             The type of the bar, which includes information about the bar's duration.
 
         Returns
         -------
         int
 
         """
-        ts = self._convert_ib_bar_date_to_unix_nanos(bar, bar_type)
+        ts = await self._convert_ib_bar_date_to_unix_nanos(bar, bar_type)
         return ts + pd.Timedelta(bar_type.spec.timedelta).value
 
-    def _ib_bar_to_nautilus_bar(
+    async def _ib_bar_to_nautilus_bar(
         self,
         bar_type: BarType,
         bar: BarData,
         ts_init: int,
         is_revision: bool = False,
     ) -> Bar:
         """
@@ -585,28 +592,28 @@
         Bar
 
         """
         instrument = self._cache.instrument(bar_type.instrument_id)
         if not instrument:
             raise ValueError(f"No cached instrument for {bar_type.instrument_id}")
 
-        ts_event = self._convert_ib_bar_date_to_unix_nanos(bar, bar_type)
+        ts_event = await self._convert_ib_bar_date_to_unix_nanos(bar, bar_type)
         return Bar(
             bar_type=bar_type,
             open=instrument.make_price(bar.open),
             high=instrument.make_price(bar.high),
             low=instrument.make_price(bar.low),
             close=instrument.make_price(bar.close),
             volume=instrument.make_qty(0 if bar.volume == -1 else bar.volume),
             ts_event=ts_event,
             ts_init=ts_init,
             is_revision=is_revision,
         )
 
-    def _process_trade_ticks(self, req_id: int, ticks: list[HistoricalTickLast]) -> None:
+    async def _process_trade_ticks(self, req_id: int, ticks: list[HistoricalTickLast]) -> None:
         """
         Process received trade tick data, convert it to Nautilus Trader TradeTick type,
         and add it to the relevant request's result.
 
         Parameters
         ----------
         req_id : int
@@ -630,40 +637,40 @@
                     ts_event=ts_event,
                     ts_init=ts_event,
                 )
                 request.result.append(trade_tick)
 
             self._end_request(req_id)
 
-    def _handle_data(self, data: Data) -> None:
+    async def _handle_data(self, data: Data) -> None:
         """
         Handle and forward processed data to the appropriate destination. This method is
         a generic data handler that forwards processed market data, such as bars or
         ticks, to the DataEngine.process message bus endpoint.
 
         Parameters
         ----------
         data : Data
             The processed market data ready to be forwarded.
 
         """
         self._msgbus.send(endpoint="DataEngine.process", msg=data)
 
-    def process_market_data_type(self, *, req_id: int, market_data_type: int) -> None:
+    async def process_market_data_type(self, *, req_id: int, market_data_type: int) -> None:
         """
         Return the market data type (real-time, frozen, delayed, delayed-frozen)
         of ticker sent by EClientSocket::reqMktData when TWS switches from real-time
         to frozen and back and from delayed to delayed-frozen and back.
         """
         if market_data_type == MarketDataTypeEnum.REALTIME:
             self._log.debug(f"Market DataType is {MarketDataTypeEnum.to_str(market_data_type)}")
         else:
             self._log.warning(f"Market DataType is {MarketDataTypeEnum.to_str(market_data_type)}")
 
-    def process_tick_by_tick_bid_ask(
+    async def process_tick_by_tick_bid_ask(
         self,
         *,
         req_id: int,
         time: int,
         bid_price: float,
         ask_price: float,
         bid_size: Decimal,
@@ -686,17 +693,17 @@
             ask_price=instrument.make_price(ask_price),
             bid_size=instrument.make_qty(bid_size),
             ask_size=instrument.make_qty(ask_size),
             ts_event=ts_event,
             ts_init=max(self._clock.timestamp_ns(), ts_event),  # `ts_event` <= `ts_init`
         )
 
-        self._handle_data(quote_tick)
+        await self._handle_data(quote_tick)
 
-    def process_tick_by_tick_all_last(
+    async def process_tick_by_tick_all_last(
         self,
         *,
         req_id: int,
         tick_type: str,
         time: int,
         price: float,
         size: Decimal,
@@ -724,17 +731,17 @@
             size=instrument.make_qty(size),
             aggressor_side=AggressorSide.NO_AGGRESSOR,
             trade_id=generate_trade_id(ts_event=ts_event, price=price, size=size),
             ts_event=ts_event,
             ts_init=max(self._clock.timestamp_ns(), ts_event),  # `ts_event` <= `ts_init`
         )
 
-        self._handle_data(trade_tick)
+        await self._handle_data(trade_tick)
 
-    def process_realtime_bar(
+    async def process_realtime_bar(
         self,
         *,
         req_id: int,
         time: int,
         open_: float,
         high: float,
         low: float,
@@ -759,73 +766,73 @@
             close=instrument.make_price(close),
             volume=instrument.make_qty(0 if volume == -1 else volume),
             ts_event=pd.Timestamp.fromtimestamp(time, tz=pytz.utc).value,
             ts_init=self._clock.timestamp_ns(),
             is_revision=False,
         )
 
-        self._handle_data(bar)
+        await self._handle_data(bar)
 
-    def process_historical_data(self, *, req_id: int, bar: BarData) -> None:
+    async def process_historical_data(self, *, req_id: int, bar: BarData) -> None:
         """
         Return the requested historical data bars.
         """
         if request := self._requests.get(req_id=req_id):
-            bar_type = BarType.from_str(request.name)
-            bar = self._ib_bar_to_nautilus_bar(
+            bar_type = request.name[0]
+            bar = await self._ib_bar_to_nautilus_bar(
                 bar_type=bar_type,
                 bar=bar,
-                ts_init=self._ib_bar_to_ts_init(bar, bar_type),
+                ts_init=await self._ib_bar_to_ts_init(bar, bar_type),
             )
             if bar:
                 request.result.append(bar)
         elif subscription := self._subscriptions.get(req_id=req_id):
-            bar = self._process_bar_data(
+            bar = await self._process_bar_data(
                 bar_type_str=str(subscription.name),
                 bar=bar,
                 handle_revised_bars=False,
                 historical=True,
             )
             if bar:
-                self._handle_data(bar)
+                await self._handle_data(bar)
         else:
             self._log.debug(f"Received {bar=} on {req_id=}")
             return
 
-    def process_historical_data_end(self, *, req_id: int, start: str, end: str) -> None:
+    async def process_historical_data_end(self, *, req_id: int, start: str, end: str) -> None:
         """
         Mark the end of receiving historical bars.
         """
         self._end_request(req_id)
 
-    def process_historical_data_update(self, *, req_id: int, bar: BarData) -> None:
+    async def process_historical_data_update(self, *, req_id: int, bar: BarData) -> None:
         """
         Receive bars in real-time if keepUpToDate is set as True in reqHistoricalData.
 
         Similar to realTimeBars function, except returned data is a composite of
         historical data and real time data that is equivalent to TWS chart functionality
         to keep charts up to date. Returned bars are successfully updated using real-
         time data.
 
         """
         if not (subscription := self._subscriptions.get(req_id=req_id)):
             return
         if not isinstance(subscription.handle, functools.partial):
             raise TypeError(f"Expecting partial type subscription method. {subscription=}")
-        if bar := self._process_bar_data(
+        if bar := await self._process_bar_data(
             bar_type_str=str(subscription.name),
             bar=bar,
             handle_revised_bars=subscription.handle.keywords.get("handle_revised_bars", False),
         ):
             if bar.is_single_price() and bar.open.as_double() == 0:
                 self._log.debug(f"Ignoring Zero priced {bar=}")
             else:
-                self._handle_data(bar)
+                await self._handle_data(bar)
 
-    def process_historical_ticks_bid_ask(
+    async def process_historical_ticks_bid_ask(
         self,
         *,
         req_id: int,
         ticks: list,
         done: bool,
     ) -> None:
         """
@@ -848,22 +855,22 @@
                     ts_event=ts_event,
                     ts_init=ts_event,
                 )
                 request.result.append(quote_tick)
 
             self._end_request(req_id)
 
-    def process_historical_ticks_last(self, *, req_id: int, ticks: list, done: bool) -> None:
+    async def process_historical_ticks_last(self, *, req_id: int, ticks: list, done: bool) -> None:
         """
         Return the requested historic trade ticks.
         """
         if not done:
             return
-        self._process_trade_ticks(req_id, ticks)
+        await self._process_trade_ticks(req_id, ticks)
 
-    def process_historical_ticks(self, *, req_id: int, ticks: list, done: bool) -> None:
+    async def process_historical_ticks(self, *, req_id: int, ticks: list, done: bool) -> None:
         """
         Return the requested historic ticks.
         """
         if not done:
             return
-        self._process_trade_ticks(req_id, ticks)
+        await self._process_trade_ticks(req_id, ticks)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/client/wrapper.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/client/wrapper.py`

 * *Files 5% similar despite different names*

```diff
@@ -10,14 +10,15 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from decimal import Decimal
+from functools import partial
 from typing import TYPE_CHECKING
 
 from ibapi.commission_report import CommissionReport
 from ibapi.common import BarData
 from ibapi.common import FaDataType
 from ibapi.common import HistogramData
 from ibapi.common import ListOfContractDescription
@@ -83,20 +84,22 @@
         advancedOrderRejectJson="",
     ) -> None:
         """
         Call this event in response to an error in communication or when TWS needs to
         send a message to the client.
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_error(
+        task = partial(
+            self._client.process_error,
             req_id=reqId,
             error_code=errorCode,
             error_string=errorString,
             advanced_order_reject_json=advancedOrderRejectJson,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def winError(self, text: str, lastError: int) -> None:
         self.logAnswer(current_fn_name(), vars())
 
     def connectAck(self) -> None:
         """
         Invoke this callback to signify the completion of a successful connection.
@@ -119,15 +122,20 @@
         reqId : TickerId
             The request's identifier.
         marketDataType : int
             The type of market data being received. Possible values are 1 for real-time streaming, 2 for frozen market data.
 
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_market_data_type(req_id=reqId, market_data_type=marketDataType)
+        task = partial(
+            self._client.process_market_data_type,
+            req_id=reqId,
+            market_data_type=marketDataType,
+        )
+        self._client.submit_to_msg_handler_queue(task)
 
     def tickPrice(
         self,
         reqId: TickerId,
         tickType: TickType,
         price: float,
         attrib: TickAttrib,
@@ -264,27 +272,29 @@
             This field is used to identify an order held when TWS is trying to locate shares for a short sell.
             The value used to indicate this is 'locate'.
         mktCapPrice: float
             The price at which the market cap price is calculated.
 
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_order_status(
+        task = partial(
+            self._client.process_order_status,
             order_id=orderId,
             status=status,
             filled=filled,
             remaining=remaining,
             avg_fill_price=avgFillPrice,
             perm_id=permId,
             parent_id=parentId,
             last_fill_price=lastFillPrice,
             client_id=clientId,
             why_held=whyHeld,
             mkt_cap_price=mktCapPrice,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def openOrder(
         self,
         orderId: OrderId,
         contract: Contract,
         order: Order,
         orderState: OrderState,
@@ -301,27 +311,31 @@
         order: Order
             The Order class gives the details of the open order.
         orderState: OrderState
             The orderState class includes attributes Used for both pre and post trade margin and commission data.
 
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_open_order(
+        task = partial(
+            self._client.process_open_order,
             order_id=orderId,
             contract=contract,
             order=order,
             order_state=orderState,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def openOrderEnd(self) -> None:
         """
         Call this at the end of a given request for open orders.
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_open_order_end()
+        self._client.submit_to_msg_handler_queue(
+            self._client.process_open_order_end,
+        )
 
     def connectionClosed(self) -> None:
         """
         Call this function when TWS closes the socket connection with the ActiveX
         control, or when TWS is shut down.
         """
         self.logAnswer(current_fn_name(), vars())
@@ -367,27 +381,36 @@
         self.logAnswer(current_fn_name(), vars())
 
     def nextValidId(self, orderId: int) -> None:
         """
         Receives next valid order id.
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_next_valid_id(order_id=orderId)
+        task = partial(
+            self._client.process_next_valid_id,
+            order_id=orderId,
+        )
+        self._client.submit_to_msg_handler_queue(task)
 
     def contractDetails(self, reqId: int, contractDetails: ContractDetails) -> None:
         """
         Receives the full contract's definitions.
 
         This method will return all
         contracts matching the requested via EEClientSocket::reqContractDetails.
         For example, one can obtain the whole option chain with it.
 
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_contract_details(req_id=reqId, contract_details=contractDetails)
+        task = partial(
+            self._client.process_contract_details,
+            req_id=reqId,
+            contract_details=contractDetails,
+        )
+        self._client.submit_to_msg_handler_queue(task)
 
     def bondContractDetails(self, reqId: int, contractDetails: ContractDetails) -> None:
         """
         Call this function when the reqContractDetails function has been called for
         bonds.
         """
         self.logAnswer(current_fn_name(), vars())
@@ -396,27 +419,33 @@
         """
         Call this function once all contract details for a given request are received.
 
         This helps to define the end of an option chain.
 
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_contract_details_end(req_id=reqId)
+        task = partial(
+            self._client.process_contract_details_end,
+            req_id=reqId,
+        )
+        self._client.submit_to_msg_handler_queue(task)
 
     def execDetails(self, reqId: int, contract: Contract, execution: Execution) -> None:
         """
         Fire this event when the reqExecutions() function is invoked or when an order is
         filled.
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_exec_details(
+        task = partial(
+            self._client.process_exec_details,
             req_id=reqId,
             contract=contract,
             execution=execution,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def execDetailsEnd(self, reqId: int) -> None:
         """
         Call this function once all executions have been sent to a client in response to
         reqExecutions().
         """
         self.logAnswer(current_fn_name(), vars())
@@ -521,15 +550,19 @@
         self.logAnswer(current_fn_name(), vars())
 
     def managedAccounts(self, accountsList: str) -> None:
         """
         Receives a comma-separated string with the managed account ids.
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_managed_accounts(accounts_list=accountsList)
+        task = partial(
+            self._client.process_managed_accounts,
+            accounts_list=accountsList,
+        )
+        self._client.submit_to_msg_handler_queue(task)
 
     def receiveFA(self, faData: FaDataType, cxml: str) -> None:
         """
         Receives the Financial Advisor's configuration available in the TWS.
 
         Parameters
         ----------
@@ -554,21 +587,33 @@
         reqId : int
             The request's identifier.
         bar : BarData
             The bar's data.
 
         """
         self.logAnswer(current_fn_name(), vars())
+        task = partial(
+            self._client.process_historical_data,
+            req_id=reqId,
+            bar=bar,
+        )
+        self._client.submit_to_msg_handler_queue(task)
 
     def historicalDataEnd(self, reqId: int, start: str, end: str) -> None:
         """
         Mark the end of the reception of historical bars.
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_historical_data_end(req_id=reqId, start=start, end=end)
+        task = partial(
+            self._client.process_historical_data_end,
+            req_id=reqId,
+            start=start,
+            end=end,
+        )
+        self._client.submit_to_msg_handler_queue(task)
 
     def scannerParameters(self, xml: str) -> None:
         """
         Provide the XML-formatted parameters available to create a market scanner.
 
         Parameters
         ----------
@@ -657,25 +702,27 @@
         wap : float
             The bar's Weighted Average Price.
         count : int
             The number of trades during the bar's timespan (only available for TRADES).
 
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_realtime_bar(
+        task = partial(
+            self._client.process_realtime_bar,
             req_id=reqId,
             time=time,
             open_=open_,
             high=high,
             low=low,
             close=close,
             volume=volume,
             wap=wap,
             count=count,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def currentTime(self, time: int) -> None:
         """
         Obtain the IB server's system time by calling this method as a result of
         invoking `reqCurrentTime`.
         """
         self.logAnswer(current_fn_name(), vars())
@@ -711,63 +758,73 @@
         Trigger this callback in the following scenarios:
 
         - Immediately after a trade execution.
         - By calling reqExecutions().
 
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_commission_report(commission_report=commissionReport)
+        task = partial(
+            self._client.process_commission_report,
+            commission_report=commissionReport,
+        )
+        self._client.submit_to_msg_handler_queue(task)
 
     def position(
         self,
         account: str,
         contract: Contract,
         position: Decimal,
         avgCost: float,
     ) -> None:
         """
         Return real-time positions for all accounts in response to the reqPositions()
         method.
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_position(
+        task = partial(
+            self._client.process_position,
             account_id=account,
             contract=contract,
             position=position,
             avg_cost=avgCost,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def positionEnd(self) -> None:
         """
         Call this once all position data for a given request has been received, serving
         as an end marker for the position() data.
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_position_end()
+        self._client.submit_to_msg_handler_queue(
+            self._client.process_position_end,
+        )
 
     def accountSummary(
         self,
         reqId: int,
         account: str,
         tag: str,
         value: str,
         currency: str,
     ) -> None:
         """
         Return the data from the TWS Account Window Summary tab in response to
         reqAccountSummary().
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_account_summary(
+        task = partial(
+            self._client.process_account_summary,
             req_id=reqId,
             account_id=account,
             tag=tag,
             value=value,
             currency=currency,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def accountSummaryEnd(self, reqId: int) -> None:
         """
         Call this method when all account summary data for a given request has been
         received.
         """
         self.logAnswer(current_fn_name(), vars())
@@ -919,37 +976,43 @@
         expirations : list[str]
             A list of expiry dates for the options of this underlying on this exchange.
         strikes : list[float]
             A list of possible strikes for options of this underlying on this exchange.
 
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_security_definition_option_parameter(
+        task = partial(
+            self._client.process_security_definition_option_parameter,
             req_id=reqId,
             exchange=exchange,
             underlying_con_id=underlyingConId,
             trading_class=tradingClass,
             multiplier=multiplier,
             expirations=expirations,
             strikes=strikes,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def securityDefinitionOptionParameterEnd(self, reqId: int) -> None:
         """
         Invoke this after all callbacks to securityDefinitionOptionParameter have been
         completed.
 
         Parameters
         ----------
         reqId : int
             The ID used in the initial call to `securityDefinitionOptionParameter`.
 
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_security_definition_option_parameter_end(req_id=reqId)
+        task = partial(
+            self._client.process_security_definition_option_parameter_end,
+            req_id=reqId,
+        )
+        self._client.submit_to_msg_handler_queue(task)
 
     def softDollarTiers(self, reqId: int, tiers: list) -> None:
         """
         Invoke this upon receiving Soft Dollar Tier configuration information.
 
         Call this method when Soft Dollar Tier configuration details are received.
 
@@ -974,18 +1037,20 @@
         reqId: int,
         contractDescriptions: ListOfContractDescription,
     ) -> None:
         """
         Return an array of sample contract descriptions.
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_symbol_samples(
+        task = partial(
+            self._client.process_symbol_samples,
             req_id=reqId,
             contract_descriptions=contractDescriptions,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def mktDepthExchanges(self, depthMktDataDescriptions: ListOfDepthExchanges) -> None:
         """
         Return an array of exchanges that provide depth data to UpdateMktDepthL2.
         """
         self.logAnswer(current_fn_name(), vars())
 
@@ -1066,18 +1131,20 @@
         self.logAnswer(current_fn_name(), vars())
 
     def historicalDataUpdate(self, reqId: int, bar: BarData) -> None:
         """
         Return updates in real time when keepUpToDate is set to True.
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_historical_data_update(
+        task = partial(
+            self._client.process_historical_data_update,
             req_id=reqId,
             bar=bar,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def rerouteMktDataReq(self, reqId: int, conId: int, exchange: str) -> None:
         """
         Return rerouted CFD contract information for a market data request.
         """
         self.logAnswer(current_fn_name(), vars())
 
@@ -1114,46 +1181,52 @@
         self.logAnswer(current_fn_name(), vars())
 
     def historicalTicks(self, reqId: int, ticks: ListOfHistoricalTick, done: bool) -> None:
         """
         Return historical tick data when whatToShow is set to MIDPOINT.
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_historical_ticks(
+        task = partial(
+            self._client.process_historical_ticks,
             req_id=reqId,
             ticks=ticks,
             done=done,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def historicalTicksBidAsk(
         self,
         reqId: int,
         ticks: ListOfHistoricalTickBidAsk,
         done: bool,
     ) -> None:
         """
         Return historical tick data when whatToShow is set to BID_ASK.
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_historical_ticks_bid_ask(
+        task = partial(
+            self._client.process_historical_ticks_bid_ask,
             req_id=reqId,
             ticks=ticks,
             done=done,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def historicalTicksLast(self, reqId: int, ticks: ListOfHistoricalTickLast, done: bool) -> None:
         """
         Return historical tick data when whatToShow is set to TRADES.
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_historical_ticks_last(
+        task = partial(
+            self._client.process_historical_ticks_last,
             req_id=reqId,
             ticks=ticks,
             done=done,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def tickByTickAllLast(
         self,
         reqId: int,
         tickType: int,
         time: int,
         price: float,
@@ -1162,24 +1235,26 @@
         exchange: str,
         specialConditions: str,
     ) -> None:
         """
         Return tick-by-tick data for tickType set to "Last" or "AllLast".
         """
         self.logAnswer(current_fn_name(), vars())
-        self._process_tick_by_tick_all_last(
+        task = partial(
+            self._client.process_tick_by_tick_all_last,
             req_id=reqId,
             tick_type=tickType,
             time=time,
             price=price,
             size=size,
             tick_attrib_last=tickAttribLast,
             exchange=exchange,
             special_conditions=specialConditions,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def tickByTickBidAsk(
         self,
         reqId: int,
         time: int,
         bidPrice: float,
         askPrice: float,
@@ -1187,23 +1262,25 @@
         askSize: Decimal,
         tickAttribBidAsk: TickAttribBidAsk,
     ) -> None:
         """
         Return tick-by-tick data for tickType set to "BidAsk".
         """
         self.logAnswer(current_fn_name(), vars())
-        self._client.process_tick_by_tick_bid_ask(
+        task = partial(
+            self._client.process_tick_by_tick_bid_ask,
             req_id=reqId,
             time=time,
             bid_price=bidPrice,
             ask_price=askPrice,
             bid_size=bidSize,
             ask_size=askSize,
             tick_attrib_bid_ask=tickAttribBidAsk,
         )
+        self._client.submit_to_msg_handler_queue(task)
 
     def tickByTickMidPoint(self, reqId: int, time: int, midPoint: float) -> None:
         """
         Return tick-by-tick data for tickType set to "MidPoint".
         """
         self.logAnswer(current_fn_name(), vars())
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/common.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/common.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/config.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/data.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross_stop_entry.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,446 +9,456 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import asyncio
-from operator import attrgetter
-from typing import Any
-
-import pandas as pd
-
-# fmt: off
-from nautilus_trader.adapters.interactive_brokers.client import InteractiveBrokersClient
-from nautilus_trader.adapters.interactive_brokers.common import IB_VENUE
-from nautilus_trader.adapters.interactive_brokers.common import IBContract
-from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersDataClientConfig
-from nautilus_trader.adapters.interactive_brokers.parsing.data import timedelta_to_duration_str
-from nautilus_trader.adapters.interactive_brokers.providers import InteractiveBrokersInstrumentProvider
-from nautilus_trader.cache.cache import Cache
-from nautilus_trader.common.component import LiveClock
-from nautilus_trader.common.component import MessageBus
-from nautilus_trader.core.uuid import UUID4
-from nautilus_trader.live.data_client import LiveMarketDataClient
+from decimal import Decimal
+
+from nautilus_trader.common.enums import LogColor
+from nautilus_trader.config import PositiveFloat
+from nautilus_trader.config import PositiveInt
+from nautilus_trader.config import StrategyConfig
+from nautilus_trader.core.correctness import PyCondition
+from nautilus_trader.core.data import Data
+from nautilus_trader.core.message import Event
+from nautilus_trader.indicators.atr import AverageTrueRange
+from nautilus_trader.indicators.average.ema import ExponentialMovingAverage
+from nautilus_trader.model.book import OrderBook
 from nautilus_trader.model.data import Bar
 from nautilus_trader.model.data import BarType
-from nautilus_trader.model.data import DataType
 from nautilus_trader.model.data import QuoteTick
 from nautilus_trader.model.data import TradeTick
-from nautilus_trader.model.enums import BookType
-from nautilus_trader.model.identifiers import ClientId
+from nautilus_trader.model.enums import OrderSide
+from nautilus_trader.model.enums import TimeInForce
+from nautilus_trader.model.enums import TrailingOffsetType
+from nautilus_trader.model.enums import TriggerType
+from nautilus_trader.model.events import OrderFilled
 from nautilus_trader.model.identifiers import InstrumentId
-from nautilus_trader.model.identifiers import Venue
-from nautilus_trader.model.instruments.currency_pair import CurrencyPair
+from nautilus_trader.model.instruments import Instrument
+from nautilus_trader.model.objects import Price
+from nautilus_trader.model.orders import MarketIfTouchedOrder
+from nautilus_trader.model.orders import TrailingStopMarketOrder
+from nautilus_trader.trading.strategy import Strategy
+
+
+# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
+# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***
+
 
+class EMACrossStopEntryConfig(StrategyConfig, frozen=True):
+    """
+    Configuration for ``EMACrossStopEntry`` instances.
+
+    Parameters
+    ----------
+    instrument_id : InstrumentId
+        The instrument ID for the strategy.
+    bar_type : BarType
+        The bar type for the strategy.
+    atr_period : PositiveInt
+        The period for the ATR indicator.
+    trailing_atr_multiple : PositiveFloat
+        The ATR multiple for the trailing stop.
+    trailing_offset_type : str
+        The trailing offset type (interpreted as `TrailingOffsetType`).
+    trailing_offset : Decimal
+        The trailing offset amount.
+    trigger_type : str
+        The trailing stop trigger type (interpreted as `TriggerType`).
+    trade_size : str
+        The position size per trade (interpreted as Decimal).
+    fast_ema_period : PositiveInt, default 10
+        The fast EMA period.
+    slow_ema_period : PositiveInt, default 20
+        The slow EMA period.
+    emulation_trigger : str, default 'NO_TRIGGER'
+        The emulation trigger for submitting emulated orders.
+        If 'NONE' then orders will not be emulated.
+    order_id_tag : str
+        The unique order ID tag for the strategy. Must be unique
+        amongst all running strategies for a particular trader ID.
+    oms_type : OmsType
+        The order management system type for the strategy. This will determine
+        how the `ExecutionEngine` handles position IDs (see docs).
+
+    """
 
-# fmt: on
+    instrument_id: InstrumentId
+    bar_type: BarType
+    atr_period: PositiveInt
+    trailing_atr_multiple: PositiveFloat
+    trailing_offset_type: str
+    trailing_offset: Decimal
+    trigger_type: str
+    trade_size: Decimal
+    fast_ema_period: PositiveInt = 10
+    slow_ema_period: PositiveInt = 20
+    emulation_trigger: str = "NO_TRIGGER"
 
 
-class InteractiveBrokersDataClient(LiveMarketDataClient):
+class EMACrossStopEntry(Strategy):
     """
-    Provides a data client for the InteractiveBrokers exchange by using the `Gateway` to
-    stream market data.
+    A simple moving average cross example strategy with a `MARKET_IF_TOUCHED` entry and
+    `TRAILING_STOP_MARKET` stop.
+
+    When the fast EMA crosses the slow EMA then submits a `MARKET_IF_TOUCHED` order
+    one tick above the current bar for BUY, or one tick below the current bar
+    for SELL.
+
+    If the entry order is filled then a `TRAILING_STOP_MARKET` at a specified
+    ATR distance is submitted and managed.
+
+    Cancels all orders and closes all positions on stop.
+
+    Parameters
+    ----------
+    config : EMACrossStopEntryConfig
+        The configuration for the instance.
+
+    Raises
+    ------
+    ValueError
+        If `config.fast_ema_period` is not less than `config.slow_ema_period`.
+
     """
 
-    def __init__(
-        self,
-        loop: asyncio.AbstractEventLoop,
-        client: InteractiveBrokersClient,
-        msgbus: MessageBus,
-        cache: Cache,
-        clock: LiveClock,
-        instrument_provider: InteractiveBrokersInstrumentProvider,
-        ibg_client_id: int,
-        config: InteractiveBrokersDataClientConfig,
-    ) -> None:
+    def __init__(self, config: EMACrossStopEntryConfig) -> None:
+        PyCondition.true(
+            config.fast_ema_period < config.slow_ema_period,
+            "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
+        )
+        super().__init__(config)
+
+        # Configuration
+        self.instrument_id = config.instrument_id
+        self.bar_type = config.bar_type
+        self.trade_size = Decimal(config.trade_size)
+        self.trailing_atr_multiple = config.trailing_atr_multiple
+        self.trailing_offset_type = TrailingOffsetType[config.trailing_offset_type]
+        self.trailing_offset = config.trailing_offset
+        self.trigger_type = TriggerType[config.trigger_type]
+        self.emulation_trigger = TriggerType[config.emulation_trigger]
+
+        # Create the indicators for the strategy
+        self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
+        self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)
+        self.atr = AverageTrueRange(config.atr_period)
+
+        self.instrument: Instrument | None = None  # Initialized in `on_start()`
+        self.tick_size: Price | None = None  # Initialized in `on_start()`
+
+        # Users order management variables
+        self.entry = None
+        self.trailing_stop = None
+
+    def on_start(self) -> None:
+        """
+        Actions to be performed on strategy start.
+        """
+        self.instrument = self.cache.instrument(self.instrument_id)
+        if self.instrument is None:
+            self.log.error(f"Could not find instrument for {self.instrument_id}")
+            self.stop()
+            return
+
+        self.tick_size = self.instrument.price_increment
+
+        # Register the indicators for updating
+        self.register_indicator_for_bars(self.bar_type, self.fast_ema)
+        self.register_indicator_for_bars(self.bar_type, self.slow_ema)
+        self.register_indicator_for_bars(self.bar_type, self.atr)
+
+        # Get historical data
+        self.request_bars(self.bar_type)
+
+        # Subscribe to live data
+        self.subscribe_bars(self.bar_type)
+        self.subscribe_quote_ticks(self.instrument_id)
+        self.subscribe_trade_ticks(self.instrument_id)
+
+    def on_instrument(self, instrument: Instrument) -> None:
         """
-        Initialize a new instance of the ``InteractiveBrokersDataClient`` class.
+        Actions to be performed when the strategy is running and receives an instrument.
 
         Parameters
         ----------
-        loop : asyncio.AbstractEventLoop
-            The event loop for the client.
-        client : InteractiveBrokersClient
-            The nautilus InteractiveBrokersClient using ibapi.
-        msgbus : MessageBus
-            The message bus for the client.
-        cache : Cache
-            The cache for the client.
-        clock : LiveClock
-            The clock for the client.
-        instrument_provider : InteractiveBrokersInstrumentProvider
-            The instrument provider.
-        ibg_client_id : int
-            Client ID used to connect TWS/Gateway.
-        config : InteractiveBrokersDataClientConfig
-            Configuration for the client.
-
-        """
-        super().__init__(
-            loop=loop,
-            client_id=ClientId(f"{IB_VENUE.value}-{ibg_client_id:03d}"),
-            venue=None,
-            msgbus=msgbus,
-            cache=cache,
-            clock=clock,
-            instrument_provider=instrument_provider,
-            config=config,
-        )
-        self._client = client
-        self._handle_revised_bars = config.handle_revised_bars
-        self._use_regular_trading_hours = config.use_regular_trading_hours
-        self._market_data_type = config.market_data_type
-
-    @property
-    def instrument_provider(self) -> InteractiveBrokersInstrumentProvider:
-        return self._instrument_provider  # type: ignore
-
-    async def _connect(self):
-        # Connect client
-        await self._client.wait_until_ready()
-        self._client.registered_nautilus_clients.add(self.id)
-
-        # Set Market Data Type
-        await self._client.set_market_data_type(self._market_data_type)
-
-        # Load instruments based on config
-        await self.instrument_provider.initialize()
-        for instrument in self._instrument_provider.list_all():
-            self._handle_data(instrument)
-
-    async def _disconnect(self):
-        self._client.registered_nautilus_clients.remove(self.id)
-        if self._client.is_running and self._client.registered_nautilus_clients == set():
-            self._client.stop()
-
-    async def _subscribe(self, data_type: DataType) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_subscribe` coroutine",  # pragma: no cover
-        )
+        instrument : Instrument
+            The instrument received.
 
-    async def _subscribe_instruments(self) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_subscribe_instruments` coroutine",  # pragma: no cover
-        )
+        """
 
-    async def _subscribe_instrument(self, instrument_id: InstrumentId) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_subscribe_instrument` coroutine",  # pragma: no cover
-        )
+    def on_order_book(self, order_book: OrderBook) -> None:
+        """
+        Actions to be performed when the strategy is running and receives an order book.
 
-    async def _subscribe_order_book_deltas(
-        self,
-        instrument_id: InstrumentId,
-        book_type: BookType,
-        depth: int | None = None,
-        kwargs: dict[str, Any] | None = None,
-    ) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_subscribe_order_book_deltas` coroutine",  # pragma: no cover
-        )
+        Parameters
+        ----------
+        order_book : OrderBook
+            The order book received.
 
-    async def _subscribe_order_book_snapshots(
-        self,
-        instrument_id: InstrumentId,
-        book_type: BookType,
-        depth: int | None = None,
-        kwargs: dict[str, Any] | None = None,
-    ) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_subscribe_order_book_snapshots` coroutine",  # pragma: no cover
-        )
+        """
+        # self.log.info(f"Received {order_book}")  # For debugging (must add a subscription)
 
-    async def _subscribe_quote_ticks(self, instrument_id: InstrumentId) -> None:
-        if not (instrument := self._cache.instrument(instrument_id)):
-            self._log.error(
-                f"Cannot subscribe to QuoteTicks for {instrument_id}, Instrument not found.",
-            )
-            return
+    def on_quote_tick(self, tick: QuoteTick) -> None:
+        """
+        Actions to be performed when the strategy is running and receives a quote tick.
 
-        await self._client.subscribe_ticks(
-            instrument_id=instrument_id,
-            contract=IBContract(**instrument.info["contract"]),
-            tick_type="BidAsk",
-        )
+        Parameters
+        ----------
+        tick : QuoteTick
+            The tick received.
 
-    async def _subscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:
-        if not (instrument := self._cache.instrument(instrument_id)):
-            self._log.error(
-                f"Cannot subscribe to TradeTicks for {instrument_id}, Instrument not found.",
-            )
+        """
+
+    def on_trade_tick(self, tick: TradeTick) -> None:
+        """
+        Actions to be performed when the strategy is running and receives a trade tick.
+
+        Parameters
+        ----------
+        tick : TradeTick
+            The tick received.
+
+        """
+
+    def on_bar(self, bar: Bar) -> None:
+        """
+        Actions to be performed when the strategy is running and receives a bar.
+
+        Parameters
+        ----------
+        bar : Bar
+            The bar received.
+
+        """
+        self.log.info(f"Received {bar!r}")
+
+        # Check if indicators ready
+        if not self.indicators_initialized():
+            self.log.info(
+                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]",
+                color=LogColor.BLUE,
+            )
+            return  # Wait for indicators to warm up...
+
+        if self.portfolio.is_flat(self.instrument_id):
+            if self.entry is not None:
+                self.cancel_order(self.entry)
+
+            # BUY LOGIC
+            if self.fast_ema.value >= self.slow_ema.value:
+                self.entry_buy(bar)
+            # SELL LOGIC
+            else:  # fast_ema.value < self.slow_ema.value
+                self.entry_sell(bar)
+
+    def entry_buy(self, last_bar: Bar) -> None:
+        """
+        Users simple buy entry method (example).
+
+        Parameters
+        ----------
+        last_bar : Bar
+            The last bar received.
+
+        """
+        if not self.instrument:
+            self.log.error("No instrument loaded")
             return
 
-        if isinstance(instrument, CurrencyPair):
-            self._log.error(
-                "InteractiveBrokers doesn't support Trade Ticks for CurrencyPair.",
-            )
+        if not self.tick_size:
+            self.log.error("No tick size loaded")
             return
 
-        await self._client.subscribe_ticks(
-            instrument_id=instrument_id,
-            contract=IBContract(**instrument.info["contract"]),
-            tick_type="AllLast",
-        )
+        order: MarketIfTouchedOrder = self.order_factory.market_if_touched(
+            instrument_id=self.instrument_id,
+            order_side=OrderSide.BUY,
+            quantity=self.instrument.make_qty(self.trade_size),
+            time_in_force=TimeInForce.IOC,
+            trigger_price=self.instrument.make_price(last_bar.high + (self.tick_size * 2)),
+            emulation_trigger=self.emulation_trigger,
+        )
+        # TODO: Uncomment below order for development
+        # order: LimitIfTouchedOrder = self.order_factory.limit_if_touched(
+        #     instrument_id=self.instrument_id,
+        #     order_side=OrderSide.BUY,
+        #     quantity=self.instrument.make_qty(self.trade_size),
+        #     time_in_force=TimeInForce.IOC,
+        #     price=self.instrument.make_price(last_bar.low - (self.tick_size * 2)),
+        #     trigger_price=self.instrument.make_price(last_bar.high + (self.tick_size * 2)),
+        # )
+
+        self.entry = order
+        self.submit_order(order)
 
-    async def _subscribe_bars(self, bar_type: BarType) -> None:
-        if not (instrument := self._cache.instrument(bar_type.instrument_id)):
-            self._log.error(f"Cannot subscribe to {bar_type}, Instrument not found.")
+    def entry_sell(self, last_bar: Bar) -> None:
+        """
+        Users simple sell entry method (example).
+
+        Parameters
+        ----------
+        last_bar : Bar
+            The last bar received.
+
+        """
+        if not self.instrument:
+            self.log.error("No instrument loaded")
             return
 
-        if bar_type.spec.timedelta.total_seconds() == 5:
-            await self._client.subscribe_realtime_bars(
-                bar_type=bar_type,
-                contract=IBContract(**instrument.info["contract"]),
-                use_rth=self._use_regular_trading_hours,
-            )
-        else:
-            await self._client.subscribe_historical_bars(
-                bar_type=bar_type,
-                contract=IBContract(**instrument.info["contract"]),
-                use_rth=self._use_regular_trading_hours,
-                handle_revised_bars=self._handle_revised_bars,
-            )
+        if not self.tick_size:
+            self.log.error("No tick size loaded")
+            return
 
-    async def _subscribe_instrument_status(self, instrument_id: InstrumentId) -> None:
-        pass  # Subscribed as part of orderbook
+        order: MarketIfTouchedOrder = self.order_factory.market_if_touched(
+            instrument_id=self.instrument_id,
+            order_side=OrderSide.SELL,
+            quantity=self.instrument.make_qty(self.trade_size),
+            time_in_force=TimeInForce.IOC,
+            trigger_price=self.instrument.make_price(last_bar.low - (self.tick_size * 2)),
+            emulation_trigger=self.emulation_trigger,
+        )
+        # TODO: Uncomment below order for development
+        # order: LimitIfTouchedOrder = self.order_factory.limit_if_touched(
+        #     instrument_id=self.instrument_id,
+        #     order_side=OrderSide.SELL,
+        #     quantity=self.instrument.make_qty(self.trade_size),
+        #     time_in_force=TimeInForce.IOC,
+        #     price=self.instrument.make_price(last_bar.low - (self.tick_size * 2)),
+        #     trigger_price=self.instrument.make_price(last_bar.low - (self.tick_size * 2)),
+        # )
 
-    async def _subscribe_instrument_close(self, instrument_id: InstrumentId) -> None:
-        pass  # Subscribed as part of orderbook
+        self.entry = order
+        self.submit_order(order)
 
-    async def _unsubscribe(self, data_type: DataType) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_unsubscribe` coroutine",  # pragma: no cover
-        )
+    def trailing_stop_buy(self) -> None:
+        """
+        Users simple trailing stop BUY for (``SHORT`` positions).
+        """
+        if not self.instrument:
+            self.log.error("No instrument loaded")
+            return
 
-    async def _unsubscribe_instruments(self) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_unsubscribe_instruments` coroutine",  # pragma: no cover
+        offset = self.atr.value * self.trailing_atr_multiple
+        order: TrailingStopMarketOrder = self.order_factory.trailing_stop_market(
+            instrument_id=self.instrument_id,
+            order_side=OrderSide.BUY,
+            quantity=self.instrument.make_qty(self.trade_size),
+            trailing_offset=Decimal(f"{offset:.{self.instrument.price_precision}f}"),
+            trailing_offset_type=self.trailing_offset_type,
+            trigger_type=self.trigger_type,
+            reduce_only=True,
+            emulation_trigger=self.emulation_trigger,
         )
 
-    async def _unsubscribe_instrument(self, instrument_id: InstrumentId) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_unsubscribe_instrument` coroutine",  # pragma: no cover
-        )
+        self.trailing_stop = order
+        self.submit_order(order)
 
-    async def _unsubscribe_order_book_deltas(self, instrument_id: InstrumentId) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_unsubscribe_order_book_deltas` coroutine",  # pragma: no cover
-        )
+    def trailing_stop_sell(self) -> None:
+        """
+        Users simple trailing stop SELL for (LONG positions).
+        """
+        if not self.instrument:
+            self.log.error("No instrument loaded")
+            return
 
-    async def _unsubscribe_order_book_snapshots(self, instrument_id: InstrumentId) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_unsubscribe_order_book_snapshots` coroutine",  # pragma: no cover
+        offset = self.atr.value * self.trailing_atr_multiple
+        order: TrailingStopMarketOrder = self.order_factory.trailing_stop_market(
+            instrument_id=self.instrument_id,
+            order_side=OrderSide.SELL,
+            quantity=self.instrument.make_qty(self.trade_size),
+            trailing_offset=Decimal(f"{offset:.{self.instrument.price_precision}f}"),
+            trailing_offset_type=self.trailing_offset_type,
+            trigger_type=self.trigger_type,
+            reduce_only=True,
+            emulation_trigger=self.emulation_trigger,
         )
 
-    async def _unsubscribe_quote_ticks(self, instrument_id: InstrumentId) -> None:
-        await self._client.unsubscribe_ticks(instrument_id, "BidAsk")
+        self.trailing_stop = order
+        self.submit_order(order)
 
-    async def _unsubscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:
-        await self._client.unsubscribe_ticks(instrument_id, "AllLast")
+    def on_data(self, data: Data) -> None:
+        """
+        Actions to be performed when the strategy is running and receives data.
 
-    async def _unsubscribe_bars(self, bar_type: BarType) -> None:
-        if bar_type.spec.timedelta == 5:
-            await self._client.unsubscribe_realtime_bars(bar_type)
-        else:
-            await self._client.unsubscribe_historical_bars(bar_type)
-
-    async def _unsubscribe_instrument_status(self, instrument_id: InstrumentId) -> None:
-        pass  # Subscribed as part of orderbook
-
-    async def _unsubscribe_instrument_close(self, instrument_id: InstrumentId) -> None:
-        pass  # Subscribed as part of orderbook
-
-    async def _request(self, data_type: DataType, correlation_id: UUID4) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_request` coroutine",  # pragma: no cover
-        )
+        Parameters
+        ----------
+        data : Data
+            The data received.
 
-    async def _request_instrument(
-        self,
-        instrument_id: InstrumentId,
-        correlation_id: UUID4,
-        start: pd.Timestamp | None = None,
-        end: pd.Timestamp | None = None,
-    ) -> None:
-        if start is not None:
-            self._log.warning(
-                f"Requesting instrument {instrument_id} with specified `start` which has no effect.",
-            )
+        """
 
-        if end is not None:
-            self._log.warning(
-                f"Requesting instrument {instrument_id} with specified `end` which has no effect.",
-            )
+    def on_event(self, event: Event) -> None:
+        """
+        Actions to be performed when the strategy is running and receives an event.
 
-        await self.instrument_provider.load_async(instrument_id)
-        if instrument := self.instrument_provider.find(instrument_id):
-            self._handle_data(instrument)
-        else:
-            self._log.warning(f"{instrument_id} not available.")
-            return
-        self._handle_instrument(instrument, correlation_id)
+        Parameters
+        ----------
+        event : Event
+            The event received.
 
-    async def _request_instruments(
-        self,
-        venue: Venue,
-        correlation_id: UUID4,
-        start: pd.Timestamp | None = None,
-        end: pd.Timestamp | None = None,
-    ) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_request_instruments` coroutine",  # pragma: no cover
-        )
+        """
+        if isinstance(event, OrderFilled):
+            if self.entry and event.client_order_id == self.entry.client_order_id:
+                if event.order_side == OrderSide.BUY:
+                    self.trailing_stop_sell()
+                elif event.order_side == OrderSide.SELL:
+                    self.trailing_stop_buy()
+            if self.trailing_stop and event.client_order_id == self.trailing_stop.client_order_id:
+                self.trailing_stop = None
 
-    async def _request_quote_ticks(
-        self,
-        instrument_id: InstrumentId,
-        limit: int,
-        correlation_id: UUID4,
-        start: pd.Timestamp | None = None,
-        end: pd.Timestamp | None = None,
-    ) -> None:
-        if not (instrument := self._cache.instrument(instrument_id)):
-            self._log.error(
-                f"Cannot request QuoteTicks for {instrument_id}, Instrument not found.",
-            )
-            return
+    def on_stop(self) -> None:
+        """
+        Actions to be performed when the strategy is stopped.
+        """
+        self.cancel_all_orders(self.instrument_id)
+        self.close_all_positions(self.instrument_id)
 
-        ticks = await self._handle_ticks_request(
-            IBContract(**instrument.info["contract"]),
-            "BID_ASK",
-            limit,
-            start,
-            end,
-        )
-        if not ticks:
-            self._log.warning(f"QuoteTicks not received for {instrument_id}")
-            return
+        # Unsubscribe from data
+        self.unsubscribe_bars(self.bar_type)
+        self.unsubscribe_quote_ticks(self.instrument_id)
+        self.unsubscribe_trade_ticks(self.instrument_id)
 
-        self._handle_quote_ticks(instrument_id, ticks, correlation_id)
+    def on_reset(self) -> None:
+        """
+        Actions to be performed when the strategy is reset.
+        """
+        # Reset indicators here
+        self.fast_ema.reset()
+        self.slow_ema.reset()
+        self.atr.reset()
 
-    async def _request_trade_ticks(
-        self,
-        instrument_id: InstrumentId,
-        limit: int,
-        correlation_id: UUID4,
-        start: pd.Timestamp | None = None,
-        end: pd.Timestamp | None = None,
-    ) -> None:
-        if not (instrument := self._cache.instrument(instrument_id)):
-            self._log.error(
-                f"Cannot request TradeTicks for {instrument_id}, Instrument not found.",
-            )
-            return
+    def on_save(self) -> dict[str, bytes]:
+        """
+        Actions to be performed when the strategy is saved.
 
-        if isinstance(instrument, CurrencyPair):
-            self._log.error(
-                "InteractiveBrokers doesn't support Trade Ticks for CurrencyPair.",
-            )
-            return
+        Create and return a state dictionary of values to be saved.
 
-        ticks = await self._handle_ticks_request(
-            IBContract(**instrument.info["contract"]),
-            "TRADES",
-            limit,
-            start,
-            end,
-        )
-        if not ticks:
-            self._log.warning(f"TradeTicks not received for {instrument_id}")
-            return
+        Returns
+        -------
+        dict[str, bytes]
+            The strategy state dictionary.
 
-        self._handle_trade_ticks(instrument_id, ticks, correlation_id)
+        """
+        return {}
 
-    async def _handle_ticks_request(
-        self,
-        contract: IBContract,
-        tick_type: str,
-        limit: int,
-        start: pd.Timestamp | None = None,
-        end: pd.Timestamp | None = None,
-    ) -> list[QuoteTick | TradeTick]:
-        if not start:
-            limit = self._cache.tick_capacity
-
-        if not end:
-            end = pd.Timestamp.utcnow()
-
-        ticks: list[QuoteTick | TradeTick] = []
-        while (start and end > start) or (len(ticks) < limit > 0):
-            await self._client.wait_until_ready()
-            ticks_part = await self._client.get_historical_ticks(
-                contract,
-                tick_type,
-                end_date_time=end,
-                use_rth=self._use_regular_trading_hours,
-            )
-            if not ticks_part:
-                break
-            end = pd.Timestamp(min(ticks_part, key=attrgetter("ts_init")).ts_init, tz="UTC")
-            ticks.extend(ticks_part)
-
-        ticks.sort(key=lambda x: x.ts_init)
-        return ticks
-
-    async def _request_bars(
-        self,
-        bar_type: BarType,
-        limit: int,
-        correlation_id: UUID4,
-        start: pd.Timestamp | None = None,
-        end: pd.Timestamp | None = None,
-    ) -> None:
-        if not (instrument := self._cache.instrument(bar_type.instrument_id)):
-            self._log.error(
-                f"Cannot request {bar_type}, Instrument not found.",
-            )
-            return
+    def on_load(self, state: dict[str, bytes]) -> None:
+        """
+        Actions to be performed when the strategy is loaded.
 
-        if not bar_type.spec.is_time_aggregated():
-            self._log.error(
-                f"Cannot request {bar_type}: only time bars are aggregated by InteractiveBrokers.",
-            )
-            return
+        Saved state values will be contained in the give state dictionary.
 
-        if not start and limit == 0:
-            limit = 1000
+        Parameters
+        ----------
+        state : dict[str, bytes]
+            The strategy state dictionary.
 
-        if not end:
-            end = pd.Timestamp.utcnow()
+        """
 
-        if start:
-            duration = end - start
-            duration_str = timedelta_to_duration_str(duration)
-        else:
-            duration_str = "7 D" if bar_type.spec.timedelta.total_seconds() >= 60 else "1 D"
-
-        bars: list[Bar] = []
-        while (start and end > start) or (len(bars) < limit > 0):
-            bars_part: list[Bar] = await self._client.get_historical_bars(
-                bar_type=bar_type,
-                contract=IBContract(**instrument.info["contract"]),
-                use_rth=self._use_regular_trading_hours,
-                end_date_time=end.strftime("%Y%m%d %H:%M:%S %Z"),
-                duration=duration_str,
-            )
-            bars.extend(bars_part)
-            if not bars_part or start:
-                break
-            end = pd.Timestamp(min(bars, key=attrgetter("ts_event")).ts_event, tz="UTC")
-
-        if bars:
-            bars = list(set(bars))
-            bars.sort(key=lambda x: x.ts_init)
-            self._handle_bars(bar_type, bars, bars[0], correlation_id)
-            status_msg = {"id": correlation_id, "status": "Success"}
-        else:
-            self._log.warning(f"Bar Data not received for {bar_type}")
-            status_msg = {"id": correlation_id, "status": "Failed"}
-
-        # Publish Status event
-        self._msgbus.publish(
-            topic=f"requests.{correlation_id}",
-            msg=status_msg,
-        )
+    def on_dispose(self) -> None:
+        """
+        Actions to be performed when the strategy is disposed.
+
+        Cleanup any resources used by the strategy here.
+
+        """
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/execution.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/execution.py`

 * *Files 1% similar despite different names*

```diff
@@ -116,33 +116,36 @@
         The clock for the client.
     instrument_provider : InteractiveBrokersInstrumentProvider
         The instrument provider.
     ibg_client_id : int
         Client ID used to connect TWS/Gateway.
     config : InteractiveBrokersExecClientConfig, optional
         The configuration for the instance.
+    name : str, optional
+        The custom client ID.
 
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client: InteractiveBrokersClient,
         account_id: AccountId,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         instrument_provider: InteractiveBrokersInstrumentProvider,
         ibg_client_id: int,
         config: InteractiveBrokersExecClientConfig,
+        name: str | None = None,
     ) -> None:
         super().__init__(
             loop=loop,
             # client_id=ClientId(f"{IB_VENUE.value}-{ibg_client_id:03d}"), # TODO: Fix account_id.get_id()
-            client_id=ClientId(f"{IB_VENUE.value}"),
+            client_id=ClientId(name or f"{IB_VENUE.value}"),
             venue=IB_VENUE,
             oms_type=OmsType.NETTING,
             instrument_provider=instrument_provider,
             account_type=AccountType.MARGIN,
             base_currency=None,  # IB accounts are multi-currency
             msgbus=msgbus,
             cache=cache,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/factories.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/factories.py`

 * *Files 2% similar despite different names*

```diff
@@ -151,15 +151,15 @@
         Create a new InteractiveBrokers data client.
 
         Parameters
         ----------
         loop : asyncio.AbstractEventLoop
             The event loop for the client.
         name : str
-            The client name.
+            The custom client ID.
         config : dict
             The configuration dictionary.
         msgbus : MessageBus
             The message bus for the client.
         cache : Cache
             The cache for the client.
         clock : LiveClock
@@ -193,14 +193,15 @@
             client=client,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             instrument_provider=provider,
             ibg_client_id=config.ibg_client_id,
             config=config,
+            name=name,
         )
         return data_client
 
 
 class InteractiveBrokersLiveExecClientFactory(LiveExecClientFactory):
     """
     Provides a `InteractiveBrokers` live execution client factory.
@@ -219,15 +220,15 @@
         Create a new InteractiveBrokers execution client.
 
         Parameters
         ----------
         loop : asyncio.AbstractEventLoop
             The event loop for the client.
         name : str
-            The client name.
+            The custom client ID.
         config : dict[str, object]
             The configuration for the client.
         msgbus : MessageBus
             The message bus for the client.
         cache : Cache
             The cache for the client.
         clock : LiveClock
@@ -257,22 +258,23 @@
 
         # Set account ID
         ib_account = config.account_id or os.environ.get("TWS_ACCOUNT")
         assert (
             ib_account
         ), f"Must pass `{config.__class__.__name__}.account_id` or set `TWS_ACCOUNT` env var."
 
-        account_id = AccountId(f"{IB_VENUE.value}-{ib_account}")
+        account_id = AccountId(f"{name or IB_VENUE.value}-{ib_account}")
 
         # Create client
         exec_client = InteractiveBrokersExecutionClient(
             loop=loop,
             client=client,
             account_id=account_id,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             instrument_provider=provider,
             ibg_client_id=config.ibg_client_id,
             config=config,
+            name=name,
         )
         return exec_client
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/gateway.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/gateway.py`

 * *Files 1% similar despite different names*

```diff
@@ -177,15 +177,15 @@
         )
         self.log.info(f"Container `{self.CONTAINER_NAME}-{self.port}` starting, waiting for ready")
 
         if wait is not None:
             for _ in range(wait):
                 if self.is_logged_in(container=self._container):
                     break
-                self.log.debug("Waiting for IB Gateway to start ..")
+                self.log.debug("Waiting for IB Gateway to start")
                 sleep(1)
             else:
                 raise RuntimeError(f"Gateway `{self.CONTAINER_NAME}-{self.port}` not ready")
 
         self.log.info(
             f"Gateway `{self.CONTAINER_NAME}-{self.port}` ready. VNC port is {self.port + 100}",
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/historic/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/historic/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/historic/client.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/historic/client.py`

 * *Files 1% similar despite different names*

```diff
@@ -62,15 +62,15 @@
         market_data_type: MarketDataTypeEnum = MarketDataTypeEnum.REALTIME,
         log_level: str = "INFO",
     ) -> None:
         loop = asyncio.get_event_loop()
         loop.set_debug(True)
         clock = LiveClock()
 
-        init_logging(level_stdout=log_level_from_str(log_level))
+        self._log_guard = init_logging(level_stdout=log_level_from_str(log_level))
 
         self.log = Logger(name="HistoricInteractiveBrokersClient")
         msgbus = MessageBus(
             TraderId("historic_interactive_brokers_client-001"),
             clock,
         )
         cache = Cache()
@@ -80,18 +80,19 @@
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             host=host,
             port=port,
             client_id=client_id,
         )
+        self._client.start()
 
     async def _connect(self) -> None:
         # Connect client
-        self._client.start()
+        await self._client.wait_until_ready()
         self._client.registered_nautilus_clients.add(1)
 
         # Set Market Data Type
         await self._client.set_market_data_type(self.market_data_type)
 
     async def request_instruments(
         self,
@@ -264,15 +265,15 @@
                         f"with duration '{segment_duration}'",
                     )
 
                     bars = await self._client.get_historical_bars(
                         bar_type,
                         contract,
                         use_rth,
-                        segment_end_date_time.strftime("%Y%m%d-%H:%M:%S"),
+                        segment_end_date_time,
                         segment_duration,
                         timeout=timeout,
                     )
                     if bars:
                         self.log.info(
                             f"{instrument_id}: Number of bars retrieved in batch: {len(bars)}",
                         )
@@ -329,15 +330,15 @@
         if start_date_time >= end_date_time:
             raise ValueError("Start date must be before end date.")
         start_date_time = pd.Timestamp(start_date_time, tz=tz_name).tz_convert("UTC")
         end_date_time = pd.Timestamp(end_date_time, tz=tz_name).tz_convert("UTC")
         if (end_date_time - start_date_time) > pd.Timedelta(days=1):
             self.log.warning(
                 "Requesting tick data for more than 1 day may take a long time, particularly for liquid instruments. "
-                "You may want to consider sourcing tick data elsewhere.",
+                "You may want to consider sourcing tick data elsewhere",
             )
 
         contracts = contracts or []
         instrument_ids = instrument_ids or []
         if not contracts and not instrument_ids:
             raise ValueError("Either contracts or instrument_ids must be provided")
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/parsing/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/bybit/websocket/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/parsing/data.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/parsing/data.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/parsing/execution.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/parsing/execution.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/parsing/instruments.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/parsing/instruments.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/providers.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/providers.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/interactive_brokers/web.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/web.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/sandbox/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/interactive_brokers/parsing/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/sandbox/config.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/sandbox/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/sandbox/execution.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/sandbox/execution.py`

 * *Files 2% similar despite different names*

```diff
@@ -19,14 +19,15 @@
 
 import pandas as pd
 
 from nautilus_trader.backtest.exchange import SimulatedExchange
 from nautilus_trader.backtest.execution_client import BacktestExecClient
 from nautilus_trader.backtest.models import FillModel
 from nautilus_trader.backtest.models import LatencyModel
+from nautilus_trader.backtest.models import MakerTakerFeeModel
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.component import LiveClock
 from nautilus_trader.common.component import MessageBus
 from nautilus_trader.common.component import TestClock
 from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.core.data import Data
 from nautilus_trader.execution.reports import FillReport
@@ -115,14 +116,15 @@
             leverages={},
             instruments=self.INSTRUMENTS,
             modules=[],
             portfolio=portfolio,
             msgbus=self._msgbus,
             cache=cache,
             fill_model=FillModel(),
+            fee_model=MakerTakerFeeModel(),
             latency_model=LatencyModel(0),
             clock=self.test_clock,
             frozen_account=True,  # <-- Freezing account
         )
         self._client = BacktestExecClient(
             exchange=self.exchange,
             msgbus=msgbus,
@@ -135,23 +137,23 @@
         """
         Connect the client.
         """
         self._log.info("Connecting...")
         self._msgbus.subscribe("data.*", handler=self.on_data)
         self._client._set_connected(True)
         self._set_connected(True)
-        self._log.info("Connected.")
+        self._log.info("Connected")
 
     def disconnect(self) -> None:
         """
         Disconnect the client.
         """
         self._log.info("Disconnecting...")
         self._set_connected(False)
-        self._log.info("Disconnected.")
+        self._log.info("Disconnected")
 
     async def generate_order_status_report(
         self,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId | None = None,
         venue_order_id: VenueOrderId | None = None,
     ) -> OrderStatusReport | None:
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/sandbox/factory.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/sandbox/factory.py`

 * *Files 6% similar despite different names*

```diff
@@ -43,15 +43,15 @@
         Create a new Sandbox execution client.
 
         Parameters
         ----------
         loop : asyncio.AbstractEventLoop
             The event loop for the client.
         name : str
-            The client name.
+            The custom client ID.
         config : dict[str, object]
             The configuration for the client.
         portfolio : PortfolioFacade
             The read-only portfolio for the client.
         msgbus : MessageBus
             The message bus for the client.
         cache : Cache
@@ -66,12 +66,12 @@
         """
         exec_client = SandboxExecutionClient(
             loop=loop,
             clock=clock,
             portfolio=portfolio,
             msgbus=msgbus,
             cache=cache,
-            venue=config.venue,
+            venue=name or config.venue,
             balance=config.balance,
             currency=config.currency,
         )
         return exec_client
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/tardis/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pyx`

 * *Files 8% similar despite different names*

```diff
@@ -8,10 +8,12 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-"""
-Provides a data integration for Tardis https://tardis.dev/.
-"""
+
+from nautilus_trader.indicators.fuzzy_enums.candle_body cimport CandleBodySize
+
+
+__all__ = ["CandleBodySize"]
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/adapters/tardis/loaders.py` & `nautilus_trader-1.191.0/nautilus_trader/adapters/tardis/loaders.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/analyzer.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/analyzer.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/reporter.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/reporter.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistic.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistic.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/expectancy.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/expectancy.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/long_ratio.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/long_ratio.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/loser_avg.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/loser_avg.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/loser_max.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/loser_max.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/loser_min.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/loser_min.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/profit_factor.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/profit_factor.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/returns_avg.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/returns_avg.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/returns_avg_loss.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/returns_avg_loss.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/returns_avg_win.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/returns_avg_win.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/returns_volatility.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/returns_volatility.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/risk_return_ratio.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/risk_return_ratio.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/sharpe_ratio.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/sharpe_ratio.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/sortino_ratio.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/sortino_ratio.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/win_rate.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/win_rate.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/winner_avg.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/winner_avg.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/winner_max.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/winner_max.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/analysis/statistics/winner_min.py` & `nautilus_trader-1.191.0/nautilus_trader/analysis/statistics/winner_min.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/adapters/sandbox/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/persistence/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,9 +9,10 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 """
-The `backtest` subpackage groups components relating to backtesting.
+The `persistence` subpackage handles data storage and retrieval, mainly to support
+backtesting.
 """
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/__main__.py` & `nautilus_trader-1.191.0/nautilus_trader/backtest/__main__.py`

 * *Files 3% similar despite different names*

```diff
@@ -32,14 +32,15 @@
     if raw is None and fsspec_url is None:
         raise ValueError("Must pass one of `raw` or `fsspec_url`")
 
     if fsspec_url and raw is None:
         with fsspec.open(fsspec_url, "rb") as f:
             data = f.read().decode()
     else:
+        assert raw is not None  # Type checking
         data = raw.encode()
 
     configs = msgspec.json.decode(
         data,
         type=list[BacktestRunConfig],
         dec_hook=msgspec_decoding_hook,
     )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/auction.py` & `nautilus_trader-1.191.0/nautilus_trader/backtest/auction.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/config.py` & `nautilus_trader-1.191.0/nautilus_trader/backtest/config.py`

 * *Files 1% similar despite different names*

```diff
@@ -84,15 +84,15 @@
     bar_execution: bool = True
     reject_stop_orders: bool = True
     support_gtd_orders: bool = True
     support_contingent_orders: bool = True
     use_position_ids: bool = True
     use_random_ids: bool = False
     use_reduce_only: bool = True
-    # fill_model: FillModel | None = None  # TODO(cs): Implement
+    # fill_model: FillModel | None = None  # TODO: Implement
     modules: list[ImportableActorConfig] | None = None
 
 
 class BacktestDataConfig(NautilusConfig, frozen=True):
     """
     Represents the data configuration for one specific backtest run.
     """
@@ -273,8 +273,8 @@
     Parameters
     ----------
     rate_data : pd.DataFrame
         The interest rate data for the internal rollover interest calculator.
 
     """
 
-    rate_data: pd.DataFrame  # TODO(cs): This could probably just become JSON data
+    rate_data: pd.DataFrame  # TODO: This could probably just become JSON data
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/data_client.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/rma.pxd`

 * *Files 16% similar despite different names*

```diff
@@ -9,17 +9,13 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.data.client cimport DataClient
-from nautilus_trader.data.client cimport MarketDataClient
+from nautilus_trader.indicators.average.ema cimport MovingAverage
 
 
-cdef class BacktestDataClient(DataClient):
-    pass
-
-
-cdef class BacktestMarketDataClient(MarketDataClient):
-    pass
+cdef class WilderMovingAverage(MovingAverage):
+    cdef readonly double alpha
+    """The moving average alpha value.\n\n:returns: `double`"""
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/data_client.pyx` & `nautilus_trader-1.191.0/nautilus_trader/backtest/data_client.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -73,20 +73,20 @@
         )
 
         self.is_connected = False
 
     cpdef void _start(self):
         self._log.info(f"Connecting...")
         self.is_connected = True
-        self._log.info(f"Connected.")
+        self._log.info(f"Connected")
 
     cpdef void _stop(self):
         self._log.info(f"Disconnecting...")
         self.is_connected = False
-        self._log.info(f"Disconnected.")
+        self._log.info(f"Disconnected")
 
 # -- SUBSCRIPTIONS --------------------------------------------------------------------------------
 
     cpdef void subscribe(self, DataType data_type):
         Condition.not_none(data_type, "data_type")
 
         self._add_subscription(data_type)
@@ -137,35 +137,35 @@
         )
 
         self.is_connected = False
 
     cpdef void _start(self):
         self._log.info(f"Connecting...")
         self.is_connected = True
-        self._log.info(f"Connected.")
+        self._log.info(f"Connected")
 
     cpdef void _stop(self):
         self._log.info(f"Disconnecting...")
         self.is_connected = False
-        self._log.info(f"Disconnected.")
+        self._log.info(f"Disconnected")
 
 # -- SUBSCRIPTIONS --------------------------------------------------------------------------------
 
     cpdef void subscribe_instruments(self):
         cdef Instrument instrument
         for instrument in self._cache.instruments(Venue(self.id.value)):
             self.subscribe_instrument(instrument.id)
         # Do nothing else for backtest
 
     cpdef void subscribe_instrument(self, InstrumentId instrument_id):
         Condition.not_none(instrument_id, "instrument_id")
 
         if not self._cache.instrument(instrument_id):
             self._log.error(
-                f"Cannot find instrument {instrument_id} to subscribe for `Instrument` data.",
+                f"Cannot find instrument {instrument_id} to subscribe for `Instrument` data",
             )
             return
 
         self._add_subscription_instrument(instrument_id)
         # Do nothing else for backtest
 
     cpdef void subscribe_order_book_deltas(
@@ -175,16 +175,16 @@
         int depth = 0,
         dict kwargs = None,
     ):
         Condition.not_none(instrument_id, "instrument_id")
 
         if not self._cache.instrument(instrument_id):
             self._log.error(
-                f"Cannot find instrument {instrument_id} to subscribe for `OrderBookDelta` data. "
-                "No data has been loaded for this instrument.",
+                f"Cannot find instrument {instrument_id} to subscribe for `OrderBookDelta` data, "
+                "no data has been loaded for this instrument",
             )
             return
 
         self._add_subscription_order_book_deltas(instrument_id)
         # Do nothing else for backtest
 
     cpdef void subscribe_order_book_snapshots(
@@ -194,55 +194,55 @@
         int depth = 0,
         dict kwargs = None,
     ):
         Condition.not_none(instrument_id, "instrument_id")
 
         if not self._cache.instrument(instrument_id):
             self._log.error(
-                f"Cannot find instrument {instrument_id} to subscribe for `OrderBook` data. "
-                "No data has been loaded for this instrument.",
+                f"Cannot find instrument {instrument_id} to subscribe for `OrderBook` data, "
+                "no data has been loaded for this instrument.",
             )
             return
 
         self._add_subscription_order_book_snapshots(instrument_id)
         # Do nothing else for backtest
 
     cpdef void subscribe_quote_ticks(self, InstrumentId instrument_id):
         Condition.not_none(instrument_id, "instrument_id")
 
         if not self._cache.instrument(instrument_id):
             self._log.error(
-                f"Cannot find instrument {instrument_id} to subscribe for `QuoteTick` data. "
-                "No data has been loaded for this instrument.",
+                f"Cannot find instrument {instrument_id} to subscribe for `QuoteTick` data, "
+                "No data has been loaded for this instrument",
             )
             return
 
         self._add_subscription_quote_ticks(instrument_id)
         # Do nothing else for backtest
 
     cpdef void subscribe_trade_ticks(self, InstrumentId instrument_id):
         Condition.not_none(instrument_id, "instrument_id")
 
         if not self._cache.instrument(instrument_id):
             self._log.error(
-                f"Cannot find instrument {instrument_id} to subscribe for `TradeTick` data. "
-                "No data has been loaded for this instrument.",
+                f"Cannot find instrument {instrument_id} to subscribe for `TradeTick` data, "
+                "No data has been loaded for this instrument",
             )
             return
 
         self._add_subscription_trade_ticks(instrument_id)
         # Do nothing else for backtest
 
     cpdef void subscribe_bars(self, BarType bar_type):
         Condition.not_none(bar_type, "bar_type")
 
         if not self._cache.instrument(bar_type.instrument_id):
             self._log.error(
-                f"Cannot find instrument {bar_type.instrument_id} to subscribe for `Bar` data. "
-                "No data has been loaded for this instrument.",
+                f"Cannot find instrument {bar_type.instrument_id} to subscribe for `Bar` data, "
+                "No data has been loaded for this instrument",
             )
             return
 
         self._add_subscription_bars(bar_type)
         # Do nothing else for backtest
 
     cpdef void subscribe_venue_status(self, Venue venue):
@@ -330,15 +330,15 @@
         datetime end: datetime | None = None,
     ):
         Condition.not_none(instrument_id, "instrument_id")
         Condition.not_none(correlation_id, "correlation_id")
 
         cdef Instrument instrument = self._cache.instrument(instrument_id)
         if instrument is None:
-            self._log.error(f"Cannot find instrument for {instrument_id}.")
+            self._log.error(f"Cannot find instrument for {instrument_id}")
             return
 
         data_type = DataType(
             type=Instrument,
             metadata={"instrument_id": instrument_id},
         )
 
@@ -354,15 +354,15 @@
         datetime start: datetime | None = None,
         datetime end: datetime | None = None,
     ):
         Condition.not_none(correlation_id, "correlation_id")
 
         cdef list instruments = self._cache.instruments(venue)
         if not instruments:
-            self._log.error(f"Cannot find instruments.")
+            self._log.error(f"Cannot find instruments")
             return
 
         self._handle_instruments(
             venue=venue,
             instruments=instruments,
             correlation_id=correlation_id,
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/engine.pxd` & `nautilus_trader-1.191.0/nautilus_trader/backtest/engine.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/engine.pyx` & `nautilus_trader-1.191.0/nautilus_trader/backtest/engine.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -37,16 +37,18 @@
 from cpython.object cimport PyObject
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.backtest.data_client cimport BacktestDataClient
 from nautilus_trader.backtest.data_client cimport BacktestMarketDataClient
 from nautilus_trader.backtest.exchange cimport SimulatedExchange
 from nautilus_trader.backtest.execution_client cimport BacktestExecClient
+from nautilus_trader.backtest.models cimport FeeModel
 from nautilus_trader.backtest.models cimport FillModel
 from nautilus_trader.backtest.models cimport LatencyModel
+from nautilus_trader.backtest.models cimport MakerTakerFeeModel
 from nautilus_trader.backtest.modules cimport SimulationModule
 from nautilus_trader.cache.base cimport CacheFacade
 from nautilus_trader.common.actor cimport Actor
 from nautilus_trader.common.component cimport LiveClock
 from nautilus_trader.common.component cimport Logger
 from nautilus_trader.common.component cimport TestClock
 from nautilus_trader.common.component cimport TimeEvent
@@ -362,14 +364,15 @@
         account_type: AccountType,
         starting_balances: list[Money],
         base_currency: Currency | None = None,
         default_leverage: Decimal | None = None,
         leverages: dict[InstrumentId, Decimal] | None = None,
         modules: list[SimulationModule] | None = None,
         fill_model: FillModel | None = None,
+        fee_model: FeeModel | None = None,
         latency_model: LatencyModel | None = None,
         book_type: BookType = BookType.L1_MBP,
         routing: bool = False,
         frozen_account: bool = False,
         bar_execution: bool = True,
         reject_stop_orders: bool = True,
         support_gtd_orders: bool = True,
@@ -398,14 +401,16 @@
             The account default leverage (for margin accounts).
         leverages : dict[InstrumentId, Decimal], optional
             The instrument specific leverage configuration (for margin accounts).
         modules : list[SimulationModule], optional
             The simulation modules to load into the exchange.
         fill_model : FillModel, optional
             The fill model for the exchange.
+        fee_model : FeeModel, optional
+            The fee model for the venue.
         latency_model : LatencyModel, optional
             The latency model for the exchange.
         book_type : BookType, default ``BookType.L1_MBP``
             The default order book type for fill modelling.
         routing : bool, default False
             If multi-venue routing should be enabled for the execution client.
         frozen_account : bool, default False
@@ -432,19 +437,22 @@
             If `venue` is already registered with the engine.
 
         """
         if modules is None:
             modules = []
         if fill_model is None:
             fill_model = FillModel()
+        if fee_model is None:
+            fee_model = MakerTakerFeeModel()
         Condition.not_none(venue, "venue")
         Condition.not_in(venue, self._venues, "venue", "_venues")
         Condition.not_empty(starting_balances, "starting_balances")
         Condition.list_type(modules, SimulationModule, "modules")
-        Condition.type_or_none(fill_model, FillModel, "fill_model")
+        Condition.type(fill_model, FillModel, "fill_model")
+        Condition.type(fee_model, FeeModel, "fee_model")
 
         if default_leverage is None:
             if account_type == AccountType.MARGIN:
                 default_leverage = Decimal(10)
             else:
                 default_leverage = Decimal(1)
 
@@ -459,14 +467,15 @@
             leverages=leverages or {},
             instruments=[],
             modules=modules,
             portfolio=self.kernel.portfolio,
             msgbus=self.kernel.msgbus,
             cache=self.kernel.cache,
             fill_model=fill_model,
+            fee_model=fee_model,
             latency_model=latency_model,
             book_type=book_type,
             clock=self.kernel.clock,
             frozen_account=frozen_account,
             bar_execution=bar_execution,
             reject_stop_orders=reject_stop_orders,
             support_gtd_orders=support_gtd_orders,
@@ -487,15 +496,15 @@
             routing=routing,
             frozen_account=frozen_account,
         )
 
         exchange.register_client(exec_client)
         self.kernel.exec_engine.register_client(exec_client)
 
-        self._log.info(f"Added {exchange}.")
+        self._log.info(f"Added {exchange}")
 
     def change_fill_model(self, Venue venue, FillModel model) -> None:
         """
         Change the fill model for the exchange of the given venue.
 
         Parameters
         ----------
@@ -556,15 +565,15 @@
         # Check client has been registered
         self._add_market_data_client_if_not_exists(instrument.id.venue)
 
         # Add data
         self.kernel.data_engine.process(instrument)  # Adds to cache
         self._venues[instrument.id.venue].add_instrument(instrument)
 
-        self._log.info(f"Added {instrument.id} Instrument.")
+        self._log.info(f"Added {instrument.id} Instrument")
 
     def add_data(
         self,
         list data,
         ClientId client_id = None,
         bint validate = True,
         bint sort = True,
@@ -653,15 +662,15 @@
         # Add data
         self._data.extend(data)
 
         if sort:
             self._data = sorted(self._data, key=lambda x: x.ts_init)
 
         self._log.info(
-            f"Added {len(data):,} {data_added_str} element{'' if len(data) == 1 else 's'}.",
+            f"Added {len(data):,} {data_added_str} element{'' if len(data) == 1 else 's'}",
         )
 
     def dump_pickled_data(self) -> bytes:
         """
         Return the internal data stream pickled.
 
         Returns
@@ -689,15 +698,15 @@
         """
         Condition.not_none(data, "data")
 
         self._data = pickle.loads(data)
 
         self._log.info(
             f"Loaded {len(self._data):,} data "
-            f"element{'' if len(data) == 1 else 's'} from pickle.",
+            f"element{'' if len(data) == 1 else 's'} from pickle",
         )
 
     def add_actor(self, actor: Actor) -> None:
         """
         Add the given actor to the backtest engine.
 
         Parameters
@@ -780,15 +789,15 @@
 
         All stateful fields are reset to their initial value.
 
         Note: instruments and data are not dropped/reset, this can be done through a
         separate call to `.clear_data()` if desired.
 
         """
-        self._log.debug(f"Resetting...")
+        self._log.debug(f"Resetting")
 
         if self.kernel.trader.is_running:
             # End current backtest run
             self.end()
 
         # Reset DataEngine
         if self.kernel.data_engine.is_running:
@@ -823,15 +832,15 @@
         self._iteration = 0
         self._index = 0
         self._run_started = None
         self._run_finished = None
         self._backtest_start = None
         self._backtest_end = None
 
-        self._log.info("Reset.")
+        self._log.info("Reset")
 
     def clear_data(self) -> None:
         """
         Clear the engines internal data stream.
 
         Does not clear added instruments.
 
@@ -1033,15 +1042,15 @@
                 for order in open_orders:
                     if order.is_emulated:
                         # Order should be loaded in the emulator already
                         continue
                     matching_engine = exchange.get_matching_engine(order.instrument_id)
                     if matching_engine is None:
                         self._log.error(
-                            f"No matching engine for {order.instrument_id} to process {order}.",
+                            f"No matching engine for {order.instrument_id} to process {order}",
                         )
                         continue
                     matching_engine.process_order(order, order.account_id)
                 ###################################################################################
 
             # Common kernel start-up sequence
             self._kernel.start()
@@ -1123,15 +1132,15 @@
                     # Drop processed event handlers
                     vec_time_event_handlers_drop(raw_handlers)
                     raw_handlers_count = 0
 
                 self._iteration += 1
         except AccountError as e:
             force_stop = True
-            self._log.error(f"Stopping backtest from {e}.")
+            self._log.error(f"Stopping backtest from {e}")
         # ---------------------------------------------------------------------#
 
         if force_stop:
             return
 
         # Process remaining messages
         for exchange in self._venues.values():
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/exchange.pxd` & `nautilus_trader-1.191.0/nautilus_trader/backtest/exchange.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -14,14 +14,15 @@
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.accounting.accounts.base cimport Account
 from nautilus_trader.backtest.execution_client cimport BacktestExecClient
 from nautilus_trader.backtest.matching_engine cimport OrderMatchingEngine
+from nautilus_trader.backtest.models cimport FeeModel
 from nautilus_trader.backtest.models cimport FillModel
 from nautilus_trader.backtest.models cimport LatencyModel
 from nautilus_trader.cache.cache cimport Cache
 from nautilus_trader.common.component cimport Clock
 from nautilus_trader.common.component cimport Logger
 from nautilus_trader.common.component cimport MessageBus
 from nautilus_trader.core.data cimport Data
@@ -74,14 +75,16 @@
     """The accounts instrument specific leverage configuration.\n\n:returns: `dict[InstrumentId, Decimal]`"""
     cdef readonly bint is_frozen_account
     """If the account for the exchange is frozen.\n\n:returns: `bool`"""
     cdef readonly LatencyModel latency_model
     """The latency model for the exchange.\n\n:returns: `LatencyModel`"""
     cdef readonly FillModel fill_model
     """The fill model for the exchange.\n\n:returns: `FillModel`"""
+    cdef readonly FeeModel fee_model
+    """The fee model for the exchange.\n\n:returns: `FeeModel`"""
     cdef readonly bint bar_execution
     """If bars should be processed by the matching engine(s) (and move the market).\n\n:returns: `bool`"""
     cdef readonly bint reject_stop_orders
     """If stop orders are rejected on submission if in the market.\n\n:returns: `bool`"""
     cdef readonly bint support_gtd_orders
     """If orders with GTD time in force will be supported by the venue.\n\n:returns: `bool`"""
     cdef readonly bint support_contingent_orders
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/exchange.pyx` & `nautilus_trader-1.191.0/nautilus_trader/backtest/exchange.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -20,16 +20,18 @@
 from nautilus_trader.common.config import InvalidConfiguration
 
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.accounting.accounts.base cimport Account
 from nautilus_trader.backtest.execution_client cimport BacktestExecClient
 from nautilus_trader.backtest.matching_engine cimport OrderMatchingEngine
+from nautilus_trader.backtest.models cimport FeeModel
 from nautilus_trader.backtest.models cimport FillModel
 from nautilus_trader.backtest.models cimport LatencyModel
+from nautilus_trader.backtest.models cimport MakerTakerFeeModel
 from nautilus_trader.backtest.modules cimport SimulationModule
 from nautilus_trader.cache.base cimport CacheFacade
 from nautilus_trader.common.component cimport Logger
 from nautilus_trader.common.component cimport TestClock
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.rust.model cimport AccountType
 from nautilus_trader.core.rust.model cimport BookType
@@ -58,15 +60,15 @@
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.orders.base cimport Order
 from nautilus_trader.portfolio.base cimport PortfolioFacade
 
 
 cdef class SimulatedExchange:
     """
-    Provides a simulated financial market exchange.
+    Provides a simulated exchange venue.
 
     Parameters
     ----------
     venue : Venue
         The venue to simulate.
     oms_type : OmsType {``HEDGING``, ``NETTING``}
         The order management system type used by the exchange.
@@ -84,14 +86,16 @@
         The read-only portfolio for the exchange.
     msgbus : MessageBus
         The message bus for the exchange.
     cache : CacheFacade
         The read-only cache for the exchange.
     fill_model : FillModel
         The fill model for the exchange.
+    fee_model : FeeModel
+        The fee model for the exchange.
     latency_model : LatencyModel, optional
         The latency model for the exchange.
     clock : TestClock
         The clock for the exchange.
     book_type : BookType
         The order book type for the exchange.
     frozen_account : bool, default False
@@ -140,14 +144,15 @@
         list instruments not None,
         list modules not None,
         PortfolioFacade portfolio not None,
         MessageBus msgbus not None,
         CacheFacade cache not None,
         TestClock clock not None,
         FillModel fill_model not None,
+        FeeModel fee_model not None,
         LatencyModel latency_model = None,
         BookType book_type = BookType.L1_MBP,
         bint frozen_account = False,
         bint bar_execution = True,
         bint reject_stop_orders = True,
         bint support_gtd_orders = True,
         bint support_contingent_orders = True,
@@ -189,29 +194,30 @@
         self.reject_stop_orders = reject_stop_orders
         self.support_gtd_orders = support_gtd_orders
         self.support_contingent_orders = support_contingent_orders
         self.use_position_ids = use_position_ids
         self.use_random_ids = use_random_ids
         self.use_reduce_only = use_reduce_only
         self.fill_model = fill_model
+        self.fee_model = fee_model
         self.latency_model = latency_model
 
         # Load modules
         self.modules = []
         for module in modules:
             Condition.not_in(module, self.modules, "module", "modules")
             module.register_venue(self)
             module.register_base(
                 portfolio=portfolio,
                 msgbus=msgbus,
                 cache=cache,
                 clock=clock,
             )
             self.modules.append(module)
-            self._log.info(f"Loaded {module}.")
+            self._log.info(f"Loaded {module}")
 
         # Markets
         self._matching_engines: dict[InstrumentId, OrderMatchingEngine] = {}
 
         # Load instruments
         self.instruments: dict[InstrumentId, Instrument] = {}
         for instrument in instruments:
@@ -241,15 +247,15 @@
             The client to register
 
         """
         Condition.not_none(client, "client")
 
         self.exec_client = client
 
-        self._log.info(f"Registered ExecutionClient-{client}.")
+        self._log.info(f"Registered ExecutionClient-{client}")
 
     cpdef void set_fill_model(self, FillModel fill_model):
         """
         Set the fill model for all matching engines.
 
         Parameters
         ----------
@@ -262,15 +268,15 @@
         self.fill_model = fill_model
 
         cdef OrderMatchingEngine matching_engine
         for matching_engine in self._matching_engines.values():
             matching_engine.set_fill_model(fill_model)
             self._log.info(
                 f"Changed `FillModel` for {matching_engine.venue} "
-                f"to {self.fill_model}.",
+                f"to {self.fill_model}",
             )
 
     cpdef void set_latency_model(self, LatencyModel latency_model):
         """
         Change the latency model for this exchange.
 
         Parameters
@@ -279,15 +285,15 @@
             The latency model to set.
 
         """
         Condition.not_none(latency_model, "latency_model")
 
         self.latency_model = latency_model
 
-        self._log.info("Changed latency model.")
+        self._log.info("Changed latency model")
 
     cpdef void initialize_account(self):
         """
         Initialize the account to the starting balances.
         """
         self._generate_fresh_account_state()
 
@@ -324,14 +330,15 @@
 
         self.instruments[instrument.id] = instrument
 
         cdef OrderMatchingEngine matching_engine = OrderMatchingEngine(
             instrument=instrument,
             raw_id=len(self.instruments),
             fill_model=self.fill_model,
+            fee_model=self.fee_model,
             book_type=self.book_type,
             oms_type=self.oms_type,
             account_type=self.account_type,
             msgbus=self.msgbus,
             cache=self.cache,
             clock=self._clock,
             bar_execution=self.bar_execution,
@@ -341,15 +348,15 @@
             use_position_ids=self.use_position_ids,
             use_random_ids=self.use_random_ids,
             use_reduce_only=self.use_reduce_only,
         )
 
         self._matching_engines[instrument.id] = matching_engine
 
-        self._log.info(f"Added instrument {instrument.id} and created matching engine.")
+        self._log.info(f"Added instrument {instrument.id} and created matching engine")
 
 # -- QUERIES --------------------------------------------------------------------------------------
 
     cpdef Price best_bid_price(self, InstrumentId instrument_id):
         """
         Return the best bid price for the given instrument ID (if found).
 
@@ -846,29 +853,29 @@
 
     cpdef void reset(self):
         """
         Reset the simulated exchange.
 
         All stateful fields are reset to their initial value.
         """
-        self._log.debug(f"Resetting...")
+        self._log.debug(f"Resetting")
 
         for module in self.modules:
             module.reset()
 
         self._generate_fresh_account_state()
 
         for matching_engine in self._matching_engines.values():
             matching_engine.reset()
 
         self._message_queue = deque()
         self._inflight_queue.clear()
         self._inflight_counter.clear()
 
-        self._log.info("Reset.")
+        self._log.info("Reset")
 
 # -- EVENT GENERATORS -----------------------------------------------------------------------------
 
     cdef void _generate_fresh_account_state(self):
         cdef list balances = [
             AccountBalance(
                 total=money,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/execution_client.pxd` & `nautilus_trader-1.191.0/nautilus_trader/backtest/execution_client.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/execution_client.pyx` & `nautilus_trader-1.191.0/nautilus_trader/backtest/execution_client.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -80,20 +80,20 @@
 
         self._exchange = exchange
         self.is_connected = False
 
     cpdef void _start(self):
         self._log.info(f"Connecting...")
         self.is_connected = True
-        self._log.info(f"Connected.")
+        self._log.info(f"Connected")
 
     cpdef void _stop(self):
         self._log.info(f"Disconnecting...")
         self.is_connected = False
-        self._log.info(f"Disconnected.")
+        self._log.info(f"Disconnected")
 
 # -- COMMAND HANDLERS -----------------------------------------------------------------------------
 
     cpdef void submit_order(self, SubmitOrder command):
         Condition.true(self.is_connected, "not connected")
 
         self.generate_order_submitted(
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/matching_engine.pxd` & `nautilus_trader-1.191.0/nautilus_trader/backtest/matching_engine.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -13,14 +13,15 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport int64_t
 from libc.stdint cimport uint32_t
 from libc.stdint cimport uint64_t
 
+from nautilus_trader.backtest.models cimport FeeModel
 from nautilus_trader.backtest.models cimport FillModel
 from nautilus_trader.cache.base cimport CacheFacade
 from nautilus_trader.common.component cimport Clock
 from nautilus_trader.common.component cimport Logger
 from nautilus_trader.common.component cimport MessageBus
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.core.rust.model cimport AccountType
@@ -72,23 +73,26 @@
     cdef Clock _clock
     cdef Logger _log
     cdef MessageBus _msgbus
     cdef OrderBook _book
     cdef OrderBook _opening_auction_book
     cdef OrderBook _closing_auction_book
     cdef FillModel _fill_model
+    cdef FeeModel _fee_model
     # cdef object _auction_match_algo
     cdef bint _bar_execution
     cdef bint _reject_stop_orders
     cdef bint _support_gtd_orders
     cdef bint _support_contingent_orders
     cdef bint _use_position_ids
     cdef bint _use_random_ids
     cdef bint _use_reduce_only
     cdef dict _account_ids
+    cdef dict _execution_bar_types
+    cdef dict _execution_bar_deltas
 
     cdef readonly Venue venue
     """The venue for the matching engine.\n\n:returns: `Venue`"""
     cdef readonly Instrument instrument
     """The instrument for the matching engine.\n\n:returns: `Instrument`"""
     cdef readonly uint32_t raw_id
     """The instruments raw integer ID for the exchange.\n\n:returns: `int`"""
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/matching_engine.pyx` & `nautilus_trader-1.191.0/nautilus_trader/backtest/matching_engine.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -14,25 +14,27 @@
 # -------------------------------------------------------------------------------------------------
 
 import uuid
 
 
 # from nautilus_trader.backtest.auction import default_auction_match
 
+from cpython.datetime cimport timedelta
 from libc.stdint cimport uint64_t
 
+from nautilus_trader.backtest.models cimport FeeModel
 from nautilus_trader.backtest.models cimport FillModel
 from nautilus_trader.cache.base cimport CacheFacade
 from nautilus_trader.common.component cimport LogColor
 from nautilus_trader.common.component cimport Logger
 from nautilus_trader.common.component cimport MessageBus
 from nautilus_trader.common.component cimport TestClock
+from nautilus_trader.common.component cimport is_logging_initialized
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.data cimport Data
-from nautilus_trader.core.rust.common cimport logging_is_initialized
 from nautilus_trader.core.rust.model cimport AccountType
 from nautilus_trader.core.rust.model cimport AggressorSide
 from nautilus_trader.core.rust.model cimport BookType
 from nautilus_trader.core.rust.model cimport ContingencyType
 from nautilus_trader.core.rust.model cimport LiquiditySide
 from nautilus_trader.core.rust.model cimport OmsType
 from nautilus_trader.core.rust.model cimport OrderSide
@@ -52,14 +54,15 @@
 from nautilus_trader.execution.matching_core cimport MatchingCore
 from nautilus_trader.execution.messages cimport BatchCancelOrders
 from nautilus_trader.execution.messages cimport CancelAllOrders
 from nautilus_trader.execution.messages cimport CancelOrder
 from nautilus_trader.execution.messages cimport ModifyOrder
 from nautilus_trader.execution.trailing cimport TrailingStopCalculator
 from nautilus_trader.model.book cimport OrderBook
+from nautilus_trader.model.data cimport BarType
 from nautilus_trader.model.data cimport BookOrder
 from nautilus_trader.model.data cimport QuoteTick
 from nautilus_trader.model.data cimport TradeTick
 from nautilus_trader.model.events.order cimport OrderAccepted
 from nautilus_trader.model.events.order cimport OrderCanceled
 from nautilus_trader.model.events.order cimport OrderCancelRejected
 from nautilus_trader.model.events.order cimport OrderExpired
@@ -104,14 +107,16 @@
     ----------
     instrument : Instrument
         The market instrument for the matching engine.
     raw_id : uint32_t
         The raw integer ID for the instrument.
     fill_model : FillModel
         The fill model for the matching engine.
+    fee_model : FeeModel
+        The fee model for the matching engine.
     book_type : BookType
         The order book type for the engine.
     oms_type : OmsType
         The order management system type for the matching engine. Determines
         the generation and handling of venue position IDs.
     account_type : AccountType
         The account type for the matching engine. Determines allowable
@@ -144,14 +149,15 @@
     """
 
     def __init__(
         self,
         Instrument instrument not None,
         uint32_t raw_id,
         FillModel fill_model not None,
+        FeeModel fee_model not None,
         BookType book_type,
         OmsType oms_type,
         AccountType account_type,
         MessageBus msgbus not None,
         CacheFacade cache not None,
         TestClock clock not None,
         bint bar_execution = True,
@@ -181,28 +187,31 @@
         self._support_gtd_orders = support_gtd_orders
         self._support_contingent_orders = support_contingent_orders
         self._use_position_ids = use_position_ids
         self._use_random_ids = use_random_ids
         self._use_reduce_only = use_reduce_only
         # self._auction_match_algo = auction_match_algo
         self._fill_model = fill_model
+        self._fee_model = fee_model
         self._book = OrderBook(
             instrument_id=instrument.id,
             book_type=book_type,
         )
         self._opening_auction_book = OrderBook(
             instrument_id=instrument.id,
             book_type=BookType.L3_MBO,
         )
         self._closing_auction_book = OrderBook(
             instrument_id=instrument.id,
             book_type=BookType.L3_MBO,
         )
 
         self._account_ids: dict[TraderId, AccountId]  = {}
+        self._execution_bar_types: dict[InstrumentId, BarType]  =  {}
+        self._execution_bar_deltas: dict[BarType, timedelta]  =  {}
 
         # Market
         self._core = MatchingCore(
             instrument_id=instrument.id,
             price_increment=instrument.price_increment,
             trigger_stop_order=self.trigger_stop_order,
             fill_market_order=self.fill_market_order,
@@ -225,31 +234,33 @@
             f"{type(self).__name__}("
             f"venue={self.venue.value}, "
             f"instrument_id={self.instrument.id.value}, "
             f"raw_id={self.raw_id})"
         )
 
     cpdef void reset(self):
-        self._log.debug(f"Resetting OrderMatchingEngine {self.instrument.id}...")
+        self._log.debug(f"Resetting OrderMatchingEngine {self.instrument.id}")
 
         self._book.clear(0, 0)
         self._account_ids.clear()
+        self._execution_bar_types.clear()
+        self._execution_bar_deltas.clear()
         self._core.reset()
         self._target_bid = 0
         self._target_ask = 0
         self._target_last = 0
         self._has_targets = False
         self._last_bid_bar = None
         self._last_ask_bar = None
 
         self._position_count = 0
         self._order_count = 0
         self._execution_count = 0
 
-        self._log.info(f"Reset OrderMatchingEngine {self.instrument.id}.")
+        self._log.info(f"Reset OrderMatchingEngine {self.instrument.id}")
 
     cpdef void set_fill_model(self, FillModel fill_model):
         """
         Set the fill model to the given model.
 
         Parameters
         ----------
@@ -257,15 +268,15 @@
             The fill model to set.
 
         """
         Condition.not_none(fill_model, "fill_model")
 
         self._fill_model = fill_model
 
-        self._log.debug(f"Changed `FillModel` to {self._fill_model}.")
+        self._log.debug(f"Changed `FillModel` to {self._fill_model}")
 
 # -- QUERIES --------------------------------------------------------------------------------------
 
     cpdef Price best_bid_price(self):
         """
         Return the best bid price for the given instrument ID (if found).
 
@@ -344,20 +355,20 @@
         ----------
         delta : OrderBookDelta
             The order book delta to process.
 
         """
         Condition.not_none(delta, "delta")
 
-        if logging_is_initialized():
-            self._log.debug(f"Processing {repr(delta)}...")
+        if is_logging_initialized():
+            self._log.debug(f"Processing {repr(delta)}")
 
         self._book.apply_delta(delta)
 
-        # TODO(cs): WIP to introduce flags
+        # TODO: WIP to introduce flags
         # if data.flags == TimeInForce.GTC:
         #     self._book.apply(data)
         # elif data.flags == TimeInForce.AT_THE_OPEN:
         #     self._opening_auction_book.apply(data)
         # elif data.flags == TimeInForce.AT_THE_CLOSE:
         #     self._closing_auction_book.apply(data)
         # else:
@@ -373,20 +384,20 @@
         ----------
         delta : OrderBookDeltas
             The order book deltas to process.
 
         """
         Condition.not_none(deltas, "deltas")
 
-        if logging_is_initialized():
-            self._log.debug(f"Processing {repr(deltas)}...")
+        if is_logging_initialized():
+            self._log.debug(f"Processing {repr(deltas)}")
 
         self._book.apply_deltas(deltas)
 
-        # TODO(cs): WIP to introduce flags
+        # TODO: WIP to introduce flags
         # if data.flags == TimeInForce.GTC:
         #     self._book.apply(data)
         # elif data.flags == TimeInForce.AT_THE_OPEN:
         #     self._opening_auction_book.apply(data)
         # elif data.flags == TimeInForce.AT_THE_CLOSE:
         #     self._closing_auction_book.apply(data)
         # else:
@@ -404,16 +415,16 @@
         ----------
         tick : QuoteTick
             The tick to process.
 
         """
         Condition.not_none(tick, "tick")
 
-        if logging_is_initialized():
-            self._log.debug(f"Processing {repr(tick)}...")
+        if is_logging_initialized():
+            self._log.debug(f"Processing {repr(tick)}")
 
         if self.book_type == BookType.L1_MBP:
             self._book.update_quote_tick(tick)
 
         self.iterate(tick.ts_init)
 
     cpdef void process_trade_tick(self, TradeTick tick):
@@ -426,16 +437,16 @@
         ----------
         tick : TradeTick
             The tick to process.
 
         """
         Condition.not_none(tick, "tick")
 
-        if logging_is_initialized():
-            self._log.debug(f"Processing {repr(tick)}...")
+        if is_logging_initialized():
+            self._log.debug(f"Processing {repr(tick)}")
 
         if self.book_type == BookType.L1_MBP:
             self._book.update_trade_tick(tick)
 
         self._core.set_last_raw(tick._mem.price.raw)
 
         self.iterate(tick.ts_init)
@@ -453,21 +464,40 @@
 
         """
         Condition.not_none(bar, "bar")
 
         if not self._bar_execution:
             return
 
-        if logging_is_initialized():
-            self._log.debug(f"Processing {repr(bar)}...")
-
         if self.book_type != BookType.L1_MBP:
             return  # Can only process an L1 book with bars
 
-        cdef PriceType price_type = bar.bar_type.spec.price_type
+        cdef BarType bar_type = bar.bar_type
+        cdef InstrumentId instrument_id = bar_type.instrument_id
+        cdef BarType execution_bar_type = self._execution_bar_types.get(instrument_id)
+
+        if execution_bar_type is None:
+            execution_bar_type = bar_type
+            self._execution_bar_types[instrument_id] = bar_type
+            self._execution_bar_deltas[bar_type] = bar_type.spec.timedelta
+
+        if execution_bar_type != bar_type:
+            bar_type_timedelta = self._execution_bar_deltas.get(bar_type)
+            if bar_type_timedelta is None:
+                bar_type_timedelta = bar_type.spec.timedelta
+                self._execution_bar_deltas[bar_type] = bar_type_timedelta
+            if self._execution_bar_deltas[execution_bar_type] >= bar_type_timedelta:
+                self._execution_bar_types[instrument_id] = bar_type
+            else:
+                return
+
+        if is_logging_initialized():
+            self._log.debug(f"Processing {repr(bar)}")
+
+        cdef PriceType price_type = bar_type.spec.price_type
         if price_type == PriceType.LAST or price_type == PriceType.MID:
             self._process_trade_ticks_from_bar(bar)
         elif price_type == PriceType.BID:
             self._last_bid_bar = bar
             self._process_quote_ticks_from_bar()
         elif price_type == PriceType.ASK:
             self._last_ask_bar = bar
@@ -704,39 +734,44 @@
                     f"was {trigger_price.precision} "
                     f"when {self.instrument.id} price precision is {self.instrument.price_precision}"
                 )
                 return  # Invalid order
 
         cdef Position position = self.cache.position_for_order(order.client_order_id)
 
+        cdef PositionId position_id
+        if position is None and self.oms_type == OmsType.NETTING:
+            position_id = PositionId(f"{order.instrument_id}-{order.strategy_id}")
+            position = self.cache.position(position_id)
+
         # Check not shorting an equity without a MARGIN account
         if (
             order.side == OrderSide.SELL
             and self.account_type != AccountType.MARGIN
             and isinstance(self.instrument, Equity)
             and (position is None or not order.would_reduce_only(position.side, position.quantity))
         ):
             self._generate_order_rejected(
                 order,
-                f"SHORT SELLING not permitted on a CASH account with order {repr(order)}."
+                f"SHORT SELLING not permitted on a CASH account with position {position} and order {repr(order)}"
             )
             return  # Cannot short sell
 
         # Check reduce-only instruction
         if self._use_reduce_only and order.is_reduce_only and not order.is_closed_c():
             if (
                 not position
                 or position.is_closed_c()
                 or (order.is_buy_c() and position.is_long_c())
                 or (order.is_sell_c() and position.is_short_c())
             ):
                 self._generate_order_rejected(
                     order,
                     f"REDUCE_ONLY {order.type_string_c()} {order.side_string_c()} order "
-                    f"would have increased position.",
+                    f"would have increased position",
                 )
                 return  # Reduce only
 
         if order.order_type == OrderType.MARKET:
             self._process_market_order(order)
         elif order.order_type == OrderType.MARKET_TO_LIMIT:
             self._process_market_to_limit_order(order)
@@ -997,17 +1032,17 @@
                 side=order.side,
                 order_id=self._clock.timestamp_ns(),
             )
         self._process_auction_book_order(book_order, time_in_force=order.time_in_force)
 
     cdef void _process_auction_book_order(self, BookOrder order, TimeInForce time_in_force):
         if time_in_force == TimeInForce.AT_THE_OPEN:
-            self._opening_auction_book.add(order, 0, 0)
+            self._opening_auction_book.add(order, 0, 0, 0)
         elif time_in_force == TimeInForce.AT_THE_CLOSE:
-            self._closing_auction_book.add(order, 0, 0)
+            self._closing_auction_book.add(order, 0, 0, 0)
         else:
             raise RuntimeError(time_in_force)
 
     cdef void _update_limit_order(
         self,
         Order order,
         Quantity qty,
@@ -1443,15 +1478,15 @@
         cdef PositionId venue_position_id = self._get_position_id(order)
         cdef Position position = None
         if venue_position_id is not None:
             position = self.cache.position(venue_position_id)
         if self._use_reduce_only and order.is_reduce_only and position is None:
             self._log.warning(
                 f"Canceling REDUCE_ONLY {order.type_string_c()} "
-                f"as would increase position.",
+                f"as would increase position",
             )
             self.cancel_order(order)
             return  # Order canceled
 
         order.liquidity_side = LiquiditySide.TAKER
         cdef list fills = self.determine_market_price_and_volume(order)
 
@@ -1490,15 +1525,15 @@
         cdef PositionId venue_position_id = self._get_position_id(order)
         cdef Position position = None
         if venue_position_id is not None:
             position = self.cache.position(venue_position_id)
         if self._use_reduce_only and order.is_reduce_only and position is None:
             self._log.warning(
                 f"Canceling REDUCE_ONLY {order.type_string_c()} "
-                f"as would increase position.",
+                f"as would increase position",
             )
             self.cancel_order(order)
             return  # Order canceled
 
         cdef list fills = self.determine_limit_price_and_volume(order)
 
         self.apply_fills(
@@ -1564,46 +1599,46 @@
 
             if order.leaves_qty._mem.raw > total_size_raw:
                 self.cancel_order(order)
                 return  # Cannot fill full size - so kill/cancel
 
         if not fills:
             self._log.error(
-                "Cannot fill order: no fills from book when fills were expected (check sizes in data).",
+                "Cannot fill order: no fills from book when fills were expected (check sizes in data)",
             )
             return  # No fills
 
         if self.oms_type == OmsType.NETTING:
             venue_position_id = None  # No position IDs generated by the venue
 
-        if logging_is_initialized():
+        if is_logging_initialized():
             self._log.debug(
                 f"Applying fills to {order}, "
                 f"venue_position_id={venue_position_id}, "
                 f"position={position}, "
-                f"fills={fills}.",
+                f"fills={fills}",
             )
 
         cdef:
             bint initial_market_to_limit_fill = False
             Price last_fill_px = None
         for fill_px, fill_qty in fills:
             # Validate price precision
-            if fill_px.precision != self.instrument.price_precision:
+            if fill_px._mem.precision != self.instrument.price_precision:
                 raise RuntimeError(
                     f"Invalid price precision for fill {fill_px.precision} "
                     f"when instrument price precision is {self.instrument.price_precision}. "
-                    f"Check that the data price precision matches the {self.instrument.id} instrument."
+                    f"Check that the data price precision matches the {self.instrument.id} instrument"
                 )
             # Validate size precision
-            if fill_qty.precision != self.instrument.size_precision:
+            if fill_qty._mem.precision != self.instrument.size_precision:
                 raise RuntimeError(
                     f"Invalid size precision for fill {fill_qty.precision} "
                     f"when instrument size precision is {self.instrument.size_precision}. "
-                    f"Check that the data size precision matches the {self.instrument.id} instrument."
+                    f"Check that the data size precision matches the {self.instrument.id} instrument"
                 )
 
             if order.filled_qty._mem.raw == 0:
                 if order.order_type == OrderType.MARKET_TO_LIMIT:
                     self._generate_order_updated(
                         order,
                         qty=order.quantity,
@@ -1731,35 +1766,20 @@
         Condition.not_none(last_px, "last_px")
         Condition.not_none(last_qty, "last_qty")
         Condition.not_equal(liquidity_side, LiquiditySide.NO_LIQUIDITY_SIDE, "liquidity_side", "NO_LIQUIDITY_SIDE")
 
         order.liquidity_side = liquidity_side
 
         # Calculate commission
-        cdef double notional = self.instrument.notional_value(
-            quantity=last_qty,
-            price=last_px,
-            use_quote_for_inverse=False,
-        ).as_f64_c()
-
-        cdef double commission_f64
-        if order.liquidity_side == LiquiditySide.MAKER:
-            commission_f64 = notional * float(self.instrument.maker_fee)
-        elif order.liquidity_side == LiquiditySide.TAKER:
-            commission_f64 = notional * float(self.instrument.taker_fee)
-        else:
-            raise ValueError(
-                f"invalid `LiquiditySide`, was {liquidity_side_to_str(order.liquidity_side)}"
-            )
-
-        cdef Money commission
-        if self.instrument.is_inverse:  # Not using quote for inverse (see above):
-            commission = Money(commission_f64, self.instrument.base_currency)
-        else:
-            commission = Money(commission_f64, self.instrument.quote_currency)
+        cdef Money commission = self._fee_model.get_commission(
+            order=order,
+            fill_qty=last_qty,
+            fill_px=last_px,
+            instrument=self.instrument,
+        )
 
         self._generate_order_filled(
             order=order,
             venue_position_id=venue_position_id,
             last_qty=last_qty,
             last_px=last_px,
             quote_currency=self.instrument.quote_currency,
@@ -1922,15 +1942,15 @@
             self._cancel_contingent_orders(order)
 
         self._generate_order_expired(order)
 
     cpdef void cancel_order(self, Order order, bint cancel_contingencies=True):
         if order.is_active_local_c():
             self._log.error(
-                f"Cannot cancel an order with {order.status_string_c()} from the matching engine.",
+                f"Cannot cancel an order with {order.status_string_c()} from the matching engine",
             )
             return
 
         if order.venue_order_id is None:
             order.venue_order_id = self._generate_venue_order_id()
 
         self._core.delete_order(order)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/models.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/donchian_channel.pxd`

 * *Files 16% similar despite different names*

```diff
@@ -9,34 +9,24 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from libc.stdint cimport uint64_t
+from nautilus_trader.indicators.base.indicator cimport Indicator
 
 
-cdef class FillModel:
-    cdef readonly double prob_fill_on_limit
-    """The probability of limit orders filling on the limit price.\n\n:returns: `bool`"""
-    cdef readonly double prob_fill_on_stop
-    """The probability of stop orders filling on the stop price.\n\n:returns: `bool`"""
-    cdef readonly double prob_slippage
-    """The probability of aggressive order execution slipping.\n\n:returns: `bool`"""
+cdef class DonchianChannel(Indicator):
+    cdef object _upper_prices
+    cdef object _lower_prices
+
+    cdef readonly int period
+    """The period for the moving average.\n\n:returns: `int`"""
+    cdef readonly double upper
+    """The current value of the upper band.\n\n:returns: `double`"""
+    cdef readonly double middle
+    """The current value of the middle band.\n\n:returns: `double`"""
+    cdef readonly double lower
+    """The current value of the lower band.\n\n:returns: `double`"""
 
-    cpdef bint is_limit_filled(self)
-    cpdef bint is_stop_filled(self)
-    cpdef bint is_slipped(self)
-
-    cdef bint _event_success(self, double probability)
-
-
-cdef class LatencyModel:
-    cdef readonly uint64_t base_latency_nanos
-    """The default latency to the exchange.\n\n:returns: `int`"""
-    cdef readonly uint64_t insert_latency_nanos
-    """The latency (nanoseconds) for order insert messages to reach the exchange.\n\n:returns: `int`"""
-    cdef readonly uint64_t update_latency_nanos
-    """The latency (nanoseconds) for order update messages to reach the exchange.\n\n:returns: `int`"""
-    cdef readonly uint64_t cancel_latency_nanos
-    """The latency (nanoseconds) for order cancel messages to reach the exchange.\n\n:returns: `int`"""
+    cpdef void update_raw(self, double high, double low)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/modules.pxd` & `nautilus_trader-1.191.0/nautilus_trader/backtest/modules.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/modules.pyx` & `nautilus_trader-1.191.0/nautilus_trader/backtest/modules.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/node.py` & `nautilus_trader-1.191.0/nautilus_trader/backtest/node.py`

 * *Files 2% similar despite different names*

```diff
@@ -20,16 +20,18 @@
 from nautilus_trader.backtest.config import BacktestDataConfig
 from nautilus_trader.backtest.config import BacktestRunConfig
 from nautilus_trader.backtest.config import BacktestVenueConfig
 from nautilus_trader.backtest.engine import BacktestEngine
 from nautilus_trader.backtest.engine import BacktestEngineConfig
 from nautilus_trader.backtest.results import BacktestResult
 from nautilus_trader.common.component import Logger
+from nautilus_trader.common.component import LogGuard
 from nautilus_trader.common.config import ActorFactory
 from nautilus_trader.common.config import InvalidConfiguration
+from nautilus_trader.core import nautilus_pyo3
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.datetime import dt_to_unix_nanos
 from nautilus_trader.core.inspect import is_nautilus_class
 from nautilus_trader.core.nautilus_pyo3 import DataBackendSession
 from nautilus_trader.model.data import Bar
 from nautilus_trader.model.data import capsule_to_list
 from nautilus_trader.model.enums import AccountType
@@ -68,30 +70,43 @@
         PyCondition.true(
             all(isinstance(config, BacktestRunConfig) for config in configs),
             "configs",
         )
 
         self._validate_configs(configs)
 
-        # Configuration
         self._configs: list[BacktestRunConfig] = configs
         self._engines: dict[str, BacktestEngine] = {}
+        self._log_guard: nautilus_pyo3.LogGuard | LogGuard | None = None
 
     @property
     def configs(self) -> list[BacktestRunConfig]:
         """
         Return the loaded backtest run configs for the node.
 
         Returns
         -------
         list[BacktestRunConfig]
 
         """
         return self._configs
 
+    def get_log_guard(self) -> nautilus_pyo3.LogGuard | LogGuard | None:
+        """
+        Return the global logging systems log guard.
+
+        May return ``None`` if no internal engines are initialized yet.
+
+        Returns
+        -------
+        nautilus_pyo3.LogGuard | LogGuard | None
+
+        """
+        return self._log_guard
+
     def get_engine(self, run_config_id: str) -> BacktestEngine | None:
         """
         Return the backtest engine associated with the given run config ID (if found).
 
         Parameters
         ----------
         run_config_id : str
@@ -181,14 +196,20 @@
         venue_configs: list[BacktestVenueConfig],
         data_configs: list[BacktestDataConfig],
     ) -> BacktestEngine:
         # Build the backtest engine
         engine = BacktestEngine(config=config)
         self._engines[run_config_id] = engine
 
+        # Assign the global logging system guard to keep it alive for
+        # the duration of the nodes runs.
+        log_guard = engine.kernel.get_log_guard()
+        if log_guard:
+            self._log_guard = log_guard
+
         # Add venues (must be added prior to instruments)
         for config in venue_configs:
             base_currency: str | None = config.base_currency
             leverages = (
                 {InstrumentId.from_str(i): Decimal(v) for i, v in config.leverages.items()}
                 if config.leverages
                 else {}
@@ -307,14 +328,15 @@
                 validate=False,  # Cannot validate mixed type stream
                 sort=True,  # Temporarily sorting  # Already sorted from kmerge
             )
             engine.run(
                 run_config_id=run_config_id,
                 streaming=True,
             )
+            engine.clear_data()
 
         engine.end()
         engine.dispose()
 
     def _run_oneshot(
         self,
         run_config_id: str,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/backtest/results.py` & `nautilus_trader-1.191.0/nautilus_trader/backtest/results.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/cache/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/backtest/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/cache/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/cache/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/cache/base.pxd` & `nautilus_trader-1.191.0/nautilus_trader/cache/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/cache/base.pyx` & `nautilus_trader-1.191.0/nautilus_trader/cache/base.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/cache/cache.pxd` & `nautilus_trader-1.191.0/nautilus_trader/cache/cache.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -10,29 +10,32 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from cpython.datetime cimport datetime
+from cpython.datetime cimport timedelta
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.accounting.accounts.base cimport Account
 from nautilus_trader.accounting.calculators cimport ExchangeRateCalculator
 from nautilus_trader.cache.base cimport CacheFacade
 from nautilus_trader.cache.facade cimport CacheDatabaseFacade
 from nautilus_trader.common.actor cimport Actor
 from nautilus_trader.common.component cimport Logger
+from nautilus_trader.core.rust.model cimport AggregationSource
 from nautilus_trader.core.rust.model cimport OmsType
 from nautilus_trader.core.rust.model cimport OrderSide
 from nautilus_trader.core.rust.model cimport PositionSide
 from nautilus_trader.execution.messages cimport SubmitOrder
 from nautilus_trader.execution.messages cimport SubmitOrderList
 from nautilus_trader.model.book cimport OrderBook
 from nautilus_trader.model.data cimport Bar
+from nautilus_trader.model.data cimport BarType
 from nautilus_trader.model.data cimport QuoteTick
 from nautilus_trader.model.data cimport TradeTick
 from nautilus_trader.model.identifiers cimport AccountId
 from nautilus_trader.model.identifiers cimport ClientId
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
@@ -119,14 +122,15 @@
     cpdef void cache_order_lists(self)
     cpdef void cache_positions(self)
     cpdef void build_index(self)
     cpdef bint check_integrity(self)
     cpdef bint check_residuals(self)
     cpdef void clear_index(self)
     cpdef void reset(self)
+    cpdef void dispose(self)
     cpdef void flush_db(self)
 
     cdef tuple _build_quote_table(self, Venue venue)
     cdef void _build_index_venue_account(self)
     cdef void _cache_venue_account_id(self, AccountId account_id)
     cdef void _build_indexes_from_orders(self)
     cdef void _build_indexes_from_positions(self)
@@ -170,7 +174,16 @@
     cpdef void update_position(self, Position position)
     cpdef void update_actor(self, Actor actor)
     cpdef void delete_actor(self, Actor actor)
     cpdef void update_strategy(self, Strategy strategy)
     cpdef void delete_strategy(self, Strategy strategy)
 
     cpdef void heartbeat(self, datetime timestamp)
+
+    cdef timedelta _get_timedelta(self, BarType bar_type)
+
+    cpdef list bar_types(
+        self,
+        InstrumentId instrument_id=*,
+        object price_type=*,
+        AggregationSource aggregation_source=*,
+    )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/cache/cache.pyx` & `nautilus_trader-1.191.0/nautilus_trader/cache/cache.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -17,25 +17,28 @@
 import pickle
 import time
 import uuid
 from collections import deque
 from decimal import Decimal
 
 from nautilus_trader.cache.config import CacheConfig
+from nautilus_trader.core.rust.model import PriceType as PriceType_py
 
 from cpython.datetime cimport datetime
+from cpython.datetime cimport timedelta
 from libc.stdint cimport uint8_t
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.accounting.accounts.base cimport Account
 from nautilus_trader.accounting.calculators cimport ExchangeRateCalculator
 from nautilus_trader.cache.facade cimport CacheDatabaseFacade
 from nautilus_trader.common.component cimport LogColor
 from nautilus_trader.common.component cimport Logger
 from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.core.rust.model cimport AggregationSource
 from nautilus_trader.core.rust.model cimport ContingencyType
 from nautilus_trader.core.rust.model cimport OmsType
 from nautilus_trader.core.rust.model cimport OrderSide
 from nautilus_trader.core.rust.model cimport PositionSide
 from nautilus_trader.core.rust.model cimport PriceType
 from nautilus_trader.core.rust.model cimport TriggerType
 from nautilus_trader.execution.messages cimport SubmitOrder
@@ -153,118 +156,118 @@
         self._index_positions: set[PositionId] = set()
         self._index_positions_open: set[PositionId] = set()
         self._index_positions_closed: set[PositionId] = set()
         self._index_actors: set[ComponentId] = set()
         self._index_strategies: set[StrategyId] = set()
         self._index_exec_algorithms: set[ExecAlgorithmId] = set()
 
-        self._log.info("READY.")
+        self._log.info("READY")
 
 # -- COMMANDS -------------------------------------------------------------------------------------
 
     cpdef void cache_general(self):
         """
         Clear the current general cache and load the general objects from the
         cache database.
         """
-        self._log.debug(f"Loading general cache from database...")
+        self._log.debug(f"Loading general cache from database")
 
         if self._database is not None:
             self._general = self._database.load()
         else:
             self._general = {}
 
         cdef int count = len(self._general)
         self._log.info(
-            f"Cached {count} general object{'' if count == 1 else 's'} from database.",
+            f"Cached {count} general object{'' if count == 1 else 's'} from database",
             color=LogColor.BLUE if self._general else LogColor.NORMAL,
         )
 
     cpdef void cache_currencies(self):
         """
         Clear the current currencies cache and load currencies from the cache
         database.
         """
-        self._log.debug(f"Loading currencies from database...")
+        self._log.debug(f"Loading currencies from database")
 
         if self._database is not None:
             self._currencies = self._database.load_currencies()
         else:
             self._currencies = {}
 
         # Register currencies with internal `CURRENCY_MAP`
         cdef Currency currency
         for currency in self._currencies.values():
             Currency.register_c(currency, overwrite=False)
 
         cdef int count = len(self._currencies)
         self._log.info(
-            f"Cached {count} currenc{'y' if count == 1 else 'ies'} from database.",
+            f"Cached {count} currenc{'y' if count == 1 else 'ies'} from database",
             color=LogColor.BLUE if self._currencies else LogColor.NORMAL,
         )
 
     cpdef void cache_instruments(self):
         """
         Clear the current instruments cache and load instruments from the cache
         database.
         """
-        self._log.debug(f"Loading instruments from database...")
+        self._log.debug(f"Loading instruments from database")
 
         if self._database is not None:
             self._instruments = self._database.load_instruments()
         else:
             self._instruments = {}
 
         cdef int count = len(self._instruments)
         self._log.info(
-            f"Cached {count} instrument{'' if count == 1 else 's'} from database.",
+            f"Cached {count} instrument{'' if count == 1 else 's'} from database",
             color=LogColor.BLUE if self._instruments else LogColor.NORMAL,
         )
 
     cpdef void cache_synthetics(self):
         """
         Clear the current synthetic instruments cache and load synthetic instruments from the cache
         database.
         """
-        self._log.debug(f"Loading synthetic instruments from database...")
+        self._log.debug(f"Loading synthetic instruments from database")
 
         if self._database is not None:
             self._synthetics = self._database.load_synthetics()
         else:
             self._synthetics = {}
 
         cdef int count = len(self._synthetics)
         self._log.info(
-            f"Cached {count} synthetic instrument{'' if count == 1 else 's'} from database.",
+            f"Cached {count} synthetic instrument{'' if count == 1 else 's'} from database",
             color=LogColor.BLUE if self._synthetics else LogColor.NORMAL,
         )
 
     cpdef void cache_accounts(self):
         """
         Clear the current accounts cache and load accounts from the cache
         database.
         """
-        self._log.debug(f"Loading accounts from database...")
+        self._log.debug(f"Loading accounts from database")
 
         if self._database is not None:
             self._accounts = self._database.load_accounts()
         else:
             self._accounts = {}
 
         cdef int count = len(self._accounts)
         self._log.info(
-            f"Cached {count} account{'' if count == 1 else 's'} from database.",
+            f"Cached {count} account{'' if count == 1 else 's'} from database",
             color=LogColor.BLUE if self._accounts else LogColor.NORMAL,
         )
 
     cpdef void cache_orders(self):
         """
         Clear the current orders cache and load orders from the cache database.
         """
-        self._log.debug(f"Loading orders from database...")
+        self._log.debug(f"Loading orders from database")
 
         if self._database is not None:
             self._orders = self._database.load_orders()
             self._index_order_position = self._database.load_index_order_position()
             self._index_order_client = self._database.load_index_order_client()
         else:
             self._orders = {}
@@ -273,23 +276,23 @@
         cdef Order order
         for order in self._orders.values():
             if order.contingency_type == ContingencyType.OTO and order.position_id is not None:
                 self._assign_position_id_to_contingencies(order)
 
         cdef int count = len(self._orders)
         self._log.info(
-            f"Cached {count} order{'' if count == 1 else 's'} from database.",
+            f"Cached {count} order{'' if count == 1 else 's'} from database",
             color=LogColor.BLUE if self._orders else LogColor.NORMAL,
         )
 
     cpdef void cache_order_lists(self):
         """
         Clear the current order lists cache and load order lists using cached orders.
         """
-        self._log.debug(f"Loading order lists...")
+        self._log.debug(f"Loading order lists")
 
         cdef dict order_list_index = {}  # type: dict[OrderListId, list[Order]]
 
         # Collect all orders common to an OrderListId
         cdef:
             Order order
             list orders
@@ -310,50 +313,50 @@
                 order_list_id=order_list_id,
                 orders=orders,
             )
             self._order_lists[order_list_id] = order_list
 
         cdef int count = len(self._order_lists)
         self._log.info(
-            f"Cached {count} order list{'' if count == 1 else 's'} from database.",
+            f"Cached {count} order list{'' if count == 1 else 's'} from database",
             color=LogColor.BLUE if self._order_lists else LogColor.NORMAL,
         )
 
     cpdef void cache_positions(self):
         """
         Clear the current positions cache and load positions from the cache
         database.
         """
-        self._log.debug(f"Loading positions from database...")
+        self._log.debug(f"Loading positions from database")
 
         if self._database is not None:
             self._positions = self._database.load_positions()
         else:
             self._positions = {}
 
         cdef int count = len(self._positions)
         self._log.info(
-            f"Cached {count} position{'' if count == 1 else 's'} from database.",
+            f"Cached {count} position{'' if count == 1 else 's'} from database",
             color=LogColor.BLUE if self._positions else LogColor.NORMAL
         )
 
     cpdef void build_index(self):
         """
         Clear the current cache index and re-build.
         """
         self.clear_index()
 
-        self._log.debug(f"Building index...")
+        self._log.debug(f"Building index")
         cdef double ts = time.time()
 
         self._build_index_venue_account()
         self._build_indexes_from_orders()
         self._build_indexes_from_positions()
 
-        self._log.debug(f"Index built in {time.time() - ts:.3f}s.")
+        self._log.debug(f"Index built in {time.time() - ts:.3f}s")
 
     cpdef bint check_integrity(self):
         """
         Check integrity of data within the cache.
 
         All data should be loaded from the database prior to this call. If an
         error is found then a log error message will also be produced.
@@ -367,15 +370,15 @@
         cdef int error_count = 0
         cdef str failure = "Integrity failure"
 
         # As there should be a bi-directional one-to-one relationship between
         # caches and indexes, each cache and index must be checked individually
 
         cdef uint64_t timestamp_us = time.time_ns() // 1000
-        self._log.info("Checking data integrity...")
+        self._log.info("Checking data integrity")
 
         # Needed type defs
         # ----------------
         cdef:
             AccountId account_id
             Order order
             Position position
@@ -631,23 +634,23 @@
                 )
                 error_count += 1
 
         # Finally
         cdef uint64_t total_us = round((time.time_ns() // 1000) - timestamp_us)
         if error_count == 0:
             self._log.info(
-                f"Integrity check passed in {total_us}μs.",
+                f"Integrity check passed in {total_us}μs",
                 color=LogColor.GREEN
             )
             return True
         else:
             self._log.error(
                 f"Integrity check failed with "
                 f"{error_count} error{'' if error_count == 1 else 's'} "
-                f"in {total_us}μs."
+                f"in {total_us}μs"
             )
             return False
 
     cpdef bint check_residuals(self):
         """
         Check for any residual open state and log warnings if any are found.
 
@@ -655,15 +658,15 @@
 
         Returns
         -------
         bool
             True if residuals exist, else False.
 
         """
-        self._log.debug("Checking residuals...")
+        self._log.debug("Checking residuals")
 
         cdef bint residuals = False
 
         # Check for any residual active orders and log warnings if any are found
         for order in self.orders_open():
             residuals = True
             self._log.warning(f"Residual {order}")
@@ -671,15 +674,15 @@
         for position in self.positions_open():
             residuals = True
             self._log.warning(f"Residual {position}")
 
         return residuals
 
     cpdef void clear_index(self):
-        self._log.debug(f"Clearing index...")
+        self._log.debug(f"Clearing index")
 
         self._index_venue_account.clear()
         self._index_venue_orders.clear()
         self._index_venue_positions.clear()
         self._index_order_ids.clear()
         self._index_order_position.clear()
         self._index_order_strategy.clear()
@@ -701,23 +704,23 @@
         self._index_positions.clear()
         self._index_positions_open.clear()
         self._index_positions_closed.clear()
         self._index_actors.clear()
         self._index_strategies.clear()
         self._index_exec_algorithms.clear()
 
-        self._log.debug(f"Cleared index.")
+        self._log.debug(f"Cleared index")
 
     cpdef void reset(self):
         """
         Reset the cache.
 
         All stateful fields are reset to their initial value.
         """
-        self._log.info("Resetting cache...")
+        self._log.debug("Resetting cache")
 
         self._general.clear()
         self._xrate_symbols.clear()
         self._quote_ticks.clear()
         self._trade_ticks.clear()
         self._order_books.clear()
         self._bars.clear()
@@ -731,31 +734,39 @@
         self._positions.clear()
         self._position_snapshots.clear()
         self.clear_index()
 
         if self._drop_instruments_on_reset:
             self._instruments.clear()
 
-        self._log.debug(f"Reset cache.")
+        self._log.info(f"Reset")
+
+    cpdef void dispose(self):
+        """
+        Dispose of the cache which will close any underlying database adapter.
+
+        """
+        if self._database is not None:
+            self._database.close()
 
     cpdef void flush_db(self):
         """
         Flush the caches database which permanently removes all persisted data.
 
         Warnings
         --------
         Permanent data loss.
 
         """
-        self._log.debug("Flushing execution database...")
+        self._log.debug("Flushing cache database")
 
         if self._database is not None:
             self._database.flush()
 
-        self._log.info("Execution database flushed.")
+        self._log.info("Cache database flushed")
 
     cdef void _build_index_venue_account(self):
         cdef AccountId account_id
         for account_id in self._accounts.keys():
             self._cache_venue_account_id(account_id)
 
     cdef void _cache_venue_account_id(self, AccountId account_id):
@@ -876,34 +887,34 @@
     cdef void _assign_position_id_to_contingencies(self, Order order):
         cdef:
             ClientOrderId client_order_id
             Order contingent_order
         for client_order_id in order.linked_order_ids or []:
             contingent_order = self._orders.get(client_order_id)
             if contingent_order is None:
-                self._log.error(f"Contingency order {client_order_id!r} not found.")
+                self._log.error(f"Contingency order {client_order_id!r} not found")
                 continue
             if contingent_order.position_id is None:
                 # Assign the parents position ID
                 contingent_order.position_id = order.position_id
 
                 self.add_position_id(
                     order.position_id,
                     order.instrument_id.venue,
                     contingent_order.client_order_id,
                     order.strategy_id,
                 )
-                self._log.info(f"Assigned {order.position_id!r} to {client_order_id!r}.")
+                self._log.info(f"Assigned {order.position_id!r} to {client_order_id!r}")
 
     cpdef Money calculate_unrealized_pnl(self, Position position):
         cdef QuoteTick quote = self.quote_tick(position.instrument_id)
         if quote is None:
             self._log.warning(
                 f"Cannot calculate unrealized PnL for {position.id!r}, "
-                f"no quotes for {position.instrument_id}.",
+                f"no quotes for {position.instrument_id}",
             )
             return None
 
         cdef Price last
         if position.side == PositionSide.FLAT:
             return Money(0.0, position.settlement_currency)
         elif position.side == PositionSide.LONG:
@@ -1190,29 +1201,29 @@
         """
         Condition.not_none(ticks, "ticks")
 
         cdef int length = len(ticks)
         cdef InstrumentId instrument_id
         if length > 0:
             instrument_id = ticks[0].instrument_id
-            self._log.debug(f"Received <QuoteTick[{length}]> data for {instrument_id}.")
+            self._log.debug(f"Received <QuoteTick[{length}]> data for {instrument_id}")
         else:
-            self._log.debug("Received <QuoteTick[]> data with no ticks.")
+            self._log.debug("Received <QuoteTick[]> data with no ticks")
             return
 
         cached_ticks = self._quote_ticks.get(instrument_id)
 
         if not cached_ticks:
             # The instrument_id was not registered
             cached_ticks = deque(maxlen=self.tick_capacity)
             self._quote_ticks[instrument_id] = cached_ticks
         elif len(cached_ticks) > 0:
             # Currently the simple solution for multiple consumers requesting
             # ticks at system spool up is just to add only if the cache is empty.
-            self._log.debug("Cache already contains ticks.")
+            self._log.debug("Cache already contains ticks")
             return
 
         cdef QuoteTick tick
         for tick in ticks:
             cached_ticks.appendleft(tick)
 
     cpdef void add_trade_ticks(self, list ticks):
@@ -1227,29 +1238,29 @@
         """
         Condition.not_none(ticks, "ticks")
 
         cdef int length = len(ticks)
         cdef InstrumentId instrument_id
         if length > 0:
             instrument_id = ticks[0].instrument_id
-            self._log.debug(f"Received <TradeTick[{length}]> data for {instrument_id}.")
+            self._log.debug(f"Received <TradeTick[{length}]> data for {instrument_id}")
         else:
-            self._log.debug("Received <TradeTick[]> data with no ticks.")
+            self._log.debug("Received <TradeTick[]> data with no ticks")
             return
 
         cached_ticks = self._trade_ticks.get(instrument_id)
 
         if not cached_ticks:
             # The instrument_id was not registered
             cached_ticks = deque(maxlen=self.tick_capacity)
             self._trade_ticks[instrument_id] = cached_ticks
         elif len(cached_ticks) > 0:
             # Currently the simple solution for multiple consumers requesting
             # ticks at system spool up is just to add only if the cache is empty.
-            self._log.debug("Cache already contains ticks.")
+            self._log.debug("Cache already contains ticks")
             return
 
         cdef TradeTick tick
         for tick in ticks:
             cached_ticks.appendleft(tick)
 
     cpdef void add_bars(self, list bars):
@@ -1264,29 +1275,29 @@
         """
         Condition.not_none(bars, "bars")
 
         cdef int length = len(bars)
         cdef BarType bar_type
         if length > 0:
             bar_type = bars[0].bar_type
-            self._log.debug(f"Received <Bar[{length}]> data for {bar_type}.")
+            self._log.debug(f"Received <Bar[{length}]> data for {bar_type}")
         else:
-            self._log.debug("Received <Bar[]> data with no ticks.")
+            self._log.debug("Received <Bar[]> data with no ticks")
             return
 
         cached_bars = self._bars.get(bar_type)
 
         if not cached_bars:
             # The instrument_id was not registered
             cached_bars = deque(maxlen=self.bar_capacity)
             self._bars[bar_type] = cached_bars
         elif len(cached_bars) > 0:
             # Currently the simple solution for multiple consumers requesting
             # bars at system spool up is just to add only if the cache is empty.
-            self._log.debug("Cache already contains bars.")
+            self._log.debug("Cache already contains bars")
             return
 
         cdef Bar bar
         for bar in bars:
             cached_bars.appendleft(bar)
 
         bar = bars[-1]
@@ -1307,15 +1318,15 @@
 
         """
         Condition.not_none(currency, "currency")
 
         self._currencies[currency.code] = currency
         Currency.register_c(currency, overwrite=False)
 
-        self._log.debug(f"Added currency {currency.code}.")
+        self._log.debug(f"Added currency {currency.code}")
 
         # Update database
         if self._database is not None:
             self._database.add_currency(currency)
 
     cpdef void add_instrument(self, Instrument instrument):
         """
@@ -1330,15 +1341,15 @@
         self._instruments[instrument.id] = instrument
 
         if isinstance(instrument, (CurrencyPair, CryptoPerpetual)):
             self._xrate_symbols[instrument.id] = (
                 f"{instrument.base_currency}/{instrument.quote_currency}"
             )
 
-        self._log.debug(f"Added instrument {instrument.id}.")
+        self._log.debug(f"Added instrument {instrument.id}")
 
         # Update database
         if self._database is not None:
             self._database.add_instrument(instrument)
 
     cpdef void add_synthetic(self, SyntheticInstrument synthetic):
         """
@@ -1348,15 +1359,15 @@
         ----------
         synthetic : SyntheticInstrument
             The synthetic instrument to add.
 
         """
         self._synthetics[synthetic.id] = synthetic
 
-        self._log.debug(f"Added synthetic instrument {synthetic.id}.")
+        self._log.debug(f"Added synthetic instrument {synthetic.id}")
 
         # Update database
         if self._database is not None:
             self._database.add_synthetic(synthetic)
 
     cpdef void add_account(self, Account account):
         """
@@ -1375,16 +1386,16 @@
         """
         Condition.not_none(account, "account")
         Condition.not_in(account.id, self._accounts, "account.id", "cached_accounts")
 
         self._accounts[account.id] = account
         self._cache_venue_account_id(account.id)
 
-        self._log.debug(f"Added Account(id={account.id.to_str()}).")
-        self._log.debug(f"Indexed {repr(account.id)}.")
+        self._log.debug(f"Added Account(id={account.id.to_str()})")
+        self._log.debug(f"Indexed {repr(account.id)}")
 
         # Update database
         if self._database is not None:
             self._database.add_account(account)
 
     cpdef void add_order(
         self,
@@ -1472,29 +1483,29 @@
 
         # Update emulation
         if order.emulation_trigger == TriggerType.NO_TRIGGER:
             self._index_orders_emulated.discard(order.client_order_id)
         else:
             self._index_orders_emulated.add(order.client_order_id)
 
-        self._log.debug(f"Added {order}.")
+        self._log.debug(f"Added {order}")
 
         if position_id is not None:
             # Index position ID
             self.add_position_id(
                 position_id,
                 order.instrument_id.venue,
                 order.client_order_id,
                 order.strategy_id,
             )
 
         # Index: ClientOrderId -> ClientId (execution client routing)
         if client_id is not None:
             self._index_order_client[order.client_order_id] = client_id
-            self._log.debug(f"Indexed {client_id!r}.")
+            self._log.debug(f"Indexed {client_id!r}")
 
         if self._database is None:
             return
 
         # Update database
         self._database.add_order(order, position_id, client_id)
         if self.snapshot_orders:
@@ -1516,15 +1527,15 @@
 
         """
         Condition.not_none(order_list, "order_list")
         Condition.not_in(order_list.id, self._order_lists, "order_list.id", "_order_lists")
 
         self._order_lists[order_list.id] = order_list
 
-        self._log.debug(f"Added {order_list}.")
+        self._log.debug(f"Added {order_list}")
 
     cpdef void add_position_id(
         self,
         PositionId position_id,
         Venue venue,
         ClientOrderId client_order_id,
         StrategyId strategy_id,
@@ -1570,15 +1581,15 @@
             self._index_strategy_positions[strategy_id] = {position_id}
         else:
             strategy_positions.add(position_id)
 
         self._log.debug(
             f"Indexed {position_id!r}, "
             f"client_order_id={client_order_id}, "
-            f"strategy_id={strategy_id}).",
+            f"strategy_id={strategy_id})",
         )
 
     cpdef void add_position(self, Position position, OmsType oms_type):
         """
         Add the given position to the cache.
 
         Parameters
@@ -1623,15 +1634,15 @@
         cdef InstrumentId instrument_id = position.instrument_id
         cdef set instrument_positions = self._index_instrument_positions.get(instrument_id)
         if not instrument_positions:
             self._index_instrument_positions[instrument_id] = {position.id}
         else:
             instrument_positions.add(position.id)
 
-        self._log.debug(f"Added Position(id={position.id.to_str()}, strategy_id={position.strategy_id.to_str()}).")
+        self._log.debug(f"Added Position(id={position.id.to_str()}, strategy_id={position.strategy_id.to_str()})")
 
         if self._database is None:
             return
 
         # Update database
         self._database.add_position(position)
         if self.snapshot_positions:
@@ -1662,15 +1673,15 @@
         cdef bytes position_pickled = pickle.dumps(copied_position)
 
         if snapshots is not None:
             snapshots.append(position_pickled)
         else:
             self._position_snapshots[position_id] = [position_pickled]
 
-        self._log.debug(f"Snapshot {repr(copied_position)}.")
+        self._log.debug(f"Snapshot {repr(copied_position)}")
 
     cpdef void snapshot_position_state(
         self,
         Position position,
         uint64_t ts_snapshot,
         bint open_only=True,
     ):
@@ -1693,15 +1704,15 @@
         Condition.not_none(position, "position")
 
         if open_only and not position.is_open_c():
             return  # Only snapshot open positions
 
         if self._database is None:
             self._log.warning(
-                "Cannot snapshot position state for {position.id:r!} (no database configured).",
+                "Cannot snapshot position state for {position.id:r!} (no database configured)",
             )
             return
 
         self._database.snapshot_position_state(
             position,
             ts_snapshot,
             self.calculate_unrealized_pnl(position),
@@ -1719,15 +1730,15 @@
             The order to snapshot the state for.
 
         """
         Condition.not_none(order, "order")
 
         if self._database is None:
             self._log.warning(
-                "Cannot snapshot order state for {order.client_order_id:r!} (no database configured).",
+                "Cannot snapshot order state for {order.client_order_id:r!} (no database configured)",
             )
             return
 
         self._database.snapshot_order_state(order)
 
     cpdef void update_account(self, Account account):
         """
@@ -1871,15 +1882,15 @@
         Condition.is_in(actor.id, self._index_actors, "actor.id", "actors")
 
         self._index_actors.discard(actor.id)
 
         # Update database
         if self._database is not None:
             self._database.delete_actor(actor.id)
-            self._log.debug(f"Deleted Actor(id={actor.id.value}).")
+            self._log.debug(f"Deleted Actor(id={actor.id.value})")
 
     cpdef void update_strategy(self, Strategy strategy):
         """
         Update the given strategy state in the cache.
 
         Parameters
         ----------
@@ -1919,15 +1930,15 @@
 
         if strategy.id in self._index_strategy_positions:
             del self._index_strategy_positions[strategy.id]
 
         # Update database
         if self._database is not None:
             self._database.delete_strategy(strategy.id)
-            self._log.debug(f"Deleted Strategy(id={strategy.id.value}).")
+            self._log.debug(f"Deleted Strategy(id={strategy.id.value})")
 
 # -- DATA QUERIES ---------------------------------------------------------------------------------
 
     cpdef bytes get(self, str key):
         """
         Add the given general object to the cache.
 
@@ -2021,18 +2032,28 @@
         Condition.not_none(instrument_id, "instrument_id")
 
         cdef TradeTick trade_tick
         cdef QuoteTick quote_tick
 
         if price_type == PriceType.LAST:
             trade_tick = self.trade_tick(instrument_id)
-            return trade_tick.price if trade_tick is not None else None
+            if trade_tick is not None:
+                return trade_tick.price
         else:
             quote_tick = self.quote_tick(instrument_id)
-            return quote_tick.extract_price(price_type) if quote_tick is not None else None
+            if quote_tick is not None:
+                return quote_tick.extract_price(price_type)
+
+        # Fallback to bar pricing
+        cdef Bar bar
+        cdef list bar_types = self.bar_types(instrument_id, price_type, AggregationSource.EXTERNAL)
+        if bar_types:
+            bar = self.bar(bar_types[0])  # Bar with smallest timedelta
+            if bar is not None:
+                return bar.close
 
     cpdef OrderBook order_book(self, InstrumentId instrument_id):
         """
         Return the order book for the given instrument ID.
 
         Parameters
         ----------
@@ -2427,14 +2448,58 @@
         Returns
         -------
         list[Instrument]
 
         """
         return [x for x in self._instruments.values() if venue is None or venue == x.id.venue]
 
+    cdef timedelta _get_timedelta(self, BarType bar_type):
+        """ Helper method to get the timedelta from a BarType. """
+        return bar_type.spec.timedelta
+
+    cpdef list bar_types(
+        self,
+        InstrumentId instrument_id = None,
+        object price_type = None,
+        AggregationSource aggregation_source = AggregationSource.EXTERNAL,
+    ):
+        """
+        Return a list of BarType for the given instrument ID and price type.
+
+        Parameters
+        ----------
+        instrument_id : InstrumentId, optional
+            The instrument ID to filter the BarType objects. If None, no filtering is done based on instrument ID.
+        price_type : PriceType or None, optional
+            The price type to filter the BarType objects. If None, no filtering is done based on price type.
+        aggregation_source : AggregationSource, default AggregationSource.EXTERNAL
+            The aggregation source to filter the BarType objects.
+
+        Returns
+        -------
+        list[BarType]
+
+        """
+        Condition.type_or_none(instrument_id, InstrumentId, "instrument_id")
+        Condition.type_or_none(price_type, PriceType_py, "price_type")
+
+        cdef list bar_types = [bar_type for bar_type in self._bars.keys()
+                               if bar_type.aggregation_source == aggregation_source]
+
+        if instrument_id is not None:
+            bar_types = [bar_type for bar_type in bar_types if bar_type.instrument_id == instrument_id]
+
+        if price_type is not None:
+            bar_types = [bar_type for bar_type in bar_types if bar_type.spec.price_type == price_type]
+
+        if instrument_id and price_type:
+            bar_types.sort(key=self._get_timedelta)
+
+        return bar_types
+
 # -- SYNTHETIC QUERIES ----------------------------------------------------------------------------
 
     cpdef SyntheticInstrument synthetic(self, InstrumentId instrument_id):
         """
         Return the synthetic instrument corresponding to the given instrument ID.
 
         Parameters
@@ -4018,11 +4083,11 @@
         timestamp : datetime
             The timestamp for the heartbeat.
 
         """
         Condition.not_none(timestamp, "timestamp")
 
         if self._database is None:
-            self._log.warning(f"Cannot set heartbeat {timestamp} (no database configured).")
+            self._log.warning(f"Cannot set heartbeat {timestamp} (no database configured)")
             return
 
         self._database.heartbeat(timestamp)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/cache/config.py` & `nautilus_trader-1.191.0/nautilus_trader/cache/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/cache/database.pxd` & `nautilus_trader-1.191.0/nautilus_trader/cache/database.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/cache/database.pyx` & `nautilus_trader-1.191.0/nautilus_trader/cache/database.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -138,15 +138,15 @@
         Condition.type(config, CacheConfig, "config")
         super().__init__(config)
 
         # Validate configuration
         if config.buffer_interval_ms and config.buffer_interval_ms > 1000:
             self._log.warning(
                 f"High `buffer_interval_ms` at {config.buffer_interval_ms}, "
-                "recommended range is [10, 1000] milliseconds.",
+                "recommended range is [10, 1000] milliseconds",
             )
 
         # Configuration
         self._log.info(f"{config.database=}", LogColor.BLUE)
         self._log.info(f"{config.encoding=}", LogColor.BLUE)
         self._log.info(f"{config.timestamps_as_iso8601=}", LogColor.BLUE)
         self._log.info(f"{config.buffer_interval_ms=}", LogColor.BLUE)
@@ -160,22 +160,31 @@
             trader_id=nautilus_pyo3.TraderId(trader_id.value),
             instance_id=nautilus_pyo3.UUID4(instance_id.value),
             config_json=msgspec.json.encode(config),
         )
 
 # -- COMMANDS -------------------------------------------------------------------------------------
 
+    cpdef void close(self):
+        """
+        Close the backing database adapter.
+
+        """
+        self._log.debug("Closing cache database adapter")
+        self._backing.close()
+        self._log.info("Closed cache database adapter")
+
     cpdef void flush(self):
         """
         Flush the database which clears all data.
 
         """
-        self._log.debug("Flushing database....")
+        self._log.debug("Flushing cache database")
         self._backing.flushdb()
-        self._log.info("Flushed database.", LogColor.BLUE)
+        self._log.info("Flushed cache database", LogColor.BLUE)
 
     cpdef list[str] keys(self, str pattern = "*"):
         """
         Return all keys in the database matching the given `pattern`.
 
         Parameters
         ----------
@@ -687,15 +696,15 @@
 
         """
         Condition.not_none(component_id, "component_id")
 
         cdef str key = f"{_ACTORS}:{component_id.to_str()}:state"
         self._backing.delete(key)
 
-        self._log.info(f"Deleted {repr(component_id)}.")
+        self._log.info(f"Deleted {repr(component_id)}")
 
     cpdef dict load_strategy(self, StrategyId strategy_id):
         """
         Load the state for the given strategy.
 
         Parameters
         ----------
@@ -727,15 +736,15 @@
 
         """
         Condition.not_none(strategy_id, "strategy_id")
 
         cdef str key = f"{_STRATEGIES}:{strategy_id.to_str()}:state"
         self._backing.delete(key)
 
-        self._log.info(f"Deleted {repr(strategy_id)}.")
+        self._log.info(f"Deleted {repr(strategy_id)}")
 
     cpdef void add(self, str key, bytes value):
         """
         Add the given general object value to the database.
 
         Parameters
         ----------
@@ -745,15 +754,15 @@
             The object value.
 
         """
         Condition.not_none(key, "key")
         Condition.not_none(value, "value")
 
         self._backing.insert(f"{_GENERAL}:{key}", [value])
-        self._log.debug(f"Added general object {key}.")
+        self._log.debug(f"Added general object {key}")
 
     cpdef void add_currency(self, Currency currency):
         """
         Add the given currency to the database.
 
         Parameters
         ----------
@@ -770,15 +779,15 @@
             "currency_type": currency_type_to_str(currency.currency_type)
         }
 
         cdef key = f"{_CURRENCIES}:{currency.code}"
         cdef list payload = [self._serializer.serialize(currency_map)]
         self._backing.insert(key, payload)
 
-        self._log.debug(f"Added currency {currency.code}.")
+        self._log.debug(f"Added currency {currency.code}")
 
     cpdef void add_instrument(self, Instrument instrument):
         """
         Add the given instrument to the database.
 
         Parameters
         ----------
@@ -788,15 +797,15 @@
         """
         Condition.not_none(instrument, "instrument")
 
         cdef str key = f"{_INSTRUMENTS}:{instrument.id.to_str()}"
         cdef list payload = [self._serializer.serialize(instrument)]
         self._backing.insert(key, payload)
 
-        self._log.debug(f"Added instrument {instrument.id}.")
+        self._log.debug(f"Added instrument {instrument.id}")
 
     cpdef void add_synthetic(self, SyntheticInstrument synthetic):
         """
         Add the given synthetic instrument to the database.
 
         Parameters
         ----------
@@ -806,15 +815,15 @@
         """
         Condition.not_none(synthetic, "synthetic")
 
         cdef str key = f"{_SYNTHETICS}:{synthetic.id.value}"
         cdef list payload = [self._serializer.serialize(synthetic)]
         self._backing.insert(key, payload)
 
-        self._log.debug(f"Added synthetic instrument {synthetic.id}.")
+        self._log.debug(f"Added synthetic instrument {synthetic.id}")
 
     cpdef void add_account(self, Account account):
         """
         Add the given account to the database.
 
         Parameters
         ----------
@@ -824,15 +833,15 @@
         """
         Condition.not_none(account, "account")
 
         cdef str key = f"{_ACCOUNTS}:{account.id.value}"
         cdef list payload = [self._serializer.serialize(account.last_event_c())]
         self._backing.insert(key, payload)
 
-        self._log.debug(f"Added {account}.")
+        self._log.debug(f"Added {account}")
 
     cpdef void add_order(self, Order order, PositionId position_id = None, ClientId client_id = None):
         """
         Add the given order to the database.
 
         Parameters
         ----------
@@ -854,15 +863,15 @@
         cdef bytes client_order_id_bytes = client_order_id_str.encode()
         payload = [client_order_id_bytes]
         self._backing.insert(_INDEX_ORDERS, payload)
 
         if order.emulation_trigger != TriggerType.NO_TRIGGER:
             self._backing.insert(_INDEX_ORDERS_EMULATED, payload)
 
-        self._log.debug(f"Added {order}.")
+        self._log.debug(f"Added {order}")
 
         if position_id is not None:
             self.index_order_position(order.client_order_id, position_id)
         if client_id is not None:
             payload = [client_order_id_bytes, client_id.to_str().encode()]
             self._backing.insert(_INDEX_ORDER_CLIENT, payload)
             self._log.debug(f"Indexed {order.client_order_id!r} -> {client_id!r}")
@@ -884,15 +893,15 @@
         cdef list payload = [self._serializer.serialize(position.last_event_c())]
         self._backing.insert(key, payload)
 
         cdef bytes position_id_bytes = position_id_str.encode()
         self._backing.insert(_INDEX_POSITIONS, [position_id_bytes])
         self._backing.insert(_INDEX_POSITIONS_OPEN, [position_id_bytes])
 
-        self._log.debug(f"Added {position}.")
+        self._log.debug(f"Added {position}")
 
     cpdef void index_venue_order_id(self, ClientOrderId client_order_id, VenueOrderId venue_order_id):
         """
         Add an index entry for the given `venue_order_id` to `client_order_id`.
 
         Parameters
         ----------
@@ -944,15 +953,15 @@
 
         cdef dict state = actor.save()  # Extract state dictionary from strategy
 
         cdef key = f"{_ACTORS}:{actor.id.value}:state"
         cdef list payload = [self._serializer.serialize(state)]
         self._backing.insert(key, payload)
 
-        self._log.debug(f"Saved actor state for {actor.id.value}.")
+        self._log.debug(f"Saved actor state for {actor.id.value}")
 
     cpdef void update_strategy(self, Strategy strategy):
         """
         Update the given strategy state in the database.
 
         Parameters
         ----------
@@ -964,15 +973,15 @@
 
         cdef dict state = strategy.save()  # Extract state dictionary from strategy
 
         cdef key = f"{_STRATEGIES}:{strategy.id.value}:state"
         cdef list payload = [self._serializer.serialize(state)]
         self._backing.insert(key, payload)
 
-        self._log.debug(f"Saved strategy state for {strategy.id.value}.")
+        self._log.debug(f"Saved strategy state for {strategy.id.value}")
 
     cpdef void update_account(self, Account account):
         """
         Update the given account in the database.
 
         Parameters
         ----------
@@ -981,15 +990,15 @@
         """
         Condition.not_none(account, "account")
 
         cdef str key = f"{_ACCOUNTS}:{account.id.to_str()}"
         cdef list payload = [self._serializer.serialize(account.last_event_c())]
         self._backing.update(key, payload)
 
-        self._log.debug(f"Updated {account}.")
+        self._log.debug(f"Updated {account}")
 
     cpdef void update_order(self, Order order):
         """
         Update the given order in the database.
 
         Parameters
         ----------
@@ -1026,15 +1035,15 @@
 
         # Update emulation state
         if order.emulation_trigger == TriggerType.NO_TRIGGER:
             self._backing.delete(_INDEX_ORDERS_EMULATED, payload)
         else:
             self._backing.insert(_INDEX_ORDERS_EMULATED, payload)
 
-        self._log.debug(f"Updated {order}.")
+        self._log.debug(f"Updated {order}")
 
     cpdef void update_position(self, Position position):
         """
         Update the given position in the database.
 
         Parameters
         ----------
@@ -1052,15 +1061,15 @@
         if position.is_open_c():
             self._backing.insert(_INDEX_POSITIONS_OPEN, payload)
             self._backing.delete(_INDEX_POSITIONS_CLOSED, payload)
         elif position.is_closed_c():
             self._backing.insert(_INDEX_POSITIONS_CLOSED, payload)
             self._backing.delete(_INDEX_POSITIONS_OPEN, payload)
 
-        self._log.debug(f"Updated {position}.")
+        self._log.debug(f"Updated {position}")
 
     cpdef void snapshot_order_state(self, Order order):
         """
         Snapshot the state of the given `order`.
 
         Parameters
         ----------
@@ -1070,15 +1079,15 @@
         """
         Condition.not_none(order, "order")
 
         cdef str key = f"{_SNAPSHOTS_ORDERS}:{order.client_order_id.to_str()}"
         cdef list payload = [self._serializer.serialize(order.to_dict())]
         self._backing.insert(key, payload)
 
-        self._log.debug(f"Added state snapshot {order}.")
+        self._log.debug(f"Added state snapshot {order}")
 
     cpdef void snapshot_position_state(self, Position position, uint64_t ts_snapshot, Money unrealized_pnl = None):
         """
         Snapshot the state of the given `position`.
 
         Parameters
         ----------
@@ -1099,15 +1108,15 @@
 
         position_state["ts_snapshot"] = ts_snapshot
 
         cdef str key = f"{_SNAPSHOTS_POSITIONS}:{position.id.to_str()}"
         cdef list payload = [self._serializer.serialize(position_state)]
         self._backing.insert(key, payload)
 
-        self._log.debug(f"Added state snapshot {position}.")
+        self._log.debug(f"Added state snapshot {position}")
 
     cpdef void heartbeat(self, datetime timestamp):
         """
         Add a heartbeat at the given `timestamp`.
 
         Parameters
         ----------
@@ -1116,8 +1125,8 @@
 
         """
         Condition.not_none(timestamp, "timestamp")
 
         cdef timestamp_str = format_iso8601(timestamp)
         self._backing.insert(_HEARTBEAT, [timestamp_str.encode()])
 
-        self._log.debug(f"Set last heartbeat {timestamp_str}.")
+        self._log.debug(f"Set last heartbeat {timestamp_str}")
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/cache/facade.pxd` & `nautilus_trader-1.191.0/nautilus_trader/cache/facade.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -51,14 +51,15 @@
 from nautilus_trader.model.position cimport Position
 from nautilus_trader.trading.strategy cimport Strategy
 
 
 cdef class CacheDatabaseFacade:
     cdef Logger _log
 
+    cpdef void close(self)
     cpdef void flush(self)
     cpdef list[str] keys(self, str pattern=*)
     cpdef dict load(self)
     cpdef dict load_currencies(self)
     cpdef dict load_instruments(self)
     cpdef dict load_synthetics(self)
     cpdef dict load_accounts(self)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/cache/facade.pyx` & `nautilus_trader-1.191.0/nautilus_trader/cache/facade.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -61,15 +61,19 @@
     --------
     This class should not be used directly, but through a concrete subclass.
     """
 
     def __init__(self, config: CacheConfig | None = None) -> None:
         self._log = Logger(name=type(self).__name__)
 
-        self._log.info("READY.")
+        self._log.info("READY")
+
+    cpdef void close(self):
+        """Abstract method (implement in subclass)."""
+        raise NotImplementedError("method `close` must be implemented in the subclass")  # pragma: no cover
 
     cpdef void flush(self):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method `flush` must be implemented in the subclass")  # pragma: no cover
 
     cpdef list[str] keys(self, str pattern = "*"):
         """Abstract method (implement in subclass)."""
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/cache/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/common/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/actor.pxd` & `nautilus_trader-1.191.0/nautilus_trader/common/actor.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/actor.pyx` & `nautilus_trader-1.191.0/nautilus_trader/common/actor.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -43,20 +43,20 @@
 from nautilus_trader.common.component cimport REQ
 from nautilus_trader.common.component cimport SENT
 from nautilus_trader.common.component cimport Clock
 from nautilus_trader.common.component cimport Component
 from nautilus_trader.common.component cimport LiveClock
 from nautilus_trader.common.component cimport Logger
 from nautilus_trader.common.component cimport MessageBus
+from nautilus_trader.common.component cimport is_logging_initialized
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.core.message cimport Event
 from nautilus_trader.core.rust.common cimport ComponentState
 from nautilus_trader.core.rust.common cimport LogColor
-from nautilus_trader.core.rust.common cimport logging_is_initialized
 from nautilus_trader.core.rust.model cimport BookType
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.data.messages cimport DataRequest
 from nautilus_trader.data.messages cimport DataResponse
 from nautilus_trader.data.messages cimport Subscribe
 from nautilus_trader.data.messages cimport Unsubscribe
 from nautilus_trader.indicators.base.indicator cimport Indicator
@@ -200,15 +200,15 @@
         Should be overridden in a user implementation.
 
         """
         # Should override in subclass
         self.log.warning(
             "The `Actor.on_start` handler was called when not overridden. "
             "It's expected that any actions required when starting the actor "
-            "occur here, such as subscribing/requesting data.",
+            "occur here, such as subscribing/requesting data",
         )
 
     cpdef void on_stop(self):
         """
         Actions to be performed on stop.
 
         The intent is that this method is called to pause, or when done for day.
@@ -236,15 +236,15 @@
         System method (not intended to be called by user code).
 
         """
         # Should override in subclass
         self.log.warning(
             "The `Actor.on_resume` handler was called when not overridden. "
             "It's expected that any actions required when resuming the actor "
-            "following a stop occur here."
+            "following a stop occur here"
         )
 
     cpdef void on_reset(self):
         """
         Actions to be performed on reset.
 
         Warnings
@@ -254,15 +254,15 @@
         Should be overridden in a user implementation.
 
         """
         # Should override in subclass
         self.log.warning(
             "The `Actor.on_reset` handler was called when not overridden. "
             "It's expected that any actions required when resetting the actor "
-            "occur here, such as resetting indicators and other state."
+            "occur here, such as resetting indicators and other state"
         )
 
     cpdef void on_dispose(self):
         """
         Actions to be performed on dispose.
 
         Cleanup/release any resources used here.
@@ -591,15 +591,15 @@
             If `executor` is not of type `concurrent.futures.Executor`
 
         """
         Condition.type(executor, Executor, "executor")
 
         self._executor = ActorExecutor(loop, executor, logger=self._log)
 
-        self._log.debug(f"Registered {executor}.")
+        self._log.debug(f"Registered {executor}")
 
     cpdef void register_warning_event(self, type event):
         """
         Register the given event type for warning log levels.
 
         Parameters
         ----------
@@ -621,15 +621,15 @@
             The event class to deregister.
 
         """
         Condition.not_none(event, "event")
 
         self._warning_events.discard(event)
 
-        self._log.debug(f"Deregistered `{event.__name__}` from warning log levels.")
+        self._log.debug(f"Deregistered `{event.__name__}` from warning log levels")
 
     cpdef void register_indicator_for_quote_ticks(self, InstrumentId instrument_id, Indicator indicator):
         """
         Register the given indicator with the actor/strategy to receive quote tick
         data for the given instrument ID.
 
         Parameters
@@ -647,17 +647,17 @@
             self._indicators.append(indicator)
 
         if instrument_id not in self._indicators_for_quotes:
             self._indicators_for_quotes[instrument_id] = []  # type: list[Indicator]
 
         if indicator not in self._indicators_for_quotes[instrument_id]:
             self._indicators_for_quotes[instrument_id].append(indicator)
-            self.log.info(f"Registered Indicator {indicator} for {instrument_id} quote ticks.")
+            self.log.info(f"Registered Indicator {indicator} for {instrument_id} quote ticks")
         else:
-            self.log.error(f"Indicator {indicator} already registered for {instrument_id} quote ticks.")
+            self.log.error(f"Indicator {indicator} already registered for {instrument_id} quote ticks")
 
     cpdef void register_indicator_for_trade_ticks(self, InstrumentId instrument_id, Indicator indicator):
         """
         Register the given indicator with the actor/strategy to receive trade tick
         data for the given instrument ID.
 
         Parameters
@@ -675,17 +675,17 @@
             self._indicators.append(indicator)
 
         if instrument_id not in self._indicators_for_trades:
             self._indicators_for_trades[instrument_id] = []  # type: list[Indicator]
 
         if indicator not in self._indicators_for_trades[instrument_id]:
             self._indicators_for_trades[instrument_id].append(indicator)
-            self.log.info(f"Registered Indicator {indicator} for {instrument_id} trade ticks.")
+            self.log.info(f"Registered Indicator {indicator} for {instrument_id} trade ticks")
         else:
-            self.log.error(f"Indicator {indicator} already registered for {instrument_id} trade ticks.")
+            self.log.error(f"Indicator {indicator} already registered for {instrument_id} trade ticks")
 
     cpdef void register_indicator_for_bars(self, BarType bar_type, Indicator indicator):
         """
         Register the given indicator with the actor/strategy to receive bar data for the
         given bar type.
 
         Parameters
@@ -703,17 +703,17 @@
             self._indicators.append(indicator)
 
         if bar_type not in self._indicators_for_bars:
             self._indicators_for_bars[bar_type] = []  # type: list[Indicator]
 
         if indicator not in self._indicators_for_bars[bar_type]:
             self._indicators_for_bars[bar_type].append(indicator)
-            self.log.info(f"Registered Indicator {indicator} for {bar_type} bars.")
+            self.log.info(f"Registered Indicator {indicator} for {bar_type} bars")
         else:
-            self.log.error(f"Indicator {indicator} already registered for {bar_type} bars.")
+            self.log.error(f"Indicator {indicator} already registered for {bar_type} bars")
 
 # -- ACTOR COMMANDS -------------------------------------------------------------------------------
 
     cpdef dict save(self):
         """
         Return the actor/strategy state dictionary to be saved.
 
@@ -727,24 +727,24 @@
         Warnings
         --------
         Exceptions raised will be caught, logged, and reraised.
 
         """
         if not self.is_initialized:
             self.log.error(
-                "Cannot save: actor/strategy has not been registered with a trader.",
+                "Cannot save: actor/strategy has not been registered with a trader",
             )
             return
         try:
-            self.log.debug("Saving state...")
+            self.log.debug("Saving state")
             user_state = self.on_save()
             if len(user_state) > 0:
-                self.log.info(f"Saved state: {list(user_state.keys())}.", color=LogColor.BLUE)
+                self.log.info(f"Saved state: {list(user_state.keys())}", color=LogColor.BLUE)
             else:
-                self.log.info("No user state to save.", color=LogColor.BLUE)
+                self.log.info("No user state to save", color=LogColor.BLUE)
             return user_state
         except Exception as e:
             self.log.exception("Error on save", e)
             raise  # Otherwise invalid state information could be saved
 
     cpdef void load(self, dict state):
         """
@@ -766,21 +766,21 @@
         --------
         Exceptions raised will be caught, logged, and reraised.
 
         """
         Condition.not_none(state, "state")
 
         if not state:
-            self.log.info("No user state to load.", color=LogColor.BLUE)
+            self.log.info("No user state to load", color=LogColor.BLUE)
             return
 
         try:
-            self.log.debug(f"Loading state...")
+            self.log.debug(f"Loading state")
             self.on_load(state)
-            self.log.info(f"Loaded state {list(state.keys())}.", color=LogColor.BLUE)
+            self.log.info(f"Loaded state {list(state.keys())}", color=LogColor.BLUE)
         except Exception as e:
             self.log.exception(f"Error on load {repr(state)}", e)
             raise
 
     cpdef void add_synthetic(self, SyntheticInstrument synthetic):
         """
         Add the created synthetic instrument to the cache.
@@ -874,15 +874,15 @@
             task_id = self._executor.queue_for_executor(
                 func,
                 *args,
                 **kwargs,
             )
 
         self._log.info(
-                f"Executor: Queued {task_id}: {func.__name__}({args=}, {kwargs=}).", LogColor.BLUE,
+            f"Executor: Queued {task_id}: {func.__name__}({args=}, {kwargs=})", LogColor.BLUE,
         )
         return task_id
 
     cpdef run_in_executor(
         self,
         func: Callable[..., Any],
         tuple args=None,
@@ -932,15 +932,15 @@
             task_id = self._executor.run_in_executor(
                 func,
                 *args,
                 **kwargs,
             )
 
         self._log.info(
-            f"Executor: Submitted {task_id}: {func.__name__}({args=}, {kwargs=}).", LogColor.BLUE,
+            f"Executor: Submitted {task_id}: {func.__name__}({args=}, {kwargs=})", LogColor.BLUE,
         )
         return task_id
 
     cpdef list queued_task_ids(self):
         """
         Return the queued task identifiers.
 
@@ -1019,15 +1019,15 @@
         Parameters
         ----------
         task_id : TaskId
             The task identifier.
 
         """
         if self._executor is None:
-            self._log.warning(f"Executor: {task_id} not found.")
+            self._log.warning(f"Executor: {task_id} not found")
             return
 
         self._executor.cancel_task(task_id)
 
     cpdef void cancel_all_tasks(self):
         """
         Cancel all queued and active tasks.
@@ -1047,18 +1047,18 @@
 
         # Clean up clock
         cdef list timer_names = self._clock.timer_names
         self._clock.cancel_timers()
 
         cdef str name
         for name in timer_names:
-            self._log.info(f"Canceled Timer(name={name}).")
+            self._log.info(f"Canceled Timer(name={name})")
 
         if self._executor is not None:
-            self._log.info(f"Canceling executor tasks...")
+            self._log.info(f"Canceling executor tasks")
             self._executor.cancel_all_tasks()
 
     cpdef void _resume(self):
         self.on_resume()
 
     cpdef void _reset(self):
         self.on_reset()
@@ -1493,15 +1493,15 @@
             venue=instrument_id.venue,
             data_type=DataType(InstrumentStatus, metadata={"instrument_id": instrument_id}),
             command_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
         )
 
         self._send_data_cmd(command)
-        self._log.info(f"Subscribed to {instrument_id} InstrumentStatus.")
+        self._log.info(f"Subscribed to {instrument_id} InstrumentStatus")
 
     cpdef void subscribe_instrument_close(self, InstrumentId instrument_id, ClientId client_id = None):
         """
         Subscribe to close updates for the given instrument ID.
 
         Parameters
         ----------
@@ -1799,15 +1799,15 @@
             venue=bar_type.instrument_id.venue,
             data_type=DataType(Bar, metadata={"bar_type": bar_type}),
             command_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
         )
 
         self._send_data_cmd(command)
-        self._log.info(f"Unsubscribed from {bar_type} bar data.")
+        self._log.info(f"Unsubscribed from {bar_type} bar data")
 
     cpdef void unsubscribe_venue_status(self, Venue venue, ClientId client_id = None):
         """
         Unsubscribe to status updates for the given venue.
 
         Parameters
         ----------
@@ -1861,15 +1861,15 @@
             venue=instrument_id.venue,
             data_type=DataType(InstrumentStatus),
             command_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
         )
 
         self._send_data_cmd(command)
-        self._log.info(f"Unsubscribed from {instrument_id} InstrumentStatus.")
+        self._log.info(f"Unsubscribed from {instrument_id} InstrumentStatus")
 
 
     cpdef void publish_data(self, DataType data_type, Data data):
         """
         Publish the given data to the message bus.
 
         Parameters
@@ -2393,17 +2393,17 @@
         Condition.not_none(instruments, "instruments")  # Could be empty
 
         cdef int length = len(instruments)
         cdef Instrument first = instruments[0] if length > 0 else None
         cdef InstrumentId instrument_id = first.id if first is not None else None
 
         if length > 0:
-            self._log.info(f"Received <Instrument[{length}]> data for {instrument_id.venue}.")
+            self._log.info(f"Received <Instrument[{length}]> data for {instrument_id.venue}")
         else:
-            self._log.warning("Received <Instrument[]> data with no instruments.")
+            self._log.warning("Received <Instrument[]> data with no instruments")
 
         cdef int i
         for i in range(length):
             self.handle_instrument(instruments[i])
 
     cpdef void handle_order_book_deltas(self, deltas):
         """
@@ -2509,17 +2509,17 @@
         Condition.not_none(ticks, "ticks")  # Could be empty
 
         cdef int length = len(ticks)
         cdef QuoteTick first = ticks[0] if length > 0 else None
         cdef InstrumentId instrument_id = first.instrument_id if first is not None else None
 
         if length > 0:
-            self._log.info(f"Received <QuoteTick[{length}]> data for {instrument_id}.")
+            self._log.info(f"Received <QuoteTick[{length}]> data for {instrument_id}")
         else:
-            self._log.warning("Received <QuoteTick[]> data with no ticks.")
+            self._log.warning("Received <QuoteTick[]> data with no ticks")
             return
 
         # Update indicators
         cdef list indicators = self._indicators_for_quotes.get(first.instrument_id)
 
         cdef:
             int i
@@ -2579,17 +2579,17 @@
         Condition.not_none(ticks, "ticks")  # Could be empty
 
         cdef int length = len(ticks)
         cdef TradeTick first = ticks[0] if length > 0 else None
         cdef InstrumentId instrument_id = first.instrument_id if first is not None else None
 
         if length > 0:
-            self._log.info(f"Received <TradeTick[{length}]> data for {instrument_id}.")
+            self._log.info(f"Received <TradeTick[{length}]> data for {instrument_id}")
         else:
-            self._log.warning("Received <TradeTick[]> data with no ticks.")
+            self._log.warning("Received <TradeTick[]> data with no ticks")
             return
 
         # Update indicators
         cdef list indicators = self._indicators_for_trades.get(first.instrument_id)
 
         cdef:
             int i
@@ -2649,17 +2649,17 @@
         Condition.not_none(bars, "bars")  # Can be empty
 
         cdef int length = len(bars)
         cdef Bar first = bars[0] if length > 0 else None
         cdef Bar last = bars[length - 1] if length > 0 else None
 
         if length > 0:
-            self._log.info(f"Received <Bar[{length}]> data for {first.bar_type}.")
+            self._log.info(f"Received <Bar[{length}]> data for {first.bar_type}")
         else:
-            self._log.error(f"Received <Bar[{length}]> data for unknown bar type.")
+            self._log.error(f"Received <Bar[{length}]> data for unknown bar type")
             return
 
         if length > 0 and first.ts_init > last.ts_init:
             raise RuntimeError(f"cannot handle <Bar[{length}]> data: incorrectly sorted")
 
         # Update indicators
         cdef list indicators = self._indicators_for_bars.get(first.bar_type)
@@ -2867,15 +2867,15 @@
         cdef Indicator indicator
         for indicator in indicators:
             indicator.handle_bar(bar)
 
 # -- EGRESS ---------------------------------------------------------------------------------------
 
     cdef void _send_data_cmd(self, DataCommand command):
-        if logging_is_initialized():
-            self._log.info(f"{CMD}{SENT} {command}.")
+        if is_logging_initialized():
+            self._log.info(f"{CMD}{SENT} {command}")
         self._msgbus.send(endpoint="DataEngine.execute", msg=command)
 
     cdef void _send_data_req(self, DataRequest request):
-        if logging_is_initialized():
-            self._log.info(f"{REQ}{SENT} {request}.")
+        if is_logging_initialized():
+            self._log.info(f"{REQ}{SENT} {request}")
         self._msgbus.request(endpoint="DataEngine.request", request=request)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/component.pxd` & `nautilus_trader-1.191.0/nautilus_trader/common/component.pxd`

 * *Files 0% similar despite different names*

```diff
@@ -27,15 +27,14 @@
 from nautilus_trader.core.message cimport Response
 from nautilus_trader.core.rust.common cimport ComponentState
 from nautilus_trader.core.rust.common cimport ComponentTrigger
 from nautilus_trader.core.rust.common cimport LiveClock_API
 from nautilus_trader.core.rust.common cimport LogColor
 from nautilus_trader.core.rust.common cimport LogGuard_API
 from nautilus_trader.core.rust.common cimport LogLevel
-from nautilus_trader.core.rust.common cimport MessageBus_API
 from nautilus_trader.core.rust.common cimport TestClock_API
 from nautilus_trader.core.rust.common cimport TimeEvent_t
 from nautilus_trader.core.rust.core cimport CVec
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.model.identifiers cimport Identifier
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.serialization.base cimport Serializer
@@ -243,50 +242,52 @@
         ComponentTrigger trigger,
         bint is_transitory,
         action: Callable[[None], None]=*,
     )
 
 
 cdef class MessageBus:
-    cdef MessageBus_API _mem
     cdef Clock _clock
     cdef Logger _log
+    cdef object _database
     cdef dict[Subscription, list[str]] _subscriptions
     cdef dict[str, Subscription[:]] _patterns
     cdef dict[str, object] _endpoints
     cdef dict[UUID4, object] _correlation_index
-    cdef bint _has_backing
     cdef tuple[type] _publishable_types
+    cdef bint _has_backing
+    cdef bint _resolved
 
     cdef readonly TraderId trader_id
     """The trader ID associated with the bus.\n\n:returns: `TraderId`"""
     cdef readonly Serializer serializer
     """The serializer for the bus.\n\n:returns: `Serializer`"""
     cdef readonly bint has_backing
     """If the message bus has a database backing.\n\n:returns: `bool`"""
     cdef readonly bint snapshot_orders
     """If order state snapshots should be published externally.\n\n:returns: `bool`"""
     cdef readonly bint snapshot_positions
     """If position state snapshots should be published externally.\n\n:returns: `bool`"""
-    cdef readonly int sent_count
-    """The count of messages sent through the bus.\n\n:returns: `int`"""
-    cdef readonly int req_count
-    """The count of requests processed by the bus.\n\n:returns: `int`"""
-    cdef readonly int res_count
-    """The count of responses processed by the bus.\n\n:returns: `int`"""
-    cdef readonly int pub_count
-    """The count of messages published by the bus.\n\n:returns: `int`"""
+    cdef readonly uint64_t sent_count
+    """The count of messages sent through the bus.\n\n:returns: `uint64_t`"""
+    cdef readonly uint64_t req_count
+    """The count of requests processed by the bus.\n\n:returns: `uint64_t`"""
+    cdef readonly uint64_t res_count
+    """The count of responses processed by the bus.\n\n:returns: `uint64_t`"""
+    cdef readonly uint64_t pub_count
+    """The count of messages published by the bus.\n\n:returns: `uint64_t`"""
 
     cpdef list endpoints(self)
     cpdef list topics(self)
     cpdef list subscriptions(self, str pattern=*)
     cpdef bint has_subscribers(self, str pattern=*)
     cpdef bint is_subscribed(self, str topic, handler)
     cpdef bint is_pending_request(self, UUID4 request_id)
 
+    cpdef void dispose(self)
     cpdef void register(self, str endpoint, handler)
     cpdef void deregister(self, str endpoint, handler)
     cpdef void send(self, str endpoint, msg)
     cpdef void request(self, str endpoint, Request request)
     cpdef void response(self, Response response)
     cpdef void subscribe(self, str topic, handler, int priority=*)
     cpdef void unsubscribe(self, str topic, handler)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/component.pyx` & `nautilus_trader-1.191.0/nautilus_trader/common/component.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -11,22 +11,18 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import asyncio
 import copy
-import platform
 import socket
 import sys
-import time
 import traceback
 from collections import deque
-from platform import python_version
-from threading import Timer as TimerThread
 from typing import Any
 from typing import Callable
 
 import cython
 import msgspec
 import numpy as np
 import pandas as pd
@@ -90,17 +86,14 @@
 from nautilus_trader.core.rust.common cimport logging_clock_set_static_time
 from nautilus_trader.core.rust.common cimport logging_init
 from nautilus_trader.core.rust.common cimport logging_is_colored
 from nautilus_trader.core.rust.common cimport logging_is_initialized
 from nautilus_trader.core.rust.common cimport logging_log_header
 from nautilus_trader.core.rust.common cimport logging_log_sysinfo
 from nautilus_trader.core.rust.common cimport logging_shutdown
-from nautilus_trader.core.rust.common cimport msgbus_drop
-from nautilus_trader.core.rust.common cimport msgbus_new
-from nautilus_trader.core.rust.common cimport msgbus_publish_external
 from nautilus_trader.core.rust.common cimport test_clock_advance_time
 from nautilus_trader.core.rust.common cimport test_clock_cancel_timer
 from nautilus_trader.core.rust.common cimport test_clock_cancel_timers
 from nautilus_trader.core.rust.common cimport test_clock_drop
 from nautilus_trader.core.rust.common cimport test_clock_new
 from nautilus_trader.core.rust.common cimport test_clock_next_time
 from nautilus_trader.core.rust.common cimport test_clock_register_default_handler
@@ -774,22 +767,14 @@
         Condition.not_in(name, self.timer_names, "name", "self.timer_names")
         Condition.not_in(name, self.timer_names, "name", "self.timer_names")
         Condition.positive_int(interval_ns, "interval_ns")
 
         if callback is not None:
             callback = create_pyo3_conversion_wrapper(callback)
 
-        cdef uint64_t ts_now = self.timestamp_ns()  # Call here for greater accuracy
-
-        if start_time_ns == 0:
-            start_time_ns = ts_now
-        if stop_time_ns:
-            Condition.true(stop_time_ns > ts_now, "stop_time was < ts_now")
-            Condition.true(start_time_ns + interval_ns <= stop_time_ns, "start_time + interval was > stop_time")
-
         live_clock_set_timer(
             &self._mem,
             pystr_to_cstr(name),
             interval_ns,
             start_time_ns,
             stop_time_ns,
             <PyObject *>callback,
@@ -1125,15 +1110,14 @@
     )
 
     cdef LogGuard log_guard = LogGuard.__new__(LogGuard)
     log_guard._mem = log_guard_api
     return log_guard
 
 
-
 LOGGING_PYO3 = False
 
 
 cpdef bint is_logging_initialized():
     if LOGGING_PYO3:
         return True
     return <bint>logging_is_initialized()
@@ -1916,21 +1900,21 @@
         ComponentTrigger trigger,
         bint is_transitory,
         action: Callable[[None], None] | None = None,
     ):
         try:
             self._fsm.trigger(trigger)
         except InvalidStateTrigger as e:
-            self._log.error(f"{repr(e)} state {self._fsm.state_string_c()}.")
+            self._log.error(f"{repr(e)} state {self._fsm.state_string_c()}")
             return  # Guards against invalid state
 
         if is_transitory:
-            self._log.debug(f"{self._fsm.state_string_c()}...")
+            self._log.debug(f"{self._fsm.state_string_c()}")
         else:
-            self._log.info(f"{self._fsm.state_string_c()}.")
+            self._log.info(f"{self._fsm.state_string_c()}")
 
         if action is not None:
             action()
 
         if self._fsm == ComponentState.PRE_INITIALIZED:
             return  # Cannot publish event
 
@@ -1981,14 +1965,16 @@
         The trader ID associated with the message bus.
     clock : Clock
         The clock for the message bus.
     name : str, optional
         The custom name for the message bus.
     serializer : Serializer, optional
         The serializer for database operations.
+    database : nautilus_pyo3.RedisMessageBusDatabase, optional
+        The backing database for the message bus.
     snapshot_orders : bool, default False
         If order state snapshots should be published externally.
     snapshot_positions : bool, default False
         If position state snapshots should be published externally.
     config : MessageBusConfig, optional
         The configuration for the message bus.
 
@@ -2006,44 +1992,46 @@
     def __init__(
         self,
         TraderId trader_id not None,
         Clock clock,
         UUID4 instance_id = None,
         str name = None,
         Serializer serializer = None,
+        database: nautilus_pyo3.RedisMessageBusDatabase | None = None,
         bint snapshot_orders: bool = False,
         bint snapshot_positions: bool = False,
         config: Any | None = None,
-    ):
+    ) -> None:
         # Temporary fix for import error
         from nautilus_trader.common.config import MessageBusConfig
 
         if instance_id is None:
             instance_id = UUID4()
         if name is None:
             name = type(self).__name__
         Condition.valid_string(name, "name")
         if config is None:
             config = MessageBusConfig()
         Condition.type(config, MessageBusConfig, "config")
 
         self.trader_id = trader_id
         self.serializer = serializer
-        self.has_backing = config.database is not None
+        self.has_backing = database is not None
         self.snapshot_orders = snapshot_orders
         self.snapshot_positions = snapshot_positions
 
         self._clock = clock
         self._log = Logger(name)
+        self._database = database
 
         # Validate configuration
         if config.buffer_interval_ms and config.buffer_interval_ms > 1000:
             self._log.warning(
                 f"High `buffer_interval_ms` at {config.buffer_interval_ms}, "
-                "recommended range is [10, 1000] milliseconds.",
+                "recommended range is [10, 1000] milliseconds",
             )
 
         # Configuration
         self._log.info(f"{config.database=}", LogColor.BLUE)
         self._log.info(f"{config.encoding=}", LogColor.BLUE)
         self._log.info(f"{config.timestamps_as_iso8601=}", LogColor.BLUE)
         self._log.info(f"{config.buffer_interval_ms=}", LogColor.BLUE)
@@ -2055,40 +2043,29 @@
         self._log.info(f"{config.types_filter=}", LogColor.BLUE)
 
         # Copy and clear `types_filter` before passing down to the core MessageBus
         cdef list types_filter = copy.copy(config.types_filter)
         if config.types_filter is not None:
             config.types_filter.clear()
 
-        self._mem = msgbus_new(
-            pystr_to_cstr(trader_id.value),
-            pystr_to_cstr(name) if name else NULL,
-            pystr_to_cstr(instance_id.to_str()),
-            pybytes_to_cstr(msgspec.json.encode(config)),
-        )
-
         self._endpoints: dict[str, Callable[[Any], None]] = {}
         self._patterns: dict[str, Subscription[:]] = {}
         self._subscriptions: dict[Subscription, list[str]] = {}
         self._correlation_index: dict[UUID4, Callable[[Any], None]] = {}
-        self._has_backing = config.database is not None
         self._publishable_types = tuple(_EXTERNAL_PUBLISHABLE_TYPES)
         if types_filter is not None:
             self._publishable_types = tuple(o for o in _EXTERNAL_PUBLISHABLE_TYPES if o not in types_filter)
+        self._resolved = False
 
         # Counters
         self.sent_count = 0
         self.req_count = 0
         self.res_count = 0
         self.pub_count = 0
 
-    def __del__(self) -> None:
-        if self._mem._0 != NULL:
-            msgbus_drop(self._mem)
-
     cpdef list endpoints(self):
         """
         Return all endpoint addresses registered with the message bus.
 
         Returns
         -------
         list[str]
@@ -2188,14 +2165,26 @@
         bool
 
         """
         Condition.not_none(request_id, "request_id")
 
         return request_id in self._correlation_index
 
+    cpdef void dispose(self):
+        """
+        Dispose of the message bus which will close the internal channel and thread.
+
+        """
+        self._log.debug("Closing message bus")
+
+        if self._database is not None:
+            self._database.close()
+
+        self._log.info("Closed message bus")
+
     cpdef void register(self, str endpoint, handler: Callable[[Any], None]):
         """
         Register the given `handler` to receive messages at the `endpoint` address.
 
         Parameters
         ----------
         endpoint : str
@@ -2215,15 +2204,15 @@
         """
         Condition.valid_string(endpoint, "endpoint")
         Condition.callable(handler, "handler")
         Condition.not_in(endpoint, self._endpoints, "endpoint", "_endpoints")
 
         self._endpoints[endpoint] = handler
 
-        self._log.debug(f"Added endpoint '{endpoint}' {handler}.")
+        self._log.debug(f"Added endpoint '{endpoint}' {handler}")
 
     cpdef void deregister(self, str endpoint, handler: Callable[[Any], None]):
         """
         Deregister the given `handler` from the `endpoint` address.
 
         Parameters
         ----------
@@ -2247,15 +2236,15 @@
         Condition.valid_string(endpoint, "endpoint")
         Condition.callable(handler, "handler")
         Condition.is_in(endpoint, self._endpoints, "endpoint", "self._endpoints")
         Condition.equal(handler, self._endpoints[endpoint], "handler", "self._endpoints[endpoint]")
 
         del self._endpoints[endpoint]
 
-        self._log.debug(f"Removed endpoint '{endpoint}' {handler}.")
+        self._log.debug(f"Removed endpoint '{endpoint}' {handler}")
 
     cpdef void send(self, str endpoint, msg: Any):
         """
         Send the given message to the given `endpoint` address.
 
         Parameters
         ----------
@@ -2267,15 +2256,15 @@
         """
         Condition.not_none(endpoint, "endpoint")
         Condition.not_none(msg, "msg")
 
         handler = self._endpoints.get(endpoint)
         if handler is None:
             self._log.error(
-                f"Cannot send message: no endpoint registered at '{endpoint}'.",
+                f"Cannot send message: no endpoint registered at '{endpoint}'",
             )
             return  # Cannot send
 
         handler(msg)
         self.sent_count += 1
 
     cpdef void request(self, str endpoint, Request request):
@@ -2294,24 +2283,24 @@
         """
         Condition.not_none(endpoint, "endpoint")
         Condition.not_none(request, "request")
 
         if request.id in self._correlation_index:
             self._log.error(
                 f"Cannot handle request: "
-                f"duplicate ID {request.id} found in correlation index.",
+                f"duplicate ID {request.id} found in correlation index",
             )
             return  # Do not handle duplicates
 
         self._correlation_index[request.id] = request.callback
 
         handler = self._endpoints.get(endpoint)
         if handler is None:
             self._log.error(
-                f"Cannot handle request: no endpoint registered at '{endpoint}'.",
+                f"Cannot handle request: no endpoint registered at '{endpoint}'",
             )
             return  # Cannot handle
 
         handler(request)
         self.req_count += 1
 
     cpdef void response(self, Response response):
@@ -2328,15 +2317,15 @@
         """
         Condition.not_none(response, "response")
 
         callback = self._correlation_index.pop(response.correlation_id, None)
         if callback is None:
             self._log.error(
                 f"Cannot handle response: "
-                f"callback not found for correlation_id {response.correlation_id}.",
+                f"callback not found for correlation_id {response.correlation_id}",
             )
             return  # Cannot handle
 
         callback(response)
         self.res_count += 1
 
     cpdef void subscribe(
@@ -2385,15 +2374,15 @@
             topic=topic,
             handler=handler,
             priority=priority,
         )
 
         # Check if already exists
         if sub in self._subscriptions:
-            self._log.debug(f"{sub} already exists.")
+            self._log.debug(f"{sub} already exists")
             return
 
         cdef list matches = []
         cdef list patterns = list(self._patterns.keys())
 
         cdef str pattern
         cdef list subs
@@ -2403,15 +2392,17 @@
                 subs.append(sub)
                 subs = sorted(subs, reverse=True)
                 self._patterns[pattern] = np.ascontiguousarray(subs, dtype=Subscription)
                 matches.append(pattern)
 
         self._subscriptions[sub] = sorted(matches)
 
-        self._log.debug(f"Added {sub}.")
+        self._resolved = False
+
+        self._log.debug(f"Added {sub}")
 
     cpdef void unsubscribe(self, str topic, handler: Callable[[Any], None]):
         """
         Unsubscribe the given callback `handler` from the given message `topic`.
 
         Parameters
         ----------
@@ -2434,27 +2425,29 @@
 
         cdef Subscription sub = Subscription(topic=topic, handler=handler)
 
         cdef list patterns = self._subscriptions.get(sub)
 
         # Check if exists
         if patterns is None:
-            self._log.warning(f"{sub} not found.")
+            self._log.warning(f"{sub} not found")
             return
 
         cdef str pattern
         for pattern in patterns:
             subs = list(self._patterns[pattern])
             subs.remove(sub)
             subs = sorted(subs, reverse=True)
             self._patterns[pattern] = np.ascontiguousarray(subs, dtype=Subscription)
 
         del self._subscriptions[sub]
 
-        self._log.debug(f"Removed {sub}.")
+        self._resolved = False
+
+        self._log.debug(f"Removed {sub}")
 
     cpdef void publish(self, str topic, msg: Any):
         """
         Publish the given message for the given `topic`.
 
         Subscription handlers will receive the message in priority order
         (highest first).
@@ -2472,39 +2465,40 @@
     @cython.boundscheck(False)
     @cython.wraparound(False)
     cdef void publish_c(self, str topic, msg: Any):
         Condition.not_none(topic, "topic")
         Condition.not_none(msg, "msg")
 
         # Get all subscriptions matching topic pattern
+        # Note: cannot use truthiness on array
         cdef Subscription[:] subs = self._patterns.get(topic)
-        if subs is None or len(subs) == 0:  # Cannot use truthiness on array
+        if subs is None or (not self._resolved and len(subs) == 0):
             # Add the topic pattern and get matching subscribers
             subs = self._resolve_subscriptions(topic)
+            self._resolved = True
 
         # Send message to all matched subscribers
         cdef:
             int i
             Subscription sub
         for i in range(len(subs)):
             sub = subs[i]
             sub.handler(msg)
 
         # Publish externally (if configured)
         cdef bytes payload_bytes
-        if self._has_backing and self.serializer is not None:
+        if self._database is not None and self.serializer is not None:
             if isinstance(msg, self._publishable_types):
                 if isinstance(msg, bytes):
                     payload_bytes = msg
                 else:
                     payload_bytes = self.serializer.serialize(msg)
-                msgbus_publish_external(
-                    &self._mem,
-                    pystr_to_cstr(topic),
-                    pybytes_to_cstr(payload_bytes),
+                self._database.publish(
+                    topic,
+                    payload_bytes,
                 )
 
         self.pub_count += 1
 
     cdef Subscription[:] _resolve_subscriptions(self, str topic):
         cdef list subs_list = []
         cdef Subscription existing_sub
@@ -2711,15 +2705,15 @@
         self.name = name
         self.limit = limit
         self.interval = interval
         self.is_limiting = False
         self.recv_count = 0
         self.sent_count = 0
 
-        self._log.info("READY.")
+        self._log.info("READY")
 
     @property
     def qsize(self) -> int:
         """
         Return the qsize of the internal buffer.
 
         Returns
@@ -2798,20 +2792,20 @@
         return self._interval_ns - diff
 
     cdef void _limit_msg(self, msg):
         if self._output_drop is None:
             # Buffer
             self._buffer.appendleft(msg)
             timer_target = self._process
-            self._log.warning(f"Buffering {msg}.")
+            self._log.warning(f"Buffering {msg}")
         else:
             # Drop
             self._output_drop(msg)
             timer_target = self._resume
-            self._log.warning(f"Dropped {msg}.")
+            self._log.warning(f"Dropped {msg}")
 
         if not self.is_limiting:
             self._set_timer(timer_target)
             self.is_limiting = True
 
     cdef void _set_timer(self, handler: Callable[[TimeEvent], None]):
         # Cancel any existing timer
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/config.py` & `nautilus_trader-1.191.0/nautilus_trader/common/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/enums.py` & `nautilus_trader-1.191.0/nautilus_trader/common/enums.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/executor.py` & `nautilus_trader-1.191.0/nautilus_trader/common/executor.py`

 * *Files 2% similar despite different names*

```diff
@@ -142,21 +142,21 @@
         """
         self._worker_task.cancel()
         try:
             await asyncio.wait_for(self._worker_task, timeout=2.0)
         except asyncio.CancelledError:
             pass  # Ignore the exception since we intentionally cancelled the task
         except asyncio.TimeoutError:
-            self._log.error("Executor: TimeoutError shutting down worker.")
+            self._log.error("Executor: TimeoutError shutting down worker")
 
     def _drain_queue(self) -> None:
         # Drain the internal task queue (this will not execute the tasks)
         while not self._queue.empty():
             task_id, _, _, _ = self._queue.get_nowait()
-            self._log.info(f"Executor: Dequeued {task_id} prior to execution.")
+            self._log.info(f"Executor: Dequeued {task_id} prior to execution")
         self._queued_tasks.clear()
 
     def _add_active_task(self, task_id: TaskId, task: Future[Any]) -> None:
         self._active_tasks[task_id] = task
         self._future_index[task] = task_id
 
     async def _worker(self) -> None:
@@ -165,41 +165,41 @@
                 task_id, func, args, kwargs = await self._queue.get()
                 if task_id not in self._queued_tasks:
                     continue  # Already canceled
 
                 task = self._submit_to_executor(func, *args, **kwargs)
 
                 self._add_active_task(task_id, task)
-                self._log.debug(f"Executor: Scheduled {task_id}, {task} ...")
+                self._log.debug(f"Executor: Scheduled {task_id}, {task}")
 
                 # Sequentially execute tasks
                 await asyncio.wrap_future(self._active_tasks[task_id])
                 self._queue.task_done()
         except asyncio.CancelledError:
-            self._log.debug("Executor: Canceled inner worker task.")
+            self._log.debug("Executor: Canceled inner worker task")
 
     def _remove_done_task(self, task: Future[Any]) -> None:
         task_id = self._future_index.pop(task, None)
         if not task_id:
-            self._log.error(f"Executor: {task} not found on done callback.")
+            self._log.error(f"Executor: {task} not found on done callback")
             return
 
         self._active_tasks.pop(task_id, None)
         self._queued_tasks.discard(task_id)
 
         if task.done():
             try:
                 if task.exception() is not None:
                     self._log.error(f"Executor: Exception in {task_id}: {task.exception()}")
                     return
             except asyncio.CancelledError:
                 # Make this a warning level for now
-                self._log.warning(f"Executor: Canceled {task_id}.")
+                self._log.warning(f"Executor: Canceled {task_id}")
                 return
-            self._log.info(f"Executor: Completed {task_id}.")
+            self._log.info(f"Executor: Completed {task_id}")
 
     def _submit_to_executor(
         self,
         func: Callable[..., Any],
         *args: Any,
         **kwargs: Any,
     ) -> Future[Any]:
@@ -262,15 +262,15 @@
         """
         self._log.info(f"Executor: {type(func).__name__}({args=}, {kwargs=})")
         task: Future = self._submit_to_executor(func, *args, **kwargs)
 
         task_id = TaskId.create()
         self._active_tasks[task_id] = task
         self._future_index[task] = task_id
-        self._log.debug(f"Executor: Scheduled {task_id}, {task} ...")
+        self._log.debug(f"Executor: Scheduled {task_id}, {task}")
 
         return task_id
 
     def queued_task_ids(self) -> list[TaskId]:
         """
         Return the queued task identifiers.
 
@@ -324,26 +324,26 @@
         ----------
         task_id : TaskId
             The active task identifier.
 
         """
         if task_id in self._queued_tasks:
             self._queued_tasks.discard(task_id)
-            self._log.info(f"Executor: Canceled {task_id} prior to execution.")
+            self._log.info(f"Executor: Canceled {task_id} prior to execution")
             return
 
         task: Future | None = self._active_tasks.pop(task_id, None)
         if not task:
-            self._log.warning(f"Executor: {task_id} not found.")
+            self._log.warning(f"Executor: {task_id} not found")
             return
 
         self._future_index.pop(task, None)
 
         result = task.cancel()
-        self._log.info(f"Executor: Canceled {task_id} with result {result}.")
+        self._log.info(f"Executor: Canceled {task_id} with result {result}")
 
     def cancel_all_tasks(self) -> None:
         """
         Cancel all active and queued tasks.
         """
         self._drain_queue()
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/factories.pxd` & `nautilus_trader-1.191.0/nautilus_trader/common/factories.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/factories.pyx` & `nautilus_trader-1.191.0/nautilus_trader/common/factories.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/functions.py` & `nautilus_trader-1.191.0/nautilus_trader/common/functions.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/generators.pxd` & `nautilus_trader-1.191.0/nautilus_trader/common/generators.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/generators.pyx` & `nautilus_trader-1.191.0/nautilus_trader/common/generators.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/messages.pxd` & `nautilus_trader-1.191.0/nautilus_trader/common/messages.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/messages.pyx` & `nautilus_trader-1.191.0/nautilus_trader/common/messages.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/common/providers.py` & `nautilus_trader-1.191.0/nautilus_trader/common/providers.py`

 * *Files 1% similar despite different names*

```diff
@@ -53,15 +53,15 @@
 
         # Async loading flags
         self._loaded = False
         self._loading = False
 
         self._tasks: set[asyncio.Task] = set()
 
-        self._log.info("READY.")
+        self._log.info("READY")
 
     @property
     def count(self) -> int:
         """
         Return the count of instruments held by the provider.
 
         Returns
@@ -146,15 +146,15 @@
             # Set async loading flag
             self._loading = True
             if self._load_all_on_start:
                 await self.load_all_async(self._filters)
             elif self._load_ids_on_start:
                 instrument_ids = [InstrumentId.from_str(i) for i in self._load_ids_on_start]
                 await self.load_ids_async(instrument_ids, self._filters)
-            self._log.info(f"Loaded {self.count} instruments.")
+            self._log.info(f"Loaded {self.count} instruments")
         else:
             self._log.debug("Awaiting loading...")
             while self._loading:
                 # Wait 100ms
                 await asyncio.sleep(0.1)
 
         # Set async loading flags
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/config/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/config/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/common/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/core/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/asynchronous.py` & `nautilus_trader-1.191.0/nautilus_trader/core/asynchronous.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/correctness.pxd` & `nautilus_trader-1.191.0/nautilus_trader/core/correctness.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/correctness.pyx` & `nautilus_trader-1.191.0/nautilus_trader/core/correctness.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/data.pxd` & `nautilus_trader-1.191.0/nautilus_trader/live/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -8,11 +8,15 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
+"""
+The `live` subpackage groups all engine and client implementations for live trading.
 
+Generally a common event loop is passed into each live engine to support the overarching
+design of a single efficient event loop, by default
+`uvloop <https://github.com/MagicStack/uvloop>`_.
 
-cdef class Data:
-    pass
+"""
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/data.pyx` & `nautilus_trader-1.191.0/nautilus_trader/core/data.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/datetime.pxd` & `nautilus_trader-1.191.0/nautilus_trader/core/datetime.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/datetime.pyx` & `nautilus_trader-1.191.0/nautilus_trader/core/datetime.pyx`

 * *Files 10% similar despite different names*

```diff
@@ -17,14 +17,15 @@
 This module provides efficient functions for performing standard datetime related operations.
 
 Functions include awareness/tz checks and conversions, as well as ISO 8601 conversion.
 """
 
 import pandas as pd
 import pytz
+from pandas.api.types import is_datetime64_ns_dtype
 
 # Re-exports
 from nautilus_trader.core.nautilus_pyo3 import micros_to_nanos as micros_to_nanos
 from nautilus_trader.core.nautilus_pyo3 import millis_to_nanos as millis_to_nanos
 from nautilus_trader.core.nautilus_pyo3 import nanos_to_micros as nanos_to_micros
 from nautilus_trader.core.nautilus_pyo3 import nanos_to_millis as nanos_to_millis
 from nautilus_trader.core.nautilus_pyo3 import nanos_to_secs as nanos_to_secs
@@ -242,20 +243,25 @@
 
     """
     Condition.not_none(data, "data")
 
     if data.empty:
         return data
 
+    # Ensure the index is localized to UTC
     if data.index.tzinfo is None:  # tz-naive
-        return data.tz_localize(pytz.utc)
+        data = data.tz_localize(pytz.utc)
     elif data.index.tzinfo != pytz.utc:
-        return data.tz_convert(None).tz_localize(pytz.utc)
-    else:
-        return data  # Already UTC
+        data = data.tz_convert(None).tz_localize(pytz.utc)
+
+    # Check if the index is in nanosecond resolution, convert if not
+    if not is_datetime64_ns_dtype(data.index.dtype):
+        data.index = data.index.astype("datetime64[ns, UTC]")
+
+    return data
 
 
 cpdef str format_iso8601(datetime dt):
     """
     Format the given datetime to a millisecond accurate ISO 8601 specification
     string.
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/fsm.pxd` & `nautilus_trader-1.191.0/nautilus_trader/core/fsm.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/fsm.pyx` & `nautilus_trader-1.191.0/nautilus_trader/core/fsm.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/includes/algorithms.h` & `nautilus_trader-1.191.0/nautilus_trader/core/includes/algorithms.h`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/includes/backtest.h` & `nautilus_trader-1.191.0/nautilus_trader/core/includes/backtest.h`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/includes/core.h` & `nautilus_trader-1.191.0/nautilus_trader/core/includes/core.h`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/includes/model.h` & `nautilus_trader-1.191.0/nautilus_trader/core/includes/model.h`

 * *Files 1% similar despite different names*

```diff
@@ -204,15 +204,15 @@
     /**
      * Trading halt is imposed by the venue to protect against extreme volatility.
      */
     VOLATILITY = 3,
 } HaltReason;
 
 /**
- * The asset type for a financial market product.
+ * The instrument class.
  */
 typedef enum InstrumentClass {
     /**
      * A spot market instrument class. The current market price of an instrument that is bought or sold for immediate delivery and payment.
      */
     SPOT = 1,
     /**
@@ -268,15 +268,15 @@
     /**
      * When the instrument expiration was reached.
      */
     CONTRACT_EXPIRED = 2,
 } InstrumentCloseType;
 
 /**
- * The liqudity side for a trade in a financial market.
+ * The liqudity side for a trade.
  */
 typedef enum LiquiditySide {
     /**
      * No liquidity side specified.
      */
     NO_LIQUIDITY_SIDE = 0,
     /**
@@ -324,15 +324,15 @@
 } MarketStatus;
 
 /**
  * The order management system (OMS) type for a trading venue or trading strategy.
  */
 typedef enum OmsType {
     /**
-     * There is no specific type of order management specified (will defer to the venue).
+     * There is no specific type of order management specified (will defer to the venue OMS).
      */
     UNSPECIFIED = 0,
     /**
      * The netting type where there is one position per instrument.
      */
     NETTING = 1,
     /**
@@ -517,15 +517,15 @@
     /**
      * A short position in the market, typically acquired through one or many SELL orders.
      */
     SHORT = 3,
 } PositionSide;
 
 /**
- * The type of price for an instrument in a financial market.
+ * The type of price for an instrument in market.
  */
 typedef enum PriceType {
     /**
      * A quoted order price where a buyer is willing to buy a quantity of an instrument.
      */
     BID = 1,
     /**
@@ -539,15 +539,45 @@
     /**
      * The last price at which a trade was made for an instrument.
      */
     LAST = 4,
 } PriceType;
 
 /**
- * The 'Time in Force' instruction for an order in the financial market.
+ * A record flag bit field, indicating packet end and data information.
+ */
+typedef enum RecordFlag {
+    /**
+     * Last message in the packet from the venue for a given `instrument_id`.
+     */
+    F_LAST = (1 << 7),
+    /**
+     * Top-of-book message, not an individual order.
+     */
+    F_TOB = (1 << 6),
+    /**
+     * Message sourced from a replay, such as a snapshot server.
+     */
+    F_SNAPSHOT = (1 << 5),
+    /**
+     * Aggregated price level message, not an individual order.
+     */
+    F_MBP = (1 << 4),
+    /**
+     * Reserved for future use.
+     */
+    RESERVED_2 = (1 << 3),
+    /**
+     * Reserved for future use.
+     */
+    RESERVED_1 = (1 << 2),
+} RecordFlag;
+
+/**
+ * The 'Time in Force' instruction for an order.
  */
 typedef enum TimeInForce {
     /**
      * Good Till Canceled (GTC) - the order remains active until canceled.
      */
     GTC = 1,
     /**
@@ -670,15 +700,23 @@
  * Represents a discrete price level in an order book.
  *
  * The level maintains a collection of orders as well as tracking insertion order
  * to preserve FIFO queue dynamics.
  */
 typedef struct Level Level;
 
-typedef struct OrderBookContainer OrderBookContainer;
+/**
+ * Provides an order book.
+ *
+ * Can handle the following granularity data:
+ * - MBO (market by order) / L3
+ * - MBP (market by price) / L2 aggregated order per level
+ * - MBP (market by price) / L1 top-of-book only
+ */
+typedef struct OrderBook OrderBook;
 
 /**
  * Represents a grouped batch of `OrderBookDelta` updates for an `OrderBook`.
  *
  * This type cannot be `repr(C)` due to the `deltas` vec.
  */
 typedef struct OrderBookDeltas_t OrderBookDeltas_t;
@@ -686,31 +724,25 @@
 /**
  * Represents a synthetic instrument with prices derived from component instruments using a
  * formula.
  */
 typedef struct SyntheticInstrument SyntheticInstrument;
 
 /**
- * Represents a valid ticker symbol ID for a tradable financial market instrument.
+ * Represents a valid ticker symbol ID for a tradable instrument.
  */
 typedef struct Symbol_t {
-    /**
-     * The ticker symbol ID value.
-     */
-    char* value;
+    char* _0;
 } Symbol_t;
 
 /**
  * Represents a valid trading venue ID.
  */
 typedef struct Venue_t {
-    /**
-     * The venue ID value.
-     */
-    char* value;
+    char* _0;
 } Venue_t;
 
 /**
  * Represents a valid instrument ID.
  *
  * The symbol and venue combination should uniquely identify the instrument.
  */
@@ -770,27 +802,27 @@
      */
     enum BookAction action;
     /**
      * The order to apply.
      */
     struct BookOrder_t order;
     /**
-     * A combination of packet end with matching engine status.
+     * The record flags bit field, indicating packet end and data information.
      */
     uint8_t flags;
     /**
      * The message sequence number assigned at the venue.
      */
     uint64_t sequence;
     /**
-     * The UNIX timestamp (nanoseconds) when the data event occurred.
+     * The UNIX timestamp (nanoseconds) when the book event occurred.
      */
     uint64_t ts_event;
     /**
-     * The UNIX timestamp (nanoseconds) when the data object was initialized.
+     * The UNIX timestamp (nanoseconds) when the struct was initialized.
      */
     uint64_t ts_init;
 } OrderBookDelta_t;
 
 /**
  * Provides a C compatible Foreign Function Interface (FFI) for an underlying [`OrderBookDeltas`].
  *
@@ -834,33 +866,33 @@
      */
     uint32_t bid_counts[DEPTH10_LEN];
     /**
      * The count of ask orders per level for the depth update.
      */
     uint32_t ask_counts[DEPTH10_LEN];
     /**
-     * A combination of packet end with matching engine status.
+     * The record flags bit field, indicating packet end and data information.
      */
     uint8_t flags;
     /**
      * The message sequence number assigned at the venue.
      */
     uint64_t sequence;
     /**
-     * The UNIX timestamp (nanoseconds) when the data event occurred.
+     * The UNIX timestamp (nanoseconds) when the book event occurred.
      */
     uint64_t ts_event;
     /**
-     * The UNIX timestamp (nanoseconds) when the data object was initialized.
+     * The UNIX timestamp (nanoseconds) when the struct was initialized.
      */
     uint64_t ts_init;
 } OrderBookDepth10_t;
 
 /**
- * Represents a single quote tick in a financial market.
+ * Represents a single quote tick in market.
  */
 typedef struct QuoteTick_t {
     /**
      * The quotes instrument ID.
      */
     struct InstrumentId_t instrument_id;
     /**
@@ -876,19 +908,19 @@
      */
     struct Quantity_t bid_size;
     /**
      * The top of book ask size.
      */
     struct Quantity_t ask_size;
     /**
-     * The UNIX timestamp (nanoseconds) when the tick event occurred.
+     * The UNIX timestamp (nanoseconds) when the quote event occurred.
      */
     uint64_t ts_event;
     /**
-     * The UNIX timestamp (nanoseconds) when the data object was initialized.
+     * The UNIX timestamp (nanoseconds) when the struct was initialized.
      */
     uint64_t ts_init;
 } QuoteTick_t;
 
 /**
  * Represents a valid trade match ID (assigned by a trading venue).
  *
@@ -903,15 +935,15 @@
     /**
      * The trade match ID value as a fixed-length C string byte array (includes null terminator).
      */
     uint8_t value[37];
 } TradeId_t;
 
 /**
- * Represents a single trade tick in a financial market.
+ * Represents a single trade tick in a market.
  */
 typedef struct TradeTick_t {
     /**
      * The trade instrument ID.
      */
     struct InstrumentId_t instrument_id;
     /**
@@ -927,19 +959,19 @@
      */
     enum AggressorSide aggressor_side;
     /**
      * The trade match ID (assigned by the venue).
      */
     struct TradeId_t trade_id;
     /**
-     * The UNIX timestamp (nanoseconds) when the tick event occurred.
+     * The UNIX timestamp (nanoseconds) when the trade event occurred.
      */
     uint64_t ts_event;
     /**
-     *  The UNIX timestamp (nanoseconds) when the data object was initialized.
+     * The UNIX timestamp (nanoseconds) when the struct was initialized.
      */
     uint64_t ts_init;
 } TradeTick_t;
 
 /**
  * Represents a bar aggregation specification including a step, aggregation
  * method/rule and price type.
@@ -1007,15 +1039,15 @@
      */
     struct Quantity_t volume;
     /**
      * The UNIX timestamp (nanoseconds) when the data event occurred.
      */
     uint64_t ts_event;
     /**
-     * The UNIX timestamp (nanoseconds) when the data object was initialized.
+     * The UNIX timestamp (nanoseconds) when the struct was initialized.
      */
     uint64_t ts_init;
 } Bar_t;
 
 typedef enum Data_t_Tag {
     DELTA,
     DELTAS,
@@ -1057,18 +1089,15 @@
  * with an order ID tag number separated by a hyphen.
  *
  * Example: "TESTER-001".
  * The reason for the numerical component of the ID is so that order and position IDs
  * do not collide with those from another node instance.
  */
 typedef struct TraderId_t {
-    /**
-     * The trader ID value.
-     */
-    char* value;
+    char* _0;
 } TraderId_t;
 
 /**
  * Represents a valid strategy ID.
  *
  * Must be correctly formatted with two valid strings either side of a hyphen.
  * It is expected a strategy ID is the class name of the strategy,
@@ -1076,28 +1105,22 @@
  *
  * Example: "EMACross-001".
  *
  * The reason for the numerical component of the ID is so that order and position IDs
  * do not collide with those from another strategy within the node instance.
  */
 typedef struct StrategyId_t {
-    /**
-     * The strategy ID value.
-     */
-    char* value;
+    char* _0;
 } StrategyId_t;
 
 /**
  * Represents a valid client order ID (assigned by the Nautilus system).
  */
 typedef struct ClientOrderId_t {
-    /**
-     * The client order ID value.
-     */
-    char* value;
+    char* _0;
 } ClientOrderId_t;
 
 typedef struct OrderDenied_t {
     struct TraderId_t trader_id;
     struct StrategyId_t strategy_id;
     struct InstrumentId_t instrument_id;
     struct ClientOrderId_t client_order_id;
@@ -1134,18 +1157,15 @@
  * Must be correctly formatted with two valid strings either side of a hyphen '-'.
  * It is expected an account ID is the name of the issuer with an account number
  * separated by a hyphen.
  *
  * Example: "IB-D02851908".
  */
 typedef struct AccountId_t {
-    /**
-     * The account ID value.
-     */
-    char* value;
+    char* _0;
 } AccountId_t;
 
 typedef struct OrderSubmitted_t {
     struct TraderId_t trader_id;
     struct StrategyId_t strategy_id;
     struct InstrumentId_t instrument_id;
     struct ClientOrderId_t client_order_id;
@@ -1155,18 +1175,15 @@
     uint64_t ts_init;
 } OrderSubmitted_t;
 
 /**
  * Represents a valid venue order ID (assigned by a trading venue).
  */
 typedef struct VenueOrderId_t {
-    /**
-     * The venue assigned order ID value.
-     */
-    char* value;
+    char* _0;
 } VenueOrderId_t;
 
 typedef struct OrderAccepted_t {
     struct TraderId_t trader_id;
     struct StrategyId_t strategy_id;
     struct InstrumentId_t instrument_id;
     struct ClientOrderId_t client_order_id;
@@ -1191,58 +1208,43 @@
     uint8_t reconciliation;
 } OrderRejected_t;
 
 /**
  * Represents a system client ID.
  */
 typedef struct ClientId_t {
-    /**
-     * The client ID value.
-     */
-    char* value;
+    char* _0;
 } ClientId_t;
 
 /**
  * Represents a valid component ID.
  */
 typedef struct ComponentId_t {
-    /**
-     * The component ID value.
-     */
-    char* value;
+    char* _0;
 } ComponentId_t;
 
 /**
  * Represents a valid execution algorithm ID.
  */
 typedef struct ExecAlgorithmId_t {
-    /**
-     * The execution algorithm ID value.
-     */
-    char* value;
+    char* _0;
 } ExecAlgorithmId_t;
 
 /**
  * Represents a valid order list ID (assigned by the Nautilus system).
  */
 typedef struct OrderListId_t {
-    /**
-     * The order list ID value.
-     */
-    char* value;
+    char* _0;
 } OrderListId_t;
 
 /**
  * Represents a valid position ID.
  */
 typedef struct PositionId_t {
-    /**
-     * The position ID value.
-     */
-    char* value;
+    char* _0;
 } PositionId_t;
 
 /**
  * Provides a C compatible Foreign Function Interface (FFI) for an underlying
  * [`SyntheticInstrument`].
  *
  * This struct wraps `SyntheticInstrument` in a way that makes it compatible with C function
@@ -1263,15 +1265,15 @@
  * calls, enabling interaction with `OrderBook` in a C environment.
  *
  * It implements the `Deref` trait, allowing instances of `OrderBook_API` to be
  * dereferenced to `OrderBook`, providing access to `OrderBook`'s methods without
  * having to manually access the underlying `OrderBook` instance.
  */
 typedef struct OrderBook_API {
-    struct OrderBookContainer *_0;
+    struct OrderBook *_0;
 } OrderBook_API;
 
 /**
  * Provides a C compatible Foreign Function Interface (FFI) for an underlying order book[`Level`].
  *
  * This struct wraps `Level` in a way that makes it compatible with C function
  * calls, enabling interaction with `Level` in a C environment.
@@ -1411,15 +1413,15 @@
                                             uint64_t ts_init);
 
 uint8_t orderbook_delta_eq(const struct OrderBookDelta_t *lhs, const struct OrderBookDelta_t *rhs);
 
 uint64_t orderbook_delta_hash(const struct OrderBookDelta_t *delta);
 
 /**
- * Creates a new `OrderBookDeltas` object from a `CVec` of `OrderBookDelta`.
+ * Creates a new `OrderBookDeltas` instance from a `CVec` of `OrderBookDelta`.
  *
  * # Safety
  * - The `deltas` must be a valid pointer to a `CVec` containing `OrderBookDelta` objects
  * - This function clones the data pointed to by `deltas` into Rust-managed memory, then forgets the original `Vec` to prevent Rust from auto-deallocating it
  * - The caller is responsible for managing the memory of `deltas` (including its deallocation) to avoid memory leaks
  */
 struct OrderBookDeltas_API orderbook_deltas_new(struct InstrumentId_t instrument_id,
@@ -1766,14 +1768,25 @@
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 enum PriceType price_type_from_cstr(const char *ptr);
 
+const char *record_flag_to_cstr(enum RecordFlag value);
+
+/**
+ * Returns an enum from a Python string.
+ *
+ * # Safety
+ *
+ * - Assumes `ptr` is a valid C string pointer.
+ */
+enum RecordFlag record_flag_from_cstr(const char *ptr);
+
 const char *time_in_force_to_cstr(enum TimeInForce value);
 
 /**
  * Returns an enum from a Python string.
  *
  * # Safety
  *
@@ -2138,32 +2151,35 @@
 
 uint64_t orderbook_ts_last(const struct OrderBook_API *book);
 
 uint64_t orderbook_count(const struct OrderBook_API *book);
 
 void orderbook_add(struct OrderBook_API *book,
                    struct BookOrder_t order,
-                   uint64_t ts_event,
-                   uint64_t sequence);
+                   uint8_t flags,
+                   uint64_t sequence,
+                   uint64_t ts_event);
 
 void orderbook_update(struct OrderBook_API *book,
                       struct BookOrder_t order,
-                      uint64_t ts_event,
-                      uint64_t sequence);
+                      uint8_t flags,
+                      uint64_t sequence,
+                      uint64_t ts_event);
 
 void orderbook_delete(struct OrderBook_API *book,
                       struct BookOrder_t order,
-                      uint64_t ts_event,
-                      uint64_t sequence);
+                      uint8_t flags,
+                      uint64_t sequence,
+                      uint64_t ts_event);
 
-void orderbook_clear(struct OrderBook_API *book, uint64_t ts_event, uint64_t sequence);
+void orderbook_clear(struct OrderBook_API *book, uint64_t sequence, uint64_t ts_event);
 
-void orderbook_clear_bids(struct OrderBook_API *book, uint64_t ts_event, uint64_t sequence);
+void orderbook_clear_bids(struct OrderBook_API *book, uint64_t sequence, uint64_t ts_event);
 
-void orderbook_clear_asks(struct OrderBook_API *book, uint64_t ts_event, uint64_t sequence);
+void orderbook_clear_asks(struct OrderBook_API *book, uint64_t sequence, uint64_t ts_event);
 
 void orderbook_apply_delta(struct OrderBook_API *book, struct OrderBookDelta_t delta);
 
 void orderbook_apply_deltas(struct OrderBook_API *book, const struct OrderBookDeltas_API *deltas);
 
 void orderbook_apply_depth(struct OrderBook_API *book, struct OrderBookDepth10_t depth);
 
@@ -2191,16 +2207,30 @@
                                          struct Quantity_t qty,
                                          enum OrderSide order_side);
 
 double orderbook_get_quantity_for_price(struct OrderBook_API *book,
                                         struct Price_t price,
                                         enum OrderSide order_side);
 
-void orderbook_update_quote_tick(struct OrderBook_API *book, const struct QuoteTick_t *tick);
+/**
+ * Updates the order book with a quote tick.
+ *
+ * # Panics
+ *
+ * If book type is not `L1_MBP`.
+ */
+void orderbook_update_quote_tick(struct OrderBook_API *book, const struct QuoteTick_t *quote);
 
+/**
+ * Updates the order book with a trade tick.
+ *
+ * # Panics
+ *
+ * If book type is not `L1_MBP`.
+ */
 void orderbook_update_trade_tick(struct OrderBook_API *book, const struct TradeTick_t *tick);
 
 CVec orderbook_simulate_fills(const struct OrderBook_API *book, struct BookOrder_t order);
 
 uint8_t orderbook_check_integrity(const struct OrderBook_API *book);
 
 void vec_fills_drop(CVec v);
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/inspect.py` & `nautilus_trader-1.191.0/nautilus_trader/core/inspect.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/message.pxd` & `nautilus_trader-1.191.0/nautilus_trader/core/message.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/message.pyx` & `nautilus_trader-1.191.0/nautilus_trader/core/message.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/nautilus_pyo3.pyi` & `nautilus_trader-1.191.0/nautilus_trader/core/nautilus_pyo3.pyi`

 * *Files 3% similar despite different names*

```diff
@@ -749,14 +749,20 @@
 
 class PriceType(Enum):
     BID = "BID"
     ASK = "ASK"
     MID = "MID"
     LAST = "LAST"
 
+class RecordFlag(Enum):
+    F_LAST = "F_LAST"
+    F_TOB = "F_TOB"
+    F_SNAPSHOT = "F_SNAPSHOT"
+    F_MBP = "F_MBP"
+
 class TimeInForce(Enum):
     GTC = "GTC"
     IOC = "IOC"
     FOK = "FOK"
     GTD = "GTD"
     DAY = "DAY"
     AT_THE_OPEN = "AT_THE_OPEN"
@@ -948,43 +954,76 @@
     def is_emulated(self) -> bool: ...
     @property
     def is_active_local(self) -> bool: ...
     @property
     def is_primary(self) -> bool: ...
     @property
     def is_spawned(self) -> bool: ...
+    @classmethod
     def from_dict(cls, values: dict[str, str]) -> LimitOrder: ...
 
 
-class LimitIfTouchedOrder: ...
+class LimitIfTouchedOrder:
+    def __init__(
+        self,
+        trader_id: TraderId,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        order_side: OrderSide,
+        quantity: Quantity,
+        price: Price,
+        trigger_price: Price,
+        trigger_type: TriggerType,
+        time_in_force: TimeInForce,
+        post_only: bool,
+        reduce_only: bool,
+        quote_quantity: bool,
+        init_id: UUID4,
+        ts_init: int,
+        expire_time: int | None = None,
+        display_qty: Quantity | None = None,
+        emulation_trigger: TriggerType | None = None,
+        trigger_instrument_id: InstrumentId | None = None,
+        contingency_type: ContingencyType | None = None,
+        order_list_id: OrderListId | None = None,
+        linked_order_ids: list[ClientOrderId] | None = None,
+        parent_order_id: ClientOrderId | None = None,
+        exec_algorithm_id: ExecAlgorithmId | None = None,
+        exec_algorithm_params: dict[str, str] | None = None,
+        exec_spawn_id: ClientOrderId | None = None,
+        tags: str | None = None,
+    ) -> None: ...
 
 class MarketOrder:
     def __init__(
         self,
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
         client_order_id: ClientOrderId,
         order_side: OrderSide,
         quantity: Quantity,
         init_id: UUID4,
         ts_init: int,
-        time_in_force: TimeInForce = ...,
-        reduce_only: bool = False,
-        quote_quantity: bool = False,
+        time_in_force: TimeInForce,
+        reduce_only: bool,
+        quote_quantity: bool,
         contingency_type: ContingencyType | None = None,
         order_list_id: OrderListId | None = None,
         linked_order_ids: list[ClientOrderId] | None = None,
-        parent_order_id: ClientOrderId | None = None,
+        parent_order_id: ClientOrderId | None  = None,
         exec_algorithm_id: ExecAlgorithmId | None = None,
         exec_algorithm_params: dict[str, str] | None = None,
         exec_spawn_id: ClientOrderId | None = None,
         tags: str | None = None,
     ) -> None: ...
     def to_dict(self) -> dict[str, str]: ...
+    @classmethod
+    def from_dict(cls, values: dict[str, str]) -> MarketOrder: ...
     @staticmethod
     def opposite_side(side: OrderSide) -> OrderSide: ...
     @staticmethod
     def closing_side(side: PositionSide) -> OrderSide: ...
     def signed_decimal_qty(self) -> Decimal: ...
     def would_reduce_only(self, side: PositionSide, position_qty: Quantity) -> bool: ...
     def commission(self, currency: Currency) -> Money | None: ...
@@ -1010,19 +1049,243 @@
     @property
     def side(self) -> OrderSide: ...
     @property
     def order_type(self) -> OrderType: ...
     @property
     def price(self) -> Price | None: ...
 
-class MarketToLimitOrder: ...
-class StopLimitOrder: ...
-class StopMarketOrder: ...
-class TrailingStopLimitOrder: ...
-class TrailingStopMarketOrder: ...
+class MarketToLimitOrder:
+    def __init__(
+        self,
+        trader_id: TraderId,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        order_side: OrderSide,
+        quantity: Quantity,
+        time_in_force: TimeInForce,
+        post_only: bool,
+        reduce_only: bool,
+        quote_quantity: bool,
+        init_id: UUID4,
+        ts_init: int,
+        expire_time: int | None = None,
+        display_qty: Quantity | None = None,
+        contingency_type: ContingencyType | None = None,
+        order_list_id: OrderListId | None = None,
+        linked_order_ids: list[ClientOrderId] | None = None,
+        parent_order_id: ClientOrderId | None = None,
+        exec_algorithm_id: ExecAlgorithmId | None = None,
+        exec_algorithm_params: dict[str, str] | None = None,
+        exec_spawn_id: ClientOrderId | None = None,
+        tags: str | None = None,
+    ): ...
+
+class MarketIfTouchedOrder:
+    def __init__(
+        self,
+        trader_id: TraderId,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        order_side: OrderSide,
+        quantity: Quantity,
+        trigger_price: Price,
+        trigger_type: TriggerType,
+        time_in_force: TimeInForce,
+        reduce_only: bool,
+        quote_quantity: bool,
+        init_id: UUID4,
+        ts_init: int,
+        expire_time: int | None = None,
+        display_qty: Quantity | None = None,
+        emulation_trigger: TriggerType | None = None,
+        trigger_instrument_id: InstrumentId | None = None,
+        contingency_type: ContingencyType | None = None,
+        order_list_id: OrderListId | None = None,
+        linked_order_ids: list[ClientOrderId] | None = None,
+        parent_order_id: ClientOrderId | None = None,
+        exec_algorithm_id: ExecAlgorithmId | None = None,
+        exec_algorithm_params: dict[str, str] | None = None,
+        exec_spawn_id: ClientOrderId | None = None,
+        tags: str | None = None,
+    ): ...
+class StopLimitOrder:
+    def __init__(
+        self,
+        trader_id: TraderId,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        order_side: OrderSide,
+        quantity: Quantity,
+        price: Price,
+        trigger_price: Price,
+        trigger_type: TriggerType,
+        time_in_force: TimeInForce,
+        post_only: bool,
+        reduce_only: bool,
+        quote_quantity: bool,
+        init_id: UUID4,
+        ts_init: int,
+        expire_time: int | None = None,
+        display_qty: Quantity | None = None,
+        emulation_trigger: TriggerType | None = None,
+        trigger_instrument_id: InstrumentId | None = None,
+        contingency_type: ContingencyType | None = None,
+        order_list_id: OrderListId | None = None,
+        linked_order_ids: list[ClientOrderId] | None = None,
+        parent_order_id: ClientOrderId | None = None,
+        exec_algorithm_id: ExecAlgorithmId | None = None,
+        exec_algorithm_params: dict[str, str] | None = None,
+        exec_spawn_id: ClientOrderId | None = None,
+        tags: str | None = None,
+    ): ...
+    @classmethod
+    def from_dict(cls, values: dict[str, str]) -> StopLimitOrder: ...
+    def to_dict(self) -> dict[str, str]: ...
+    @property
+    def trader_id(self) -> TraderId: ...
+    @property
+    def strategy_id(self) -> StrategyId: ...
+    @property
+    def instrument_id(self) -> InstrumentId: ...
+    @property
+    def client_order_id(self) -> ClientOrderId: ...
+    @property
+    def order_type(self) -> OrderType: ...
+    @property
+    def side(self) -> OrderSide: ...
+    @property
+    def quantity(self) -> Quantity: ...
+    @property
+    def price(self) -> Price: ...
+    @property
+    def trigger_price(self) -> Price: ...
+    @property
+    def trigger_type(self) -> TriggerType: ...
+    @property
+    def time_in_force(self) -> TimeInForce: ...
+    @property
+    def is_post_only(self) -> bool: ...
+    @property
+    def is_reduce_only(self) -> bool: ...
+    @property
+    def is_quote_quantity(self) -> bool: ...
+    @property
+    def is_passive(self) -> bool: ...
+    @property
+    def is_aggressive(self) -> bool: ...
+    @property
+    def is_closed(self) -> bool: ...
+    @property
+    def is_open(self) -> bool: ...
+    @property
+    def status(self) -> OrderStatus: ...
+    @property
+    def has_price(self) -> bool: ...
+    @property
+    def has_trigger_price(self) -> bool: ...
+    @property
+    def expire_time(self) -> int | None: ...
+
+class StopMarketOrder:
+    def __init__(
+        self,
+        trader_id: TraderId,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        order_side: OrderSide,
+        quantity: Quantity,
+        trigger_price: Price,
+        trigger_type: TriggerType,
+        time_in_force: TimeInForce,
+        reduce_only: bool,
+        quote_quantity: bool,
+        init_id: UUID4,
+        ts_init: int,
+        expire_time: int | None = None,
+        display_qty: Quantity | None = None,
+        emulation_trigger: TriggerType | None = None,
+        trigger_instrument_id: InstrumentId | None = None,
+        contingency_type: ContingencyType | None = None,
+        order_list_id: OrderListId | None = None,
+        linked_order_ids: list[ClientOrderId] | None = None,
+        parent_order_id: ClientOrderId | None = None,
+        exec_algorithm_id: ExecAlgorithmId | None = None,
+        exec_algorithm_params: dict[str, str] | None = None,
+        exec_spawn_id: ClientOrderId | None = None,
+        tags: str | None = None,
+    ): ...
+class TrailingStopLimitOrder:
+    def __init__(
+        self,
+        trader_id: TraderId,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        order_side: OrderSide,
+        quantity: Quantity,
+        price: Price,
+        trigger_price: Price,
+        trigger_type: TriggerType,
+        limit_offset: Price,
+        trailing_offset: Price,
+        trailing_offset_type: TrailingOffsetType,
+        time_in_force: TimeInForce,
+        post_only: bool,
+        reduce_only: bool,
+        quote_quantity: bool,
+        init_id: UUID4,
+        ts_init: int,
+        expire_time: int | None = None,
+        display_qty: Quantity | None = None,
+        emulation_trigger: TriggerType | None = None,
+        trigger_instrument_id: InstrumentId | None = None,
+        contingency_type: ContingencyType | None = None,
+        order_list_id: OrderListId | None = None,
+        linked_order_ids: list[ClientOrderId] | None = None,
+        parent_order_id: ClientOrderId | None = None,
+        exec_algorithm_id: ExecAlgorithmId | None = None,
+        exec_algorithm_params: dict[str, str] | None = None,
+        exec_spawn_id: ClientOrderId | None = None,
+        tags: str | None = None,
+    ): ...
+class TrailingStopMarketOrder:
+    def __init__(
+        self,
+        trader_id: TraderId,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        order_side: OrderSide,
+        quantity: Quantity,
+        trigger_price: Price,
+        trigger_type: TriggerType,
+        trailing_offset: Price,
+        trailing_offset_type: TrailingOffsetType,
+        time_in_force: TimeInForce,
+        reduce_only: bool,
+        quote_quantity: bool,
+        init_id: UUID4,
+        ts_init: int,
+        expire_time: int | None = None,
+        display_qty: Quantity | None = None,
+        emulation_trigger: TriggerType | None = None,
+        trigger_instrument_id: InstrumentId | None = None,
+        contingency_type: ContingencyType | None = None,
+        order_list_id: OrderListId | None = None,
+        linked_order_ids: list[ClientOrderId] | None = None,
+        parent_order_id: ClientOrderId | None = None,
+        exec_algorithm_id: ExecAlgorithmId | None = None,
+        exec_algorithm_params: dict[str, str] | None = None,
+        exec_spawn_id: ClientOrderId | None = None,
+        tags: str | None = None,
+    ): ...
 
 ### Objects
 
 class Currency:
     def __init__(
         self,
         code: str,
@@ -1122,15 +1385,15 @@
     def to_dict(self) -> dict[str, str]: ...
 
 class AccountState:
     def __init__(
         self,
         account_id: AccountId,
         account_type: AccountType,
-        base_currency: Currency,
+        base_currency: Currency | None,
         balances: list[AccountBalance],
         margins: list[MarginBalance],
         is_reported: bool,
         event_id: UUID4,
         ts_event: int,
         ts_init: int,
     ) -> None: ...
@@ -1144,14 +1407,15 @@
     def __init__(
         self,
         id: InstrumentId,
         raw_symbol: Symbol,
         underlying: Currency,
         quote_currency: Currency,
         settlement_currency: Currency,
+        is_inverse: bool,
         activation_ns: int,
         expiration_ns: int,
         price_precision: int,
         size_precision: int,
         price_increment: Price,
         size_increment: Quantity,
         maker_fee: Decimal,
@@ -1863,58 +2127,19 @@
     def size(self) -> float: ...
     def size_raw(self) -> int: ...
     def exposure(self) -> float: ...
     def exposure_raw(self) -> int: ...
     def first(self) -> BookOrder | None: ...
     def get_orders(self) -> list[BookOrder]: ...
 
-class OrderBookMbo:
-    def __init__(self, instrument_id: InstrumentId) -> None: ...
-    @property
-    def instrument_id(self) -> InstrumentId: ...
-    @property
-    def book_type(self) -> BookType: ...
-    @property
-    def sequence(self) -> int: ...
-    @property
-    def ts_event(self) -> int: ...
-    @property
-    def ts_init(self) -> int: ...
-    @property
-    def ts_last(self) -> int: ...
-    @property
-    def count(self) -> int: ...
-    def reset(self) -> None: ...
-    def update(self, order: BookOrder, ts_event: int, sequence: int = 0) -> None: ...
-    def delete(self, order: BookOrder, ts_event: int, sequence: int = 0) -> None: ...
-    def clear(self, ts_event: int, sequence: int = 0) -> None: ...
-    def clear_bids(self, ts_event: int, sequence: int = 0) -> None: ...
-    def clear_asks(self, ts_event: int, sequence: int = 0) -> None: ...
-    def apply_delta(self, delta: OrderBookDelta) -> None: ...
-    def apply_deltas(self, deltas: OrderBookDeltas) -> None: ...
-    def apply_depth(self, depth: OrderBookDepth10) -> None: ...
-    def check_integrity(self) -> None: ...
-    def bids(self) -> list[Level]: ...
-    def asks(self) -> list[Level]: ...
-    def best_bid_price(self) -> Price | None: ...
-    def best_ask_price(self) -> Price | None: ...
-    def best_bid_size(self) -> Quantity | None: ...
-    def best_ask_size(self) -> Quantity | None: ...
-    def spread(self) -> float | None: ...
-    def midpoint(self) -> float | None: ...
-    def get_avg_px_for_quantity(self, qty: Quantity, order_side: OrderSide) -> float: ...
-    def get_quantity_for_price(self, price: Price, order_side: OrderSide) -> float: ...
-    def simulate_fills(self, order: BookOrder) -> list[tuple[Price, Quantity]]: ...
-    def pprint(self, num_levels: int) -> str: ...
-
-class OrderBookMbp:
+class OrderBook:
     def __init__(
         self,
+        book_type: BookType,
         instrument_id: InstrumentId,
-        top_only: bool = False,
     ) -> None: ...
     @property
     def instrument_id(self) -> InstrumentId: ...
     @property
     def book_type(self) -> BookType: ...
     @property
     def sequence(self) -> int: ...
@@ -1923,46 +2148,58 @@
     @property
     def ts_init(self) -> int: ...
     @property
     def ts_last(self) -> int: ...
     @property
     def count(self) -> int: ...
     def reset(self) -> None: ...
-    def update(self, order: BookOrder, ts_event: int, sequence: int = 0) -> None: ...
-    def update_quote_tick(self, quote: QuoteTick) -> None: ...
-    def update_trade_tick(self, trade: TradeTick) -> None: ...
-    def delete(self, order: BookOrder, ts_event: int, sequence: int = 0) -> None: ...
-    def clear(self, ts_event: int, sequence: int = 0) -> None: ...
-    def clear_bids(self, ts_event: int, sequence: int = 0) -> None: ...
-    def clear_asks(self, ts_event: int, sequence: int = 0) -> None: ...
+    def add(self, order: BookOrder, flags: int, sequence: int, ts_event: int) -> None: ...
+    def update(self, order: BookOrder, flags: int, sequence: int, ts_event: int) -> None: ...
+    def delete(self, order: BookOrder, flags: int, sequence: int, ts_event: int) -> None: ...
+    def clear(self, sequence: int,  ts_event: int) -> None: ...
+    def clear_bids(self, sequence: int, ts_event: int) -> None: ...
+    def clear_asks(self, sequence: int, ts_event: int) -> None: ...
     def apply_delta(self, delta: OrderBookDelta) -> None: ...
     def apply_deltas(self, deltas: OrderBookDeltas) -> None: ...
     def apply_depth(self, depth: OrderBookDepth10) -> None: ...
-    def check_integrity(self) -> None: ...
     def bids(self) -> list[Level]: ...
     def asks(self) -> list[Level]: ...
     def best_bid_price(self) -> Price | None: ...
     def best_ask_price(self) -> Price | None: ...
     def best_bid_size(self) -> Quantity | None: ...
     def best_ask_size(self) -> Quantity | None: ...
     def spread(self) -> float | None: ...
     def midpoint(self) -> float | None: ...
     def get_avg_px_for_quantity(self, qty: Quantity, order_side: OrderSide) -> float: ...
     def get_quantity_for_price(self, price: Price, order_side: OrderSide) -> float: ...
     def simulate_fills(self, order: BookOrder) -> list[tuple[Price, Quantity]]: ...
     def pprint(self, num_levels: int) -> str: ...
 
+def update_book_with_quote_tick(book: OrderBook, quote: QuoteTick) -> None: ...
+def update_book_with_trade_tick(book: OrderBook, trade: TradeTick) -> None: ...
+
 ###################################################################################################
 # Infrastructure
 ###################################################################################################
 
+class RedisMessageBusDatabase:
+    def __init__(
+        self,
+        trader_id: TraderId,
+        instance_id: UUID4,
+        config_json: bytes,  # TODO: Standardize this back to `dict[str, Any]`
+    ) -> None: ...
+    def publish(self, topic: str, payload: bytes) -> None: ...
+    def close(self) -> None: ...
+
 class RedisCacheDatabase:
     def __init__(
         self,
         trader_id: TraderId,
+        instance_id: UUID4,
         config: dict[str, Any],
     ) -> None: ...
 
 ###################################################################################################
 # Network
 ###################################################################################################
 
@@ -2365,14 +2602,36 @@
     def aroon_up(self) -> float: ...
     @property
     def aroon_down(self) -> float: ...
     def update_raw(self, high: float, low: float) -> None: ...
     def handle_bar(self, bar: Bar) -> None: ...
     def reset(self) -> None: ...
 
+class Bias:
+    def __init__(
+        self,
+        period: int,
+        ma_type: MovingAverageType = ...,
+    ) -> None: ...
+    @property
+    def name(self) -> str: ...
+    @property
+    def period(self) -> int: ...
+    @property
+    def count(self) -> int: ...
+    @property
+    def initialized(self) -> bool: ...
+    @property
+    def has_inputs(self) -> bool: ...
+    @property
+    def value(self) -> float: ...
+    def update_raw(self, close: float) -> None: ...
+    def handle_bar(self, bar: Bar) -> None: ...
+    def reset(self) -> None: ...
+
 class AverageTrueRange:
     def __init__(
         self,
         period: int,
         ma_type: MovingAverageType = ...,
         use_previous: bool = True,
         value_floor: float = 0.0,
@@ -2403,16 +2662,15 @@
     def count(self) -> int: ...
     @property
     def initialized(self) -> bool: ...
     @property
     def has_inputs(self) -> bool: ...
     @property
     def value(self) -> float: ...
-    def handle_book_mbo(self, book: OrderBookMbo) -> None:...
-    def handle_book_mbp(self, book: OrderBookMbp) -> None:...
+    def handle_book(self, book: OrderBook) -> None:...
     def update(self, best_bid: Quantity | None, best_ask: Quantity) -> None: ...
     def reset(self) -> None: ...
 
 ###################################################################################################
 # Adapters
 ###################################################################################################
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/rust/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/core/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/rust/algorithms.pxd` & `nautilus_trader-1.191.0/nautilus_trader/core/rust/algorithms.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/rust/backtest.pxd` & `nautilus_trader-1.191.0/nautilus_trader/core/rust/backtest.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/rust/common.pyx` & `nautilus_trader-1.191.0/nautilus_trader/core/rust/common.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/rust/core.pxd` & `nautilus_trader-1.191.0/nautilus_trader/core/rust/core.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/rust/model.pxd` & `nautilus_trader-1.191.0/nautilus_trader/core/rust/model.pxd`

 * *Files 6% similar despite different names*

```diff
@@ -112,15 +112,15 @@
         # The venue or market session is not halted.
         NOT_HALTED # = 1,
         # Trading halt is imposed for purely regulatory reasons with/without volatility halt.
         GENERAL # = 2,
         # Trading halt is imposed by the venue to protect against extreme volatility.
         VOLATILITY # = 3,
 
-    # The asset type for a financial market product.
+    # The instrument class.
     cpdef enum InstrumentClass:
         # A spot market instrument class. The current market price of an instrument that is bought or sold for immediate delivery and payment.
         SPOT # = 1,
         # A swap instrument class. A derivative contract through which two parties exchange the cash flows or liabilities from two different financial instruments.
         SWAP # = 2,
         # A futures contract instrument class. A legal agreement to buy or sell an asset at a predetermined price at a specified time in the future.
         FUTURE # = 3,
@@ -144,15 +144,15 @@
     # The type of event for an instrument close.
     cpdef enum InstrumentCloseType:
         # When the market session ended.
         END_OF_SESSION # = 1,
         # When the instrument expiration was reached.
         CONTRACT_EXPIRED # = 2,
 
-    # The liqudity side for a trade in a financial market.
+    # The liqudity side for a trade.
     cpdef enum LiquiditySide:
         # No liquidity side specified.
         NO_LIQUIDITY_SIDE # = 0,
         # The order passively provided liqudity to the market to complete the trade (made a market).
         MAKER # = 1,
         # The order aggressively took liqudity from the market to complete the trade.
         TAKER # = 2,
@@ -172,15 +172,15 @@
         # The market session is in the pre-close.
         PRE_CLOSE # = 6,
         # The market session is closed.
         CLOSED # = 7,
 
     # The order management system (OMS) type for a trading venue or trading strategy.
     cpdef enum OmsType:
-        # There is no specific type of order management specified (will defer to the venue).
+        # There is no specific type of order management specified (will defer to the venue OMS).
         UNSPECIFIED # = 0,
         # The netting type where there is one position per instrument.
         NETTING # = 1,
         # The hedging type where there can be multiple positions per instrument.
         # This can be in LONG/SHORT directions, by position/ticket ID, or tracked virtually by
         # Nautilus.
         HEDGING # = 2,
@@ -279,26 +279,41 @@
         # A neural/flat position, where no position is currently held in the market.
         FLAT # = 1,
         # A long position in the market, typically acquired through one or many BUY orders.
         LONG # = 2,
         # A short position in the market, typically acquired through one or many SELL orders.
         SHORT # = 3,
 
-    # The type of price for an instrument in a financial market.
+    # The type of price for an instrument in market.
     cpdef enum PriceType:
         # A quoted order price where a buyer is willing to buy a quantity of an instrument.
         BID # = 1,
         # A quoted order price where a seller is willing to sell a quantity of an instrument.
         ASK # = 2,
         # The midpoint between the bid and ask prices.
         MID # = 3,
         # The last price at which a trade was made for an instrument.
         LAST # = 4,
 
-    # The 'Time in Force' instruction for an order in the financial market.
+    # A record flag bit field, indicating packet end and data information.
+    cpdef enum RecordFlag:
+        # Last message in the packet from the venue for a given `instrument_id`.
+        F_LAST # = (1 << 7),
+        # Top-of-book message, not an individual order.
+        F_TOB # = (1 << 6),
+        # Message sourced from a replay, such as a snapshot server.
+        F_SNAPSHOT # = (1 << 5),
+        # Aggregated price level message, not an individual order.
+        F_MBP # = (1 << 4),
+        # Reserved for future use.
+        RESERVED_2 # = (1 << 3),
+        # Reserved for future use.
+        RESERVED_1 # = (1 << 2),
+
+    # The 'Time in Force' instruction for an order.
     cpdef enum TimeInForce:
         # Good Till Canceled (GTC) - the order remains active until canceled.
         GTC # = 1,
         # Immediate or Cancel (IOC) - the order is filled as much as possible, the rest is canceled.
         IOC # = 2,
         # Fill or Kill (FOK) - the order must be executed in full immediately, or it is canceled.
         FOK # = 3,
@@ -359,37 +374,41 @@
     # Represents a discrete price level in an order book.
     #
     # The level maintains a collection of orders as well as tracking insertion order
     # to preserve FIFO queue dynamics.
     cdef struct Level:
         pass
 
-    cdef struct OrderBookContainer:
+    # Provides an order book.
+    #
+    # Can handle the following granularity data:
+    # - MBO (market by order) / L3
+    # - MBP (market by price) / L2 aggregated order per level
+    # - MBP (market by price) / L1 top-of-book only
+    cdef struct OrderBook:
         pass
 
     # Represents a grouped batch of `OrderBookDelta` updates for an `OrderBook`.
     #
     # This type cannot be `repr(C)` due to the `deltas` vec.
     cdef struct OrderBookDeltas_t:
         pass
 
     # Represents a synthetic instrument with prices derived from component instruments using a
     # formula.
     cdef struct SyntheticInstrument:
         pass
 
-    # Represents a valid ticker symbol ID for a tradable financial market instrument.
+    # Represents a valid ticker symbol ID for a tradable instrument.
     cdef struct Symbol_t:
-        # The ticker symbol ID value.
-        char* value;
+        char* _0;
 
     # Represents a valid trading venue ID.
     cdef struct Venue_t:
-        # The venue ID value.
-        char* value;
+        char* _0;
 
     # Represents a valid instrument ID.
     #
     # The symbol and venue combination should uniquely identify the instrument.
     cdef struct InstrumentId_t:
         # The instruments ticker symbol.
         Symbol_t symbol;
@@ -419,21 +438,21 @@
     cdef struct OrderBookDelta_t:
         # The instrument ID for the book.
         InstrumentId_t instrument_id;
         # The order book delta action.
         BookAction action;
         # The order to apply.
         BookOrder_t order;
-        # A combination of packet end with matching engine status.
+        # The record flags bit field, indicating packet end and data information.
         uint8_t flags;
         # The message sequence number assigned at the venue.
         uint64_t sequence;
-        # The UNIX timestamp (nanoseconds) when the data event occurred.
+        # The UNIX timestamp (nanoseconds) when the book event occurred.
         uint64_t ts_event;
-        # The UNIX timestamp (nanoseconds) when the data object was initialized.
+        # The UNIX timestamp (nanoseconds) when the struct was initialized.
         uint64_t ts_init;
 
     # Provides a C compatible Foreign Function Interface (FFI) for an underlying [`OrderBookDeltas`].
     #
     # This struct wraps `OrderBookDeltas` in a way that makes it compatible with C function
     # calls, enabling interaction with `OrderBookDeltas` in a C environment.
     #
@@ -459,67 +478,67 @@
         BookOrder_t bids[DEPTH10_LEN];
         # The ask orders for the depth update.
         BookOrder_t asks[DEPTH10_LEN];
         # The count of bid orders per level for the depth update.
         uint32_t bid_counts[DEPTH10_LEN];
         # The count of ask orders per level for the depth update.
         uint32_t ask_counts[DEPTH10_LEN];
-        # A combination of packet end with matching engine status.
+        # The record flags bit field, indicating packet end and data information.
         uint8_t flags;
         # The message sequence number assigned at the venue.
         uint64_t sequence;
-        # The UNIX timestamp (nanoseconds) when the data event occurred.
+        # The UNIX timestamp (nanoseconds) when the book event occurred.
         uint64_t ts_event;
-        # The UNIX timestamp (nanoseconds) when the data object was initialized.
+        # The UNIX timestamp (nanoseconds) when the struct was initialized.
         uint64_t ts_init;
 
-    # Represents a single quote tick in a financial market.
+    # Represents a single quote tick in market.
     cdef struct QuoteTick_t:
         # The quotes instrument ID.
         InstrumentId_t instrument_id;
         # The top of book bid price.
         Price_t bid_price;
         # The top of book ask price.
         Price_t ask_price;
         # The top of book bid size.
         Quantity_t bid_size;
         # The top of book ask size.
         Quantity_t ask_size;
-        # The UNIX timestamp (nanoseconds) when the tick event occurred.
+        # The UNIX timestamp (nanoseconds) when the quote event occurred.
         uint64_t ts_event;
-        # The UNIX timestamp (nanoseconds) when the data object was initialized.
+        # The UNIX timestamp (nanoseconds) when the struct was initialized.
         uint64_t ts_init;
 
     # Represents a valid trade match ID (assigned by a trading venue).
     #
     # Maximum length is 36 characters.
     #
     # The unique ID assigned to the trade entity once it is received or matched by
     # the exchange or central counterparty.
     #
     # Can correspond to the `TradeID <1003> field` of the FIX protocol.
     cdef struct TradeId_t:
         # The trade match ID value as a fixed-length C string byte array (includes null terminator).
         uint8_t value[37];
 
-    # Represents a single trade tick in a financial market.
+    # Represents a single trade tick in a market.
     cdef struct TradeTick_t:
         # The trade instrument ID.
         InstrumentId_t instrument_id;
         # The traded price.
         Price_t price;
         # The traded size.
         Quantity_t size;
         # The trade aggressor side.
         AggressorSide aggressor_side;
         # The trade match ID (assigned by the venue).
         TradeId_t trade_id;
-        # The UNIX timestamp (nanoseconds) when the tick event occurred.
+        # The UNIX timestamp (nanoseconds) when the trade event occurred.
         uint64_t ts_event;
-        #  The UNIX timestamp (nanoseconds) when the data object was initialized.
+        # The UNIX timestamp (nanoseconds) when the struct was initialized.
         uint64_t ts_init;
 
     # Represents a bar aggregation specification including a step, aggregation
     # method/rule and price type.
     cdef struct BarSpecification_t:
         # The step for binning samples for bar aggregation.
         uintptr_t step;
@@ -550,15 +569,15 @@
         Price_t low;
         # The bars close price.
         Price_t close;
         # The bars volume.
         Quantity_t volume;
         # The UNIX timestamp (nanoseconds) when the data event occurred.
         uint64_t ts_event;
-        # The UNIX timestamp (nanoseconds) when the data object was initialized.
+        # The UNIX timestamp (nanoseconds) when the struct was initialized.
         uint64_t ts_init;
 
     cpdef enum Data_t_Tag:
         DELTA,
         DELTAS,
         DEPTH10,
         QUOTE,
@@ -580,35 +599,32 @@
     # It is expected a trader ID is the abbreviated name of the trader
     # with an order ID tag number separated by a hyphen.
     #
     # Example: "TESTER-001".
     # The reason for the numerical component of the ID is so that order and position IDs
     # do not collide with those from another node instance.
     cdef struct TraderId_t:
-        # The trader ID value.
-        char* value;
+        char* _0;
 
     # Represents a valid strategy ID.
     #
     # Must be correctly formatted with two valid strings either side of a hyphen.
     # It is expected a strategy ID is the class name of the strategy,
     # with an order ID tag number separated by a hyphen.
     #
     # Example: "EMACross-001".
     #
     # The reason for the numerical component of the ID is so that order and position IDs
     # do not collide with those from another strategy within the node instance.
     cdef struct StrategyId_t:
-        # The strategy ID value.
-        char* value;
+        char* _0;
 
     # Represents a valid client order ID (assigned by the Nautilus system).
     cdef struct ClientOrderId_t:
-        # The client order ID value.
-        char* value;
+        char* _0;
 
     cdef struct OrderDenied_t:
         TraderId_t trader_id;
         StrategyId_t strategy_id;
         InstrumentId_t instrument_id;
         ClientOrderId_t client_order_id;
         char* reason;
@@ -639,31 +655,29 @@
     #
     # Must be correctly formatted with two valid strings either side of a hyphen '-'.
     # It is expected an account ID is the name of the issuer with an account number
     # separated by a hyphen.
     #
     # Example: "IB-D02851908".
     cdef struct AccountId_t:
-        # The account ID value.
-        char* value;
+        char* _0;
 
     cdef struct OrderSubmitted_t:
         TraderId_t trader_id;
         StrategyId_t strategy_id;
         InstrumentId_t instrument_id;
         ClientOrderId_t client_order_id;
         AccountId_t account_id;
         UUID4_t event_id;
         uint64_t ts_event;
         uint64_t ts_init;
 
     # Represents a valid venue order ID (assigned by a trading venue).
     cdef struct VenueOrderId_t:
-        # The venue assigned order ID value.
-        char* value;
+        char* _0;
 
     cdef struct OrderAccepted_t:
         TraderId_t trader_id;
         StrategyId_t strategy_id;
         InstrumentId_t instrument_id;
         ClientOrderId_t client_order_id;
         VenueOrderId_t venue_order_id;
@@ -683,36 +697,31 @@
         UUID4_t event_id;
         uint64_t ts_event;
         uint64_t ts_init;
         uint8_t reconciliation;
 
     # Represents a system client ID.
     cdef struct ClientId_t:
-        # The client ID value.
-        char* value;
+        char* _0;
 
     # Represents a valid component ID.
     cdef struct ComponentId_t:
-        # The component ID value.
-        char* value;
+        char* _0;
 
     # Represents a valid execution algorithm ID.
     cdef struct ExecAlgorithmId_t:
-        # The execution algorithm ID value.
-        char* value;
+        char* _0;
 
     # Represents a valid order list ID (assigned by the Nautilus system).
     cdef struct OrderListId_t:
-        # The order list ID value.
-        char* value;
+        char* _0;
 
     # Represents a valid position ID.
     cdef struct PositionId_t:
-        # The position ID value.
-        char* value;
+        char* _0;
 
     # Provides a C compatible Foreign Function Interface (FFI) for an underlying
     # [`SyntheticInstrument`].
     #
     # This struct wraps `SyntheticInstrument` in a way that makes it compatible with C function
     # calls, enabling interaction with `SyntheticInstrument` in a C environment.
     #
@@ -727,15 +736,15 @@
     # This struct wraps `OrderBook` in a way that makes it compatible with C function
     # calls, enabling interaction with `OrderBook` in a C environment.
     #
     # It implements the `Deref` trait, allowing instances of `OrderBook_API` to be
     # dereferenced to `OrderBook`, providing access to `OrderBook`'s methods without
     # having to manually access the underlying `OrderBook` instance.
     cdef struct OrderBook_API:
-        OrderBookContainer *_0;
+        OrderBook *_0;
 
     # Provides a C compatible Foreign Function Interface (FFI) for an underlying order book[`Level`].
     #
     # This struct wraps `Level` in a way that makes it compatible with C function
     # calls, enabling interaction with `Level` in a C environment.
     #
     # It implements the `Deref` trait, allowing instances of `Level_API` to be
@@ -851,15 +860,15 @@
                                          uint64_t ts_event,
                                          uint64_t ts_init);
 
     uint8_t orderbook_delta_eq(const OrderBookDelta_t *lhs, const OrderBookDelta_t *rhs);
 
     uint64_t orderbook_delta_hash(const OrderBookDelta_t *delta);
 
-    # Creates a new `OrderBookDeltas` object from a `CVec` of `OrderBookDelta`.
+    # Creates a new `OrderBookDeltas` instance from a `CVec` of `OrderBookDelta`.
     #
     # # Safety
     # - The `deltas` must be a valid pointer to a `CVec` containing `OrderBookDelta` objects
     # - This function clones the data pointed to by `deltas` into Rust-managed memory, then forgets the original `Vec` to prevent Rust from auto-deallocating it
     # - The caller is responsible for managing the memory of `deltas` (including its deallocation) to avoid memory leaks
     OrderBookDeltas_API orderbook_deltas_new(InstrumentId_t instrument_id,
                                              const CVec *deltas);
@@ -1152,14 +1161,23 @@
     # Returns an enum from a Python string.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     PriceType price_type_from_cstr(const char *ptr);
 
+    const char *record_flag_to_cstr(RecordFlag value);
+
+    # Returns an enum from a Python string.
+    #
+    # # Safety
+    #
+    # - Assumes `ptr` is a valid C string pointer.
+    RecordFlag record_flag_from_cstr(const char *ptr);
+
     const char *time_in_force_to_cstr(TimeInForce value);
 
     # Returns an enum from a Python string.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
@@ -1469,32 +1487,35 @@
 
     uint64_t orderbook_ts_last(const OrderBook_API *book);
 
     uint64_t orderbook_count(const OrderBook_API *book);
 
     void orderbook_add(OrderBook_API *book,
                        BookOrder_t order,
-                       uint64_t ts_event,
-                       uint64_t sequence);
+                       uint8_t flags,
+                       uint64_t sequence,
+                       uint64_t ts_event);
 
     void orderbook_update(OrderBook_API *book,
                           BookOrder_t order,
-                          uint64_t ts_event,
-                          uint64_t sequence);
+                          uint8_t flags,
+                          uint64_t sequence,
+                          uint64_t ts_event);
 
     void orderbook_delete(OrderBook_API *book,
                           BookOrder_t order,
-                          uint64_t ts_event,
-                          uint64_t sequence);
+                          uint8_t flags,
+                          uint64_t sequence,
+                          uint64_t ts_event);
 
-    void orderbook_clear(OrderBook_API *book, uint64_t ts_event, uint64_t sequence);
+    void orderbook_clear(OrderBook_API *book, uint64_t sequence, uint64_t ts_event);
 
-    void orderbook_clear_bids(OrderBook_API *book, uint64_t ts_event, uint64_t sequence);
+    void orderbook_clear_bids(OrderBook_API *book, uint64_t sequence, uint64_t ts_event);
 
-    void orderbook_clear_asks(OrderBook_API *book, uint64_t ts_event, uint64_t sequence);
+    void orderbook_clear_asks(OrderBook_API *book, uint64_t sequence, uint64_t ts_event);
 
     void orderbook_apply_delta(OrderBook_API *book, OrderBookDelta_t delta);
 
     void orderbook_apply_deltas(OrderBook_API *book, const OrderBookDeltas_API *deltas);
 
     void orderbook_apply_depth(OrderBook_API *book, OrderBookDepth10_t depth);
 
@@ -1522,16 +1543,26 @@
                                              Quantity_t qty,
                                              OrderSide order_side);
 
     double orderbook_get_quantity_for_price(OrderBook_API *book,
                                             Price_t price,
                                             OrderSide order_side);
 
-    void orderbook_update_quote_tick(OrderBook_API *book, const QuoteTick_t *tick);
+    # Updates the order book with a quote tick.
+    #
+    # # Panics
+    #
+    # If book type is not `L1_MBP`.
+    void orderbook_update_quote_tick(OrderBook_API *book, const QuoteTick_t *quote);
 
+    # Updates the order book with a trade tick.
+    #
+    # # Panics
+    #
+    # If book type is not `L1_MBP`.
     void orderbook_update_trade_tick(OrderBook_API *book, const TradeTick_t *tick);
 
     CVec orderbook_simulate_fills(const OrderBook_API *book, BookOrder_t order);
 
     uint8_t orderbook_check_integrity(const OrderBook_API *book);
 
     void vec_fills_drop(CVec v);
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/rust/model.pyx` & `nautilus_trader-1.191.0/nautilus_trader/core/rust/model.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/stats.pxd` & `nautilus_trader-1.191.0/nautilus_trader/core/stats.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/stats.pyx` & `nautilus_trader-1.191.0/nautilus_trader/core/stats.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/string.pxd` & `nautilus_trader-1.191.0/nautilus_trader/core/string.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/uuid.pxd` & `nautilus_trader-1.191.0/nautilus_trader/core/uuid.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/core/uuid.pyx` & `nautilus_trader-1.191.0/nautilus_trader/core/uuid.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/data/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/core/rust/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/data/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/data/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/data/aggregation.pxd` & `nautilus_trader-1.191.0/nautilus_trader/data/aggregation.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/data/aggregation.pyx` & `nautilus_trader-1.191.0/nautilus_trader/data/aggregation.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -705,15 +705,15 @@
             name=self._timer_name,
             interval=self.interval,
             start_time=self.get_start_time(),
             stop_time=None,
             callback=self._build_bar,
         )
 
-        self._log.debug(f"Started timer {self._timer_name}.")
+        self._log.debug(f"Started timer {self._timer_name}")
 
     cdef void _apply_update(self, Price price, Quantity size, uint64_t ts_event):
         self._builder.update(price, size, ts_event)
         if self._build_on_next_tick:
             ts_init = ts_event
 
             # Adjusting the timestamp logic based on interval_type
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/data/client.pxd` & `nautilus_trader-1.191.0/nautilus_trader/data/client.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/data/client.pyx` & `nautilus_trader-1.191.0/nautilus_trader/data/client.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -118,30 +118,30 @@
         ----------
         data_type : DataType
             The data type for the subscription.
 
         """
         self._log.error(
             f"Cannot subscribe to {data_type}: not implemented. "
-            f"You can implement by overriding the `subscribe` method for this client.",
+            f"You can implement by overriding the `subscribe` method for this client",
         )
 
     cpdef void unsubscribe(self, DataType data_type):
         """
         Unsubscribe from data for the given data type.
 
         Parameters
         ----------
         data_type : DataType
             The data type for the subscription.
 
         """
         self._log.error(
             f"Cannot unsubscribe from {data_type}: not implemented. "
-            f"You can implement by overriding the `unsubscribe` method for this client.",
+            f"You can implement by overriding the `unsubscribe` method for this client",
         )
 
     cpdef void _add_subscription(self, DataType data_type):
         Condition.not_none(data_type, "data_type")
 
         self._subscriptions_generic.add(data_type)
 
@@ -162,15 +162,15 @@
             The data type for the subscription.
         correlation_id : UUID4
             The correlation ID for the response.
 
         """
         self._log.error(
             f"Cannot request {data_type}: not implemented. "
-            f"You can implement by overriding the `request` method for this client.",
+            f"You can implement by overriding the `request` method for this client",
         )
 
 # -- PYTHON WRAPPERS ------------------------------------------------------------------------------
 
     def _handle_data_py(self, Data data):
         self._handle_data(data)
 
@@ -372,37 +372,37 @@
         ----------
         data_type : DataType
             The data type for the subscription.
 
         """
         self._log.error(
             f"Cannot subscribe to {data_type}: not implemented. "
-            f"You can implement by overriding the `subscribe` method for this client.",
+            f"You can implement by overriding the `subscribe` method for this client",
         )
         raise NotImplementedError("method `subscribe` must be implemented in the subclass")
 
     cpdef void subscribe_instruments(self):
         """
         Subscribe to all `Instrument` data.
 
         """
         self._log.error(
             f"Cannot subscribe to all `Instrument` data: not implemented. "
-            f"You can implement by overriding the `subscribe_instruments` method for this client.",
+            f"You can implement by overriding the `subscribe_instruments` method for this client",
         )
         raise NotImplementedError("method `subscribe_instruments` must be implemented in the subclass")
 
     cpdef void subscribe_instrument(self, InstrumentId instrument_id):
         """
         Subscribe to the `Instrument` with the given instrument ID.
 
         """
         self._log.error(
             f"Cannot subscribe to `Instrument` data for {instrument_id}: not implemented. "
-            f"You can implement by overriding the `subscribe_instrument` method for this client.",
+            f"You can implement by overriding the `subscribe_instrument` method for this client",
         )
         raise NotImplementedError("method `subscribe_instrument` must be implemented in the subclass")
 
     cpdef void subscribe_order_book_deltas(self, InstrumentId instrument_id, BookType book_type, int depth = 0, dict kwargs = None):
         """
         Subscribe to `OrderBookDeltas` data for the given instrument ID.
 
@@ -416,15 +416,15 @@
             The maximum depth for the subscription.
         kwargs : dict, optional
             The keyword arguments for exchange specific parameters.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot subscribe to `OrderBookDeltas` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `subscribe_order_book_deltas` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `subscribe_order_book_deltas` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `subscribe_order_book_deltas` must be implemented in the subclass")
 
     cpdef void subscribe_order_book_snapshots(self, InstrumentId instrument_id, BookType book_type, int depth = 0, dict kwargs = None):
         """
         Subscribe to `OrderBook` snapshots data for the given instrument ID.
 
@@ -438,15 +438,15 @@
             The maximum depth for the order book. A depth of 0 is maximum depth.
         kwargs : dict, optional
             The keyword arguments for exchange specific parameters.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot subscribe to `OrderBook` snapshots data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `subscribe_order_book_snapshots` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `subscribe_order_book_snapshots` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `subscribe_order_book_snapshots` must be implemented in the subclass")
 
     cpdef void subscribe_quote_ticks(self, InstrumentId instrument_id):
         """
         Subscribe to `QuoteTick` data for the given instrument ID.
 
@@ -454,15 +454,15 @@
         ----------
         instrument_id : InstrumentId
             The tick instrument to subscribe to.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot subscribe to `QuoteTick` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `subscribe_quote_ticks` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `subscribe_quote_ticks` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `subscribe_quote_ticks` must be implemented in the subclass")
 
     cpdef void subscribe_trade_ticks(self, InstrumentId instrument_id):
         """
         Subscribe to `TradeTick` data for the given instrument ID.
 
@@ -470,15 +470,15 @@
         ----------
         instrument_id : InstrumentId
             The tick instrument to subscribe to.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot subscribe to `TradeTick` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `subscribe_trade_ticks` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `subscribe_trade_ticks` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `subscribe_trade_ticks` must be implemented in the subclass")
 
     cpdef void subscribe_venue_status(self, Venue venue):
         """
         Subscribe to `InstrumentStatus` data for the venue.
 
@@ -486,15 +486,15 @@
         ----------
         venue : Venue
             The venue to subscribe to.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot subscribe to `VenueStatus` data for {venue}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `subscribe_venue_status` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `subscribe_venue_status` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `subscribe_venue_status` must be implemented in the subclass")
 
     cpdef void subscribe_instrument_status(self, InstrumentId instrument_id):
         """
         Subscribe to `InstrumentStatus` data for the given instrument ID.
 
@@ -502,15 +502,15 @@
         ----------
         instrument_id : InstrumentId
             The tick instrument to subscribe to.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot subscribe to `InstrumentStatus` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `subscribe_instrument_status` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `subscribe_instrument_status` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `subscribe_instrument_status` must be implemented in the subclass")
 
     cpdef void subscribe_instrument_close(self, InstrumentId instrument_id):
         """
         Subscribe to `InstrumentClose` updates for the given instrument ID.
 
@@ -518,15 +518,15 @@
         ----------
         instrument_id : InstrumentId
             The tick instrument to subscribe to.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot subscribe to `InstrumentClose` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `subscribe_instrument_close` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `subscribe_instrument_close` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `subscribe_instrument_close` must be implemented in the subclass")
 
     cpdef void subscribe_bars(self, BarType bar_type):
         """
         Subscribe to `Bar` data for the given bar type.
 
@@ -534,15 +534,15 @@
         ----------
         bar_type : BarType
             The bar type to subscribe to.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot subscribe to `Bar` data for {bar_type}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `subscribe_bars` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `subscribe_bars` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `subscribe_bars` must be implemented in the subclass")
 
     cpdef void unsubscribe(self, DataType data_type):
         """
         Unsubscribe from data for the given data type.
 
@@ -550,25 +550,25 @@
         ----------
         data_type : DataType
             The data type for the subscription.
 
         """
         self._log.error(
             f"Cannot unsubscribe from {data_type}: not implemented. "
-            f"You can implement by overriding the `unsubscribe` method for this client.",
+            f"You can implement by overriding the `unsubscribe` method for this client",
         )
 
     cpdef void unsubscribe_instruments(self):
         """
         Unsubscribe from all `Instrument` data.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot unsubscribe from all `Instrument` data: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `unsubscribe_instruments` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `unsubscribe_instruments` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `unsubscribe_instruments` must be implemented in the subclass")
 
     cpdef void unsubscribe_instrument(self, InstrumentId instrument_id):
         """
         Unsubscribe from `Instrument` data for the given instrument ID.
 
@@ -576,15 +576,15 @@
         ----------
         instrument_id : InstrumentId
             The instrument to unsubscribe from.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot unsubscribe from `Instrument` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `unsubscribe_instrument` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `unsubscribe_instrument` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `unsubscribe_instrument` must be implemented in the subclass")
 
     cpdef void unsubscribe_order_book_deltas(self, InstrumentId instrument_id):
         """
         Unsubscribe from `OrderBookDeltas` data for the given instrument ID.
 
@@ -592,15 +592,15 @@
         ----------
         instrument_id : InstrumentId
             The order book instrument to unsubscribe from.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot unsubscribe from `OrderBookDeltas` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `unsubscribe_order_book_deltas` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `unsubscribe_order_book_deltas` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `unsubscribe_order_book_deltas` must be implemented in the subclass")
 
     cpdef void unsubscribe_order_book_snapshots(self, InstrumentId instrument_id):
         """
         Unsubscribe from `OrderBook` snapshots data for the given instrument ID.
 
@@ -608,15 +608,15 @@
         ----------
         instrument_id : InstrumentId
             The order book instrument to unsubscribe from.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot unsubscribe from `OrderBook` snapshot data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `unsubscribe_order_book_snapshots` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `unsubscribe_order_book_snapshots` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `unsubscribe_order_book_snapshots` must be implemented in the subclass")
 
     cpdef void unsubscribe_quote_ticks(self, InstrumentId instrument_id):
         """
         Unsubscribe from `QuoteTick` data for the given instrument ID.
 
@@ -624,15 +624,15 @@
         ----------
         instrument_id : InstrumentId
             The tick instrument to unsubscribe from.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot unsubscribe from `QuoteTick` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `unsubscribe_quote_ticks` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `unsubscribe_quote_ticks` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `unsubscribe_quote_ticks` must be implemented in the subclass")
 
     cpdef void unsubscribe_trade_ticks(self, InstrumentId instrument_id):
         """
         Unsubscribe from `TradeTick` data for the given instrument ID.
 
@@ -640,15 +640,15 @@
         ----------
         instrument_id : InstrumentId
             The tick instrument to unsubscribe from.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot unsubscribe from `TradeTick` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `unsubscribe_trade_ticks` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `unsubscribe_trade_ticks` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `unsubscribe_trade_ticks` must be implemented in the subclass")
 
     cpdef void unsubscribe_bars(self, BarType bar_type):
         """
         Unsubscribe from `Bar` data for the given bar type.
 
@@ -656,15 +656,15 @@
         ----------
         bar_type : BarType
             The bar type to unsubscribe from.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot unsubscribe from `Bar` data for {bar_type}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `unsubscribe_bars` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `unsubscribe_bars` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `unsubscribe_bars` must be implemented in the subclass")
 
     cpdef void unsubscribe_venue_status(self, Venue venue):
         """
         Unsubscribe from `InstrumentStatus` data for the given venue.
 
@@ -672,15 +672,15 @@
         ----------
         venue : Venue
             The venue to unsubscribe from.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot unsubscribe from `VenueStatus` data for {venue}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `unsubscribe_venue_status` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `unsubscribe_venue_status` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `unsubscribe_venue_status` must be implemented in the subclass")
 
     cpdef void unsubscribe_instrument_status(self, InstrumentId instrument_id):
         """
         Unsubscribe from `InstrumentStatus` data for the given instrument ID.
 
@@ -688,15 +688,15 @@
         ----------
         instrument_id : InstrumentId
             The instrument status updates to unsubscribe from.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot unsubscribe from `InstrumentStatus` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `unsubscribe_instrument_status` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `unsubscribe_instrument_status` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `unsubscribe_instrument_status` must be implemented in the subclass")
 
     cpdef void unsubscribe_instrument_close(self, InstrumentId instrument_id):
         """
         Unsubscribe from `InstrumentClose` data for the given instrument ID.
 
@@ -704,15 +704,15 @@
         ----------
         instrument_id : InstrumentId
             The tick instrument to unsubscribe from.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot unsubscribe from `InstrumentClose` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `unsubscribe_instrument_close` method for this client.",  # pragma: no cover
+            f"You can implement by overriding the `unsubscribe_instrument_close` method for this client",  # pragma: no cover
         )
         raise NotImplementedError("method `unsubscribe_instrument_close` must be implemented in the subclass")
 
     cpdef void _add_subscription(self, DataType data_type):
         Condition.not_none(data_type, "data_type")
 
         self._subscriptions_generic.add(data_type)
@@ -835,15 +835,15 @@
         end : datetime, optional
             The end datetime (UTC) of request time range.
             The inclusiveness depends on individual data client implementation.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot request `Instrument` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `request_instrument` method for this client.",  # pragma: no cover  # noqa
+            f"You can implement by overriding the `request_instrument` method for this client",  # pragma: no cover  # noqa
         )
 
     cpdef void request_instruments(
         self,
         Venue venue,
         UUID4 correlation_id,
         datetime start = None,
@@ -863,15 +863,15 @@
         end : datetime, optional
             The end datetime (UTC) of request time range.
             The inclusiveness depends on individual data client implementation.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot request all `Instrument` data: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `request_instruments` method for this client.",  # pragma: no cover  # noqa
+            f"You can implement by overriding the `request_instruments` method for this client",  # pragma: no cover  # noqa
         )
 
     cpdef void request_quote_ticks(
         self,
         InstrumentId instrument_id,
         int limit,
         UUID4 correlation_id,
@@ -894,15 +894,15 @@
         end : datetime, optional
             The end datetime (UTC) of request time range.
             The inclusiveness depends on individual data client implementation.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot request `QuoteTick` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `request_quote_ticks` method for this client.",  # pragma: no cover  # noqa
+            f"You can implement by overriding the `request_quote_ticks` method for this client",  # pragma: no cover  # noqa
         )
 
     cpdef void request_trade_ticks(
         self,
         InstrumentId instrument_id,
         int limit,
         UUID4 correlation_id,
@@ -925,15 +925,15 @@
         end : datetime, optional
             The end datetime (UTC) of request time range.
             The inclusiveness depends on individual data client implementation.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot request `TradeTick` data for {instrument_id}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `request_trade_ticks` method for this client.",  # pragma: no cover  # noqa
+            f"You can implement by overriding the `request_trade_ticks` method for this client",  # pragma: no cover  # noqa
         )
 
     cpdef void request_bars(
         self,
         BarType bar_type,
         int limit,
         UUID4 correlation_id,
@@ -956,15 +956,15 @@
         end : datetime, optional
             The end datetime (UTC) of request time range.
             The inclusiveness depends on individual data client implementation.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot request `Bar` data for {bar_type}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `request_bars` method for this client.",  # pragma: no cover  # noqa
+            f"You can implement by overriding the `request_bars` method for this client",  # pragma: no cover  # noqa
         )
 
 # -- PYTHON WRAPPERS ------------------------------------------------------------------------------
 
     # Convenient Python wrappers for the data handlers. Often Python methods
     # involving threads or the event loop don't work with `cpdef` methods.
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/data/config.py` & `nautilus_trader-1.191.0/nautilus_trader/data/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/data/engine.pxd` & `nautilus_trader-1.191.0/nautilus_trader/data/engine.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/data/engine.pyx` & `nautilus_trader-1.191.0/nautilus_trader/data/engine.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -267,15 +267,15 @@
         if client.venue is None:
             if self._default_client is None:
                 self._default_client = client
                 routing_log = " for default routing"
         else:
             self._routing_map[client.venue] = client
 
-        self._log.info(f"Registered {client}{routing_log}.")
+        self._log.info(f"Registered {client}{routing_log}")
 
     cpdef void register_default_client(self, DataClient client):
         """
         Register the given client as the default routing client (when a specific
         venue routing cannot be found).
 
         Any existing default routing client will be overwritten.
@@ -286,15 +286,15 @@
             The client to register.
 
         """
         Condition.not_none(client, "client")
 
         self._default_client = client
 
-        self._log.info(f"Registered {client} for default routing.")
+        self._log.info(f"Registered {client} for default routing")
 
     cpdef void register_venue_routing(self, DataClient client, Venue venue):
         """
         Register the given client to route orders to the given venue.
 
         Any existing client in the routing map for the given venue will be
         overwritten.
@@ -311,15 +311,15 @@
         Condition.not_none(venue, "venue")
 
         if client.id not in self._clients:
             self._clients[client.id] = client
 
         self._routing_map[venue] = client
 
-        self._log.info(f"Registered ExecutionClient-{client} for routing to {venue}.")
+        self._log.info(f"Registered ExecutionClient-{client} for routing to {venue}")
 
     cpdef void deregister_client(self, DataClient client):
         """
         Deregister the given data client from the data engine.
 
         Parameters
         ----------
@@ -327,15 +327,15 @@
             The data client to deregister.
 
         """
         Condition.not_none(client, "client")
         Condition.is_in(client.id, self._clients, "client.id", "self._clients")
 
         del self._clients[client.id]
-        self._log.info(f"Deregistered {client}.")
+        self._log.info(f"Deregistered {client}")
 
 # -- SUBSCRIPTIONS --------------------------------------------------------------------------------
 
     cpdef list subscribed_custom_data(self):
         """
         Return the custom data types subscribed to.
 
@@ -603,38 +603,38 @@
 
         self._handle_response(response)
 
 # -- COMMAND HANDLERS -----------------------------------------------------------------------------
 
     cpdef void _execute_command(self, DataCommand command):
         if self.debug:
-            self._log.debug(f"{RECV}{CMD} {command}.")
+            self._log.debug(f"{RECV}{CMD} {command}")
         self.command_count += 1
 
         cdef Venue venue = command.venue
         cdef DataClient client = self._clients.get(command.client_id)
         if venue is not None and venue.is_synthetic():
             # No further check as no client needed
             pass
         elif client is None:
             client = self._routing_map.get(command.venue, self._default_client)
             if client is None:
                 self._log.error(
                     f"Cannot execute command: "
                     f"no data client configured for {command.venue} or `client_id` {command.client_id}, "
-                    f"{command}."
+                    f"{command}"
                 )
                 return  # No client to handle command
 
         if isinstance(command, Subscribe):
             self._handle_subscribe(client, command)
         elif isinstance(command, Unsubscribe):
             self._handle_unsubscribe(client, command)
         else:
-            self._log.error(f"Cannot handle command: unrecognized {command}.")
+            self._log.error(f"Cannot handle command: unrecognized {command}")
 
     cpdef void _handle_subscribe(self, DataClient client, Subscribe command):
         if command.data_type.type == Instrument:
             self._handle_subscribe_instrument(
                 client,
                 command.data_type.metadata.get("instrument_id"),
             )
@@ -728,15 +728,15 @@
         Condition.not_none(client, "client")
 
         if instrument_id is None:
             client.subscribe_instruments()
             return
 
         if instrument_id.is_synthetic():
-            self._log.error("Cannot subscribe for synthetic instrument `Instrument` data.")
+            self._log.error("Cannot subscribe for synthetic instrument `Instrument` data")
             return
 
         if instrument_id not in client.subscribed_instruments():
             client.subscribe_instrument(instrument_id)
 
     cpdef void _handle_subscribe_order_book_deltas(
         self,
@@ -745,15 +745,15 @@
         dict metadata,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
         Condition.not_none(metadata, "metadata")
 
         if instrument_id.is_synthetic():
-            self._log.error("Cannot subscribe for synthetic instrument `OrderBookDelta` data.")
+            self._log.error("Cannot subscribe for synthetic instrument `OrderBookDelta` data")
             return
 
         self._setup_order_book(
             client,
             instrument_id,
             metadata,
             only_deltas=True,
@@ -767,15 +767,15 @@
         dict metadata,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
         Condition.not_none(metadata, "metadata")
 
         if instrument_id.is_synthetic():
-            self._log.error("Cannot subscribe for synthetic instrument `OrderBook` data.")
+            self._log.error("Cannot subscribe for synthetic instrument `OrderBook` data")
             return
 
         cdef:
             uint64_t interval_ms = metadata["interval_ms"]
             uint64_t interval_ns
             uint64_t timestamp_ns
         key = (instrument_id, interval_ms)
@@ -793,15 +793,15 @@
             self._clock.set_timer_ns(
                 name=timer_name,
                 interval_ns=interval_ns,
                 start_time_ns=start_time_ns,
                 stop_time_ns=0,  # No stop
                 callback=self._snapshot_order_book,
             )
-            self._log.debug(f"Set timer {timer_name}.")
+            self._log.debug(f"Set timer {timer_name}")
 
         self._setup_order_book(
             client,
             instrument_id,
             metadata,
             only_deltas=False,
             managed=metadata["managed"]
@@ -821,24 +821,24 @@
 
         # Create order book
         if managed and not self._cache.has_order_book(instrument_id):
             instrument = self._cache.instrument(instrument_id)
             if instrument is None:
                 self._log.error(
                     f"Cannot subscribe to {instrument_id} <OrderBook> data: "
-                    f"no instrument found in the cache.",
+                    f"no instrument found in the cache",
                 )
                 return
             order_book = OrderBook(
                 instrument_id=instrument.id,
                 book_type=metadata["book_type"],
             )
 
             self._cache.add_order_book(order_book)
-            self._log.debug(f"Created {type(order_book).__name__}.")
+            self._log.debug(f"Created {type(order_book).__name__}")
 
         # Always re-subscribe to override previous settings
         try:
             if instrument_id not in client.subscribed_order_book_deltas():
                 client.subscribe_order_book_deltas(
                     instrument_id=instrument_id,
                     book_type=metadata["book_type"],
@@ -896,15 +896,15 @@
             client.subscribe_quote_ticks(instrument_id)
 
     cpdef void _handle_subscribe_synthetic_quote_ticks(self, InstrumentId instrument_id):
         cdef SyntheticInstrument synthetic = self._cache.synthetic(instrument_id)
         if synthetic is None:
             self._log.error(
                 f"Cannot subscribe to `QuoteTick` data for synthetic instrument {instrument_id}, "
-                " not found."
+                " not found"
             )
             return
 
         if instrument_id in self._subscribed_synthetic_quotes:
             return  # Already setup
 
         cdef:
@@ -936,15 +936,15 @@
             client.subscribe_trade_ticks(instrument_id)
 
     cpdef void _handle_subscribe_synthetic_trade_ticks(self, InstrumentId instrument_id):
         cdef SyntheticInstrument synthetic = self._cache.synthetic(instrument_id)
         if synthetic is None:
             self._log.error(
                 f"Cannot subscribe to `TradeTick` data for synthetic instrument {instrument_id}, "
-                " not found."
+                " not found"
             )
             return
 
         if instrument_id in self._subscribed_synthetic_trades:
             return  # Already setup
 
         cdef:
@@ -974,15 +974,15 @@
             # Internal aggregation
             if bar_type not in self._bar_aggregators:
                 self._start_bar_aggregator(client, bar_type, await_partial)
         else:
             # External aggregation
             if bar_type.instrument_id.is_synthetic():
                 self._log.error(
-                    "Cannot subscribe for externally aggregated synthetic instrument bar data.",
+                    "Cannot subscribe for externally aggregated synthetic instrument bar data",
                 )
                 return
 
             if bar_type not in client.subscribed_bars():
                 client.subscribe_bars(bar_type)
 
     cpdef void _handle_subscribe_data(
@@ -995,15 +995,15 @@
 
         try:
             if data_type not in client.subscribed_custom_data():
                 client.subscribe(data_type)
         except NotImplementedError:
             self._log.error(
                 f"Cannot subscribe: {client.id.value} "
-                f"has not implemented {data_type} subscriptions.",
+                f"has not implemented {data_type} subscriptions",
             )
             return
 
     cpdef void _handle_subscribe_venue_status(
         self,
         MarketDataClient client,
         Venue venue,
@@ -1020,15 +1020,15 @@
         InstrumentId instrument_id,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
 
         if instrument_id.is_synthetic():
             self._log.error(
-                "Cannot subscribe for synthetic instrument `InstrumentStatus` data.",
+                "Cannot subscribe for synthetic instrument `InstrumentStatus` data",
             )
             return
 
         if instrument_id not in client.subscribed_instrument_status():
             client.subscribe_instrument_status(instrument_id)
 
     cpdef void _handle_subscribe_instrument_close(
@@ -1036,15 +1036,15 @@
         MarketDataClient client,
         InstrumentId instrument_id,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
 
         if instrument_id.is_synthetic():
-            self._log.error("Cannot subscribe for synthetic instrument `InstrumentClose` data.")
+            self._log.error("Cannot subscribe for synthetic instrument `InstrumentClose` data")
             return
 
         if instrument_id not in client.subscribed_instrument_close():
             client.subscribe_instrument_close(instrument_id)
 
     cpdef void _handle_unsubscribe_instrument(
         self,
@@ -1055,15 +1055,15 @@
 
         if instrument_id is None:
             if not self._msgbus.has_subscribers(f"data.instrument.{client.id.value}.*"):
                 client.unsubscribe_instruments()
             return
         else:
             if instrument_id.is_synthetic():
-                self._log.error("Cannot unsubscribe from synthetic instrument `Instrument` data.")
+                self._log.error("Cannot unsubscribe from synthetic instrument `Instrument` data")
                 return
 
             if not self._msgbus.has_subscribers(
                 f"data.instrument"
                 f".{instrument_id.venue}"
                 f".{instrument_id.symbol}",
             ):
@@ -1076,15 +1076,15 @@
         dict metadata,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
         Condition.not_none(metadata, "metadata")
 
         if instrument_id.is_synthetic():
-            self._log.error("Cannot unsubscribe from synthetic instrument `OrderBookDelta` data.")
+            self._log.error("Cannot unsubscribe from synthetic instrument `OrderBookDelta` data")
             return
 
         if not self._msgbus.has_subscribers(
             f"data.book.deltas"
             f".{instrument_id.venue}"
             f".{instrument_id.symbol}",
         ):
@@ -1097,15 +1097,15 @@
         dict metadata,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
         Condition.not_none(metadata, "metadata")
 
         if instrument_id.is_synthetic():
-            self._log.error("Cannot unsubscribe from synthetic instrument `OrderBook` data.")
+            self._log.error("Cannot unsubscribe from synthetic instrument `OrderBook` data")
             return
 
         if not self._msgbus.has_subscribers(
             f"data.book.snapshots"
             f".{instrument_id.venue}"
             f".{instrument_id.symbol}",
         ):
@@ -1171,23 +1171,23 @@
 
         try:
             if not self._msgbus.has_subscribers(f"data.{data_type}"):
                 client.unsubscribe(data_type)
         except NotImplementedError:
             self._log.error(
                 f"Cannot unsubscribe: {client.id.value} "
-                f"has not implemented data type {data_type} subscriptions.",
+                f"has not implemented data type {data_type} subscriptions",
             )
             return
 
 # -- REQUEST HANDLERS -----------------------------------------------------------------------------
 
     cpdef void _handle_request(self, DataRequest request):
         if self.debug:
-            self._log.debug(f"{RECV}{REQ} {request}.", LogColor.MAGENTA)
+            self._log.debug(f"{RECV}{REQ} {request}", LogColor.MAGENTA)
         self.request_count += 1
 
         # Query data catalog
         if self._catalog:
             # For now we'll just query the catalog if its present (as very likely this is a backtest)
             self._query_catalog(request)
             return
@@ -1198,15 +1198,15 @@
             client = self._routing_map.get(
                 request.venue,
                 self._default_client,
             )
             if client is None:
                 self._log.error(
                     f"Cannot handle request: "
-                    f"no client registered for '{request.client_id}', {request}.")
+                    f"no client registered for '{request.client_id}', {request}")
                 return  # No client to handle request
 
         if request.data_type.type == Instrument:
             Condition.true(isinstance(client, MarketDataClient), "client was not a MarketDataClient")
             instrument_id = request.data_type.metadata.get("instrument_id")
             if instrument_id is None:
                 client.request_instruments(
@@ -1249,15 +1249,15 @@
                 request.data_type.metadata.get("start"),
                 request.data_type.metadata.get("end"),
             )
         else:
             try:
                 client.request(request.data_type, request.id)
             except NotImplementedError:
-                self._log.error(f"Cannot handle request: unrecognized data type {request.data_type}.")
+                self._log.error(f"Cannot handle request: unrecognized data type {request.data_type}")
 
     cpdef void _query_catalog(self, DataRequest request):
         cdef datetime start = request.data_type.metadata.get("start")
         cdef datetime end = request.data_type.metadata.get("end")
 
         cdef uint64_t ts_now = self._clock.timestamp_ns()
         cdef uint64_t ts_start = dt_to_unix_nanos(start) if start is not None else 0
@@ -1265,15 +1265,15 @@
 
         # Validate request time range
         Condition.true(ts_start <= ts_end, f"{ts_start=} was greater than {ts_end=}")
 
         if end is not None and ts_end > ts_now:
             self._log.warning(
                 "Cannot request data beyond current time. "
-                f"Truncating `end` to current UNIX nanoseconds {unix_nanos_to_dt(ts_now)}.",
+                f"Truncating `end` to current UNIX nanoseconds {unix_nanos_to_dt(ts_now)}",
             )
             ts_end = ts_now
 
         if request.data_type.type == Instrument:
             instrument_id = request.data_type.metadata.get("instrument_id")
             if instrument_id is None:
                 data = self._catalog.instruments()
@@ -1290,15 +1290,15 @@
                 instrument_ids=[str(request.data_type.metadata.get("instrument_id"))],
                 start=ts_start,
                 end=ts_end,
             )
         elif request.data_type.type == Bar:
             bar_type = request.data_type.metadata.get("bar_type")
             if bar_type is None:
-                self._log.error("No bar type provided for bars request.")
+                self._log.error("No bar type provided for bars request")
                 return
             data = self._catalog.bars(
                 instrument_ids=[str(bar_type.instrument_id)],
                 bar_type=str(bar_type),
                 start=ts_start,
                 end=ts_end,
             )
@@ -1358,15 +1358,15 @@
         elif isinstance(data, InstrumentStatus):
             self._handle_instrument_status(data)
         elif isinstance(data, InstrumentClose):
             self._handle_close_price(data)
         elif isinstance(data, CustomData):
             self._handle_custom_data(data)
         else:
-            self._log.error(f"Cannot handle data: unrecognized type {type(data)} {data}.")
+            self._log.error(f"Cannot handle data: unrecognized type {type(data)} {data}")
 
     cpdef void _handle_instrument(self, Instrument instrument):
         self._cache.add_instrument(instrument)
         self._msgbus.publish_c(
             topic=f"data.instrument"
                   f".{instrument.id.venue}"
                   f".{instrument.id.symbol}",
@@ -1440,32 +1440,32 @@
             list bars
             int i
         if self._validate_data_sequence:
             last_bar = self._cache.bar(bar_type)
             if last_bar is not None:
                 if bar.ts_event < last_bar.ts_event:
                     self._log.warning(
-                        f"Bar {bar} was prior to last bar `ts_event` {last_bar.ts_event}.",
+                        f"Bar {bar} was prior to last bar `ts_event` {last_bar.ts_event}",
                     )
                     return  # `bar` is out of sequence
                 if bar.ts_init < last_bar.ts_init:
                     self._log.warning(
-                        f"Bar {bar} was prior to last bar `ts_init` {last_bar.ts_init}.",
+                        f"Bar {bar} was prior to last bar `ts_init` {last_bar.ts_init}",
                     )
                     return  # `bar` is out of sequence
                 if bar.is_revision:
                     if bar.ts_event == last_bar.ts_event:
                         # Replace `last_bar`, previously cached bar will fall out of scope
                         self._cache._bars.get(bar_type)[0] = bar  # noqa
                     elif bar.ts_event > last_bar.ts_event:
                         # Bar is latest, consider as new bar
                         self._cache.add_bar(bar)
                     else:
                         self._log.warning(
-                            f"Bar revision {bar} was not at last bar `ts_event` {last_bar.ts_event}.",
+                            f"Bar revision {bar} was not at last bar `ts_event` {last_bar.ts_event}",
                         )
                         return  # Revision SHOULD be at `last_bar.ts_event`
 
         if not bar.is_revision:
             self._cache.add_bar(bar)
 
         self._msgbus.publish_c(topic=f"data.bars.{bar_type}", msg=bar)
@@ -1482,15 +1482,15 @@
     cpdef void _handle_custom_data(self, CustomData data):
         self._msgbus.publish_c(topic=f"data.{data.data_type.topic}", msg=data.data)
 
 # -- RESPONSE HANDLERS ----------------------------------------------------------------------------
 
     cpdef void _handle_response(self, DataResponse response):
         if self.debug:
-            self._log.debug(f"{RECV}{RES} {response}.", LogColor.MAGENTA)
+            self._log.debug(f"{RECV}{RES} {response}", LogColor.MAGENTA)
         self.response_count += 1
 
         if response.data_type.type == Instrument:
             if isinstance(response.data, list):
                 self._handle_instruments(response.data)
             else:
                 self._handle_instrument(response.data)
@@ -1520,22 +1520,22 @@
         cdef BarAggregator aggregator
         if partial is not None and partial.bar_type.is_internally_aggregated():
             # Update partial time bar
             aggregator = self._bar_aggregators.get(partial.bar_type)
             aggregator.set_await_partial(False)
 
             if aggregator:
-                self._log.debug(f"Applying partial bar {partial} for {partial.bar_type}.")
+                self._log.debug(f"Applying partial bar {partial} for {partial.bar_type}")
                 aggregator.set_partial(partial)
             else:
                 if self._fsm.state == ComponentState.RUNNING:
                     # Only log this error if the component is running, because
                     # there may have been an immediate stop called after start
                     # - with the partial bar being for a now removed aggregator.
-                    self._log.error("No aggregator for partial bar update.")
+                    self._log.error("No aggregator for partial bar update")
 
 # -- INTERNAL -------------------------------------------------------------------------------------
 
     # Python wrapper to enable callbacks
     cpdef void _internal_update_instruments(self, list instruments: [Instrument]):
         # Handle all instruments individually
         cdef Instrument instrument
@@ -1558,42 +1558,42 @@
         cdef tuple[str] parts = snap_event.name.partition('|')[2].rpartition('|')
         cdef InstrumentId instrument_id = InstrumentId.from_str_c(parts[0])
         cdef int interval_ms = int(parts[2])
 
         cdef OrderBook order_book = self._cache.order_book(instrument_id)
         if order_book:
             if order_book.ts_last == 0:
-                self._log.debug("OrderBook not yet updated, skipping snapshot.")
+                self._log.debug("OrderBook not yet updated, skipping snapshot")
                 return
 
             self._msgbus.publish_c(
                 topic=f"data.book.snapshots"
                       f".{instrument_id.venue}"
                       f".{instrument_id.symbol}"
                       f".{interval_ms}",
                 msg=order_book,
             )
 
         else:
             self._log.error(
                 f"Cannot snapshot orderbook: "
-                f"no order book found, {snap_event}.",
+                f"no order book found, {snap_event}",
             )
 
     cpdef void _start_bar_aggregator(
         self,
         MarketDataClient client,
         BarType bar_type,
         bint await_partial,
     ):
         cdef Instrument instrument = self._cache.instrument(bar_type.instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot start bar aggregation: "
-                f"no instrument found for {bar_type.instrument_id}.",
+                f"no instrument found for {bar_type.instrument_id}",
             )
 
         if bar_type.spec.is_time_aggregated():
             # Create aggregator
             aggregator = TimeBarAggregator(
                 instrument=instrument,
                 bar_type=bar_type,
@@ -1629,15 +1629,15 @@
             )
 
         # Set if awaiting initial partial bar
         aggregator.set_await_partial(await_partial)
 
         # Add aggregator
         self._bar_aggregators[bar_type] = aggregator
-        self._log.debug(f"Added {aggregator} for {bar_type} bars.")
+        self._log.debug(f"Added {aggregator} for {bar_type} bars")
 
         # Subscribe to required data
         if bar_type.spec.price_type == PriceType.LAST:
             self._msgbus.subscribe(
                 topic=f"data.trades"
                       f".{bar_type.instrument_id.venue}"
                       f".{bar_type.instrument_id.symbol}",
@@ -1710,15 +1710,15 @@
                 inputs_bid.append(update_bid.as_f64_c())
                 inputs_ask.append(update_ask.as_f64_c())
                 continue
             component_quote = self._cache.quote_tick(instrument_id)
             if component_quote is None:
                 self._log.warning(
                     f"Cannot calculate synthetic instrument {synthetic.id} price, "
-                    f"no quotes for {instrument_id} yet...",
+                    f"no quotes for {instrument_id} yet",
                 )
                 return
             update_bid = component_quote.bid_price
             update_ask = component_quote.ask_price
             inputs_bid.append(update_bid.as_f64_c())
             inputs_ask.append(update_ask.as_f64_c())
 
@@ -1762,15 +1762,15 @@
                 update_price = update.price
                 inputs.append(update_price.as_f64_c())
                 continue
             component_trade = self._cache.trade_tick(instrument_id)
             if component_trade is None:
                 self._log.warning(
                     f"Cannot calculate synthetic instrument {synthetic.id} price, "
-                    f"no trades for {instrument_id} yet...",
+                    f"no trades for {instrument_id} yet",
                 )
                 return
             update_price = component_trade.price
             inputs.append(update_price.as_f64_c())
 
         cdef Price price = synthetic.calculate(inputs)
         cdef Quantity size_one = Quantity(1, 0)  # Placeholder for now
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/data/messages.pxd` & `nautilus_trader-1.191.0/nautilus_trader/data/messages.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/data/messages.pyx` & `nautilus_trader-1.191.0/nautilus_trader/data/messages.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/data/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/algorithms/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/algorithms/blank.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/algorithms/blank.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/algorithms/twap.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/algorithms/twap.py`

 * *Files 2% similar despite different names*

```diff
@@ -148,53 +148,53 @@
             "order.client_order_id",
             "self._scheduled_sizes",
         )
         self.log.info(repr(order), LogColor.CYAN)
 
         if order.order_type != OrderType.MARKET:
             self.log.error(
-                f"Cannot execute order: only implemented for market orders, {order.order_type=}.",
+                f"Cannot execute order: only implemented for market orders, {order.order_type=}",
             )
             return
 
         instrument = self.cache.instrument(order.instrument_id)
         if not instrument:
             self.log.error(
-                f"Cannot execute order: instrument {order.instrument_id} not found.",
+                f"Cannot execute order: instrument {order.instrument_id} not found",
             )
             return
 
         # Validate execution parameters
         exec_params = order.exec_algorithm_params
         if not exec_params:
             self.log.error(
                 f"Cannot execute order: "
-                f"`exec_algorithm_params` not found for primary order {order!r}.",
+                f"`exec_algorithm_params` not found for primary order {order!r}",
             )
             return
 
         horizon_secs = exec_params.get("horizon_secs")
         if not horizon_secs:
             self.log.error(
                 f"Cannot execute order: "
-                f"`horizon_secs` not found in `exec_algorithm_params` {exec_params}.",
+                f"`horizon_secs` not found in `exec_algorithm_params` {exec_params}",
             )
             return
 
         interval_secs = exec_params.get("interval_secs")
         if not interval_secs:
             self.log.error(
                 f"Cannot execute order: "
-                f"`interval_secs` not found in `exec_algorithm_params` {exec_params}.",
+                f"`interval_secs` not found in `exec_algorithm_params` {exec_params}",
             )
             return
 
         if horizon_secs < interval_secs:
             self.log.error(
-                f"Cannot execute order: " f"{horizon_secs=} was less than {interval_secs=}.",
+                f"Cannot execute order: " f"{horizon_secs=} was less than {interval_secs=}",
             )
             return
 
         # Calculate the number of intervals
         num_intervals: int = math.floor(horizon_secs / interval_secs)
 
         # Divide the order quantity evenly and determine any remainder
@@ -206,24 +206,24 @@
 
         if (
             qty_per_interval == order.quantity
             or qty_per_interval < instrument.size_increment
             or (instrument.min_quantity and qty_per_interval < instrument.min_quantity)
         ):
             # Immediately submit first order for entire size
-            self.log.warning(f"Submitting for entire size {qty_per_interval=}, {order.quantity=}.")
+            self.log.warning(f"Submitting for entire size {qty_per_interval=}, {order.quantity=}")
             self.submit_order(order)
             return  # Done
 
         scheduled_sizes: list[Quantity] = [qty_per_interval] * num_intervals
         if qty_remainder:
             scheduled_sizes.append(instrument.make_qty(qty_remainder))
 
         assert sum(scheduled_sizes) == order.quantity
-        self.log.info(f"Order execution size schedule: {scheduled_sizes}.", LogColor.BLUE)
+        self.log.info(f"Order execution size schedule: {scheduled_sizes}", LogColor.BLUE)
 
         self._scheduled_sizes[order.client_order_id] = scheduled_sizes
         first_qty: Quantity = scheduled_sizes.pop(0)
 
         spawned_order: MarketOrder = self.spawn_market(
             primary=order,
             quantity=first_qty,
@@ -238,15 +238,15 @@
         self.clock.set_timer(
             name=order.client_order_id.value,
             interval=timedelta(seconds=interval_secs),
             callback=self.on_time_event,
         )
         self.log.info(
             f"Started TWAP execution for {order.client_order_id}: "
-            f"{horizon_secs=}, {interval_secs=}.",
+            f"{horizon_secs=}, {interval_secs=}",
             LogColor.BLUE,
         )
 
     def on_time_event(self, event: TimeEvent) -> None:
         """
         Actions to be performed when the algorithm receives a time event.
 
@@ -268,15 +268,15 @@
         if primary.is_closed:
             self.complete_sequence(primary.client_order_id)
             return
 
         instrument: Instrument = self.cache.instrument(primary.instrument_id)
         if not instrument:
             self.log.error(
-                f"Cannot execute order: instrument {primary.instrument_id} not found.",
+                f"Cannot execute order: instrument {primary.instrument_id} not found",
             )
             return
 
         scheduled_sizes = self._scheduled_sizes.get(exec_spawn_id)
         if scheduled_sizes is None:
             self.log.error(f"Cannot find scheduled sizes for {exec_spawn_id=}")
             return
@@ -310,8 +310,8 @@
         exec_spawn_id : ClientOrderId
             The execution spawn ID to complete.
 
         """
         if exec_spawn_id.value in self.clock.timer_names:
             self.clock.cancel_timer(exec_spawn_id.value)
         self._scheduled_sizes.pop(exec_spawn_id, None)
-        self.log.info(f"Completed TWAP execution for {exec_spawn_id}.", LogColor.BLUE)
+        self.log.info(f"Completed TWAP execution for {exec_spawn_id}", LogColor.BLUE)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/examples/algorithms/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/blank.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/blank.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross.py`

 * *Files 1% similar despite different names*

```diff
@@ -79,16 +79,14 @@
 class EMACross(Strategy):
     """
     A simple moving average cross example strategy.
 
     When the fast EMA crosses the slow EMA then enter a position at the market
     in that direction.
 
-    Cancels all orders and closes all positions on stop.
-
     Parameters
     ----------
     config : EMACrossConfig
         The configuration for the instance.
 
     Raises
     ------
@@ -133,16 +131,16 @@
         # Get historical data
         self.request_bars(self.bar_type, start=self._clock.utc_now() - pd.Timedelta(days=1))
         # self.request_quote_ticks(self.instrument_id)
         # self.request_trade_ticks(self.instrument_id)
 
         # Subscribe to live data
         self.subscribe_bars(self.bar_type)
-        self.subscribe_quote_ticks(self.instrument_id)
-        # self.subscribe_trade_ticks(self.instrument_id)
+        # self.subscribe_quote_ticks(self.instrument_id)
+        self.subscribe_trade_ticks(self.instrument_id)
         # self.subscribe_ticker(self.instrument_id)  # For debugging
         # self.subscribe_order_book_deltas(self.instrument_id, depth=20)  # For debugging
         # self.subscribe_order_book_snapshots(self.instrument_id, depth=20)  # For debugging
 
     def on_instrument(self, instrument: Instrument) -> None:
         """
         Actions to be performed when the strategy is running and receives an instrument.
@@ -190,28 +188,28 @@
         Parameters
         ----------
         tick : QuoteTick
             The tick received.
 
         """
         # For debugging (must add a subscription)
-        # self.log.info(repr(tick), LogColor.CYAN)
+        self.log.info(repr(tick), LogColor.CYAN)
 
     def on_trade_tick(self, tick: TradeTick) -> None:
         """
         Actions to be performed when the strategy is running and receives a trade tick.
 
         Parameters
         ----------
         tick : TradeTick
             The tick received.
 
         """
         # For debugging (must add a subscription)
-        # self.log.info(repr(tick), LogColor.CYAN)
+        self.log.info(repr(tick), LogColor.CYAN)
 
     def on_bar(self, bar: Bar) -> None:
         """
         Actions to be performed when the strategy is running and receives a bar.
 
         Parameters
         ----------
@@ -220,15 +218,15 @@
 
         """
         self.log.info(repr(bar), LogColor.CYAN)
 
         # Check if indicators ready
         if not self.indicators_initialized():
             self.log.info(
-                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]...",
+                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]",
                 color=LogColor.BLUE,
             )
             return  # Wait for indicators to warm up...
 
         if bar.is_single_price():
             # Implies no market information for this bar
             return
@@ -303,15 +301,15 @@
         self.cancel_all_orders(self.instrument_id)
         if self.close_positions_on_stop:
             self.close_all_positions(self.instrument_id)
 
         # Unsubscribe from data
         self.unsubscribe_bars(self.bar_type)
         # self.unsubscribe_quote_ticks(self.instrument_id)
-        # self.unsubscribe_trade_ticks(self.instrument_id)
+        self.unsubscribe_trade_ticks(self.instrument_id)
         # self.unsubscribe_ticker(self.instrument_id)
         # self.unsubscribe_order_book_deltas(self.instrument_id)
         # self.unsubscribe_order_book_snapshots(self.instrument_id)
 
     def on_reset(self) -> None:
         """
         Actions to be performed when the strategy is reset.
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross_bracket.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross_bracket.py`

 * *Files 0% similar despite different names*

```diff
@@ -174,15 +174,15 @@
 
         """
         self.log.info(repr(bar), LogColor.CYAN)
 
         # Check if indicators ready
         if not self.indicators_initialized():
             self.log.info(
-                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]...",
+                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]",
                 color=LogColor.BLUE,
             )
             return  # Wait for indicators to warm up...
 
         if bar.is_single_price():
             # Implies no market information for this bar
             return
@@ -207,15 +207,15 @@
                 self.sell(bar)
 
     def buy(self, last_bar: Bar) -> None:
         """
         Users bracket buy method (example).
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
         bracket_distance: float = self.bracket_distance_atr * self.atr.value
         order_list: OrderList = self.order_factory.bracket(
             instrument_id=self.instrument_id,
             order_side=OrderSide.BUY,
             quantity=self.instrument.make_qty(self.trade_size),
@@ -232,15 +232,15 @@
         self.submit_order_list(order_list)
 
     def sell(self, last_bar: Bar) -> None:
         """
         Users bracket sell method (example).
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
         bracket_distance: float = self.bracket_distance_atr * self.atr.value
         order_list: OrderList = self.order_factory.bracket(
             instrument_id=self.instrument_id,
             order_side=OrderSide.SELL,
             quantity=self.instrument.make_qty(self.trade_size),
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross_bracket_algo.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross_bracket_algo.py`

 * *Files 0% similar despite different names*

```diff
@@ -209,15 +209,15 @@
 
         """
         self.log.info(repr(bar), LogColor.CYAN)
 
         # Check if indicators ready
         if not self.indicators_initialized():
             self.log.info(
-                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]...",
+                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]",
                 color=LogColor.BLUE,
             )
             return  # Wait for indicators to warm up...
 
         if bar.is_single_price():
             # Implies no market information for this bar
             return
@@ -242,15 +242,15 @@
                 self.sell(bar)
 
     def buy(self, last_bar: Bar) -> None:
         """
         Users bracket buy method (example).
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
         tick_size: Price = self.instrument.price_increment
         bracket_distance: float = self.bracket_distance_atr * self.atr.value
 
         order_list: OrderList = self.order_factory.bracket(
             instrument_id=self.instrument_id,
@@ -274,15 +274,15 @@
         self.submit_order_list(order_list)
 
     def sell(self, last_bar: Bar) -> None:
         """
         Users bracket sell method (example).
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
         tick_size: Price = self.instrument.price_increment
         bracket_distance: float = self.bracket_distance_atr * self.atr.value
 
         order_list: OrderList = self.order_factory.bracket(
             instrument_id=self.instrument_id,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross_cython.pyx` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross_cython.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -201,15 +201,15 @@
 
         """
         self.log.info(f"Received Bar({bar})")
 
         # Check if indicators ready
         if not self.indicators_initialized():
             self.log.info(
-                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]...",
+                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]",
                 color=LogColor.BLUE,
             )
             return  # Wait for indicators to warm up...
 
         # BUY LOGIC
         if self.fast_ema.value >= self.slow_ema.value:
             if self.portfolio.is_flat(self.instrument_id):
@@ -226,15 +226,15 @@
                 self.sell()
 
     cpdef void buy(self):
         """
         Users simple buy method (example).
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
         cdef MarketOrder order = self.order_factory.market(
             instrument_id=self.instrument_id,
             order_side=OrderSide.BUY,
             quantity=self.instrument.make_qty(self.trade_size),
         )
@@ -242,15 +242,15 @@
         self.submit_order(order)
 
     cpdef void sell(self):
         """
         Users simple sell method (example).
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
         cdef MarketOrder order = self.order_factory.market(
             instrument_id=self.instrument_id,
             order_side=OrderSide.SELL,
             quantity=self.instrument.make_qty(self.trade_size),
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross_stop_entry.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross_trailing_stop.py`

 * *Files 15% similar despite different names*

```diff
@@ -26,47 +26,47 @@
 from nautilus_trader.indicators.average.ema import ExponentialMovingAverage
 from nautilus_trader.model.book import OrderBook
 from nautilus_trader.model.data import Bar
 from nautilus_trader.model.data import BarType
 from nautilus_trader.model.data import QuoteTick
 from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import OrderSide
-from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import TrailingOffsetType
 from nautilus_trader.model.enums import TriggerType
 from nautilus_trader.model.events import OrderFilled
+from nautilus_trader.model.events import PositionChanged
+from nautilus_trader.model.events import PositionClosed
+from nautilus_trader.model.events import PositionOpened
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
-from nautilus_trader.model.orders import MarketIfTouchedOrder
+from nautilus_trader.model.orders import MarketOrder
 from nautilus_trader.model.orders import TrailingStopMarketOrder
 from nautilus_trader.trading.strategy import Strategy
 
 
 # *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
 # *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***
 
 
-class EMACrossStopEntryConfig(StrategyConfig, frozen=True):
+class EMACrossTrailingStopConfig(StrategyConfig, frozen=True):
     """
-    Configuration for ``EMACrossStopEntry`` instances.
+    Configuration for ``EMACrossTrailingStop`` instances.
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The instrument ID for the strategy.
     bar_type : BarType
         The bar type for the strategy.
     atr_period : PositiveInt
         The period for the ATR indicator.
     trailing_atr_multiple : PositiveFloat
         The ATR multiple for the trailing stop.
     trailing_offset_type : str
         The trailing offset type (interpreted as `TrailingOffsetType`).
-    trailing_offset : Decimal
-        The trailing offset amount.
     trigger_type : str
         The trailing stop trigger type (interpreted as `TriggerType`).
     trade_size : str
         The position size per trade (interpreted as Decimal).
     fast_ema_period : PositiveInt, default 10
         The fast EMA period.
     slow_ema_period : PositiveInt, default 20
@@ -84,76 +84,75 @@
     """
 
     instrument_id: InstrumentId
     bar_type: BarType
     atr_period: PositiveInt
     trailing_atr_multiple: PositiveFloat
     trailing_offset_type: str
-    trailing_offset: Decimal
     trigger_type: str
     trade_size: Decimal
     fast_ema_period: PositiveInt = 10
     slow_ema_period: PositiveInt = 20
     emulation_trigger: str = "NO_TRIGGER"
 
 
-class EMACrossStopEntry(Strategy):
+class EMACrossTrailingStop(Strategy):
     """
-    A simple moving average cross example strategy with a `MARKET_IF_TOUCHED` entry and
-    `TRAILING_STOP_MARKET` stop.
+    A simple moving average cross example strategy with a stop-market entry and trailing
+    stop.
 
-    When the fast EMA crosses the slow EMA then submits a `MARKET_IF_TOUCHED` order
-    one tick above the current bar for BUY, or one tick below the current bar
+    When the fast EMA crosses the slow EMA then submits a stop-market order one
+    tick above the current bar for BUY, or one tick below the current bar
     for SELL.
 
-    If the entry order is filled then a `TRAILING_STOP_MARKET` at a specified
-    ATR distance is submitted and managed.
+    If the entry order is filled then a trailing stop at a specified ATR
+    distance is submitted and managed.
 
     Cancels all orders and closes all positions on stop.
 
     Parameters
     ----------
-    config : EMACrossStopEntryConfig
+    config : EMACrossTrailingStopConfig
         The configuration for the instance.
 
     Raises
     ------
     ValueError
         If `config.fast_ema_period` is not less than `config.slow_ema_period`.
 
     """
 
-    def __init__(self, config: EMACrossStopEntryConfig) -> None:
+    def __init__(self, config: EMACrossTrailingStopConfig) -> None:
         PyCondition.true(
             config.fast_ema_period < config.slow_ema_period,
             "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
         )
         super().__init__(config)
 
         # Configuration
         self.instrument_id = config.instrument_id
         self.bar_type = config.bar_type
         self.trade_size = Decimal(config.trade_size)
         self.trailing_atr_multiple = config.trailing_atr_multiple
         self.trailing_offset_type = TrailingOffsetType[config.trailing_offset_type]
-        self.trailing_offset = config.trailing_offset
         self.trigger_type = TriggerType[config.trigger_type]
         self.emulation_trigger = TriggerType[config.emulation_trigger]
 
         # Create the indicators for the strategy
         self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
         self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)
         self.atr = AverageTrueRange(config.atr_period)
 
-        self.instrument: Instrument | None = None  # Initialized in `on_start()`
-        self.tick_size = None  # Initialized in `on_start()`
+        self.instrument: Instrument | None = None  # Initialized in on_start
+        self.tick_size = None  # Initialized in on_start
 
         # Users order management variables
         self.entry = None
         self.trailing_stop = None
+        self.position_id = None
 
     def on_start(self) -> None:
         """
         Actions to be performed on strategy start.
         """
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
@@ -168,17 +167,36 @@
         self.register_indicator_for_bars(self.bar_type, self.slow_ema)
         self.register_indicator_for_bars(self.bar_type, self.atr)
 
         # Get historical data
         self.request_bars(self.bar_type)
 
         # Subscribe to live data
-        self.subscribe_bars(self.bar_type)
         self.subscribe_quote_ticks(self.instrument_id)
-        self.subscribe_trade_ticks(self.instrument_id)
+        self.subscribe_bars(self.bar_type)
+
+    def on_stop(self) -> None:
+        """
+        Actions to be performed when the strategy is stopped.
+        """
+        self.cancel_all_orders(self.instrument_id)
+        self.close_all_positions(self.instrument_id)
+
+        # Unsubscribe from data
+        self.unsubscribe_quote_ticks(self.instrument_id)
+        self.unsubscribe_bars(self.bar_type)
+
+    def on_reset(self) -> None:
+        """
+        Actions to be performed when the strategy is reset.
+        """
+        # Reset indicators here
+        self.fast_ema.reset()
+        self.slow_ema.reset()
+        self.atr.reset()
 
     def on_instrument(self, instrument: Instrument) -> None:
         """
         Actions to be performed when the strategy is running and receives an instrument.
 
         Parameters
         ----------
@@ -227,111 +245,72 @@
 
         Parameters
         ----------
         bar : Bar
             The bar received.
 
         """
-        self.log.info(f"Received {bar!r}")
+        # self.log.info(f"Received {bar!r}")
 
         # Check if indicators ready
         if not self.indicators_initialized():
             self.log.info(
-                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]...",
+                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]",
                 color=LogColor.BLUE,
             )
             return  # Wait for indicators to warm up...
 
         if self.portfolio.is_flat(self.instrument_id):
-            if self.entry is not None:
-                self.cancel_order(self.entry)
-
             # BUY LOGIC
             if self.fast_ema.value >= self.slow_ema.value:
-                self.entry_buy(bar)
+                self.entry_buy()
             # SELL LOGIC
             else:  # fast_ema.value < self.slow_ema.value
-                self.entry_sell(bar)
+                self.entry_sell()
 
-    def entry_buy(self, last_bar: Bar) -> None:
+    def entry_buy(self) -> None:
         """
         Users simple buy entry method (example).
-
-        Parameters
-        ----------
-        last_bar : Bar
-            The last bar received.
-
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
-        order: MarketIfTouchedOrder = self.order_factory.market_if_touched(
+        order: MarketOrder = self.order_factory.market(
             instrument_id=self.instrument_id,
             order_side=OrderSide.BUY,
             quantity=self.instrument.make_qty(self.trade_size),
-            time_in_force=TimeInForce.IOC,
-            trigger_price=self.instrument.make_price(last_bar.high + (self.tick_size * 2)),
-            emulation_trigger=self.emulation_trigger,
         )
-        # TODO(cs): Uncomment below order for development
-        # order: LimitIfTouchedOrder = self.order_factory.limit_if_touched(
-        #     instrument_id=self.instrument_id,
-        #     order_side=OrderSide.BUY,
-        #     quantity=self.instrument.make_qty(self.trade_size),
-        #     time_in_force=TimeInForce.IOC,
-        #     price=self.instrument.make_price(last_bar.low - (self.tick_size * 2)),
-        #     trigger_price=self.instrument.make_price(last_bar.high + (self.tick_size * 2)),
-        # )
 
         self.entry = order
         self.submit_order(order)
 
-    def entry_sell(self, last_bar: Bar) -> None:
+    def entry_sell(self) -> None:
         """
         Users simple sell entry method (example).
-
-        Parameters
-        ----------
-        last_bar : Bar
-            The last bar received.
-
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
-        order: MarketIfTouchedOrder = self.order_factory.market_if_touched(
+        order: MarketOrder = self.order_factory.market(
             instrument_id=self.instrument_id,
             order_side=OrderSide.SELL,
             quantity=self.instrument.make_qty(self.trade_size),
-            time_in_force=TimeInForce.IOC,
-            trigger_price=self.instrument.make_price(last_bar.low - (self.tick_size * 2)),
-            emulation_trigger=self.emulation_trigger,
         )
-        # TODO(cs): Uncomment below order for development
-        # order: LimitIfTouchedOrder = self.order_factory.limit_if_touched(
-        #     instrument_id=self.instrument_id,
-        #     order_side=OrderSide.SELL,
-        #     quantity=self.instrument.make_qty(self.trade_size),
-        #     time_in_force=TimeInForce.IOC,
-        #     price=self.instrument.make_price(last_bar.low - (self.tick_size * 2)),
-        #     trigger_price=self.instrument.make_price(last_bar.low - (self.tick_size * 2)),
-        # )
 
         self.entry = order
         self.submit_order(order)
 
     def trailing_stop_buy(self) -> None:
         """
         Users simple trailing stop BUY for (``SHORT`` positions).
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
         offset = self.atr.value * self.trailing_atr_multiple
         order: TrailingStopMarketOrder = self.order_factory.trailing_stop_market(
             instrument_id=self.instrument_id,
             order_side=OrderSide.BUY,
             quantity=self.instrument.make_qty(self.trade_size),
@@ -339,22 +318,22 @@
             trailing_offset_type=self.trailing_offset_type,
             trigger_type=self.trigger_type,
             reduce_only=True,
             emulation_trigger=self.emulation_trigger,
         )
 
         self.trailing_stop = order
-        self.submit_order(order)
+        self.submit_order(order, position_id=self.position_id)
 
     def trailing_stop_sell(self) -> None:
         """
         Users simple trailing stop SELL for (LONG positions).
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
         offset = self.atr.value * self.trailing_atr_multiple
         order: TrailingStopMarketOrder = self.order_factory.trailing_stop_market(
             instrument_id=self.instrument_id,
             order_side=OrderSide.SELL,
             quantity=self.instrument.make_qty(self.trade_size),
@@ -362,15 +341,15 @@
             trailing_offset_type=self.trailing_offset_type,
             trigger_type=self.trigger_type,
             reduce_only=True,
             emulation_trigger=self.emulation_trigger,
         )
 
         self.trailing_stop = order
-        self.submit_order(order)
+        self.submit_order(order, position_id=self.position_id)
 
     def on_data(self, data: Data) -> None:
         """
         Actions to be performed when the strategy is running and receives data.
 
         Parameters
         ----------
@@ -386,42 +365,26 @@
         Parameters
         ----------
         event : Event
             The event received.
 
         """
         if isinstance(event, OrderFilled):
-            if self.entry and event.client_order_id == self.entry.client_order_id:
-                if event.order_side == OrderSide.BUY:
-                    self.trailing_stop_sell()
-                elif event.order_side == OrderSide.SELL:
-                    self.trailing_stop_buy()
             if self.trailing_stop and event.client_order_id == self.trailing_stop.client_order_id:
                 self.trailing_stop = None
-
-    def on_stop(self) -> None:
-        """
-        Actions to be performed when the strategy is stopped.
-        """
-        self.cancel_all_orders(self.instrument_id)
-        self.close_all_positions(self.instrument_id)
-
-        # Unsubscribe from data
-        self.unsubscribe_bars(self.bar_type)
-        self.unsubscribe_quote_ticks(self.instrument_id)
-        self.unsubscribe_trade_ticks(self.instrument_id)
-
-    def on_reset(self) -> None:
-        """
-        Actions to be performed when the strategy is reset.
-        """
-        # Reset indicators here
-        self.fast_ema.reset()
-        self.slow_ema.reset()
-        self.atr.reset()
+        elif isinstance(event, PositionOpened | PositionChanged):
+            if self.entry and event.opening_order_id == self.entry.client_order_id:
+                if event.entry == OrderSide.BUY:
+                    self.position_id = event.position_id
+                    self.trailing_stop_sell()
+                elif event.entry == OrderSide.SELL:
+                    self.position_id = event.position_id
+                    self.trailing_stop_buy()
+        elif isinstance(event, PositionClosed):
+            self.position_id = None
 
     def on_save(self) -> dict[str, bytes]:
         """
         Actions to be performed when the strategy is saved.
 
         Create and return a state dictionary of values to be saved.
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross_trailing_stop.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/volatility_market_maker.py`

 * *Files 13% similar despite different names*

```diff
@@ -11,380 +11,379 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from decimal import Decimal
 
+import pandas as pd
+
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.config import PositiveFloat
 from nautilus_trader.config import PositiveInt
 from nautilus_trader.config import StrategyConfig
-from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.data import Data
 from nautilus_trader.core.message import Event
 from nautilus_trader.indicators.atr import AverageTrueRange
-from nautilus_trader.indicators.average.ema import ExponentialMovingAverage
 from nautilus_trader.model.book import OrderBook
 from nautilus_trader.model.data import Bar
 from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import OrderBookDeltas
 from nautilus_trader.model.data import QuoteTick
 from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import OrderSide
-from nautilus_trader.model.enums import TrailingOffsetType
+from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import TriggerType
 from nautilus_trader.model.events import OrderFilled
-from nautilus_trader.model.events import PositionChanged
-from nautilus_trader.model.events import PositionClosed
-from nautilus_trader.model.events import PositionOpened
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
-from nautilus_trader.model.orders import MarketOrder
-from nautilus_trader.model.orders import TrailingStopMarketOrder
+from nautilus_trader.model.orders import LimitOrder
 from nautilus_trader.trading.strategy import Strategy
 
 
 # *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
 # *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***
 
 
-class EMACrossTrailingStopConfig(StrategyConfig, frozen=True):
+class VolatilityMarketMakerConfig(StrategyConfig, frozen=True):
     """
-    Configuration for ``EMACrossTrailingStop`` instances.
+    Configuration for ``VolatilityMarketMaker`` instances.
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The instrument ID for the strategy.
     bar_type : BarType
         The bar type for the strategy.
     atr_period : PositiveInt
         The period for the ATR indicator.
-    trailing_atr_multiple : PositiveFloat
-        The ATR multiple for the trailing stop.
-    trailing_offset_type : str
-        The trailing offset type (interpreted as `TrailingOffsetType`).
-    trigger_type : str
-        The trailing stop trigger type (interpreted as `TriggerType`).
-    trade_size : str
-        The position size per trade (interpreted as Decimal).
-    fast_ema_period : PositiveInt, default 10
-        The fast EMA period.
-    slow_ema_period : PositiveInt, default 20
-        The slow EMA period.
-    emulation_trigger : str, default 'NO_TRIGGER'
-        The emulation trigger for submitting emulated orders.
-        If 'NONE' then orders will not be emulated.
+    atr_multiple : PositiveFloat
+        The ATR multiple for bracketing limit orders.
+    trade_size : Decimal
+        The position size per trade.
     order_id_tag : str
         The unique order ID tag for the strategy. Must be unique
         amongst all running strategies for a particular trader ID.
+    emulation_trigger : str, default 'NO_TRIGGER'
+        The emulation trigger for submitting emulated orders.
+        If ``None`` then orders will not be emulated.
     oms_type : OmsType
         The order management system type for the strategy. This will determine
         how the `ExecutionEngine` handles position IDs (see docs).
 
     """
 
     instrument_id: InstrumentId
     bar_type: BarType
     atr_period: PositiveInt
-    trailing_atr_multiple: PositiveFloat
-    trailing_offset_type: str
-    trigger_type: str
+    atr_multiple: PositiveFloat
     trade_size: Decimal
-    fast_ema_period: PositiveInt = 10
-    slow_ema_period: PositiveInt = 20
     emulation_trigger: str = "NO_TRIGGER"
 
 
-class EMACrossTrailingStop(Strategy):
+class VolatilityMarketMaker(Strategy):
     """
-    A simple moving average cross example strategy with a stop-market entry and trailing
-    stop.
-
-    When the fast EMA crosses the slow EMA then submits a stop-market order one
-    tick above the current bar for BUY, or one tick below the current bar
-    for SELL.
-
-    If the entry order is filled then a trailing stop at a specified ATR
-    distance is submitted and managed.
+    A very dumb market maker which brackets the current market based on volatility
+    measured by an ATR indicator.
 
     Cancels all orders and closes all positions on stop.
 
     Parameters
     ----------
-    config : EMACrossTrailingStopConfig
+    config : VolatilityMarketMakerConfig
         The configuration for the instance.
 
-    Raises
-    ------
-    ValueError
-        If `config.fast_ema_period` is not less than `config.slow_ema_period`.
-
     """
 
-    def __init__(self, config: EMACrossTrailingStopConfig) -> None:
-        PyCondition.true(
-            config.fast_ema_period < config.slow_ema_period,
-            "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
-        )
+    def __init__(self, config: VolatilityMarketMakerConfig) -> None:
         super().__init__(config)
 
         # Configuration
         self.instrument_id = config.instrument_id
         self.bar_type = config.bar_type
+        self.atr_multiple = config.atr_multiple
         self.trade_size = Decimal(config.trade_size)
-        self.trailing_atr_multiple = config.trailing_atr_multiple
-        self.trailing_offset_type = TrailingOffsetType[config.trailing_offset_type]
-        self.trigger_type = TriggerType[config.trigger_type]
         self.emulation_trigger = TriggerType[config.emulation_trigger]
 
+        self.instrument: Instrument | None = None  # Initialized in on_start
+
         # Create the indicators for the strategy
-        self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
-        self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)
         self.atr = AverageTrueRange(config.atr_period)
 
-        self.instrument: Instrument | None = None  # Initialized in on_start
-        self.tick_size = None  # Initialized in on_start
-
         # Users order management variables
-        self.entry = None
-        self.trailing_stop = None
-        self.position_id = None
+        self.buy_order: LimitOrder | None = None
+        self.sell_order: LimitOrder | None = None
 
     def on_start(self) -> None:
         """
         Actions to be performed on strategy start.
         """
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
             self.log.error(f"Could not find instrument for {self.instrument_id}")
             self.stop()
             return
 
-        self.tick_size = self.instrument.price_increment
-
         # Register the indicators for updating
-        self.register_indicator_for_bars(self.bar_type, self.fast_ema)
-        self.register_indicator_for_bars(self.bar_type, self.slow_ema)
         self.register_indicator_for_bars(self.bar_type, self.atr)
 
         # Get historical data
         self.request_bars(self.bar_type)
 
         # Subscribe to live data
-        self.subscribe_quote_ticks(self.instrument_id)
         self.subscribe_bars(self.bar_type)
+        self.subscribe_quote_ticks(self.instrument_id)
 
-    def on_stop(self) -> None:
-        """
-        Actions to be performed when the strategy is stopped.
+        self.subscribe_trade_ticks(self.instrument_id)
+        # self.subscribe_order_book_deltas(self.instrument_id)  # For debugging
+        # self.subscribe_order_book_snapshots(
+        #     self.instrument_id,
+        #     depth=20,
+        #     interval_ms=1000,
+        # )  # For debugging
+
+        # self.subscribe_data(
+        #     data_type=DataType(
+        #         BinanceTicker,
+        #         metadata={"instrument_id": self.instrument.id},
+        #     ),
+        #     client_id=ClientId("BINANCE"),
+        # )
+
+        # self.subscribe_data(
+        #     data_type=DataType(
+        #         BinanceFuturesMarkPriceUpdate,
+        #         metadata={"instrument_id": self.instrument.id},
+        #     ),
+        #     client_id=ClientId("BINANCE"),
+        # )
+
+    def on_data(self, data: Data) -> None:
         """
-        self.cancel_all_orders(self.instrument_id)
-        self.close_all_positions(self.instrument_id)
+        Actions to be performed when the strategy is running and receives data.
 
-        # Unsubscribe from data
-        self.unsubscribe_quote_ticks(self.instrument_id)
-        self.unsubscribe_bars(self.bar_type)
+        Parameters
+        ----------
+        data : Data
+            The data received.
 
-    def on_reset(self) -> None:
-        """
-        Actions to be performed when the strategy is reset.
         """
-        # Reset indicators here
-        self.fast_ema.reset()
-        self.slow_ema.reset()
-        self.atr.reset()
+        # For debugging (must add a subscription)
+        self.log.info(repr(data), LogColor.CYAN)
 
     def on_instrument(self, instrument: Instrument) -> None:
         """
         Actions to be performed when the strategy is running and receives an instrument.
 
         Parameters
         ----------
         instrument : Instrument
             The instrument received.
 
         """
+        # For debugging (must add a subscription)
+        # self.log.info(repr(instrument), LogColor.CYAN)
 
     def on_order_book(self, order_book: OrderBook) -> None:
         """
         Actions to be performed when the strategy is running and receives an order book.
 
         Parameters
         ----------
         order_book : OrderBook
             The order book received.
 
         """
-        # self.log.info(f"Received {order_book}")  # For debugging (must add a subscription)
+        # For debugging (must add a subscription)
+        self.log.info(repr(order_book), LogColor.CYAN)
+
+    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
+        """
+        Actions to be performed when the strategy is running and receives order book
+        deltas.
+
+        Parameters
+        ----------
+        deltas : OrderBookDeltas
+            The order book deltas received.
+
+        """
+        # For debugging (must add a subscription)
+        self.log.info(repr(deltas), LogColor.CYAN)
 
     def on_quote_tick(self, tick: QuoteTick) -> None:
         """
         Actions to be performed when the strategy is running and receives a quote tick.
 
         Parameters
         ----------
         tick : QuoteTick
             The tick received.
 
         """
+        # For debugging (must add a subscription)
+        self.log.info(repr(tick), LogColor.CYAN)
 
     def on_trade_tick(self, tick: TradeTick) -> None:
         """
         Actions to be performed when the strategy is running and receives a trade tick.
 
         Parameters
         ----------
         tick : TradeTick
             The tick received.
 
         """
+        # For debugging (must add a subscription)
+        self.log.info(repr(tick), LogColor.CYAN)
 
     def on_bar(self, bar: Bar) -> None:
         """
         Actions to be performed when the strategy is running and receives a bar.
 
         Parameters
         ----------
         bar : Bar
             The bar received.
 
         """
-        # self.log.info(f"Received {bar!r}")
+        self.log.info(repr(bar), LogColor.CYAN)
+
+        if not self.instrument:
+            self.log.error("No instrument loaded.")
+            return
 
         # Check if indicators ready
         if not self.indicators_initialized():
             self.log.info(
-                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]...",
+                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]",
                 color=LogColor.BLUE,
             )
             return  # Wait for indicators to warm up...
 
-        if self.portfolio.is_flat(self.instrument_id):
-            # BUY LOGIC
-            if self.fast_ema.value >= self.slow_ema.value:
-                self.entry_buy()
-            # SELL LOGIC
-            else:  # fast_ema.value < self.slow_ema.value
-                self.entry_sell()
-
-    def entry_buy(self) -> None:
-        """
-        Users simple buy entry method (example).
-        """
-        if not self.instrument:
-            self.log.error("No instrument loaded.")
-            return
-
-        order: MarketOrder = self.order_factory.market(
-            instrument_id=self.instrument_id,
-            order_side=OrderSide.BUY,
-            quantity=self.instrument.make_qty(self.trade_size),
-        )
-
-        self.entry = order
-        self.submit_order(order)
-
-    def entry_sell(self) -> None:
-        """
-        Users simple sell entry method (example).
-        """
-        if not self.instrument:
-            self.log.error("No instrument loaded.")
+        last: QuoteTick = self.cache.quote_tick(self.instrument_id)
+        if last is None:
+            self.log.info("No quotes yet")
             return
 
-        order: MarketOrder = self.order_factory.market(
-            instrument_id=self.instrument_id,
-            order_side=OrderSide.SELL,
-            quantity=self.instrument.make_qty(self.trade_size),
-        )
-
-        self.entry = order
-        self.submit_order(order)
+        # Maintain buy orders
+        if self.buy_order and (self.buy_order.is_emulated or self.buy_order.is_open):
+            # price: Decimal = last.bid_price - (self.atr.value * self.atr_multiple)
+            # self.modify_order(
+            #     order=self.buy_order,
+            #     price=self.instrument.make_price(price),
+            # )
+            # return
+            self.cancel_order(self.buy_order)
+        self.create_buy_order(last)
+
+        # Maintain sell orders
+        if self.sell_order and (self.sell_order.is_emulated or self.sell_order.is_open):
+            # price = last.ask_price + (self.atr.value * self.atr_multiple)
+            # self.modify_order(
+            #     order=self.sell_order,
+            #     price=self.instrument.make_price(price),
+            # )
+            # return
+            self.cancel_order(self.sell_order)
+        self.create_sell_order(last)
 
-    def trailing_stop_buy(self) -> None:
+    def create_buy_order(self, last: QuoteTick) -> None:
         """
-        Users simple trailing stop BUY for (``SHORT`` positions).
+        Market maker simple buy limit method (example).
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
-        offset = self.atr.value * self.trailing_atr_multiple
-        order: TrailingStopMarketOrder = self.order_factory.trailing_stop_market(
+        price: Decimal = last.bid_price - (self.atr.value * self.atr_multiple)
+        order: LimitOrder = self.order_factory.limit(
             instrument_id=self.instrument_id,
             order_side=OrderSide.BUY,
             quantity=self.instrument.make_qty(self.trade_size),
-            trailing_offset=Decimal(f"{offset:.{self.instrument.price_precision}f}"),
-            trailing_offset_type=self.trailing_offset_type,
-            trigger_type=self.trigger_type,
-            reduce_only=True,
+            price=self.instrument.make_price(price),
+            time_in_force=TimeInForce.GTD,
+            expire_time=self.clock.utc_now() + pd.Timedelta(minutes=10),
+            post_only=True,  # default value is True
+            # display_qty=self.instrument.make_qty(self.trade_size / 2),  # iceberg
             emulation_trigger=self.emulation_trigger,
         )
 
-        self.trailing_stop = order
-        self.submit_order(order, position_id=self.position_id)
+        self.buy_order = order
+        self.submit_order(order)
 
-    def trailing_stop_sell(self) -> None:
+    def create_sell_order(self, last: QuoteTick) -> None:
         """
-        Users simple trailing stop SELL for (LONG positions).
+        Market maker simple sell limit method (example).
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
-        offset = self.atr.value * self.trailing_atr_multiple
-        order: TrailingStopMarketOrder = self.order_factory.trailing_stop_market(
+        price: Decimal = last.ask_price + (self.atr.value * self.atr_multiple)
+        order: LimitOrder = self.order_factory.limit(
             instrument_id=self.instrument_id,
             order_side=OrderSide.SELL,
             quantity=self.instrument.make_qty(self.trade_size),
-            trailing_offset=Decimal(f"{offset:.{self.instrument.price_precision}f}"),
-            trailing_offset_type=self.trailing_offset_type,
-            trigger_type=self.trigger_type,
-            reduce_only=True,
+            price=self.instrument.make_price(price),
+            time_in_force=TimeInForce.GTD,
+            expire_time=self.clock.utc_now() + pd.Timedelta(minutes=10),
+            post_only=True,  # default value is True
+            # display_qty=self.instrument.make_qty(self.trade_size / 2),  # iceberg
             emulation_trigger=self.emulation_trigger,
         )
 
-        self.trailing_stop = order
-        self.submit_order(order, position_id=self.position_id)
-
-    def on_data(self, data: Data) -> None:
-        """
-        Actions to be performed when the strategy is running and receives data.
-
-        Parameters
-        ----------
-        data : Data
-            The data received.
-
-        """
+        self.sell_order = order
+        self.submit_order(order)
 
     def on_event(self, event: Event) -> None:
         """
         Actions to be performed when the strategy is running and receives an event.
 
         Parameters
         ----------
         event : Event
             The event received.
 
         """
+        last: QuoteTick = self.cache.quote_tick(self.instrument_id)
+        if last is None:
+            self.log.info("No quotes yet")
+            return
+
+        # If order filled then replace order at ATR multiple distance from the market
         if isinstance(event, OrderFilled):
-            if self.trailing_stop and event.client_order_id == self.trailing_stop.client_order_id:
-                self.trailing_stop = None
-        elif isinstance(event, PositionOpened | PositionChanged):
-            if self.entry and event.opening_order_id == self.entry.client_order_id:
-                if event.entry == OrderSide.BUY:
-                    self.position_id = event.position_id
-                    self.trailing_stop_sell()
-                elif event.entry == OrderSide.SELL:
-                    self.position_id = event.position_id
-                    self.trailing_stop_buy()
-        elif isinstance(event, PositionClosed):
-            self.position_id = None
+            if self.buy_order and event.order_side == OrderSide.BUY:
+                if self.buy_order.is_closed:
+                    self.create_buy_order(last)
+            elif (
+                self.sell_order and event.order_side == OrderSide.SELL and self.sell_order.is_closed
+            ):
+                self.create_sell_order(last)
+
+    def on_stop(self) -> None:
+        """
+        Actions to be performed when the strategy is stopped.
+        """
+        self.cancel_all_orders(self.instrument_id)
+        self.close_all_positions(self.instrument_id)
+
+        # Unsubscribe from data
+        self.unsubscribe_bars(self.bar_type)
+        self.unsubscribe_quote_ticks(self.instrument_id)
+        self.unsubscribe_trade_ticks(self.instrument_id)
+        # self.unsubscribe_order_book_deltas(self.instrument_id)  # For debugging
+        # self.unsubscribe_order_book_snapshots(self.instrument_id)  # For debugging
+
+    def on_reset(self) -> None:
+        """
+        Actions to be performed when the strategy is reset.
+        """
+        # Reset indicators here
+        self.atr.reset()
 
     def on_save(self) -> dict[str, bytes]:
         """
         Actions to be performed when the strategy is saved.
 
         Create and return a state dictionary of values to be saved.
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/ema_cross_twap.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/ema_cross_twap.py`

 * *Files 0% similar despite different names*

```diff
@@ -235,15 +235,15 @@
 
         """
         self.log.info(repr(bar), LogColor.CYAN)
 
         # Check if indicators ready
         if not self.indicators_initialized():
             self.log.info(
-                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]...",
+                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]",
                 color=LogColor.BLUE,
             )
             return  # Wait for indicators to warm up...
 
         if bar.is_single_price():
             # Implies no market information for this bar
             return
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/market_maker.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/market_maker.py`

 * *Files 1% similar despite different names*

```diff
@@ -77,15 +77,15 @@
         )
 
         # Subscribe to live data
         self.subscribe_order_book_deltas(self.instrument_id)
 
     def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
         if not self._book:
-            self.log.error("No book being maintained.")
+            self.log.error("No book being maintained")
             return
 
         self._book.apply_deltas(deltas)
         bid_price = self._book.best_bid_price()
         ask_price = self._book.best_ask_price()
         if bid_price and ask_price:
             mid = (bid_price + ask_price) / 2
@@ -106,15 +106,15 @@
             self._adj = Decimal(0)
 
     def buy(self, price: Decimal) -> None:
         """
         Users simple buy method (example).
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
         order = self.order_factory.limit(
             instrument_id=self.instrument_id,
             order_side=OrderSide.BUY,
             price=Price(price, precision=self.instrument.price_precision),
             quantity=self.instrument.make_qty(self.trade_size),
@@ -123,15 +123,15 @@
         self.submit_order(order)
 
     def sell(self, price: Decimal) -> None:
         """
         Users simple sell method (example).
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
         order = self.order_factory.limit(
             instrument_id=self.instrument_id,
             order_side=OrderSide.SELL,
             price=Price(price, precision=self.instrument.price_precision),
             quantity=self.instrument.make_qty(self.trade_size),
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/orderbook_imbalance.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/orderbook_imbalance.py`

 * *Files 0% similar despite different names*

```diff
@@ -153,30 +153,30 @@
         self.check_trigger()
 
     def check_trigger(self) -> None:
         """
         Check for trigger conditions.
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
         # Fetch book from the cache being maintained by the `DataEngine`
         book = self.cache.order_book(self.instrument_id)
         if not book:
-            self.log.error("No book being maintained.")
+            self.log.error("No book being maintained")
             return
 
         if not book.spread():
             return
 
         bid_size: Quantity | None = book.best_bid_size()
         ask_size: Quantity | None = book.best_ask_size()
         if (bid_size is None or bid_size <= 0) or (ask_size is None or ask_size <= 0):
-            self.log.warning("No market yet.")
+            self.log.warning("No market yet")
             return
 
         smaller = min(bid_size, ask_size)
         larger = max(bid_size, ask_size)
         ratio = smaller / larger
         self.log.info(
             f"Book: {book.best_bid_price()} @ {book.best_ask_price()} ({ratio=:0.2f})",
@@ -188,15 +188,15 @@
         if larger > self.trigger_min_size and ratio < self.trigger_imbalance_ratio:
             self.log.info(
                 "Trigger conditions met, checking for existing orders and time since last order",
             )
             if len(self.cache.orders_inflight(strategy_id=self.id)) > 0:
                 self.log.info("Already have orders in flight - skipping.")
             elif seconds_since_last_trigger < self.min_seconds_between_triggers:
-                self.log.info("Time since last order < min_seconds_between_triggers - skipping.")
+                self.log.info("Time since last order < min_seconds_between_triggers - skipping")
             elif bid_size > ask_size:
                 order = self.order_factory.limit(
                     instrument_id=self.instrument.id,
                     price=self.instrument.make_price(book.best_ask_price()),
                     order_side=OrderSide.BUY,
                     quantity=self.instrument.make_qty(ask_size),
                     post_only=False,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/orderbook_imbalance_rust.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/orderbook_imbalance_rust.py`

 * *Files 2% similar despite different names*

```diff
@@ -17,15 +17,14 @@
 from decimal import Decimal
 
 from nautilus_trader.config import NonNegativeFloat
 from nautilus_trader.config import PositiveFloat
 from nautilus_trader.config import StrategyConfig
 from nautilus_trader.core import nautilus_pyo3
 from nautilus_trader.core.nautilus_pyo3 import BookImbalanceRatio
-from nautilus_trader.core.nautilus_pyo3 import OrderBookMbp
 from nautilus_trader.core.rust.common import LogColor
 from nautilus_trader.model.book import OrderBook
 from nautilus_trader.model.data import QuoteTick
 from nautilus_trader.model.enums import BookType
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import book_type_from_str
@@ -110,15 +109,15 @@
         self.instrument: Instrument | None = None
         if self.config.use_quote_ticks:
             assert self.config.book_type == "L1_MBP"
         self.book_type: BookType = book_type_from_str(self.config.book_type)
 
         # We need to initialize the Rust pyo3 objects
         pyo3_instrument_id = nautilus_pyo3.InstrumentId.from_str(self.instrument_id.value)
-        self.book = OrderBookMbp(pyo3_instrument_id, config.use_quote_ticks)
+        self.book = nautilus_pyo3.OrderBook(self.book_type, pyo3_instrument_id)
         self.imbalance = BookImbalanceRatio()
 
     def on_start(self) -> None:
         """
         Actions to be performed on strategy start.
         """
         self.instrument = self.cache.instrument(self.instrument_id)
@@ -142,46 +141,47 @@
         self._last_trigger_timestamp = self.clock.utc_now()
 
     def on_order_book_deltas(self, pyo3_deltas: nautilus_pyo3.OrderBookDeltas) -> None:
         """
         Actions to be performed when order book deltas are received.
         """
         self.book.apply_deltas(pyo3_deltas)
-        self.imbalance.handle_book_mbp(self.book)
+        self.imbalance.handle_book(self.book)
         self.check_trigger()
 
-    def on_quote_tick(self, tick: QuoteTick) -> None:
+    def on_quote_tick(self, quote: QuoteTick) -> None:
         """
-        Actions to be performed when a delta is received.
+        Actions to be performed when a quote tick is received.
         """
-        self.book.update_quote_tick(tick)
-        self.imbalance.handle_book_mbp(self.book)
-        self.check_trigger()
+        if self.config.use_quote_ticks:
+            nautilus_pyo3.update_book_with_quote_tick(self.book, quote)
+            self.imbalance.handle_book(self.book)
+            self.check_trigger()
 
-    def on_order_book(self, order_book: OrderBook) -> None:
+    def on_order_book(self, book: OrderBook) -> None:
         """
         Actions to be performed when an order book update is received.
         """
         self.check_trigger()
 
     def check_trigger(self) -> None:
         """
         Check for trigger conditions.
         """
         if not self.instrument:
-            self.log.error("No instrument loaded.")
+            self.log.error("No instrument loaded")
             return
 
         # This could be more efficient: for demonstration
         bid_price = self.book.best_bid_price()
         ask_price = self.book.best_ask_price()
         bid_size = self.book.best_bid_size()
         ask_size = self.book.best_ask_size()
         if not bid_size or not ask_size:
-            self.log.warning("No market yet.")
+            self.log.warning("No market yet")
             return
 
         larger = max(bid_size.as_double(), ask_size.as_double())
         ratio = self.imbalance.value
         self.log.info(
             f"Book: {self.book.best_bid_price()} @ {self.book.best_ask_price()} ({ratio=:0.2f})",
         )
@@ -192,15 +192,15 @@
         if larger > self.trigger_min_size and ratio < self.trigger_imbalance_ratio:
             self.log.info(
                 "Trigger conditions met, checking for existing orders and time since last order",
             )
             if len(self.cache.orders_inflight(strategy_id=self.id)) > 0:
                 self.log.info("Already have orders in flight - skipping.")
             elif seconds_since_last_trigger < self.min_seconds_between_triggers:
-                self.log.info("Time since last order < min_seconds_between_triggers - skipping.")
+                self.log.info("Time since last order < min_seconds_between_triggers - skipping")
             elif bid_size.as_double() > ask_size.as_double():
                 order = self.order_factory.limit(
                     instrument_id=self.instrument.id,
                     price=self.instrument.make_price(ask_price),
                     order_side=OrderSide.BUY,
                     quantity=self.instrument.make_qty(ask_size),
                     post_only=False,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/signal_strategy.py` & `nautilus_trader-1.191.0/nautilus_trader/indicators/vwap.pyx`

 * *Files 25% similar despite different names*

```diff
@@ -9,65 +9,89 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+import pandas as pd
+from cpython.datetime cimport datetime
 
-from nautilus_trader.config import StrategyConfig
-from nautilus_trader.model.data import QuoteTick
-from nautilus_trader.model.data import TradeTick
-from nautilus_trader.model.identifiers import InstrumentId
-from nautilus_trader.model.instruments import Instrument
-from nautilus_trader.trading.strategy import Strategy
+from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.indicators.base.indicator cimport Indicator
+from nautilus_trader.model.data cimport Bar
 
 
-# *** THIS IS A TEST STRATEGY ***
-
-
-class SignalStrategyConfig(StrategyConfig, frozen=True):
-    """
-    Configuration for ``SignalStrategy`` instances.
+cdef class VolumeWeightedAveragePrice(Indicator):
     """
-
-    instrument_id: InstrumentId
-
-
-class SignalStrategy(Strategy):
-    """
-    A strategy that simply emits a signal counter (FOR TESTING PURPOSES ONLY).
-
-    Parameters
-    ----------
-    config : OrderbookImbalanceConfig
-        The configuration for the instance.
-
+    An indicator which calculates the volume weighted average price for the day.
     """
 
-    def __init__(self, config: SignalStrategyConfig) -> None:
-        super().__init__(config)
-        self.instrument_id = self.config.instrument_id
-        self.instrument: Instrument | None = None
-        self.counter = 0
+    def __init__(self):
+        super().__init__(params=[])
 
-    def on_start(self) -> None:
-        """
-        Actions to be performed on strategy start.
-        """
-        self.instrument = self.cache.instrument(self.instrument_id)
-        self.subscribe_trade_ticks(instrument_id=self.instrument_id)
-        self.subscribe_quote_ticks(instrument_id=self.instrument_id)
-
-    def on_quote_tick(self, tick: QuoteTick) -> None:
-        """
-        Actions to be performed when the strategy is running and receives a quote tick.
-        """
-        self.counter += 1
-        self.publish_signal(name="counter", value=self.counter, ts_event=tick.ts_event)
-
-    def on_trade_tick(self, tick: TradeTick) -> None:
-        """
-        Actions to be performed when the strategy is running and receives a trade tick.
-        """
-        self.counter += 1
-        self.publish_signal(name="counter", value=self.counter, ts_event=tick.ts_event)
+        self._day = 0
+        self._price_volume = 0
+        self._volume_total = 0
+        self.value = 0
+
+    cpdef void handle_bar(self, Bar bar):
+        """
+        Update the indicator with the given bar.
+
+        Parameters
+        ----------
+        bar : Bar
+            The update bar.
+
+        """
+        Condition.not_none(bar, "bar")
+
+        self.update_raw(
+            bar.close.as_double(),
+            bar.volume.as_double(),
+            pd.Timestamp(bar.ts_init, tz="UTC"),
+        )
+
+    cpdef void update_raw(
+        self,
+        double price,
+        double volume,
+        datetime timestamp,
+    ):
+        """
+        Update the indicator with the given raw values.
+
+        Parameters
+        ----------
+        price : double
+            The update price.
+        volume : double
+            The update volume.
+        timestamp : datetime
+            The current timestamp.
+
+        """
+        # On a new day reset the indicator
+        if timestamp.day != self._day:
+            self.reset()
+            self._day = timestamp.day
+            self.value = price
+
+        # Initialization logic
+        if not self.initialized:
+            self._set_has_inputs(True)
+            self._set_initialized(True)
+
+        # No weighting for this price (also avoiding divide by zero)
+        if volume == 0:
+            return
+
+        self._price_volume += price * volume
+        self._volume_total += volume
+        self.value = self._price_volume / self._volume_total
+
+    cpdef void _reset(self):
+        self._day = 0
+        self._price_volume = 0
+        self._volume_total = 0
+        self.value = 0
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/subscribe.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/subscribe.py`

 * *Files 1% similar despite different names*

```diff
@@ -102,15 +102,15 @@
                 ),
                 aggregation_source=AggregationSource.EXTERNAL,
             )
             self.subscribe_bars(bar_type)
 
     def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
         if not self.book:
-            self.log.error("No book being maintained.")
+            self.log.error("No book being maintained")
             return
 
         self.book.apply_deltas(deltas)
         self.log.info(str(self.book))
 
     def on_order_book(self, order_book: OrderBook) -> None:
         self.book = order_book
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/talib_strategy.py` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/talib_strategy.py`

 * *Files 0% similar despite different names*

```diff
@@ -135,15 +135,15 @@
 
         """
         self.log.info(repr(bar), LogColor.CYAN)
 
         # Check if indicators ready
         if not self.indicators_initialized():
             self.log.info(
-                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]...",
+                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]",
                 color=LogColor.BLUE,
             )
             return  # Wait for indicators to warm up...
 
         if bar.is_single_price():
             # Implies no market information for this bar
             return
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/examples/strategies/volatility_market_maker.py` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/market_to_limit.pyx`

 * *Files 22% similar despite different names*

```diff
@@ -9,407 +9,323 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from decimal import Decimal
+from libc.stdint cimport uint64_t
 
-import pandas as pd
+from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.core.datetime cimport format_iso8601
+from nautilus_trader.core.datetime cimport unix_nanos_to_dt
+from nautilus_trader.core.rust.model cimport ContingencyType
+from nautilus_trader.core.rust.model cimport OrderSide
+from nautilus_trader.core.rust.model cimport OrderType
+from nautilus_trader.core.rust.model cimport TimeInForce
+from nautilus_trader.core.rust.model cimport TriggerType
+from nautilus_trader.core.uuid cimport UUID4
+from nautilus_trader.model.events.order cimport OrderInitialized
+from nautilus_trader.model.events.order cimport OrderUpdated
+from nautilus_trader.model.functions cimport contingency_type_to_str
+from nautilus_trader.model.functions cimport liquidity_side_to_str
+from nautilus_trader.model.functions cimport order_side_to_str
+from nautilus_trader.model.functions cimport order_type_to_str
+from nautilus_trader.model.functions cimport time_in_force_to_str
+from nautilus_trader.model.identifiers cimport ClientOrderId
+from nautilus_trader.model.identifiers cimport ExecAlgorithmId
+from nautilus_trader.model.identifiers cimport InstrumentId
+from nautilus_trader.model.identifiers cimport OrderListId
+from nautilus_trader.model.identifiers cimport StrategyId
+from nautilus_trader.model.identifiers cimport TraderId
+from nautilus_trader.model.objects cimport Quantity
+from nautilus_trader.model.orders.base cimport Order
 
-from nautilus_trader.common.enums import LogColor
-from nautilus_trader.config import PositiveFloat
-from nautilus_trader.config import PositiveInt
-from nautilus_trader.config import StrategyConfig
-from nautilus_trader.core.data import Data
-from nautilus_trader.core.message import Event
-from nautilus_trader.indicators.atr import AverageTrueRange
-from nautilus_trader.model.book import OrderBook
-from nautilus_trader.model.data import Bar
-from nautilus_trader.model.data import BarType
-from nautilus_trader.model.data import OrderBookDeltas
-from nautilus_trader.model.data import QuoteTick
-from nautilus_trader.model.data import TradeTick
-from nautilus_trader.model.enums import OrderSide
-from nautilus_trader.model.enums import TimeInForce
-from nautilus_trader.model.enums import TriggerType
-from nautilus_trader.model.events import OrderFilled
-from nautilus_trader.model.identifiers import InstrumentId
-from nautilus_trader.model.instruments import Instrument
-from nautilus_trader.model.orders import LimitOrder
-from nautilus_trader.trading.strategy import Strategy
 
-
-# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
-# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***
-
-
-class VolatilityMarketMakerConfig(StrategyConfig, frozen=True):
+cdef class MarketToLimitOrder(Order):
     """
-    Configuration for ``VolatilityMarketMaker`` instances.
+    Represents a `Market-To-Limit` (MTL) order.
+
+    A Market-to-Limit (MTL) order is submitted as a market order to execute at
+    the current best market price. If the order is only partially filled, the
+    remainder of the order is canceled and re-submitted as a Limit order with
+    the limit price equal to the price at which the filled portion of the order
+    executed.
 
     Parameters
     ----------
+    trader_id : TraderId
+        The trader ID associated with the order.
+    strategy_id : StrategyId
+        The strategy ID associated with the order.
     instrument_id : InstrumentId
-        The instrument ID for the strategy.
-    bar_type : BarType
-        The bar type for the strategy.
-    atr_period : PositiveInt
-        The period for the ATR indicator.
-    atr_multiple : PositiveFloat
-        The ATR multiple for bracketing limit orders.
-    trade_size : Decimal
-        The position size per trade.
-    order_id_tag : str
-        The unique order ID tag for the strategy. Must be unique
-        amongst all running strategies for a particular trader ID.
-    emulation_trigger : str, default 'NO_TRIGGER'
-        The emulation trigger for submitting emulated orders.
-        If ``None`` then orders will not be emulated.
-    oms_type : OmsType
-        The order management system type for the strategy. This will determine
-        how the `ExecutionEngine` handles position IDs (see docs).
-
-    """
+        The order instrument ID.
+    client_order_id : ClientOrderId
+        The client order ID.
+    order_side : OrderSide {``BUY``, ``SELL``}
+        The order side.
+    quantity : Quantity
+        The order quantity (> 0).
+    init_id : UUID4
+        The order initialization event ID.
+    ts_init : uint64_t
+        The UNIX timestamp (nanoseconds) when the object was initialized.
+    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
+        The order time in force.
+    expire_time_ns : uint64_t, default 0 (no expiry)
+        The UNIX timestamp (nanoseconds) when the order will expire.
+    reduce_only : bool, default False
+        If the order carries the 'reduce-only' execution instruction.
+    quote_quantity : bool, default False
+        If the order quantity is denominated in the quote currency.
+    display_qty : Quantity, optional
+        The quantity of the limit order to display on the public book (iceberg).
+    contingency_type : ContingencyType, default ``NO_CONTINGENCY``
+        The order contingency type.
+    order_list_id : OrderListId, optional
+        The order list ID associated with the order.
+    linked_order_ids : list[ClientOrderId], optional
+        The order linked client order ID(s).
+    parent_order_id : ClientOrderId, optional
+        The order parent client order ID.
+    exec_algorithm_id : ExecAlgorithmId, optional
+        The execution algorithm ID for the order.
+    exec_algorithm_params : dict[str, Any], optional
+        The execution algorithm parameters for the order.
+    exec_spawn_id : ClientOrderId, optional
+        The execution algorithm spawning primary client order ID.
+    tags : str, optional
+        The custom user tags for the order. These are optional and can
+        contain any arbitrary delimiter if required.
+
+    Raises
+    ------
+    ValueError
+        If `order_side` is ``NO_ORDER_SIDE``.
+    ValueError
+        If `quantity` is not positive (> 0).
+    ValueError
+        If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
 
-    instrument_id: InstrumentId
-    bar_type: BarType
-    atr_period: PositiveInt
-    atr_multiple: PositiveFloat
-    trade_size: Decimal
-    emulation_trigger: str = "NO_TRIGGER"
-
-
-class VolatilityMarketMaker(Strategy):
-    """
-    A very dumb market maker which brackets the current market based on volatility
-    measured by an ATR indicator.
-
-    Cancels all orders and closes all positions on stop.
-
-    Parameters
+    References
     ----------
-    config : VolatilityMarketMakerConfig
-        The configuration for the instance.
-
+    https://www.interactivebrokers.com/en/trading/orders/mtl.php
     """
 
-    def __init__(self, config: VolatilityMarketMakerConfig) -> None:
-        super().__init__(config)
-
-        # Configuration
-        self.instrument_id = config.instrument_id
-        self.bar_type = config.bar_type
-        self.atr_multiple = config.atr_multiple
-        self.trade_size = Decimal(config.trade_size)
-        self.emulation_trigger = TriggerType[config.emulation_trigger]
-
-        # Create the indicators for the strategy
-        self.atr = AverageTrueRange(config.atr_period)
-
-        self.instrument: Instrument | None = None  # Initialized in on_start
-
-        # Users order management variables
-        self.buy_order: LimitOrder | None = None
-        self.sell_order: LimitOrder | None = None
-
-    def on_start(self) -> None:
-        """
-        Actions to be performed on strategy start.
-        """
-        self.instrument = self.cache.instrument(self.instrument_id)
-        if self.instrument is None:
-            self.log.error(f"Could not find instrument for {self.instrument_id}")
-            self.stop()
-            return
-
-        # Register the indicators for updating
-        self.register_indicator_for_bars(self.bar_type, self.atr)
-
-        # Get historical data
-        self.request_bars(self.bar_type)
-
-        # Subscribe to live data
-        self.subscribe_bars(self.bar_type)
-        self.subscribe_quote_ticks(self.instrument_id)
-
-        # self.subscribe_trade_ticks(self.instrument_id)
-        # self.subscribe_order_book_deltas(self.instrument_id)  # For debugging
-        # self.subscribe_order_book_snapshots(
-        #     self.instrument_id,
-        #     depth=20,
-        #     interval_ms=1000,
-        # )  # For debugging
-
-        # self.subscribe_data(
-        #     data_type=DataType(
-        #         BinanceTicker,
-        #         metadata={"instrument_id": self.instrument.id},
-        #     ),
-        #     client_id=ClientId("BINANCE"),
-        # )
-
-        # self.subscribe_data(
-        #     data_type=DataType(
-        #         BinanceFuturesMarkPriceUpdate,
-        #         metadata={"instrument_id": self.instrument.id},
-        #     ),
-        #     client_id=ClientId("BINANCE"),
-        # )
-
-    def on_data(self, data: Data) -> None:
-        """
-        Actions to be performed when the strategy is running and receives data.
-
-        Parameters
-        ----------
-        data : Data
-            The data received.
-
-        """
-        # For debugging (must add a subscription)
-        self.log.info(repr(data), LogColor.CYAN)
-
-    def on_instrument(self, instrument: Instrument) -> None:
-        """
-        Actions to be performed when the strategy is running and receives an instrument.
-
-        Parameters
-        ----------
-        instrument : Instrument
-            The instrument received.
-
-        """
-        # For debugging (must add a subscription)
-        # self.log.info(repr(instrument), LogColor.CYAN)
-
-    def on_order_book(self, order_book: OrderBook) -> None:
-        """
-        Actions to be performed when the strategy is running and receives an order book.
-
-        Parameters
-        ----------
-        order_book : OrderBook
-            The order book received.
-
-        """
-        # For debugging (must add a subscription)
-        self.log.info(repr(order_book), LogColor.CYAN)
-
-    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
-        """
-        Actions to be performed when the strategy is running and receives order book
-        deltas.
-
-        Parameters
-        ----------
-        deltas : OrderBookDeltas
-            The order book deltas received.
-
-        """
-        # For debugging (must add a subscription)
-        self.log.info(repr(deltas), LogColor.CYAN)
-
-    def on_quote_tick(self, tick: QuoteTick) -> None:
-        """
-        Actions to be performed when the strategy is running and receives a quote tick.
-
-        Parameters
-        ----------
-        tick : QuoteTick
-            The tick received.
-
-        """
-        # For debugging (must add a subscription)
-        self.log.info(repr(tick), LogColor.CYAN)
-
-    def on_trade_tick(self, tick: TradeTick) -> None:
-        """
-        Actions to be performed when the strategy is running and receives a trade tick.
-
-        Parameters
-        ----------
-        tick : TradeTick
-            The tick received.
-
-        """
-        # For debugging (must add a subscription)
-        # self.log.info(repr(tick), LogColor.CYAN)
-
-    def on_bar(self, bar: Bar) -> None:
-        """
-        Actions to be performed when the strategy is running and receives a bar.
-
-        Parameters
-        ----------
-        bar : Bar
-            The bar received.
-
-        """
-        self.log.info(repr(bar), LogColor.CYAN)
-
-        if not self.instrument:
-            self.log.error("No instrument loaded.")
-            return
-
-        # Check if indicators ready
-        if not self.indicators_initialized():
-            self.log.info(
-                f"Waiting for indicators to warm up [{self.cache.bar_count(self.bar_type)}]...",
-                color=LogColor.BLUE,
-            )
-            return  # Wait for indicators to warm up...
-
-        last: QuoteTick = self.cache.quote_tick(self.instrument_id)
-        if last is None:
-            self.log.info("No quotes yet...")
-            return
-
-        # Maintain buy orders
-        if self.buy_order and (self.buy_order.is_emulated or self.buy_order.is_open):
-            # price: Decimal = last.bid_price - (self.atr.value * self.atr_multiple)
-            # self.modify_order(
-            #     order=self.buy_order,
-            #     price=self.instrument.make_price(price),
-            # )
-            self.cancel_order(self.buy_order)
-        self.create_buy_order(last)
-
-        # Maintain sell orders
-        if self.sell_order and (self.sell_order.is_emulated or self.sell_order.is_open):
-            # price = last.ask_price + (self.atr.value * self.atr_multiple)
-            # self.modify_order(
-            #     order=self.sell_order,
-            #     price=self.instrument.make_price(price),
-            # )
-            self.cancel_order(self.sell_order)
-        self.create_sell_order(last)
-
-    def create_buy_order(self, last: QuoteTick) -> None:
-        """
-        Market maker simple buy limit method (example).
-        """
-        if not self.instrument:
-            self.log.error("No instrument loaded.")
-            return
-
-        price: Decimal = last.bid_price - (self.atr.value * self.atr_multiple)
-        order: LimitOrder = self.order_factory.limit(
-            instrument_id=self.instrument_id,
-            order_side=OrderSide.BUY,
-            quantity=self.instrument.make_qty(self.trade_size),
-            price=self.instrument.make_price(price),
-            time_in_force=TimeInForce.GTD,
-            expire_time=self.clock.utc_now() + pd.Timedelta(minutes=10),
-            post_only=True,  # default value is True
-            # display_qty=self.instrument.make_qty(self.trade_size / 2),  # iceberg
-            emulation_trigger=self.emulation_trigger,
+    def __init__(
+        self,
+        TraderId trader_id not None,
+        StrategyId strategy_id not None,
+        InstrumentId instrument_id not None,
+        ClientOrderId client_order_id not None,
+        OrderSide order_side,
+        Quantity quantity not None,
+        UUID4 init_id not None,
+        uint64_t ts_init,
+        TimeInForce time_in_force = TimeInForce.GTC,
+        uint64_t expire_time_ns = 0,
+        bint reduce_only = False,
+        bint quote_quantity = False,
+        Quantity display_qty = None,
+        ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
+        OrderListId order_list_id = None,
+        list linked_order_ids = None,
+        ClientOrderId parent_order_id = None,
+        ExecAlgorithmId exec_algorithm_id = None,
+        dict exec_algorithm_params = None,
+        ClientOrderId exec_spawn_id = None,
+        str tags = None,
+    ):
+        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
+        Condition.not_equal(time_in_force, TimeInForce.AT_THE_OPEN, "time_in_force", "AT_THE_OPEN`")
+        Condition.not_equal(time_in_force, TimeInForce.AT_THE_CLOSE, "time_in_force", "AT_THE_CLOSE`")
+
+        if time_in_force == TimeInForce.GTD:
+            # Must have an expire time
+            Condition.true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
+        else:
+            # Should not have an expire time
+            Condition.true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
+
+        # Set options
+        cdef dict options = {
+            "display_qty": str(display_qty) if display_qty is not None else None,
+            "expire_time_ns": expire_time_ns,
+        }
+
+        # Create initialization event
+        cdef OrderInitialized init = OrderInitialized(
+            trader_id=trader_id,
+            strategy_id=strategy_id,
+            instrument_id=instrument_id,
+            client_order_id=client_order_id,
+            order_side=order_side,
+            order_type=OrderType.MARKET_TO_LIMIT,
+            quantity=quantity,
+            time_in_force=time_in_force,
+            post_only=False,
+            reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
+            options=options,
+            emulation_trigger=TriggerType.NO_TRIGGER,
+            trigger_instrument_id=None,
+            contingency_type=contingency_type,
+            order_list_id=order_list_id,
+            linked_order_ids=linked_order_ids,
+            parent_order_id=parent_order_id,
+            exec_algorithm_id=exec_algorithm_id,
+            exec_algorithm_params=exec_algorithm_params,
+            exec_spawn_id=exec_spawn_id,
+            tags=tags,
+            event_id=init_id,
+            ts_init=ts_init,
         )
+        super().__init__(init=init)
 
-        self.buy_order = order
-        self.submit_order(order)
+        self.price = None
+        self.expire_time_ns = expire_time_ns
+        self.display_qty = display_qty
+
+    cdef void _updated(self, OrderUpdated event):
+        if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
+            self._venue_order_ids.append(self.venue_order_id)
+            self.venue_order_id = event.venue_order_id
+        if event.quantity is not None:
+            self.quantity = event.quantity
+            self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
+        if event.price is not None:
+            self.price = event.price
+
+    cdef void _set_slippage(self):
+        if self.side == OrderSide.BUY:
+            self.slippage = self.avg_px - self.price.as_f64_c()
+        elif self.side == OrderSide.SELL:
+            self.slippage = self.price.as_f64_c() - self.avg_px
+
+    cdef bint has_price_c(self):
+        return self.price is not None
 
-    def create_sell_order(self, last: QuoteTick) -> None:
-        """
-        Market maker simple sell limit method (example).
-        """
-        if not self.instrument:
-            self.log.error("No instrument loaded.")
-            return
-
-        price: Decimal = last.ask_price + (self.atr.value * self.atr_multiple)
-        order: LimitOrder = self.order_factory.limit(
-            instrument_id=self.instrument_id,
-            order_side=OrderSide.SELL,
-            quantity=self.instrument.make_qty(self.trade_size),
-            price=self.instrument.make_price(price),
-            time_in_force=TimeInForce.GTD,
-            expire_time=self.clock.utc_now() + pd.Timedelta(minutes=10),
-            post_only=True,  # default value is True
-            # display_qty=self.instrument.make_qty(self.trade_size / 2),  # iceberg
-            emulation_trigger=self.emulation_trigger,
-        )
+    cdef bint has_trigger_price_c(self):
+        return False
 
-        self.sell_order = order
-        self.submit_order(order)
-
-    def on_event(self, event: Event) -> None:
+    @property
+    def expire_time(self):
         """
-        Actions to be performed when the strategy is running and receives an event.
+        Return the expire time for the order (UTC).
 
-        Parameters
-        ----------
-        event : Event
-            The event received.
+        Returns
+        -------
+        datetime or ``None``
 
         """
-        last: QuoteTick = self.cache.quote_tick(self.instrument_id)
-        if last is None:
-            self.log.info("No quotes yet...")
-            return
-
-        # If order filled then replace order at ATR multiple distance from the market
-        if isinstance(event, OrderFilled):
-            if self.buy_order and event.order_side == OrderSide.BUY:
-                if self.buy_order.is_closed:
-                    self.create_buy_order(last)
-            elif (
-                self.sell_order and event.order_side == OrderSide.SELL and self.sell_order.is_closed
-            ):
-                self.create_sell_order(last)
+        return None if self.expire_time_ns == 0 else unix_nanos_to_dt(self.expire_time_ns)
 
-    def on_stop(self) -> None:
-        """
-        Actions to be performed when the strategy is stopped.
+    cpdef str info(self):
         """
-        self.cancel_all_orders(self.instrument_id)
-        self.close_all_positions(self.instrument_id)
+        Return a summary description of the order.
 
-        # Unsubscribe from data
-        self.unsubscribe_bars(self.bar_type)
-        self.unsubscribe_quote_ticks(self.instrument_id)
-        # self.unsubscribe_trade_ticks(self.instrument_id)
-        # self.unsubscribe_order_book_deltas(self.instrument_id)  # For debugging
-        # self.unsubscribe_order_book_snapshots(self.instrument_id)  # For debugging
+        Returns
+        -------
+        str
 
-    def on_reset(self) -> None:
-        """
-        Actions to be performed when the strategy is reset.
         """
-        # Reset indicators here
-        self.atr.reset()
+        cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {format_iso8601(unix_nanos_to_dt(self.expire_time_ns))}"
+        return (
+            f"{order_side_to_str(self.side)} {self.quantity.to_str()} {self.instrument_id} "
+            f"{order_type_to_str(self.order_type)} @ {self.price} "
+            f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
+        )
 
-    def on_save(self) -> dict[str, bytes]:
+    cpdef dict to_dict(self):
         """
-        Actions to be performed when the strategy is saved.
-
-        Create and return a state dictionary of values to be saved.
+        Return a dictionary representation of this object.
 
         Returns
         -------
-        dict[str, bytes]
-            The strategy state dictionary.
+        dict[str, object]
 
         """
-        return {}
+        cdef ClientOrderId o
+        return {
+            "trader_id": self.trader_id.to_str(),
+            "strategy_id": self.strategy_id.to_str(),
+            "instrument_id": self.instrument_id.to_str(),
+            "client_order_id": self.client_order_id.to_str(),
+            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
+            "position_id": self.position_id.to_str() if self.position_id is not None else None,
+            "account_id": self.account_id.to_str() if self.account_id is not None else None,
+            "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
+            "type": order_type_to_str(self.order_type),
+            "side": order_side_to_str(self.side),
+            "quantity": str(self.quantity),
+            "price": str(self.price),
+            "time_in_force": time_in_force_to_str(self.time_in_force),
+            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
+            "is_reduce_only": self.is_reduce_only,
+            "is_quote_quantity": self.is_quote_quantity,
+            "display_qty": str(self.display_qty) if self.display_qty is not None else None,
+            "filled_qty": str(self.filled_qty),
+            "liquidity_side": liquidity_side_to_str(self.liquidity_side),
+            "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
+            "status": self._fsm.state_string_c(),
+            "contingency_type": contingency_type_to_str(self.contingency_type),
+            "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
+            "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
+            "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
+            "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
+            "exec_algorithm_params": self.exec_algorithm_params,
+            "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
+            "tags": self.tags,
+            "ts_init": self.ts_init,
+            "ts_last": self.ts_last,
+        }
 
-    def on_load(self, state: dict[str, bytes]) -> None:
+    @staticmethod
+    cdef MarketToLimitOrder create(OrderInitialized init):
         """
-        Actions to be performed when the strategy is loaded.
-
-        Saved state values will be contained in the give state dictionary.
+        Return a `Market-To-Limit` order from the given initialized event.
 
         Parameters
         ----------
-        state : dict[str, bytes]
-            The strategy state dictionary.
+        init : OrderInitialized
+            The event to initialize with.
 
-        """
-
-    def on_dispose(self) -> None:
-        """
-        Actions to be performed when the strategy is disposed.
-
-        Cleanup any resources used by the strategy here.
+        Returns
+        -------
+        MarketToLimitOrder
 
-        """
+        Raises
+        ------
+        ValueError
+            If `init.order_type` is not equal to ``MARKET_TO_LIMIT``.
+
+        """
+        Condition.not_none(init, "init")
+        Condition.equal(init.order_type, OrderType.MARKET_TO_LIMIT, "init.order_type", "OrderType")
+
+        cdef str display_qty_str = init.options.get("display_qty")
+
+        return MarketToLimitOrder(
+            trader_id=init.trader_id,
+            strategy_id=init.strategy_id,
+            instrument_id=init.instrument_id,
+            client_order_id=init.client_order_id,
+            order_side=init.side,
+            quantity=init.quantity,
+            time_in_force=init.time_in_force,
+            expire_time_ns=init.options["expire_time_ns"],
+            reduce_only=init.reduce_only,
+            quote_quantity=init.quote_quantity,
+            display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
+            init_id=init.id,
+            ts_init=init.ts_init,
+            order_list_id=init.order_list_id,
+            contingency_type=init.contingency_type,
+            linked_order_ids=init.linked_order_ids,
+            parent_order_id=init.parent_order_id,
+            exec_algorithm_id=init.exec_algorithm_id,
+            exec_algorithm_params=init.exec_algorithm_params,
+            exec_spawn_id=init.exec_spawn_id,
+            tags=init.tags,
+        )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/examples/strategies/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/execution/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/algorithm.pxd` & `nautilus_trader-1.191.0/nautilus_trader/execution/algorithm.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/algorithm.pyx` & `nautilus_trader-1.191.0/nautilus_trader/execution/algorithm.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -27,19 +27,19 @@
 from nautilus_trader.common.component cimport CMD
 from nautilus_trader.common.component cimport EVT
 from nautilus_trader.common.component cimport RECV
 from nautilus_trader.common.component cimport SENT
 from nautilus_trader.common.component cimport Clock
 from nautilus_trader.common.component cimport LogColor
 from nautilus_trader.common.component cimport MessageBus
+from nautilus_trader.common.component cimport is_logging_initialized
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.datetime cimport dt_to_unix_nanos
 from nautilus_trader.core.fsm cimport InvalidStateTrigger
 from nautilus_trader.core.rust.common cimport ComponentState
-from nautilus_trader.core.rust.common cimport logging_is_initialized
 from nautilus_trader.core.rust.model cimport ContingencyType
 from nautilus_trader.core.rust.model cimport OrderStatus
 from nautilus_trader.core.rust.model cimport TimeInForce
 from nautilus_trader.core.rust.model cimport TriggerType
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.execution.messages cimport CancelOrder
 from nautilus_trader.execution.messages cimport SubmitOrder
@@ -70,16 +70,16 @@
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ExecAlgorithmId
 from nautilus_trader.model.identifiers cimport PositionId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
-from nautilus_trader.model.orders.base cimport VALID_LIMIT_ORDER_TYPES
-from nautilus_trader.model.orders.base cimport VALID_STOP_ORDER_TYPES
+from nautilus_trader.model.orders.base cimport LIMIT_ORDER_TYPES
+from nautilus_trader.model.orders.base cimport STOP_ORDER_TYPES
 from nautilus_trader.model.orders.base cimport Order
 from nautilus_trader.model.orders.limit cimport LimitOrder
 from nautilus_trader.model.orders.list cimport OrderList
 from nautilus_trader.model.orders.market cimport MarketOrder
 from nautilus_trader.model.orders.market_to_limit cimport MarketToLimitOrder
 from nautilus_trader.portfolio.base cimport PortfolioFacade
 
@@ -249,32 +249,32 @@
         ------
         ValueError
             If `command.exec_algorithm_id` is not equal to `self.id`.
 
         """
         Condition.not_none(command, "command")
 
-        self._log.debug(f"{RECV}{CMD} {command}.", LogColor.MAGENTA)
+        self._log.debug(f"{RECV}{CMD} {command}", LogColor.MAGENTA)
 
         if self._fsm.state != ComponentState.RUNNING:
             return
 
         if isinstance(command, SubmitOrder):
             self._handle_submit_order(command)
         elif isinstance(command, SubmitOrderList):
             self._handle_submit_order_list(command)
         elif isinstance(command, CancelOrder):
             self._handle_cancel_order(command)
         else:
-            self._log.error(f"Cannot handle command: unrecognized {command}.")
+            self._log.error(f"Cannot handle command: unrecognized {command}")
 
         if command.strategy_id in self._subscribed_strategies:
             return  # Already subscribed
 
-        self._log.info(f"Subscribing to {command.strategy_id} order events.", LogColor.BLUE)
+        self._log.info(f"Subscribing to {command.strategy_id} order events", LogColor.BLUE)
         self._msgbus.subscribe(topic=f"events.order.{command.strategy_id.to_str()}", handler=self._handle_event)
         self._msgbus.subscribe(topic=f"events.position.{command.strategy_id.to_str()}", handler=self._handle_event)
         self._subscribed_strategies.add(command.strategy_id)
 
     cdef void _handle_submit_order(self, SubmitOrder command):
         Condition.equal(command.exec_algorithm_id, self.id, "command.exec_algorithm_id", "self.id")
         try:
@@ -295,23 +295,23 @@
             self.log.exception(f"Error on handling {repr(command.order_list)}", e)
             raise
 
     cdef void _handle_cancel_order(self, CancelOrder command):
         cdef Order order = self.cache.order(command.client_order_id)
         if order is None:  # pragma: no cover (design-time error)
             self._log.error(
-                f"Cannot cancel order: {repr(command.client_order_id)} not found.",
+                f"Cannot cancel order: {repr(command.client_order_id)} not found",
             )
             return
 
         if self.cache.is_order_pending_cancel_local(command.client_order_id):
             return  # Already pending cancel locally
 
         if order.is_closed_c():
-            self._log.warning(f"Order already canceled for {command}.")
+            self._log.warning(f"Order already canceled for {command}")
             return
 
         # Generate event
         cdef OrderCanceled event = self._generate_order_canceled(order)
 
         try:
             order.apply(event)
@@ -1069,24 +1069,24 @@
 
         if order.is_spawned_c():
             # Handle new spawned order
             primary = self.cache.order(order.exec_spawn_id)
             Condition.equal(order.strategy_id, primary.strategy_id, "order.strategy_id", "primary.strategy_id")
             if primary is None:
                 self._log.error(
-                    f"Cannot submit order: cannot find primary order for {order.exec_spawn_id!r}."
+                    f"Cannot submit order: cannot find primary order for {order.exec_spawn_id!r}"
                 )
                 return
 
             position_id = self.cache.position_id(primary.client_order_id)
             client_id = self.cache.client_id(primary.client_order_id)
 
             if self.cache.order_exists(order.client_order_id):
                 self._log.error(
-                    f"Cannot submit order: order already exists for {order.client_order_id!r}.",
+                    f"Cannot submit order: order already exists for {order.client_order_id!r}",
                 )
                 return
 
             # Publish initialized event
             self._msgbus.publish_c(
                 topic=f"events.order.{order.strategy_id.to_str()}",
                 msg=order.init_event_c(),
@@ -1183,23 +1183,23 @@
         cdef bint updating = False  # Set validation flag (must become true)
 
         if quantity is not None and quantity != order.quantity:
             updating = True
 
         if price is not None:
             Condition.true(
-                order.order_type in VALID_LIMIT_ORDER_TYPES,
+                order.order_type in LIMIT_ORDER_TYPES,
                 fail_msg=f"{order.type_string_c()} orders do not have a LIMIT price",
             )
             if price != order.price:
                 updating = True
 
         if trigger_price is not None:
             Condition.true(
-                order.order_type in VALID_STOP_ORDER_TYPES,
+                order.order_type in STOP_ORDER_TYPES,
                 fail_msg=f"{order.type_string_c()} orders do not have a STOP trigger price",
             )
             if trigger_price != order.trigger_price:
                 updating = True
 
         if not updating:
             self.log.error(
@@ -1302,23 +1302,23 @@
         cdef bint updating = False  # Set validation flag (must become true)
 
         if quantity is not None and quantity != order.quantity:
             updating = True
 
         if price is not None:
             Condition.true(
-                order.order_type in VALID_LIMIT_ORDER_TYPES,
+                order.order_type in LIMIT_ORDER_TYPES,
                 fail_msg=f"{order.type_string_c()} orders do not have a LIMIT price",
             )
             if price != order.price:
                 updating = True
 
         if trigger_price is not None:
             Condition.true(
-                order.order_type in VALID_STOP_ORDER_TYPES,
+                order.order_type in STOP_ORDER_TYPES,
                 fail_msg=f"{order.type_string_c()} orders do not have a STOP trigger price",
             )
             if trigger_price != order.trigger_price:
                 updating = True
 
         if not updating:
             self.log.error(
@@ -1459,20 +1459,20 @@
             ts_event=ts_now,
             ts_init=ts_now,
         )
 
 # -- EGRESS ---------------------------------------------------------------------------------------
 
     cdef void _send_emulator_command(self, TradingCommand command):
-        if logging_is_initialized():
+        if is_logging_initialized():
             self.log.info(f"{CMD}{SENT} {command}.")
         self._msgbus.send(endpoint="OrderEmulator.execute", msg=command)
 
     cdef void _send_risk_command(self, TradingCommand command):
-        if logging_is_initialized():
+        if is_logging_initialized():
             self.log.info(f"{CMD}{SENT} {command}.")
         self._msgbus.send(endpoint="RiskEngine.execute", msg=command)
 
     cdef void _send_exec_command(self, TradingCommand command):
-        if logging_is_initialized():
+        if is_logging_initialized():
             self.log.info(f"{CMD}{SENT} {command}.")
         self._msgbus.send(endpoint="ExecEngine.execute", msg=command)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/client.pxd` & `nautilus_trader-1.191.0/nautilus_trader/execution/client.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/client.pyx` & `nautilus_trader-1.191.0/nautilus_trader/execution/client.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -166,15 +166,15 @@
         ----------
         command : SubmitOrder
             The command to execute.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot execute command {command}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `submit_order` method for this client.",  # pragma: no cover  # noqa
+            f"You can implement by overriding the `submit_order` method for this client",  # pragma: no cover  # noqa
         )
         raise NotImplementedError("method `submit_order` must be implemented in the subclass")
 
     cpdef void submit_order_list(self, SubmitOrderList command):
         """
         Submit the order list contained in the given command for execution.
 
@@ -182,15 +182,15 @@
         ----------
         command : SubmitOrderList
             The command to execute.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot execute command {command}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `submit_order_list` method for this client.",  # pragma: no cover   # noqa
+            f"You can implement by overriding the `submit_order_list` method for this client",  # pragma: no cover   # noqa
         )
         raise NotImplementedError("method `submit_order_list` must be implemented in the subclass")
 
     cpdef void modify_order(self, ModifyOrder command):
         """
         Modify the order with parameters contained in the command.
 
@@ -198,15 +198,15 @@
         ----------
         command : ModifyOrder
             The command to execute.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot execute command {command}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `modify_order` method for this client.",  # pragma: no cover  # noqa
+            f"You can implement by overriding the `modify_order` method for this client",  # pragma: no cover  # noqa
         )
         raise NotImplementedError("method `modify_order` must be implemented in the subclass")
 
     cpdef void cancel_order(self, CancelOrder command):
         """
         Cancel the order with the client order ID contained in the given command.
 
@@ -214,15 +214,15 @@
         ----------
         command : CancelOrder
             The command to execute.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot execute command {command}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `cancel_order` method for this client.",  # pragma: no cover  # noqa
+            f"You can implement by overriding the `cancel_order` method for this client",  # pragma: no cover  # noqa
         )
         raise NotImplementedError("method `cancel_order` must be implemented in the subclass")
 
     cpdef void cancel_all_orders(self, CancelAllOrders command):
         """
         Cancel all orders for the instrument ID contained in the given command.
 
@@ -230,15 +230,15 @@
         ----------
         command : CancelAllOrders
             The command to execute.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot execute command {command}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `cancel_all_orders` method for this client.",  # pragma: no cover  # noqa
+            f"You can implement by overriding the `cancel_all_orders` method for this client",  # pragma: no cover  # noqa
         )
         raise NotImplementedError("method `cancel_all_orders` must be implemented in the subclass")
 
     cpdef void batch_cancel_orders(self, BatchCancelOrders command):
         """
         Batch cancel orders for the instrument ID contained in the given command.
 
@@ -246,15 +246,15 @@
         ----------
         command : BatchCancelOrders
             The command to execute.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot execute command {command}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `batch_cancel_orders` method for this client.",  # pragma: no cover  # noqa
+            f"You can implement by overriding the `batch_cancel_orders` method for this client",  # pragma: no cover  # noqa
         )
         raise NotImplementedError("method `batch_cancel_orders` must be implemented in the subclass")
 
     cpdef void query_order(self, QueryOrder command):
         """
         Initiate a reconciliation for the queried order which will generate an
         `OrderStatusReport`.
@@ -263,15 +263,15 @@
         ----------
         command : QueryOrder
             The command to execute.
 
         """
         self._log.error(  # pragma: no cover
             f"Cannot execute command {command}: not implemented. "  # pragma: no cover
-            f"You can implement by overriding the `query_order` method for this client.",  # pragma: no cover  # noqa
+            f"You can implement by overriding the `query_order` method for this client",  # pragma: no cover  # noqa
         )
         raise NotImplementedError("method `query_order` must be implemented in the subclass")
 
 # -- EVENT HANDLERS -------------------------------------------------------------------------------
 
     cpdef void generate_account_state(
         self,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/config.py` & `nautilus_trader-1.191.0/nautilus_trader/execution/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/emulator.pxd` & `nautilus_trader-1.191.0/nautilus_trader/execution/emulator.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/emulator.pyx` & `nautilus_trader-1.191.0/nautilus_trader/execution/emulator.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -23,17 +23,17 @@
 from nautilus_trader.common.component cimport CMD
 from nautilus_trader.common.component cimport EVT
 from nautilus_trader.common.component cimport RECV
 from nautilus_trader.common.component cimport SENT
 from nautilus_trader.common.component cimport Clock
 from nautilus_trader.common.component cimport LogColor
 from nautilus_trader.common.component cimport MessageBus
+from nautilus_trader.common.component cimport is_logging_initialized
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.message cimport Event
-from nautilus_trader.core.rust.common cimport logging_is_initialized
 from nautilus_trader.core.rust.model cimport ContingencyType
 from nautilus_trader.core.rust.model cimport OrderSide
 from nautilus_trader.core.rust.model cimport OrderStatus
 from nautilus_trader.core.rust.model cimport OrderType
 from nautilus_trader.core.rust.model cimport TimeInForce
 from nautilus_trader.core.rust.model cimport TriggerType
 from nautilus_trader.core.uuid cimport UUID4
@@ -191,30 +191,30 @@
         return self._matching_cores.get(instrument_id)
 
 # -- ACTION IMPLEMENTATIONS -----------------------------------------------------------------------
 
     cpdef void on_start(self):
         cdef list emulated_orders = self.cache.orders_emulated()
         if not emulated_orders:
-            self._log.info("No emulated orders to reactivate.")
+            self._log.info("No emulated orders to reactivate")
             return
 
         cdef:
             Order order
             SubmitOrder command
             PositionId position_id
             ClientId client_id
         for order in emulated_orders:
             if order.status_c() not in (OrderStatus.INITIALIZED, OrderStatus.EMULATED):
                 continue  # No longer emulated
 
             if order.parent_order_id is not None:
                 parent_order = self.cache.order(order.parent_order_id)
                 if parent_order is None:
-                    self._log.error("Cannot handle order: parent {order.parent_order_id!r} not found.")
+                    self._log.error("Cannot handle order: parent {order.parent_order_id!r} not found")
                     continue
                 position_id = parent_order.position_id
                 if parent_order.is_closed_c() and (position_id is None or self.cache.is_position_closed(position_id)):
                     self._manager.cancel_order(order=order)
                     continue  # Parent already closed
                 if parent_order.contingency_type == ContingencyType.OTO:
                     if parent_order.is_active_local_c() or parent_order.filled_qty == 0:
@@ -289,29 +289,29 @@
         command : TradingCommand
             The command to execute.
 
         """
         Condition.not_none(command, "command")
 
         if self.debug:
-            self._log.info(f"{RECV}{CMD} {command}.", LogColor.MAGENTA)
+            self._log.info(f"{RECV}{CMD} {command}", LogColor.MAGENTA)
         self.command_count += 1
 
         if isinstance(command, SubmitOrder):
             self._handle_submit_order(command)
         elif isinstance(command, SubmitOrderList):
             self._handle_submit_order_list(command)
         elif isinstance(command, ModifyOrder):
             self._handle_modify_order(command)
         elif isinstance(command, CancelOrder):
             self._handle_cancel_order(command)
         elif isinstance(command, CancelAllOrders):
             self._handle_cancel_all_orders(command)
         else:
-            self._log.error(f"Cannot handle command: unrecognized {command}.")
+            self._log.error(f"Cannot handle command: unrecognized {command}")
 
     cpdef MatchingCore create_matching_core(
         self,
         InstrumentId instrument_id,
         Price price_increment,
     ):
         """
@@ -343,60 +343,60 @@
             fill_market_order=self._fill_market_order,
             fill_limit_order=self._fill_limit_order,
         )
 
         self._matching_cores[instrument_id] = matching_core
 
         if self.debug:
-            self._log.info(f"Created matching core for {instrument_id}.", LogColor.MAGENTA)
+            self._log.info(f"Created matching core for {instrument_id}", LogColor.MAGENTA)
 
         return matching_core
 
     cdef void _handle_submit_order(self, SubmitOrder command):
         cdef Order order = command.order
         cdef TriggerType emulation_trigger = command.order.emulation_trigger
         Condition.not_equal(emulation_trigger, TriggerType.NO_TRIGGER, "command.order.emulation_trigger", "TriggerType.NO_TRIGGER")
         Condition.not_in(command.order.client_order_id, self._manager.get_submit_order_commands(), "command.order.client_order_id", "manager.submit_order_commands")
 
         if emulation_trigger not in SUPPORTED_TRIGGERS:
             self._log.error(
-                f"Cannot emulate order: `TriggerType` {trigger_type_to_str(emulation_trigger)} not supported.")
+                f"Cannot emulate order: `TriggerType` {trigger_type_to_str(emulation_trigger)} not supported")
             self._manager.cancel_order(order=order)
             return
 
         self._check_monitoring(command.strategy_id, command.position_id)
 
         cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
         cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
         if matching_core is None:
             if trigger_instrument_id.is_synthetic():
                 synthetic = self.cache.synthetic(trigger_instrument_id)
                 if synthetic is None:
                     self._log.error(
-                        f"Cannot emulate order: no synthetic instrument {trigger_instrument_id} for trigger.",
+                        f"Cannot emulate order: no synthetic instrument {trigger_instrument_id} for trigger",
                     )
                     self._manager.cancel_order(order=order)
                     return
                 matching_core = self.create_matching_core(synthetic.id, synthetic.price_increment)
             else:
                 instrument = self.cache.instrument(trigger_instrument_id)
                 if instrument is None:
                     self._log.error(
-                        f"Cannot emulate order: no instrument {trigger_instrument_id} for trigger.",
+                        f"Cannot emulate order: no instrument {trigger_instrument_id} for trigger",
                     )
                     self._manager.cancel_order(order=order)
                     return
                 matching_core = self.create_matching_core(instrument.id, instrument.price_increment)
 
         # Update trailing stop
         if order.order_type == OrderType.TRAILING_STOP_MARKET or order.order_type == OrderType.TRAILING_STOP_LIMIT:
             self._update_trailing_stop_order(matching_core, order)
             if order.trigger_price is None:
-                self.log.error(
-                    "Cannot handle trailing stop order with no `trigger_price` and no market updates.",
+                self._log.error(
+                    "Cannot handle trailing stop order with no `trigger_price` and no market updates",
                 )
                 self._manager.cancel_order(order)
                 return
 
         # Cache command
         self._manager.cache_submit_order_command(command)
 
@@ -441,15 +441,15 @@
 
             # Publish event
             self._msgbus.publish_c(
                 topic=f"events.order.{order.strategy_id.to_str()}",
                 msg=event,
             )
 
-        self.log.info(f"Emulating {command.order}.", LogColor.MAGENTA)
+        self._log.info(f"Emulating {command.order}", LogColor.MAGENTA)
 
     cdef void _handle_submit_order_list(self, SubmitOrderList command):
         self._check_monitoring(command.strategy_id, command.position_id)
 
         cdef Order order
         for order in command.order_list.orders:
             if order.parent_order_id is not None:
@@ -463,15 +463,15 @@
                 client_id=command.client_id,
             )
 
     cdef void _handle_modify_order(self, ModifyOrder command):
         cdef Order order = self.cache.order(command.client_order_id)
         if order is None:
             self._log.error(
-                f"Cannot modify order: {repr(order.client_order_id)} not found.",
+                f"Cannot modify order: {repr(order.client_order_id)} not found",
             )
             return
 
         cdef Price price = command.price
         if price is None and order.has_price_c():
             price = order.price
 
@@ -497,15 +497,15 @@
         )
         self._manager.send_exec_event(event)
 
         cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
         cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
         if matching_core is None:
             self._log.error(
-                f"Cannot handle `ModifyOrder`: no matching core for trigger instrument {trigger_instrument_id}.",
+                f"Cannot handle `ModifyOrder`: no matching core for trigger instrument {trigger_instrument_id}",
             )
             return
 
         matching_core.match_order(order)
         if order.side == OrderSide.BUY:
             matching_core.sort_bid_orders()
         elif order.side == OrderSide.SELL:
@@ -513,15 +513,15 @@
         else:
             raise RuntimeError("invalid `OrderSide`")  # pragma: no cover (design-time error)
 
     cdef void _handle_cancel_order(self, CancelOrder command):
         cdef Order order = self.cache.order(command.client_order_id)
         if order is None:
             self._log.error(
-                f"Cannot cancel order: {repr(command.client_order_id)} not found.",
+                f"Cannot cancel order: {repr(command.client_order_id)} not found",
             )
             return
 
         cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
         cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
         if matching_core is None:
             self._manager.cancel_order(order)
@@ -557,28 +557,28 @@
 
     cpdef void _check_monitoring(self, StrategyId strategy_id, PositionId position_id):
         if strategy_id not in self._subscribed_strategies:
             # Subscribe to all strategy events
             self._msgbus.subscribe(topic=f"events.order.{strategy_id.to_str()}", handler=self.on_event)
             self._msgbus.subscribe(topic=f"events.position.{strategy_id.to_str()}", handler=self.on_event)
             self._subscribed_strategies.add(strategy_id)
-            self._log.info(f"Subscribed to strategy {strategy_id.to_str()} order and position events.", LogColor.BLUE)
+            self._log.info(f"Subscribed to strategy {strategy_id.to_str()} order and position events", LogColor.BLUE)
 
         if position_id is not None and position_id not in self._monitored_positions:
             self._monitored_positions.add(position_id)
 
     cpdef void _cancel_order(self, Order order):
         if order is None:
             self._log.error(
-                f"Cannot cancel order: order for {repr(order.client_order_id)} not found.",
+                f"Cannot cancel order: order for {repr(order.client_order_id)} not found",
             )
             return
 
         if self.debug:
-            self._log.info(f"Cancelling order {order.client_order_id!r}.", LogColor.MAGENTA)
+            self._log.info(f"Cancelling order {order.client_order_id!r}", LogColor.MAGENTA)
 
         # Remove emulation trigger
         order.emulation_trigger = TriggerType.NO_TRIGGER
 
         cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
         cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
         if matching_core is not None:
@@ -600,21 +600,21 @@
             ts_init=ts_now,
         )
         self._manager.send_exec_event(event)
 
     cpdef void _update_order(self, Order order, Quantity new_quantity):
         if order is None:
             self._log.error(
-                f"Cannot update order: order for {repr(order.client_order_id)} not found.",
+                f"Cannot update order: order for {repr(order.client_order_id)} not found",
             )
             return
 
         if self.debug:
             self._log.info(
-                f"Updating order {order.client_order_id} quantity to {new_quantity}.",
+                f"Updating order {order.client_order_id} quantity to {new_quantity}",
                 LogColor.MAGENTA,
             )
 
         # Generate event
         cdef uint64_t ts_now = self._clock.timestamp_ns()
         cdef OrderUpdated event = OrderUpdated(
             trader_id=order.trader_id,
@@ -704,15 +704,15 @@
             ts_init=self._clock.timestamp_ns(),
         )
         transformed.apply(event)
         self.cache.update_order(transformed)
 
         self._manager.send_risk_event(event)
 
-        self.log.info(f"Releasing {transformed}...", LogColor.MAGENTA)
+        self._log.info(f"Releasing {transformed}", LogColor.MAGENTA)
 
         # Publish event
         self._msgbus.publish_c(
             topic=f"events.order.{transformed.strategy_id.to_str()}",
             msg=event,
         )
 
@@ -776,48 +776,48 @@
             ts_init=self._clock.timestamp_ns(),
         )
         transformed.apply(event)
         self.cache.update_order(transformed)
 
         self._manager.send_risk_event(event)
 
-        self.log.info(f"Releasing {transformed}...", LogColor.MAGENTA)
+        self._log.info(f"Releasing {transformed}", LogColor.MAGENTA)
 
         # Publish event
         self._msgbus.publish_c(
             topic=f"events.order.{transformed.strategy_id.to_str()}",
             msg=event,
         )
 
         if order.exec_algorithm_id is not None:
             self._manager.send_algo_command(command, order.exec_algorithm_id)
         else:
             self._manager.send_exec_command(command)
 
     cpdef void on_quote_tick(self, QuoteTick tick):
-        if logging_is_initialized():
-            self._log.debug(f"Processing {repr(tick)}...", LogColor.CYAN)
+        if is_logging_initialized():
+            self._log.debug(f"Processing {repr(tick)}", LogColor.CYAN)
 
         cdef MatchingCore matching_core = self._matching_cores.get(tick.instrument_id)
         if matching_core is None:
-            self._log.error(f"Cannot handle `QuoteTick`: no matching core for instrument {tick.instrument_id}.")
+            self._log.error(f"Cannot handle `QuoteTick`: no matching core for instrument {tick.instrument_id}")
             return
 
         matching_core.set_bid_raw(tick._mem.bid_price.raw)
         matching_core.set_ask_raw(tick._mem.ask_price.raw)
 
         self._iterate_orders(matching_core)
 
     cpdef void on_trade_tick(self, TradeTick tick):
-        if logging_is_initialized():
+        if is_logging_initialized():
             self._log.debug(f"Processing {repr(tick)}...", LogColor.CYAN)
 
         cdef MatchingCore matching_core = self._matching_cores.get(tick.instrument_id)
         if matching_core is None:
-            self._log.error(f"Cannot handle `TradeTick`: no matching core for instrument {tick.instrument_id}.")
+            self._log.error(f"Cannot handle `TradeTick`: no matching core for instrument {tick.instrument_id}")
             return
 
         matching_core.set_last_raw(tick._mem.price.raw)
         if tick.instrument_id not in self._subscribed_quotes:
             matching_core.set_bid_raw(tick._mem.price.raw)
             matching_core.set_ask_raw(tick._mem.price.raw)
 
@@ -833,15 +833,15 @@
                 continue
 
             # Manage trailing stop
             if order.order_type == OrderType.TRAILING_STOP_MARKET or order.order_type == OrderType.TRAILING_STOP_LIMIT:
                 self._update_trailing_stop_order(matching_core, order)
 
     cdef void _update_trailing_stop_order(self, MatchingCore matching_core, Order order):
-        # TODO(cs): Improve efficiency of this ---------------------------------
+        # TODO: Improve efficiency of this ---------------------------------
         cdef Price bid = None
         cdef Price ask = None
         cdef Price last = None
         if matching_core.is_bid_initialized:
             bid = Price.from_raw_c(matching_core.bid_raw, matching_core.price_precision)
         if matching_core.is_ask_initialized:
             ask = Price.from_raw_c(matching_core.ask_raw, matching_core.price_precision)
@@ -852,15 +852,15 @@
         cdef TradeTick trade_tick = self.cache.trade_tick(matching_core.instrument_id)
         if bid is None and quote_tick is not None:
             bid = quote_tick.bid_price
         if ask is None and quote_tick is not None:
             ask = quote_tick.ask_price
         if last is None and trade_tick is not None:
             last = trade_tick.price
-        # TODO(cs): ------------------------------------------------------------
+        # TODO: ------------------------------------------------------------
 
         cdef tuple output
         try:
             output = TrailingStopCalculator.calculate(
                 price_increment=matching_core.price_increment,
                 order=order,
                 bid=bid,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/engine.pxd` & `nautilus_trader-1.191.0/nautilus_trader/execution/engine.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/engine.pyx` & `nautilus_trader-1.191.0/nautilus_trader/execution/engine.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -338,15 +338,15 @@
         if client.venue is None:
             if self._default_client is None:
                 self._default_client = client
                 routing_log = " for default routing"
         else:
             self._routing_map[client.venue] = client
 
-        self._log.info(f"Registered ExecutionClient-{client}{routing_log}.")
+        self._log.info(f"Registered ExecutionClient-{client}{routing_log}")
 
     cpdef void register_default_client(self, ExecutionClient client):
         """
         Register the given client as the default routing client (when a specific
         venue routing cannot be found).
 
         Any existing default routing client will be overwritten.
@@ -357,15 +357,15 @@
             The client to register.
 
         """
         Condition.not_none(client, "client")
 
         self._default_client = client
 
-        self._log.info(f"Registered {client} for default routing.")
+        self._log.info(f"Registered {client} for default routing")
 
     cpdef void register_venue_routing(self, ExecutionClient client, Venue venue):
         """
         Register the given client to route orders to the given venue.
 
         Any existing client in the routing map for the given venue will be
         overwritten.
@@ -382,15 +382,15 @@
         Condition.not_none(venue, "venue")
 
         if client.id not in self._clients:
             self._clients[client.id] = client
 
         self._routing_map[venue] = client
 
-        self._log.info(f"Registered ExecutionClient-{client} for routing to {venue}.")
+        self._log.info(f"Registered ExecutionClient-{client} for routing to {venue}")
 
     cpdef void register_oms_type(self, Strategy strategy):
         """
         Register the given trading strategies OMS (Order Management System) type.
 
         Parameters
         ----------
@@ -400,15 +400,15 @@
         """
         Condition.not_none(strategy, "strategy")
 
         self._oms_overrides[strategy.id] = strategy.oms_type
 
         self._log.info(
             f"Registered OMS.{oms_type_to_str(strategy.oms_type)} "
-            f"for Strategy {strategy}.",
+            f"for Strategy {strategy}",
         )
 
     cpdef void register_external_order_claims(self, Strategy strategy):
         """
         Register the given strategies external order claim instrument IDs (if any)
 
         Parameters
@@ -434,15 +434,15 @@
                     f"External order claim for {instrument_id} already exists for {existing}",
                 )
             # Register strategy to claim external orders for this instrument
             self._external_order_claims[instrument_id] = strategy.id
 
         if strategy.external_order_claims:
             self._log.info(
-                f"Registered external order claims for {strategy}: {strategy.external_order_claims}.",
+                f"Registered external order claims for {strategy}: {strategy.external_order_claims}",
             )
 
     cpdef void deregister_client(self, ExecutionClient client):
         """
         Deregister the given execution client from the execution engine.
 
         Parameters
@@ -463,15 +463,15 @@
 
         if client.venue is None:
             if self._default_client == client:
                 self._default_client = None
         else:
             del self._routing_map[client.venue]
 
-        self._log.info(f"Deregistered {client}.")
+        self._log.info(f"Deregistered {client}")
 
     # -- RECONCILIATION -------------------------------------------------------------------------------
 
     async def reconcile_state(self, timeout_secs: float = 10.0) -> bool:
         """
         Reconcile the internal execution state with all execution clients (external state).
 
@@ -577,15 +577,15 @@
         self._cache.cache_order_lists()
         self._cache.cache_positions()
 
         self._cache.build_index()
         self._cache.check_integrity()
         self._set_position_id_counts()
 
-        self._log.info(f"Loaded cache in {(int(time.time() * 1000) - ts)}ms.")
+        self._log.info(f"Loaded cache in {(int(time.time() * 1000) - ts)}ms")
 
     cpdef void execute(self, TradingCommand command):
         """
         Execute the given command.
 
         Parameters
         ----------
@@ -640,15 +640,15 @@
         # Reset position ID generator
         self._pos_id_generator.reset()
 
         # Set counts
         cdef StrategyId strategy_id
         for strategy_id, count in counts.items():
             self._pos_id_generator.set_count(strategy_id, count)
-            self._log.info(f"Set PositionId count for {strategy_id!r} to {count}.")
+            self._log.info(f"Set PositionId count for {strategy_id!r} to {count}")
 
     cpdef Price _last_px_for_conversion(self, InstrumentId instrument_id, OrderSide order_side):
         cdef Price last_px = None
         cdef QuoteTick last_quote = self._cache.quote_tick(instrument_id)
         cdef TradeTick last_trade = self._cache.trade_tick(instrument_id)
         if last_quote is not None:
             last_px = last_quote.ask_price if order_side == OrderSide.BUY else last_quote.bid_price
@@ -656,15 +656,15 @@
             if last_trade is not None:
                 last_px = last_trade.price
 
         return last_px
 
     cpdef void _set_order_base_qty(self, Order order, Quantity base_qty):
         self._log.info(
-            f"Setting {order.instrument_id} order quote quantity {order.quantity} to base quantity {base_qty}.",
+            f"Setting {order.instrument_id} order quote quantity {order.quantity} to base quantity {base_qty}",
         )
         cdef Quantity original_qty = order.quantity
         order.quantity = base_qty
         order.leaves_qty = base_qty
         order.is_quote_quantity = False
 
         if order.contingency_type != ContingencyType.OTO:
@@ -672,27 +672,27 @@
 
         # Set base quantity for all OTO contingent orders
         cdef ClientOrderId client_order_id
         cdef Order contingent_order
         for client_order_id in order.linked_order_ids or []:
             contingent_order = self._cache.order(client_order_id)
             if contingent_order is None:
-                self._log.error(f"Contingency order {client_order_id!r} not found.")
+                self._log.error(f"Contingency order {client_order_id!r} not found")
                 continue
             if not contingent_order.is_quote_quantity:
                 continue  # Already base quantity
             if contingent_order.quantity != original_qty:
                 self._log.warning(
                     f"Contingent order quantity {contingent_order.quantity} "
                     f"was not equal to the OTO parent original quantity {original_qty} "
-                    f"when setting to base quantity of {base_qty}."
+                    f"when setting to base quantity of {base_qty}"
                 )
             self._log.info(
                 f"Setting {contingent_order.instrument_id} order quote quantity "
-                f"{contingent_order.quantity} to base quantity {base_qty}.",
+                f"{contingent_order.quantity} to base quantity {base_qty}",
             )
             contingent_order.quantity = base_qty
             contingent_order.leaves_qty = base_qty
             contingent_order.is_quote_quantity = False
 
     cpdef void _deny_order(self, Order order, str reason):
         # Generate event
@@ -715,28 +715,28 @@
         if self._msgbus.has_backing and self._msgbus.snapshot_orders:
             self._publish_order_snapshot(order)
 
 # -- COMMAND HANDLERS -----------------------------------------------------------------------------
 
     cpdef void _execute_command(self, TradingCommand command):
         if self.debug:
-            self._log.debug(f"{RECV}{CMD} {command}.", LogColor.MAGENTA)
+            self._log.debug(f"{RECV}{CMD} {command}", LogColor.MAGENTA)
         self.command_count += 1
 
         cdef ExecutionClient client = self._clients.get(command.client_id)
         if client is None:
             client = self._routing_map.get(
                 command.instrument_id.venue,
                 self._default_client,
             )
             if client is None:
                 self._log.error(
                     f"Cannot execute command: "
                     f"no execution client configured for {command.instrument_id.venue} or `client_id` {command.client_id}, "
-                    f"{command}."
+                    f"{command}"
                 )
                 return  # No client to handle command
 
         if isinstance(command, SubmitOrder):
             self._handle_submit_order(client, command)
         elif isinstance(command, SubmitOrderList):
             self._handle_submit_order_list(client, command)
@@ -748,30 +748,30 @@
             self._handle_cancel_all_orders(client, command)
         elif isinstance(command, BatchCancelOrders):
             self._handle_batch_cancel_orders(client, command)
         elif isinstance(command, QueryOrder):
             self._handle_query_order(client, command)
         else:
             self._log.error(  # pragma: no cover (design-time error)
-                f"Cannot handle command: unrecognized {command}.",  # pragma: no cover (design-time error)
+                f"Cannot handle command: unrecognized {command}",  # pragma: no cover (design-time error)
             )
 
     cpdef void _handle_submit_order(self, ExecutionClient client, SubmitOrder command):
         cdef Order order = command.order
         if not self._cache.order_exists(order.client_order_id):
             # Cache order
             self._cache.add_order(order, command.position_id, command.client_id)
             if self._msgbus.has_backing and self._msgbus.snapshot_orders:
                 self._publish_order_snapshot(order)
 
         cdef Instrument instrument = self._cache.instrument(order.instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot handle submit order: "
-                f"no instrument found for {order.instrument_id}, {command}."
+                f"no instrument found for {order.instrument_id}, {command}"
             )
             return
 
         # Check if converting quote quantity
         cdef Price last_px = None
         cdef Quantity base_qty = None
         if not instrument.is_inverse and order.is_quote_quantity:
@@ -794,15 +794,15 @@
                 if self._msgbus.has_backing and self._msgbus.snapshot_orders:
                     self._publish_order_snapshot(order)
 
         cdef Instrument instrument = self._cache.instrument(command.instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot handle submit order list: "
-                f"no instrument found for {command.instrument_id}, {command}."
+                f"no instrument found for {command.instrument_id}, {command}"
             )
             return
 
         # Check if converting quote quantity
         cdef Price last_px = None
         cdef Quantity quote_qty = None
         cdef Quantity base_qty = None
@@ -838,58 +838,58 @@
     cpdef void _handle_query_order(self, ExecutionClient client, QueryOrder command):
         client.query_order(command)
 
 # -- EVENT HANDLERS -------------------------------------------------------------------------------
 
     cpdef void _handle_event(self, OrderEvent event):
         if self.debug:
-            self._log.debug(f"{RECV}{EVT} {event}.", LogColor.MAGENTA)
+            self._log.debug(f"{RECV}{EVT} {event}", LogColor.MAGENTA)
         self.event_count += 1
 
         # Fetch Order from cache
         cdef ClientOrderId client_order_id = event.client_order_id
         cdef Order order = self._cache.order(event.client_order_id)
         if order is None:
             self._log.warning(
                 f"Order with {event.client_order_id!r} "
-                f"not found in the cache to apply {event}."
+                f"not found in the cache to apply {event}"
             )
 
             if event.venue_order_id is None:
                 self._log.error(
                     f"Cannot apply event to any order: "
                     f"{event.client_order_id!r} not found in the cache "
-                    f"with no `VenueOrderId`."
+                    f"with no `VenueOrderId`"
                 )
                 return  # Cannot process event further
 
             # Search cache for ClientOrderId matching the VenueOrderId
             client_order_id = self._cache.client_order_id(event.venue_order_id)
             if client_order_id is None:
                 self._log.error(
                     f"Cannot apply event to any order: "
                     f"{event.client_order_id!r} and {event.venue_order_id!r} "
-                    f"not found in the cache."
+                    f"not found in the cache"
                 )
                 return  # Cannot process event further
 
             # Search cache for Order matching the found ClientOrderId
             order = self._cache.order(client_order_id)
             if order is None:
                 self._log.error(
                     f"Cannot apply event to any order: "
                     f"{event.client_order_id!r} and {event.venue_order_id!r} "
-                    f"not found in the cache."
+                    f"not found in the cache"
                 )
                 return  # Cannot process event further
 
             # Set the correct ClientOrderId for the event
             event.set_client_order_id(client_order_id)
             self._log.info(
-                f"Order with {client_order_id!r} was found in the cache.",
+                f"Order with {client_order_id!r} was found in the cache",
                 color=LogColor.GREEN,
             )
 
         cdef OmsType oms_type
         if isinstance(event, OrderFilled):
             oms_type = self._determine_oms_type(event)
             self._determine_position_id(event, oms_type)
@@ -914,43 +914,43 @@
 
     cpdef void _determine_position_id(self, OrderFilled fill, OmsType oms_type):
         # Fetch ID from cache
         cdef PositionId position_id = self._cache.position_id(fill.client_order_id)
         if self.debug:
             self._log.debug(
                 f"Determining position ID for {fill.client_order_id!r}, "
-                f"position_id={position_id!r}.",
+                f"position_id={position_id!r}",
                 LogColor.MAGENTA,
             )
         if position_id is not None:
             if fill.position_id is not None and fill.position_id != position_id:
                 self._log.error(
                     "Incorrect position ID assigned to fill: "
                     f"cached={position_id!r}, assigned={fill.position_id!r}. "
-                    "re-assigning from cache.",
+                    "re-assigning from cache",
                 )
             # Assign position ID to fill
             fill.position_id = position_id
             if self.debug:
-                self._log.debug(f"Assigned {position_id!r} to {fill}.", LogColor.MAGENTA)
+                self._log.debug(f"Assigned {position_id!r} to {fill}", LogColor.MAGENTA)
             return
 
         if oms_type == OmsType.HEDGING:
             position_id = self._determine_hedging_position_id(fill)
         elif oms_type == OmsType.NETTING:
             # Assign netted position ID
             position_id = self._determine_netting_position_id(fill)
         else:
             raise ValueError(  # pragma: no cover (design-time error)
                 f"invalid `OmsType`, was {oms_type}",  # pragma: no cover (design-time error)
             )
 
         fill.position_id = position_id
 
-        # TODO(cs): Optimize away the need to fetch order from cache
+        # TODO: Optimize away the need to fetch order from cache
         cdef Order order = self._cache.order(fill.client_order_id)
         if order is None:
             raise RuntimeError(
                 f"Order for {fill.client_order_id!r} not found to determine position ID.",
             )
 
         # Check execution algorithm position ID
@@ -963,45 +963,45 @@
             primary.position_id = position_id
             self._cache.add_position_id(
                 position_id,
                 primary.instrument_id.venue,
                 primary.client_order_id,
                 primary.strategy_id,
             )
-            self._log.debug(f"Assigned primary order {position_id!r}.", LogColor.MAGENTA)
+            self._log.debug(f"Assigned primary order {position_id!r}", LogColor.MAGENTA)
 
     cpdef PositionId _determine_hedging_position_id(self, OrderFilled fill):
         if fill.position_id is not None:
             if self.debug:
                 self._log.debug(f"Already had a position ID of: {fill.position_id!r}", LogColor.MAGENTA)
             # Already assigned
             return fill.position_id
 
         cdef Order order = self._cache.order(fill.client_order_id)
         if order is None:
             raise RuntimeError(
-                f"Order for {fill.client_order_id!r} not found to determine position ID.",
+                f"Order for {fill.client_order_id!r} not found to determine position ID",
             )
 
         cdef:
             list exec_spawn_orders
             Order spawned_order
         if order.exec_spawn_id is not None:
             exec_spawn_orders = self._cache.orders_for_exec_spawn(order.exec_spawn_id)
             for spawned_order in exec_spawn_orders:
                 if spawned_order.position_id is not None:
                     if self.debug:
-                        self._log.debug(f"Found spawned {spawned_order.position_id!r} for {fill}.", LogColor.MAGENTA)
+                        self._log.debug(f"Found spawned {spawned_order.position_id!r} for {fill}", LogColor.MAGENTA)
                     # Use position ID for execution spawn
                     return spawned_order.position_id
 
         # Assign new position ID
         position_id = self._pos_id_generator.generate(fill.strategy_id)
         if self.debug:
-            self._log.debug(f"Generated {position_id!r} for {fill}.", LogColor.MAGENTA)
+            self._log.debug(f"Generated {position_id!r} for {fill}", LogColor.MAGENTA)
         return position_id
 
     cpdef PositionId _determine_netting_position_id(self, OrderFilled fill):
         return PositionId(f"{fill.instrument_id}-{fill.strategy_id}")
 
     cpdef void _apply_event_to_order(self, Order order, OrderEvent event):
         try:
@@ -1024,23 +1024,23 @@
             self._publish_order_snapshot(order)
 
     cpdef void _handle_order_fill(self, Order order, OrderFilled fill, OmsType oms_type):
         cdef Instrument instrument = self._cache.load_instrument(fill.instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot handle order fill: "
-                f"no instrument found for {fill.instrument_id}, {fill}."
+                f"no instrument found for {fill.instrument_id}, {fill}"
             )
             return
 
         cdef Account account = self._cache.account(fill.account_id)
         if account is None:
             self._log.error(
                 f"Cannot handle order fill: "
-                f"no account found for {fill.instrument_id.venue}, {fill}."
+                f"no account found for {fill.instrument_id.venue}, {fill}"
             )
             return
 
         if not self.allow_cash_positions and isinstance(instrument, CurrencyPair):
             if account.is_unleveraged(instrument.id):
                 return  # No spot cash positions
 
@@ -1180,15 +1180,15 @@
             # Close original position
             self._update_position(instrument, position, fill_split1, oms_type)
 
         # Guard against flipping a position with a zero fill size
         if difference._mem.raw == 0:
             self._log.warning(
                 "Zero fill size during position flip calculation, this could be caused by"
-                "a mismatch between instrument `size_precision` and a quantity `size_precision`."
+                "a mismatch between instrument `size_precision` and a quantity `size_precision`"
             )
             return
 
         cdef PositionId position_id_flip = fill.position_id
         if oms_type == OmsType.HEDGING and fill.position_id.is_virtual_c():
             # Generate new position ID for flipped virtual position
             position_id_flip = self._pos_id_generator.generate(
@@ -1215,16 +1215,16 @@
             liquidity_side=fill.liquidity_side,
             event_id=UUID4(),  # New event ID
             ts_event=fill.ts_event,
             ts_init=fill.ts_init,
         )
 
         if oms_type == OmsType.HEDGING and fill.position_id.is_virtual_c():
-            self._log.warning(f"Closing position {fill_split1}.")
-            self._log.warning(f"Flipping position {fill_split2}.")
+            self._log.warning(f"Closing position {fill_split1}")
+            self._log.warning(f"Flipping position {fill_split2}")
 
         # Open flipped position
         self._open_position(instrument, None, fill_split2, oms_type)
 
     cpdef void _publish_order_snapshot(self, Order order):
         if self._msgbus.serializer is not None:
             self._msgbus.publish_c(
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/manager.pxd` & `nautilus_trader-1.191.0/nautilus_trader/execution/manager.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/manager.pyx` & `nautilus_trader-1.191.0/nautilus_trader/execution/manager.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -21,17 +21,17 @@
 from nautilus_trader.common.component cimport EVT
 from nautilus_trader.common.component cimport RECV
 from nautilus_trader.common.component cimport SENT
 from nautilus_trader.common.component cimport Clock
 from nautilus_trader.common.component cimport LogColor
 from nautilus_trader.common.component cimport Logger
 from nautilus_trader.common.component cimport MessageBus
+from nautilus_trader.common.component cimport is_logging_initialized
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.message cimport Event
-from nautilus_trader.core.rust.common cimport logging_is_initialized
 from nautilus_trader.core.rust.model cimport ContingencyType
 from nautilus_trader.core.rust.model cimport OrderStatus
 from nautilus_trader.core.rust.model cimport TriggerType
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.execution.messages cimport CancelAllOrders
 from nautilus_trader.execution.messages cimport CancelOrder
 from nautilus_trader.execution.messages cimport ModifyOrder
@@ -182,19 +182,19 @@
         """
         Condition.not_none(order, "order")
 
         if self._cache.is_order_pending_cancel_local(order.client_order_id):
             return  # Already pending cancel locally
 
         if order.is_closed_c():
-            self._log.warning("Cannot cancel order: already closed.")
+            self._log.warning("Cannot cancel order: already closed")
             return
 
         if self.debug:
-            self._log.info(f"Cancelling order {order}.", LogColor.MAGENTA)
+            self._log.info(f"Cancelling order {order}", LogColor.MAGENTA)
 
         self._submit_order_commands.pop(order.client_order_id, None)
 
         if self._cancel_order_handler is not None:
             self._cancel_order_handler(order)
 
     cpdef void modify_order_quantity(self, Order order, Quantity new_quantity):
@@ -232,15 +232,15 @@
             The client ID for the command.
 
         """
         Condition.not_none(order, "order")
 
         if self.debug:
             self._log.info(
-                f"Creating new `SubmitOrder` command for {order}, {position_id=}, {client_id=}.",
+                f"Creating new `SubmitOrder` command for {order}, {position_id=}, {client_id=}",
                 LogColor.MAGENTA,
             )
 
         cdef SubmitOrder submit = SubmitOrder(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
             order=order,
@@ -313,74 +313,74 @@
     cpdef void handle_order_rejected(self, OrderRejected rejected):
         Condition.not_none(rejected, "rejected")
 
         cdef Order order = self._cache.order(rejected.client_order_id)
         if order is None:
             self._log.error(  # pragma: no cover (design-time error)
                 "Cannot handle `OrderRejected`: "
-                f"order for {repr(rejected.client_order_id)} not found. {rejected}.",
+                f"order for {repr(rejected.client_order_id)} not found, {rejected}",
                 )
             return
 
         if order.contingency_type != ContingencyType.NO_CONTINGENCY:
             self.handle_contingencies(order)
 
     cpdef void handle_order_canceled(self, OrderCanceled canceled):
         Condition.not_none(canceled, "canceled")
 
         cdef Order order = self._cache.order(canceled.client_order_id)
         if order is None:
             self._log.error(  # pragma: no cover (design-time error)
                 "Cannot handle `OrderCanceled`: "
-                f"order for {repr(canceled.client_order_id)} not found. {canceled}.",
+                f"order for {repr(canceled.client_order_id)} not found, {canceled}",
                 )
             return
 
         if order.contingency_type != ContingencyType.NO_CONTINGENCY:
             self.handle_contingencies(order)
 
     cpdef void handle_order_expired(self, OrderExpired expired):
         Condition.not_none(expired, "expired")
 
         cdef Order order = self._cache.order(expired.client_order_id)
         if order is None:
             self._log.error(  # pragma: no cover (design-time error)
                 "Cannot handle `OrderExpired`: "
-                f"order for {repr(expired.client_order_id)} not found. {expired}.",
+                f"order for {repr(expired.client_order_id)} not found, {expired}",
                 )
             return
 
         if order.contingency_type != ContingencyType.NO_CONTINGENCY:
             self.handle_contingencies(order)
 
     cpdef void handle_order_updated(self, OrderUpdated updated):
         Condition.not_none(updated, "updated")
 
         cdef Order order = self._cache.order(updated.client_order_id)
         if order is None:
             self._log.error(  # pragma: no cover (design-time error)
                 "Cannot handle `OrderUpdated`: "
-                f"order for {repr(updated.client_order_id)} not found. {updated}.",
+                f"order for {repr(updated.client_order_id)} not found, {updated}",
                 )
             return
 
         if order.contingency_type != ContingencyType.NO_CONTINGENCY:
             self.handle_contingencies_update(order)
 
     cpdef void handle_order_filled(self, OrderFilled filled):
         Condition.not_none(filled, "filled")
 
         if self.debug:
-            self._log.info(f"Handling fill for {filled.client_order_id}.", LogColor.MAGENTA)
+            self._log.info(f"Handling fill for {filled.client_order_id}", LogColor.MAGENTA)
 
         cdef Order order = self._cache.order(filled.client_order_id)
         if order is None:  # pragma: no cover (design-time error)
             self._log.error(
                 "Cannot handle `OrderFilled`: "
-                f"order for {repr(filled.client_order_id)} not found. {filled}.",
+                f"order for {repr(filled.client_order_id)} not found, {filled}",
             )
             return
 
         cdef:
             PositionId position_id
             ClientId client_id
             ClientOrderId client_order_id
@@ -405,16 +405,16 @@
                 if child_order is None:
                     raise RuntimeError(f"Cannot find OTO child order for {repr(client_order_id)}")  # pragma: no cover
 
                 if not self.should_manage_order(child_order):
                     continue  # Not being managed
 
                 if self.debug:
-                    self._log.info(f"Processing OTO child order {child_order}.", LogColor.MAGENTA)
-                    self._log.info(f"{parent_filled_qty=}.", LogColor.MAGENTA)
+                    self._log.info(f"Processing OTO child order {child_order}", LogColor.MAGENTA)
+                    self._log.info(f"{parent_filled_qty=}", LogColor.MAGENTA)
 
                 if child_order.position_id is None:
                     child_order.position_id = position_id
 
                 if parent_filled_qty._mem.raw != child_order.leaves_qty._mem.raw:
                     self.modify_order_quantity(child_order, parent_filled_qty)
 
@@ -431,15 +431,15 @@
             # Cancel all OCO orders
             for client_order_id in order.linked_order_ids:
                 contingent_order = self._cache.order(client_order_id)
                 if contingent_order is None:
                     raise RuntimeError(f"Cannot find OCO contingent order for {repr(client_order_id)}")  # pragma: no cover
 
                 if self.debug:
-                    self._log.info(f"Processing OCO contingent order {contingent_order}.", LogColor.MAGENTA)
+                    self._log.info(f"Processing OCO contingent order {contingent_order}", LogColor.MAGENTA)
 
                 if not self.should_manage_order(contingent_order):
                     continue  # Not being managed
                 if contingent_order.is_closed_c():
                     continue  # Already completed
                 if contingent_order.client_order_id != order.client_order_id:
                     self.cancel_order(contingent_order)
@@ -448,15 +448,15 @@
 
     cpdef void handle_contingencies(self, Order order):
         Condition.not_none(order, "order")
         Condition.not_empty(order.linked_order_ids, "order.linked_order_ids")
 
         if self.debug:
             self._log.info(
-                f"Handling contingencies for {order.client_order_id}.", LogColor.MAGENTA,
+                f"Handling contingencies for {order.client_order_id}", LogColor.MAGENTA,
             )
 
         cdef:
             Quantity filled_qty
             Quantity leaves_qty
             bint is_spawn_active = False
         if order.exec_spawn_id is not None:
@@ -480,28 +480,28 @@
                 continue  # Already being handled
             if contingent_order.is_closed_c():
                 self._submit_order_commands.pop(order.client_order_id, None)
                 continue  # Already completed
 
             if order.contingency_type == ContingencyType.OTO:
                 if self.debug:
-                    self._log.info(f"Processing OTO child order {contingent_order}.", LogColor.MAGENTA)
-                    self._log.info(f"{filled_qty=}, {contingent_order.quantity=}.", LogColor.YELLOW)
+                    self._log.info(f"Processing OTO child order {contingent_order}", LogColor.MAGENTA)
+                    self._log.info(f"{filled_qty=}, {contingent_order.quantity=}", LogColor.YELLOW)
                 if order.is_closed_c() and filled_qty._mem.raw == 0 and (order.exec_spawn_id is None or not is_spawn_active):
                     self.cancel_order(contingent_order)
                 elif filled_qty._mem.raw > 0 and filled_qty._mem.raw != contingent_order.quantity._mem.raw:
                     self.modify_order_quantity(contingent_order, filled_qty)
             elif order.contingency_type == ContingencyType.OCO:
                 if self.debug:
-                    self._log.info(f"Processing OCO contingent order {client_order_id}.", LogColor.MAGENTA)
+                    self._log.info(f"Processing OCO contingent order {client_order_id}", LogColor.MAGENTA)
                 if order.is_closed_c() and (order.exec_spawn_id is None or not is_spawn_active):
                     self.cancel_order(contingent_order)
             elif order.contingency_type == ContingencyType.OUO:
                 if self.debug:
-                    self._log.info(f"Processing OUO contingent order {client_order_id}, {leaves_qty=}, {contingent_order.leaves_qty=}.", LogColor.MAGENTA)
+                    self._log.info(f"Processing OUO contingent order {client_order_id}, {leaves_qty=}, {contingent_order.leaves_qty=}", LogColor.MAGENTA)
                 if leaves_qty._mem.raw == 0 and order.exec_spawn_id is not None:
                     self.cancel_order(contingent_order)
                 elif order.is_closed_c() and (order.exec_spawn_id is None or not is_spawn_active):
                     self.cancel_order(contingent_order)
                 elif leaves_qty._mem.raw != contingent_order.leaves_qty._mem.raw:
                     self.modify_order_quantity(contingent_order, leaves_qty)
 
@@ -550,46 +550,46 @@
         # TBC
 
 # -- EGRESS ---------------------------------------------------------------------------------------
 
     cpdef void send_emulator_command(self, TradingCommand command):
         Condition.not_none(command, "command")
 
-        if logging_is_initialized():
-            self._log.info(f"{CMD}{SENT} {command}.")  # pragma: no cover  (no logging in tests)
+        if is_logging_initialized():
+            self._log.info(f"{CMD}{SENT} {command}")  # pragma: no cover  (no logging in tests)
         self._msgbus.send(endpoint="OrderEmulator.execute", msg=command)
 
     cpdef void send_algo_command(self, TradingCommand command, ExecAlgorithmId exec_algorithm_id):
         Condition.not_none(command, "command")
         Condition.not_none(exec_algorithm_id, "exec_algorithm_id")
 
-        if logging_is_initialized():
-            self._log.info(f"{CMD}{SENT} {command}.")  # pragma: no cover  (no logging in tests)
+        if is_logging_initialized():
+            self._log.info(f"{CMD}{SENT} {command}")  # pragma: no cover  (no logging in tests)
         self._msgbus.send(endpoint=f"{exec_algorithm_id}.execute", msg=command)
 
     cpdef void send_risk_command(self, TradingCommand command):
         Condition.not_none(command, "command")
 
-        if logging_is_initialized():
-            self._log.info(f"{CMD}{SENT} {command}.")  # pragma: no cover  (no logging in tests)
+        if is_logging_initialized():
+            self._log.info(f"{CMD}{SENT} {command}")  # pragma: no cover  (no logging in tests)
         self._msgbus.send(endpoint="RiskEngine.execute", msg=command)
 
     cpdef void send_exec_command(self, TradingCommand command):
         Condition.not_none(command, "command")
 
-        if logging_is_initialized():
-            self._log.info(f"{CMD}{SENT} {command}.")  # pragma: no cover  (no logging in tests)
+        if is_logging_initialized():
+            self._log.info(f"{CMD}{SENT} {command}")  # pragma: no cover  (no logging in tests)
         self._msgbus.send(endpoint="ExecEngine.execute", msg=command)
 
     cpdef void send_risk_event(self, OrderEvent event):
         Condition.not_none(event, "event")
 
-        if logging_is_initialized():
-            self._log.info(f"{EVT}{SENT} {event}.")  # pragma: no cover  (no logging in tests)
+        if is_logging_initialized():
+            self._log.info(f"{EVT}{SENT} {event}")  # pragma: no cover  (no logging in tests)
         self._msgbus.send(endpoint="RiskEngine.process", msg=event)
 
     cpdef void send_exec_event(self, OrderEvent event):
         Condition.not_none(event, "event")
 
-        if logging_is_initialized():
-            self._log.info(f"{EVT}{SENT} {event}.")  # pragma: no cover (no logging in tests)
+        if is_logging_initialized():
+            self._log.info(f"{EVT}{SENT} {event}")  # pragma: no cover (no logging in tests)
         self._msgbus.send(endpoint="ExecEngine.process", msg=event)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/matching_core.pxd` & `nautilus_trader-1.191.0/nautilus_trader/execution/matching_core.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/matching_core.pyx` & `nautilus_trader-1.191.0/nautilus_trader/execution/matching_core.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/messages.pxd` & `nautilus_trader-1.191.0/nautilus_trader/execution/messages.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/messages.pyx` & `nautilus_trader-1.191.0/nautilus_trader/execution/messages.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/reports.py` & `nautilus_trader-1.191.0/nautilus_trader/execution/reports.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/trailing.pxd` & `nautilus_trader-1.191.0/nautilus_trader/execution/trailing.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/execution/trailing.pyx` & `nautilus_trader-1.191.0/nautilus_trader/execution/trailing.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/execution/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/indicators/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/amat.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/amat.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/amat.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/amat.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/aroon.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/aroon.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/aroon.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/aroon.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/atr.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/atr.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/atr.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/atr.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/ama.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/ama.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/ama.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/ama.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/dema.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/dema.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/dema.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/dema.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/ema.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/ema.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/ema.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/ema.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/hma.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/hma.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/hma.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/hma.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/ma_factory.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/ma_factory.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/moving_average.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/moving_average.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/moving_average.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/moving_average.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/rma.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/vidya.pxd`

 * *Files 10% similar despite different names*

```diff
@@ -10,12 +10,17 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.indicators.average.ema cimport MovingAverage
+from nautilus_trader.indicators.cmo cimport ChandeMomentumOscillator
 
 
-cdef class WilderMovingAverage(MovingAverage):
+cdef class VariableIndexDynamicAverage(MovingAverage):
+    cdef ChandeMomentumOscillator cmo
+
     cdef readonly double alpha
     """The moving average alpha value.\n\n:returns: `double`"""
+    cdef readonly double cmo_pct
+    """The normal cmo value.\n\n:returns: `double`"""
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/rma.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/rma.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/sma.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/sma.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/sma.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/sma.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/vidya.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/vhf.pxd`

 * *Files 13% similar despite different names*

```diff
@@ -9,18 +9,24 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.average.ema cimport MovingAverage
-from nautilus_trader.indicators.cmo cimport ChandeMomentumOscillator
+from nautilus_trader.indicators.average.moving_average cimport MovingAverage
+from nautilus_trader.indicators.base.indicator cimport Indicator
 
 
-cdef class VariableIndexDynamicAverage(MovingAverage):
-    cdef ChandeMomentumOscillator cmo
+cdef class VerticalHorizontalFilter(Indicator):
+    cdef MovingAverage _ma
+    cdef object _prices
 
-    cdef readonly double alpha
-    """The moving average alpha value.\n\n:returns: `double`"""
-    cdef readonly double cmo_pct
-    """The normal cmo value.\n\n:returns: `double`"""
+    cdef readonly int period
+    """The window period.\n\n:returns: `int`"""
+    cdef readonly double _previous_close
+    """The previous close price.\n\n:returns: `double`"""
+    cdef readonly double value
+    """The current value.\n\n:returns: `double`"""
+
+    cpdef void update_raw(self, double close)
+    cdef void _check_initialized(self)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/vidya.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/vidya.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/wma.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/wma.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/average/wma.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/wma.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/base/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/average/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/base/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/indicators/base/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/base/indicator.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/base/indicator.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/base/indicator.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/base/indicator.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/bias.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/bias.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/bias.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/bias.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/bollinger_bands.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/bollinger_bands.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/bollinger_bands.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/bollinger_bands.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/cci.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/cci.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/cci.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/cci.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/cmo.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/cmo.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/cmo.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/cmo.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/dm.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/dm.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/dm.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/dm.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/donchian_channel.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/efficiency_ratio.pxd`

 * *Files 14% similar despite different names*

```diff
@@ -12,21 +12,17 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.indicators.base.indicator cimport Indicator
 
 
-cdef class DonchianChannel(Indicator):
-    cdef object _upper_prices
-    cdef object _lower_prices
+cdef class EfficiencyRatio(Indicator):
+    cdef object _inputs
+    cdef object _deltas
 
     cdef readonly int period
-    """The period for the moving average.\n\n:returns: `int`"""
-    cdef readonly double upper
-    """The current value of the upper band.\n\n:returns: `double`"""
-    cdef readonly double middle
-    """The current value of the middle band.\n\n:returns: `double`"""
-    cdef readonly double lower
-    """The current value of the lower band.\n\n:returns: `double`"""
+    """The window period.\n\n:returns: `int`"""
+    cdef readonly double value
+    """The current value.\n\n:returns: `double`"""
 
-    cpdef void update_raw(self, double high, double low)
+    cpdef void update_raw(self, double price)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/donchian_channel.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/donchian_channel.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/efficiency_ratio.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/roc.pxd`

 * *Files 11% similar despite different names*

```diff
@@ -12,17 +12,17 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.indicators.base.indicator cimport Indicator
 
 
-cdef class EfficiencyRatio(Indicator):
-    cdef object _inputs
-    cdef object _deltas
+cdef class RateOfChange(Indicator):
+    cdef bint _use_log
+    cdef object _prices
 
     cdef readonly int period
     """The window period.\n\n:returns: `int`"""
     cdef readonly double value
     """The current value.\n\n:returns: `double`"""
 
     cpdef void update_raw(self, double price)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/efficiency_ratio.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/efficiency_ratio.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_candlesticks.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_candlesticks.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_candlesticks.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_candlesticks.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enum.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enum.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/base/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pxd`

 * *Files 9% similar despite different names*

```diff
@@ -9,11 +9,13 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.fuzzy_enums.candle_body cimport CandleBodySize
 
-
-__all__ = ["CandleBodySize"]
+cpdef enum CandleWickSize:
+    NONE = 0  # No candle wick
+    SMALL = 1
+    MEDIUM = 2
+    LARGE = 3
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -8,14 +8,7 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-
-cpdef enum CandleWickSize:
-    NONE = 0  # No candle wick
-    SMALL = 1
-    MEDIUM = 2
-    LARGE = 3
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/keltner_channel.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/keltner_channel.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/keltner_channel.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/keltner_channel.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/keltner_position.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/keltner_position.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/keltner_position.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/pressure.pyx`

 * *Files 20% similar despite different names*

```diff
@@ -9,80 +9,66 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from nautilus_trader.indicators.average.ma_factory import MovingAverageFactory
 from nautilus_trader.indicators.average.moving_average import MovingAverageType
 
 from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.indicators.atr cimport AverageTrueRange
 from nautilus_trader.indicators.base.indicator cimport Indicator
-from nautilus_trader.indicators.keltner_channel cimport KeltnerChannel
 from nautilus_trader.model.data cimport Bar
 
 
-cdef class KeltnerPosition(Indicator):
+cdef class Pressure(Indicator):
     """
-    An indicator which calculates the relative position of the given price
-    within a defined Keltner channel. This provides a measure of the relative
-    'extension' of a market from the mean, as a multiple of volatility.
+    An indicator which calculates the relative volume (multiple of average volume)
+    to move the market across a relative range (multiple of ATR).
 
     Parameters
     ----------
     period : int
-        The rolling window period for the indicator (> 0).
-    k_multiplier : double
-        The multiplier for the ATR (> 0).
+        The period for the indicator (> 0).
     ma_type : MovingAverageType
-        The moving average type for the middle band (cannot be None).
-    ma_type_atr : MovingAverageType
-        The moving average type for the internal ATR (cannot be None).
-    use_previous : bool
-        The boolean flag indicating whether previous price values should be used.
+        The moving average type for the calculations.
     atr_floor : double
-        The ATR floor (minimum) output value for the indicator (>= 0).
+        The ATR floor (minimum) output value for the indicator (>= 0.).
+
+    Raises
+    ------
+    ValueError
+        If `period` is not positive (> 0).
+    ValueError
+        If `atr_floor` is negative (< 0).
     """
 
     def __init__(
         self,
         int period,
-        double k_multiplier,
         ma_type not None: MovingAverageType=MovingAverageType.EXPONENTIAL,
-        ma_type_atr not None: MovingAverageType=MovingAverageType.SIMPLE,
-        bint use_previous=True,
         double atr_floor=0,
     ):
         Condition.positive_int(period, "period")
-        Condition.positive(k_multiplier, "k_multiplier")
         Condition.not_negative(atr_floor, "atr_floor")
 
-        params = [
+        params=[
             period,
-            k_multiplier,
             ma_type.name,
-            ma_type_atr.name,
-            use_previous,
             atr_floor,
         ]
         super().__init__(params=params)
 
         self.period = period
-        self.k_multiplier = k_multiplier
-
-        self._kc = KeltnerChannel(
-            period,
-            k_multiplier,
-            ma_type,
-            ma_type_atr,
-            use_previous,
-            atr_floor,
-        )
-
+        self._atr = AverageTrueRange(period, MovingAverageType.EXPONENTIAL, atr_floor)
+        self._average_volume = MovingAverageFactory.create(period, ma_type)
         self.value = 0
+        self.value_cumulative = 0
 
     cpdef void handle_bar(self, Bar bar):
         """
         Update the indicator with the given bar.
 
         Parameters
         ----------
@@ -92,46 +78,58 @@
         """
         Condition.not_none(bar, "bar")
 
         self.update_raw(
             bar.high.as_double(),
             bar.low.as_double(),
             bar.close.as_double(),
+            bar.volume.as_double(),
         )
 
     cpdef void update_raw(
         self,
         double high,
         double low,
         double close,
+        double volume,
     ):
         """
-        Update the indicator with the given raw value.
+        Update the indicator with the given raw values.
 
         Parameters
         ----------
         high : double
             The high price.
         low : double
             The low price.
         close : double
             The close price.
+        volume : double
+            The volume.
 
         """
-        self._kc.update_raw(high, low, close)
+        self._atr.update_raw(high, low, close)
+        self._average_volume.update_raw(volume)
 
-        # Initialization logic
+        # Initialization logic (do not move this to the bottom as guard against zero will return)
         if not self.initialized:
             self._set_has_inputs(True)
-            if self._kc.initialized:
+            if self._atr.initialized:
                 self._set_initialized(True)
 
-        cdef double k_width = (self._kc.upper - self._kc.lower) / 2
-
-        if k_width > 0:
-            self.value = (close - self._kc.middle) / k_width
-        else:
+        # Guard against zero values
+        if self._average_volume.value == 0 or self._atr.value == 0:
             self.value = 0
+            return
+
+        cdef double relative_volume = volume / self._average_volume.value
+        cdef double buy_pressure = ((close - low) / self._atr.value) * relative_volume
+        cdef double sell_pressure = ((high - close) / self._atr.value) * relative_volume
+
+        self.value = buy_pressure - sell_pressure
+        self.value_cumulative += self.value
 
     cpdef void _reset(self):
-        self._kc.reset()
+        self._atr.reset()
+        self._average_volume.reset()
         self.value = 0
+        self.value_cumulative = 0
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/kvo.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/kvo.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/kvo.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/kvo.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/linear_regression.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/linear_regression.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/linear_regression.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/linear_regression.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/macd.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/macd.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/macd.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/macd.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/obv.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/obv.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/obv.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/obv.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/pressure.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/pressure.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/pressure.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/volatility_ratio.pyx`

 * *Files 16% similar despite different names*

```diff
@@ -9,66 +9,79 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.average.ma_factory import MovingAverageFactory
 from nautilus_trader.indicators.average.moving_average import MovingAverageType
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.indicators.atr cimport AverageTrueRange
 from nautilus_trader.indicators.base.indicator cimport Indicator
 from nautilus_trader.model.data cimport Bar
 
 
-cdef class Pressure(Indicator):
+cdef class VolatilityRatio(Indicator):
     """
-    An indicator which calculates the relative volume (multiple of average volume)
-    to move the market across a relative range (multiple of ATR).
+    An indicator which calculates the ratio of different ranges of volatility.
+    Different moving average types can be selected for the inner ATR calculations.
 
     Parameters
     ----------
-    period : int
-        The period for the indicator (> 0).
+    fast_period : int
+        The period for the fast ATR (> 0).
+    slow_period : int
+        The period for the slow ATR (> 0 & > fast_period).
     ma_type : MovingAverageType
-        The moving average type for the calculations.
-    atr_floor : double
-        The ATR floor (minimum) output value for the indicator (>= 0.).
+        The moving average type for the ATR calculations.
+    use_previous : bool
+        The boolean flag indicating whether previous price values should be used.
+    value_floor : double
+        The floor (minimum) output value for the indicator (>= 0).
 
     Raises
     ------
     ValueError
-        If `period` is not positive (> 0).
+        If `fast_period` is not positive (> 0).
     ValueError
-        If `atr_floor` is negative (< 0).
+        If `slow_period` is not positive (> 0).
+    ValueError
+        If `fast_period` is not < `slow_period`.
+    ValueError
+        If `value_floor` is negative (< 0).
     """
 
     def __init__(
         self,
-        int period,
-        ma_type not None: MovingAverageType=MovingAverageType.EXPONENTIAL,
-        double atr_floor=0,
+        int fast_period,
+        int slow_period,
+        ma_type not None: MovingAverageType=MovingAverageType.SIMPLE,
+        bint use_previous=True,
+        double value_floor=0,
     ):
-        Condition.positive_int(period, "period")
-        Condition.not_negative(atr_floor, "atr_floor")
-
-        params=[
-            period,
+        Condition.positive_int(fast_period, "fast_period")
+        Condition.positive_int(slow_period, "slow_period")
+        Condition.true(fast_period < slow_period, "fast_period was >= slow_period")
+        Condition.not_negative(value_floor, "value_floor")
+
+        params = [
+            fast_period,
+            slow_period,
             ma_type.name,
-            atr_floor,
+            use_previous,
+            value_floor,
         ]
         super().__init__(params=params)
 
-        self.period = period
-        self._atr = AverageTrueRange(period, MovingAverageType.EXPONENTIAL, atr_floor)
-        self._average_volume = MovingAverageFactory.create(period, ma_type)
+        self.fast_period = fast_period
+        self.slow_period = slow_period
+        self._atr_fast = AverageTrueRange(fast_period, ma_type, use_previous, value_floor)
+        self._atr_slow = AverageTrueRange(slow_period, ma_type, use_previous, value_floor)
         self.value = 0
-        self.value_cumulative = 0
 
     cpdef void handle_bar(self, Bar bar):
         """
         Update the indicator with the given bar.
 
         Parameters
         ----------
@@ -78,58 +91,47 @@
         """
         Condition.not_none(bar, "bar")
 
         self.update_raw(
             bar.high.as_double(),
             bar.low.as_double(),
             bar.close.as_double(),
-            bar.volume.as_double(),
         )
 
     cpdef void update_raw(
         self,
         double high,
         double low,
         double close,
-        double volume,
     ):
         """
-        Update the indicator with the given raw values.
+        Update the indicator with the given raw value.
 
         Parameters
         ----------
         high : double
             The high price.
         low : double
             The low price.
         close : double
             The close price.
-        volume : double
-            The volume.
 
         """
-        self._atr.update_raw(high, low, close)
-        self._average_volume.update_raw(volume)
+        self._atr_fast.update_raw(high, low, close)
+        self._atr_slow.update_raw(high, low, close)
+
+        if self._atr_fast.value > 0:  # Guard against divide by zero
+            self.value = self._atr_slow.value / self._atr_fast.value
 
-        # Initialization logic (do not move this to the bottom as guard against zero will return)
+        self._check_initialized()
+
+    cdef void _check_initialized(self):
         if not self.initialized:
             self._set_has_inputs(True)
-            if self._atr.initialized:
-                self._set_initialized(True)
 
-        # Guard against zero values
-        if self._average_volume.value == 0 or self._atr.value == 0:
-            self.value = 0
-            return
-
-        cdef double relative_volume = volume / self._average_volume.value
-        cdef double buy_pressure = ((close - low) / self._atr.value) * relative_volume
-        cdef double sell_pressure = ((high - close) / self._atr.value) * relative_volume
-
-        self.value = buy_pressure - sell_pressure
-        self.value_cumulative += self.value
+            if self._atr_fast.initialized and self._atr_slow.initialized:
+                self._set_initialized(True)
 
     cpdef void _reset(self):
-        self._atr.reset()
-        self._average_volume.reset()
+        self._atr_fast.reset()
+        self._atr_slow.reset()
         self.value = 0
-        self.value_cumulative = 0
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/psl.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/rsi.pxd`

 * *Files 11% similar despite different names*

```diff
@@ -13,20 +13,19 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.indicators.average.moving_average cimport MovingAverage
 from nautilus_trader.indicators.base.indicator cimport Indicator
 
 
-cdef class PsychologicalLine(Indicator):
-    cdef MovingAverage _ma
+cdef class RelativeStrengthIndex(Indicator):
+    cdef double _rsi_max
+    cdef MovingAverage _average_gain
+    cdef MovingAverage _average_loss
+    cdef double _last_value
 
     cdef readonly int period
     """The window period.\n\n:returns: `int`"""
-    cdef readonly double _diff
-    """The current difference.\n\n:returns: `double`"""
-    cdef readonly double _previous_close
-    """The previous close price.\n\n:returns: `double`"""
     cdef readonly double value
-    """The current  value.\n\n:returns: `double`"""
+    """The current value.\n\n:returns: `double`"""
 
-    cpdef void update_raw(self, double close)
+    cpdef void update_raw(self, double value)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/psl.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/psl.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/roc.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/volatility_ratio.pxd`

 * *Files 11% similar despite different names*

```diff
@@ -9,20 +9,24 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from nautilus_trader.indicators.atr cimport AverageTrueRange
 from nautilus_trader.indicators.base.indicator cimport Indicator
 
 
-cdef class RateOfChange(Indicator):
-    cdef bint _use_log
-    cdef object _prices
+cdef class VolatilityRatio(Indicator):
+    cdef AverageTrueRange _atr_fast
+    cdef AverageTrueRange _atr_slow
 
-    cdef readonly int period
-    """The window period.\n\n:returns: `int`"""
+    cdef readonly int fast_period
+    """The period of the fast ATR.\n\n:returns: `int`"""
+    cdef readonly int slow_period
+    """The period of the slow ATR.\n\n:returns: `int`"""
     cdef readonly double value
     """The current value.\n\n:returns: `double`"""
 
-    cpdef void update_raw(self, double price)
+    cpdef void update_raw(self, double high, double low, double close)
+    cdef void _check_initialized(self)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/roc.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/roc.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/rsi.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/rvi.pxd`

 * *Files 13% similar despite different names*

```diff
@@ -11,21 +11,29 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.indicators.average.moving_average cimport MovingAverage
 from nautilus_trader.indicators.base.indicator cimport Indicator
+from nautilus_trader.model.data cimport Bar
 
 
-cdef class RelativeStrengthIndex(Indicator):
-    cdef double _rsi_max
-    cdef MovingAverage _average_gain
-    cdef MovingAverage _average_loss
-    cdef double _last_value
+cdef class RelativeVolatilityIndex(Indicator):
+    cdef MovingAverage _ma
+    cdef MovingAverage _pos_ma
+    cdef MovingAverage _neg_ma
+    cdef object _prices
 
     cdef readonly int period
     """The window period.\n\n:returns: `int`"""
+    cdef readonly double scalar
+    """The positive float to scale the bands.\n\n:returns: `double`"""
+    cdef readonly double _previous_close
+    """The previous price value.\n\n:returns: `double`"""
+    cdef readonly double _std
+    """The current price stddev value.\n\n:returns: `double`"""
     cdef readonly double value
-    """The current value.\n\n:returns: `double`"""
+    """The current  value.\n\n:returns: `double`"""
 
-    cpdef void update_raw(self, double value)
+    cpdef void handle_bar(self, Bar bar)
+    cpdef void update_raw(self, double close)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/rsi.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/rsi.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/rvi.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/spread_analyzer.pxd`

 * *Files 14% similar despite different names*

```diff
@@ -9,31 +9,22 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.average.moving_average cimport MovingAverage
 from nautilus_trader.indicators.base.indicator cimport Indicator
-from nautilus_trader.model.data cimport Bar
+from nautilus_trader.model.identifiers cimport InstrumentId
 
 
-cdef class RelativeVolatilityIndex(Indicator):
-    cdef MovingAverage _ma
-    cdef MovingAverage _pos_ma
-    cdef MovingAverage _neg_ma
-    cdef object _prices
+cdef class SpreadAnalyzer(Indicator):
+    cdef object _spreads
 
-    cdef readonly int period
-    """The window period.\n\n:returns: `int`"""
-    cdef readonly double scalar
-    """The positive float to scale the bands.\n\n:returns: `double`"""
-    cdef readonly double _previous_close
-    """The previous price value.\n\n:returns: `double`"""
-    cdef readonly double _std
-    """The current price stddev value.\n\n:returns: `double`"""
-    cdef readonly double value
-    """The current  value.\n\n:returns: `double`"""
-
-    cpdef void handle_bar(self, Bar bar)
-    cpdef void update_raw(self, double close)
+    cdef readonly InstrumentId instrument_id
+    """The indicators instrument ID.\n\n:returns: `InstrumentId`"""
+    cdef readonly int capacity
+    """The indicators spread capacity.\n\n:returns: `int`"""
+    cdef readonly double current
+    """The current spread.\n\n:returns: `double`"""
+    cdef readonly double average
+    """The current average spread.\n\n:returns: `double`"""
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/rvi.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/rvi.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/spread_analyzer.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/crypto_perpetual.pxd`

 * *Files 17% similar despite different names*

```diff
@@ -9,22 +9,27 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.base.indicator cimport Indicator
-from nautilus_trader.model.identifiers cimport InstrumentId
+from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.objects cimport Currency
 
 
-cdef class SpreadAnalyzer(Indicator):
-    cdef object _spreads
+cdef class CryptoPerpetual(Instrument):
+    cdef readonly Currency base_currency
+    """The base currency for the instrument.\n\n:returns: `Currency`"""
+    cdef readonly Currency settlement_currency
+    """The settlement currency for the instrument.\n\n:returns: `Currency`"""
+    cdef readonly bint is_quanto
+    """If the instrument is quanto.\n\n:returns: `bool`"""
 
-    cdef readonly InstrumentId instrument_id
-    """The indicators instrument ID.\n\n:returns: `InstrumentId`"""
-    cdef readonly int capacity
-    """The indicators spread capacity.\n\n:returns: `int`"""
-    cdef readonly double current
-    """The current spread.\n\n:returns: `double`"""
-    cdef readonly double average
-    """The current average spread.\n\n:returns: `double`"""
+    @staticmethod
+    cdef CryptoPerpetual from_dict_c(dict values)
+
+    @staticmethod
+    cdef dict to_dict_c(CryptoPerpetual obj)
+
+    @staticmethod
+    cdef CryptoPerpetual from_pyo3_c(pyo3_instrument)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/spread_analyzer.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/spread_analyzer.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/stochastics.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/stochastics.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/stochastics.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/stochastics.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/swings.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/swings.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/swings.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/swings.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/ta_lib/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/indicators/ta_lib/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/ta_lib/common.py` & `nautilus_trader-1.191.0/nautilus_trader/indicators/ta_lib/common.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/ta_lib/manager.py` & `nautilus_trader-1.191.0/nautilus_trader/indicators/ta_lib/manager.py`

 * *Files 0% similar despite different names*

```diff
@@ -388,24 +388,28 @@
 
         This method logs actions at the debug level to track the calculation and
         updating process.
 
         """
         self._log.debug("Calculating outputs.")
 
+        if self._input_deque is None:
+            return
+
         combined_output = np.zeros(1, dtype=self._output_dtypes)
         combined_output["ts_event"] = self._input_deque[-1]["ts_event"].item()
         combined_output["ts_init"] = self._input_deque[-1]["ts_init"].item()
         combined_output["open"] = self._input_deque[-1]["open"].item()
         combined_output["high"] = self._input_deque[-1]["high"].item()
         combined_output["low"] = self._input_deque[-1]["low"].item()
         combined_output["close"] = self._input_deque[-1]["close"].item()
         combined_output["volume"] = self._input_deque[-1]["volume"].item()
 
         input_array = np.concatenate(self._input_deque)
+        assert self._indicators  # Type checking
         for indicator in self._indicators:
             self._log.debug(f"Calculating {indicator.name} outputs.")
             inputs_dict = {name: input_array[name] for name in input_array.dtype.names}
             indicator.fn.set_input_arrays(inputs_dict)
             results = indicator.fn.run()
 
             if len(indicator.output_names) == 1:
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/vhf.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/options_contract.pxd`

 * *Files 18% similar despite different names*

```diff
@@ -9,24 +9,36 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.average.moving_average cimport MovingAverage
-from nautilus_trader.indicators.base.indicator cimport Indicator
+from libc.stdint cimport uint64_t
 
+from nautilus_trader.core.rust.model cimport OptionKind
+from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.objects cimport Price
 
-cdef class VerticalHorizontalFilter(Indicator):
-    cdef MovingAverage _ma
-    cdef object _prices
-
-    cdef readonly int period
-    """The window period.\n\n:returns: `int`"""
-    cdef readonly double _previous_close
-    """The previous close price.\n\n:returns: `double`"""
-    cdef readonly double value
-    """The current value.\n\n:returns: `double`"""
 
-    cpdef void update_raw(self, double close)
-    cdef void _check_initialized(self)
+cdef class OptionsContract(Instrument):
+    cdef readonly str exchange
+    """The exchange ISO 10383 Market Identifier Code (MIC) where the instrument trades.\n\n:returns: `str` or ``None``"""
+    cdef readonly str underlying
+    """The underlying asset for the contract.\n\n:returns: `str`"""
+    cdef readonly OptionKind option_kind
+    """The option kind (PUT | CALL) for the contract.\n\n:returns: `OptionKind`"""
+    cdef readonly uint64_t activation_ns
+    """The UNIX timestamp (nanoseconds) for contract activation.\n\n:returns: `unit64_t`"""
+    cdef readonly uint64_t expiration_ns
+    """The UNIX timestamp (nanoseconds) for contract expiration.\n\n:returns: `unit64_t`"""
+    cdef readonly Price strike_price
+    """The strike price for the contract.\n\n:returns: `Price`"""
+
+    @staticmethod
+    cdef OptionsContract from_dict_c(dict values)
+
+    @staticmethod
+    cdef dict to_dict_c(OptionsContract obj)
+
+    @staticmethod
+    cdef OptionsContract from_pyo3_c(pyo3_instrument)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/vhf.pyx` & `nautilus_trader-1.191.0/nautilus_trader/indicators/vhf.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/volatility_ratio.pxd` & `nautilus_trader-1.191.0/nautilus_trader/indicators/vwap.pxd`

 * *Files 17% similar despite different names*

```diff
@@ -9,24 +9,21 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.atr cimport AverageTrueRange
+from cpython.datetime cimport datetime
+
 from nautilus_trader.indicators.base.indicator cimport Indicator
 
 
-cdef class VolatilityRatio(Indicator):
-    cdef AverageTrueRange _atr_fast
-    cdef AverageTrueRange _atr_slow
-
-    cdef readonly int fast_period
-    """The period of the fast ATR.\n\n:returns: `int`"""
-    cdef readonly int slow_period
-    """The period of the slow ATR.\n\n:returns: `int`"""
+cdef class VolumeWeightedAveragePrice(Indicator):
+    cdef int _day
+    cdef double _price_volume
+    cdef double _volume_total
+
     cdef readonly double value
     """The current value.\n\n:returns: `double`"""
 
-    cpdef void update_raw(self, double high, double low, double close)
-    cdef void _check_initialized(self)
+    cpdef void update_raw(self, double price, double volume, datetime timestamp)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/indicators/vwap.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/implementations/tiered.pxd`

 * *Files 18% similar despite different names*

```diff
@@ -9,21 +9,26 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from cpython.datetime cimport datetime
+cimport numpy as np
 
-from nautilus_trader.indicators.base.indicator cimport Indicator
+from nautilus_trader.model.objects cimport Price
+from nautilus_trader.model.tick_scheme.base cimport TickScheme
 
 
-cdef class VolumeWeightedAveragePrice(Indicator):
-    cdef int _day
-    cdef double _price_volume
-    cdef double _volume_total
+cdef class TieredTickScheme(TickScheme):
+    cdef list tiers
+    cdef int max_ticks_per_tier
+    cdef int price_precision
+    cdef int tick_count
 
-    cdef readonly double value
-    """The current value.\n\n:returns: `double`"""
+    cdef readonly np.ndarray ticks
 
-    cpdef void update_raw(self, double price, double volume, datetime timestamp)
+    cpdef _build_ticks(self)
+
+    cpdef int find_tick_index(self, double value)
+    cpdef Price next_ask_price(self, double value, int n=*)
+    cpdef Price next_bid_price(self, double value, int n=*)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/live/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/serialization/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -9,14 +9,14 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 """
-The `live` subpackage groups all engine and client implementations for live trading.
+The `serialization` subpackage groups all serialization components and serializer
+implementations.
 
-Generally a common event loop is passed into each live engine to support the overarching
-design of a single efficient event loop, by default
-`uvloop <https://github.com/MagicStack/uvloop>`_.
+Base classes are defined which can allow for other serialization implementations beside
+the built-in specification serializers.
 
 """
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/live/__main__.py` & `nautilus_trader-1.191.0/nautilus_trader/live/__main__.py`

 * *Files 7% similar despite different names*

```diff
@@ -30,15 +30,15 @@
     fsspec_url: str | None = None,
     start: bool = True,
 ) -> None:
     assert raw is not None or fsspec_url is not None, "Must pass one of `raw` or `fsspec_url`"
     if fsspec_url and raw is None:
         with fsspec.open(fsspec_url, "rb") as f:
             raw = f.read().decode()
-    assert raw is not None  # type checking
+    assert raw is not None  # Type checking
     config: TradingNodeConfig = msgspec.json.decode(raw, type=TradingNodeConfig)
     node = TradingNode(config=config)
     node.build()
     if start:
         try:
             node.run()
         finally:
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/live/config.py` & `nautilus_trader-1.191.0/nautilus_trader/live/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/live/data_client.py` & `nautilus_trader-1.191.0/nautilus_trader/live/data_client.py`

 * *Files 20% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 """
 The `LiveDataClient` class is responsible for interfacing with a particular API which
-may be presented directly by an exchange, or broker intermediary.
+may be presented directly by a venue, or through a broker intermediary.
 
 It could also be possible to write clients for specialized data providers.
 
 """
 
 import asyncio
 import functools
@@ -116,55 +116,60 @@
         return await coro
 
     def create_task(
         self,
         coro: Coroutine,
         log_msg: str | None = None,
         actions: Callable | None = None,
-        success: str | None = None,
+        success_msg: str | None = None,
+        success_color: LogColor = LogColor.NORMAL,
     ) -> asyncio.Task:
         """
         Run the given coroutine with error handling and optional callback actions when
         done.
 
         Parameters
         ----------
         coro : Coroutine
             The coroutine to run.
         log_msg : str, optional
             The log message for the task.
         actions : Callable, optional
             The actions callback to run when the coroutine is done.
-        success : str, optional
-            The log message to write on actions success.
+        success_msg : str, optional
+            The log message to write on `actions` success.
+        success_color : LogColor, default ``NORMAL``
+            The log message color for `actions` success.
 
         Returns
         -------
         asyncio.Task
 
         """
         log_msg = log_msg or coro.__name__
-        self._log.debug(f"Creating task {log_msg}.")
+        self._log.debug(f"Creating task {log_msg}")
         task = self._loop.create_task(
             coro,
             name=coro.__name__,
         )
         task.add_done_callback(
             functools.partial(
                 self._on_task_completed,
                 actions,
-                success,
+                success_msg,
+                success_color,
             ),
         )
         return task
 
     def _on_task_completed(
         self,
         actions: Callable | None,
-        success: str | None,
+        success_msg: str | None,
+        success_color: LogColor,
         task: Task,
     ) -> None:
         e: BaseException | None = task.exception()
         if e:
             tb_str = "".join(traceback.format_exception(type(e), e, e.__traceback__))
             self._log.error(
                 f"Error on `{task.get_name()}`: " f"{task.exception()!r}\n{tb_str}",
@@ -175,59 +180,65 @@
                     actions()
                 except Exception as e:
                     tb_str = "".join(traceback.format_exception(type(e), e, e.__traceback__))
                     self._log.error(
                         f"Failed triggering action {actions.__name__} on `{task.get_name()}`: "
                         f"{e!r}\n{tb_str}",
                     )
-            if success:
-                self._log.info(success, LogColor.GREEN)
+            if success_msg:
+                self._log.info(success_msg, success_color)
 
     def connect(self) -> None:
         """
         Connect the client.
         """
         self._log.info("Connecting...")
         self.create_task(
             self._connect(),
             actions=lambda: self._set_connected(True),
-            success="Connected",
+            success_msg="Connected",
+            success_color=LogColor.GREEN,
         )
 
     def disconnect(self) -> None:
         """
         Disconnect the client.
         """
         self._log.info("Disconnecting...")
         self.create_task(
             self._disconnect(),
             actions=lambda: self._set_connected(False),
-            success="Disconnected",
+            success_msg="Disconnected",
+            success_color=LogColor.GREEN,
         )
 
     # -- SUBSCRIPTIONS ----------------------------------------------------------------------------
 
     def subscribe(self, data_type: DataType) -> None:
+        self._add_subscription(data_type)
         self.create_task(
             self._subscribe(data_type),
             log_msg=f"subscribe: {data_type}",
-            actions=lambda: self._add_subscription(data_type),
+            success_msg=f"Subscribed {data_type}",
+            success_color=LogColor.BLUE,
         )
 
     def unsubscribe(self, data_type: DataType) -> None:
+        self._remove_subscription(data_type)
         self.create_task(
             self._unsubscribe(data_type),
             log_msg=f"unsubscribe_{data_type}",
-            actions=lambda: self._remove_subscription(data_type),
+            success_msg=f"Unsubscribed {data_type}",
+            success_color=LogColor.BLUE,
         )
 
     # -- REQUESTS ---------------------------------------------------------------------------------
 
     def request(self, data_type: DataType, correlation_id: UUID4) -> None:
-        self._log.debug(f"Request {data_type} {correlation_id}.")
+        self._log.debug(f"Request {data_type} {correlation_id}")
         self.create_task(
             self._request(data_type, correlation_id),
             log_msg=f"request_{data_type}",
         )
 
     ############################################################################
     # Coroutines to implement
@@ -332,279 +343,331 @@
         return await coro
 
     def create_task(
         self,
         coro: Coroutine,
         log_msg: str | None = None,
         actions: Callable | None = None,
-        success: str | None = None,
+        success_msg: str | None = None,
+        success_color: LogColor = LogColor.NORMAL,
     ) -> asyncio.Task:
         """
         Run the given coroutine with error handling and optional callback actions when
         done.
 
         Parameters
         ----------
         coro : Coroutine
             The coroutine to run.
         log_msg : str, optional
             The log message for the task.
         actions : Callable, optional
             The actions callback to run when the coroutine is done.
-        success : str, optional
-            The log message to write on actions success.
+        success_msg : str, optional
+            The log message to write on `actions` success.
+        success_color : LogColor, default ``NORMAL``
+            The log message color for `actions` success.
 
         Returns
         -------
         asyncio.Task
 
         """
         log_msg = log_msg or coro.__name__
-        self._log.debug(f"Creating task {log_msg}.")
+        self._log.debug(f"Creating task {log_msg}")
         task = self._loop.create_task(
             coro,
             name=coro.__name__,
         )
         task.add_done_callback(
             functools.partial(
                 self._on_task_completed,
                 actions,
-                success,
+                success_msg,
+                success_color,
             ),
         )
         return task
 
     def _on_task_completed(
         self,
         actions: Callable | None,
-        success: str | None,
+        success_msg: str | None,
+        success_color: LogColor,
         task: Task,
     ) -> None:
-        if task.exception():
+        e: BaseException | None = task.exception()
+        if e:
+            tb_str = "".join(traceback.format_exception(type(e), e, e.__traceback__))
             self._log.error(
-                f"Error on `{task.get_name()}`: " f"{task.exception()!r}",
+                f"Error on `{task.get_name()}`: " f"{task.exception()!r}\n{tb_str}",
             )
         else:
             if actions:
                 try:
                     actions()
                 except Exception as e:
+                    tb_str = "".join(traceback.format_exception(type(e), e, e.__traceback__))
                     self._log.error(
                         f"Failed triggering action {actions.__name__} on `{task.get_name()}`: "
-                        f"{e!r}",
+                        f"{e!r}\n{tb_str}",
                     )
-            if success:
-                self._log.info(success, LogColor.GREEN)
+            if success_msg:
+                self._log.info(success_msg, success_color)
 
     def connect(self) -> None:
         """
         Connect the client.
         """
         self._log.info("Connecting...")
         self.create_task(
             self._connect(),
             actions=lambda: self._set_connected(True),
-            success="Connected",
+            success_msg="Connected",
+            success_color=LogColor.GREEN,
         )
 
     def disconnect(self) -> None:
         """
         Disconnect the client.
         """
         self._log.info("Disconnecting...")
         self.create_task(
             self._disconnect(),
             actions=lambda: self._set_connected(False),
-            success="Disconnected",
+            success_msg="Disconnected",
+            success_color=LogColor.GREEN,
         )
 
     # -- SUBSCRIPTIONS ----------------------------------------------------------------------------
 
     def subscribe(self, data_type: DataType) -> None:
+        self._add_subscription(data_type)
         self.create_task(
             self._subscribe(data_type),
             log_msg=f"subscribe: {data_type}",
-            actions=lambda: self._add_subscription(data_type),
+            success_msg=f"Subscribed {data_type}",
+            success_color=LogColor.BLUE,
         )
 
     def subscribe_instruments(self) -> None:
         instrument_ids = list(self._instrument_provider.get_all().keys())
+        [self._add_subscription_instrument(i) for i in instrument_ids]
         self.create_task(
             self._subscribe_instruments(),
             log_msg=f"subscribe: instruments {self.venue}",
-            actions=lambda: [self._add_subscription_instrument(i) for i in instrument_ids],
+            success_msg=f"Subscribed instruments {self.venue}",
+            success_color=LogColor.BLUE,
         )
 
     def subscribe_instrument(self, instrument_id: InstrumentId) -> None:
+        self._add_subscription_instrument(instrument_id)
         self.create_task(
             self._subscribe_instrument(instrument_id),
             log_msg=f"subscribe: instrument {instrument_id}",
-            actions=lambda: self._add_subscription_instrument(instrument_id),
+            success_msg=f"Subscribed instrument {instrument_id}",
+            success_color=LogColor.BLUE,
         )
 
     def subscribe_order_book_deltas(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
         depth: int | None = None,
         kwargs: dict[str, Any] | None = None,
     ) -> None:
+        self._add_subscription_order_book_deltas(instrument_id)
         self.create_task(
             self._subscribe_order_book_deltas(
                 instrument_id=instrument_id,
                 book_type=book_type,
                 depth=depth,
                 kwargs=kwargs,
             ),
             log_msg=f"subscribe: order_book_deltas {instrument_id}",
-            actions=lambda: self._add_subscription_order_book_deltas(instrument_id),
+            success_msg=f"Subscribed order book deltas {instrument_id} depth={depth}",
+            success_color=LogColor.BLUE,
         )
 
     def subscribe_order_book_snapshots(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
         depth: int | None = None,
         kwargs: dict[str, Any] | None = None,
     ) -> None:
+        self._add_subscription_order_book_snapshots(instrument_id)
         self.create_task(
             self._subscribe_order_book_snapshots(
                 instrument_id=instrument_id,
                 book_type=book_type,
                 depth=depth,
                 kwargs=kwargs,
             ),
             log_msg=f"subscribe: order_book_snapshots {instrument_id}",
-            actions=lambda: self._add_subscription_order_book_snapshots(instrument_id),
+            success_msg=f"Subscribed order book snapshots {instrument_id} depth={depth}",
+            success_color=LogColor.BLUE,
         )
 
     def subscribe_quote_ticks(self, instrument_id: InstrumentId) -> None:
+        self._add_subscription_quote_ticks(instrument_id)
         self.create_task(
             self._subscribe_quote_ticks(instrument_id),
             log_msg=f"subscribe: quote_ticks {instrument_id}",
-            actions=lambda: self._add_subscription_quote_ticks(instrument_id),
+            success_msg=f"Subscribed quotes {instrument_id}",
+            success_color=LogColor.BLUE,
         )
 
     def subscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:
+        self._add_subscription_trade_ticks(instrument_id)
         self.create_task(
             self._subscribe_trade_ticks(instrument_id),
             log_msg=f"subscribe: trade_ticks {instrument_id}",
-            actions=lambda: self._add_subscription_trade_ticks(instrument_id),
+            success_msg=f"Subscribed trades {instrument_id}",
+            success_color=LogColor.BLUE,
         )
 
     def subscribe_bars(self, bar_type: BarType) -> None:
         PyCondition.true(bar_type.is_externally_aggregated(), "aggregation_source is not EXTERNAL")
 
+        self._add_subscription_bars(bar_type)
         self.create_task(
             self._subscribe_bars(bar_type),
             log_msg=f"subscribe: bars {bar_type}",
-            actions=lambda: self._add_subscription_bars(bar_type),
+            success_msg=f"Subscribed bars {bar_type}",
+            success_color=LogColor.BLUE,
         )
 
     def subscribe_instrument_status(self, instrument_id: InstrumentId) -> None:
+        self._add_subscription_instrument_status(instrument_id)
         self.create_task(
             self._subscribe_instrument_status(instrument_id),
             log_msg=f"subscribe: instrument_status {instrument_id}",
-            actions=lambda: self._add_subscription_instrument_status(instrument_id),
+            success_msg=f"Subscribed instrument status {instrument_id}",
+            success_color=LogColor.BLUE,
         )
 
     def subscribe_instrument_close(self, instrument_id: InstrumentId) -> None:
+        self._add_subscription_instrument_close(instrument_id)
         self.create_task(
             self._subscribe_instrument_close(instrument_id),
             log_msg=f"subscribe: instrument_close {instrument_id}",
-            actions=lambda: self._add_subscription_instrument_close(instrument_id),
+            success_msg=f"Subscribed instrument close {instrument_id}",
+            success_color=LogColor.BLUE,
         )
 
     def unsubscribe(self, data_type: DataType) -> None:
+        self._remove_subscription(data_type)
         self.create_task(
             self._unsubscribe(data_type),
             log_msg=f"unsubscribe {data_type}",
-            actions=lambda: self._remove_subscription(data_type),
+            success_msg=f"Unsubscribed {data_type}",
+            success_color=LogColor.BLUE,
         )
 
     def unsubscribe_instruments(self) -> None:
         instrument_ids = list(self._instrument_provider.get_all().keys())
+        [self._remove_subscription_instrument(i) for i in instrument_ids]
         self.create_task(
             self._unsubscribe_instruments(),
-            actions=lambda: [self._remove_subscription_instrument(i) for i in instrument_ids],
+            log_msg=f"unsubscribe: instruments {self.venue}",
+            success_msg=f"Unsubscribed instruments {self.venue}",
+            success_color=LogColor.BLUE,
         )
 
     def unsubscribe_instrument(self, instrument_id: InstrumentId) -> None:
+        self._remove_subscription_instrument(instrument_id)
         self.create_task(
             self._unsubscribe_instrument(instrument_id),
             log_msg=f"unsubscribe: instrument {instrument_id}",
-            actions=lambda: self._remove_subscription_instrument(instrument_id),
+            success_msg=f"Unsubscribed instrument {instrument_id}",
+            success_color=LogColor.BLUE,
         )
 
     def unsubscribe_order_book_deltas(self, instrument_id: InstrumentId) -> None:
+        self._remove_subscription_order_book_deltas(instrument_id)
         self.create_task(
             self._unsubscribe_order_book_deltas(instrument_id),
             log_msg=f"unsubscribe: order_book_deltas {instrument_id}",
-            actions=lambda: self._remove_subscription_order_book_deltas(instrument_id),
+            success_msg=f"Unsubscribed order book deltas {instrument_id}",
+            success_color=LogColor.BLUE,
         )
 
     def unsubscribe_order_book_snapshots(self, instrument_id: InstrumentId) -> None:
+        self._remove_subscription_order_book_snapshots(instrument_id)
         self.create_task(
             self._unsubscribe_order_book_snapshots(instrument_id),
             log_msg=f"unsubscribe: order_book_snapshots {instrument_id}",
-            actions=lambda: self._remove_subscription_order_book_snapshots(instrument_id),
+            success_msg=f"Unsubscribed order book snapshots {instrument_id}",
+            success_color=LogColor.BLUE,
         )
 
     def unsubscribe_quote_ticks(self, instrument_id: InstrumentId) -> None:
+        self._remove_subscription_quote_ticks(instrument_id)
         self.create_task(
             self._unsubscribe_quote_ticks(instrument_id),
             log_msg=f"unsubscribe: quote_ticks {instrument_id}",
-            actions=lambda: self._remove_subscription_quote_ticks(instrument_id),
+            success_msg=f"Unsubscribed quotes {instrument_id}",
+            success_color=LogColor.BLUE,
         )
 
     def unsubscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:
+        self._remove_subscription_trade_ticks(instrument_id)
         self.create_task(
             self._unsubscribe_trade_ticks(instrument_id),
             log_msg=f"unsubscribe: trade_ticks {instrument_id}",
-            actions=lambda: self._remove_subscription_trade_ticks(instrument_id),
+            success_msg=f"Unsubscribed trades {instrument_id}",
+            success_color=LogColor.BLUE,
         )
 
     def unsubscribe_bars(self, bar_type: BarType) -> None:
+        self._remove_subscription_bars(bar_type)
         self.create_task(
             self._unsubscribe_bars(bar_type),
             log_msg=f"unsubscribe: bars {bar_type}",
-            actions=lambda: self._remove_subscription_bars(bar_type),
+            success_msg=f"Unsubscribed bars {bar_type}",
+            success_color=LogColor.BLUE,
         )
 
     def unsubscribe_instrument_status(self, instrument_id: InstrumentId) -> None:
+        self._remove_subscription_instrument_status(instrument_id)
         self.create_task(
             self._unsubscribe_instrument_status(instrument_id),
             log_msg=f"unsubscribe: instrument_status {instrument_id}",
-            actions=lambda: self._remove_subscription_instrument_status(instrument_id),
+            success_msg=f"Unsubscribed instrument status {instrument_id}",
+            success_color=LogColor.BLUE,
         )
 
     def unsubscribe_instrument_close(self, instrument_id: InstrumentId) -> None:
+        self._remove_subscription_instrument_close(instrument_id)
         self.create_task(
             self._unsubscribe_instrument_close(instrument_id),
             log_msg=f"unsubscribe: instrument_close {instrument_id}",
-            actions=lambda: self._remove_subscription_instrument_close(instrument_id),
+            success_msg=f"Unsubscribed instrument close {instrument_id}",
+            success_color=LogColor.BLUE,
         )
 
     # -- REQUESTS ---------------------------------------------------------------------------------
 
     def request(self, data_type: DataType, correlation_id: UUID4) -> None:
-        self._log.debug(f"Request data {data_type}.")
+        self._log.info(f"Request {data_type}", LogColor.BLUE)
         self.create_task(
             self._request(data_type, correlation_id),
             log_msg=f"request: {data_type}",
         )
 
     def request_instrument(
         self,
         instrument_id: InstrumentId,
         correlation_id: UUID4,
         start: pd.Timestamp | None = None,
         end: pd.Timestamp | None = None,
     ) -> None:
-        self._log.debug(f"Request instrument {instrument_id}.")
+        time_range = f" {start} to {end}" if (start or end) else ""
+        self._log.info(f"Request instrument {instrument_id}{time_range}", LogColor.BLUE)
         self.create_task(
             self._request_instrument(
                 instrument_id=instrument_id,
                 correlation_id=correlation_id,
                 start=start,
                 end=end,
             ),
@@ -614,15 +677,19 @@
     def request_instruments(
         self,
         venue: Venue,
         correlation_id: UUID4,
         start: pd.Timestamp | None = None,
         end: pd.Timestamp | None = None,
     ) -> None:
-        self._log.debug(f"Request instruments for {venue} {correlation_id}.")
+        time_range = f" {start} to {end}" if (start or end) else ""
+        self._log.info(
+            f"Request instruments for {venue}{time_range}",
+            LogColor.BLUE,
+        )
         self.create_task(
             self._request_instruments(
                 venue=venue,
                 correlation_id=correlation_id,
                 start=start,
                 end=end,
             ),
@@ -633,15 +700,17 @@
         self,
         instrument_id: InstrumentId,
         limit: int,
         correlation_id: UUID4,
         start: pd.Timestamp | None = None,
         end: pd.Timestamp | None = None,
     ) -> None:
-        self._log.debug(f"Request quote ticks {instrument_id}.")
+        time_range = f" {start} to {end}" if (start or end) else ""
+        limit_str = f" limit={limit}" if limit else ""
+        self._log.info(f"Request quote ticks {instrument_id}{time_range}{limit_str}", LogColor.BLUE)
         self.create_task(
             self._request_quote_ticks(
                 instrument_id=instrument_id,
                 limit=limit,
                 correlation_id=correlation_id,
                 start=start,
                 end=end,
@@ -653,15 +722,17 @@
         self,
         instrument_id: InstrumentId,
         limit: int,
         correlation_id: UUID4,
         start: pd.Timestamp | None = None,
         end: pd.Timestamp | None = None,
     ) -> None:
-        self._log.debug(f"Request trade ticks {instrument_id}.")
+        time_range = f" {start} to {end}" if (start or end) else ""
+        limit_str = f" limit={limit}" if limit else ""
+        self._log.info(f"Request trade ticks {instrument_id}{time_range}{limit_str}", LogColor.BLUE)
         self.create_task(
             self._request_trade_ticks(
                 instrument_id=instrument_id,
                 limit=limit,
                 correlation_id=correlation_id,
                 start=start,
                 end=end,
@@ -673,15 +744,17 @@
         self,
         bar_type: BarType,
         limit: int,
         correlation_id: UUID4,
         start: pd.Timestamp | None = None,
         end: pd.Timestamp | None = None,
     ) -> None:
-        self._log.debug(f"Request bars {bar_type}.")
+        time_range = f" {start} to {end}" if (start or end) else ""
+        limit_str = f" limit={limit}" if limit else ""
+        self._log.info(f"Request bars {bar_type}{time_range}{limit_str}", LogColor.BLUE)
         self.create_task(
             self._request_bars(
                 bar_type=bar_type,
                 limit=limit,
                 correlation_id=correlation_id,
                 start=start,
                 end=end,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/live/data_engine.py` & `nautilus_trader-1.191.0/nautilus_trader/live/data_engine.py`

 * *Files 2% similar despite different names*

```diff
@@ -89,28 +89,28 @@
     def connect(self) -> None:
         """
         Connect the engine by calling connect on all registered clients.
         """
         if self._clients:
             self._log.info("Connecting all clients...")
         else:
-            self._log.warning("No clients to connect.")
+            self._log.warning("No clients to connect")
             return
 
         for client in self._clients.values():
             client.connect()
 
     def disconnect(self) -> None:
         """
         Disconnect the engine by calling disconnect on all registered clients.
         """
         if self._clients:
             self._log.info("Disconnecting all clients...")
         else:
-            self._log.warning("No clients to disconnect.")
+            self._log.warning("No clients to disconnect")
             return
 
         for client in self._clients.values():
             client.disconnect()
 
     def get_cmd_queue_task(self) -> asyncio.Task | None:
         """
@@ -200,31 +200,31 @@
         """
         return self._data_queue.qsize()
 
     def kill(self) -> None:
         """
         Kill the engine by abruptly canceling the queue tasks and calling stop.
         """
-        self._log.warning("Killing engine...")
+        self._log.warning("Killing engine")
         self._kill = True
         self.stop()
         if self._cmd_queue_task:
-            self._log.debug(f"Canceling {self._cmd_queue_task.get_name()}...")
+            self._log.debug(f"Canceling {self._cmd_queue_task.get_name()}")
             self._cmd_queue_task.cancel()
             self._cmd_queue_task = None
         if self._req_queue_task:
-            self._log.debug(f"Canceling {self._req_queue_task.get_name()}...")
+            self._log.debug(f"Canceling {self._req_queue_task.get_name()}")
             self._req_queue_task.cancel()
             self._req_queue_task = None
         if self._res_queue_task:
-            self._log.debug(f"Canceling {self._res_queue_task.get_name()}...")
+            self._log.debug(f"Canceling {self._res_queue_task.get_name()}")
             self._res_queue_task.cancel()
             self._res_queue_task = None
         if self._data_queue_task:
-            self._log.debug(f"Canceling {self._data_queue_task.get_name()}...")
+            self._log.debug(f"Canceling {self._data_queue_task.get_name()}")
             self._data_queue_task.cancel()
             self._data_queue_task = None
 
     def execute(self, command: DataCommand) -> None:
         """
         Execute the given data command.
 
@@ -246,15 +246,15 @@
         # Do not allow None through (None is a sentinel value which stops the queue)
 
         try:
             self._loop.call_soon_threadsafe(self._cmd_queue.put_nowait, command)
         except asyncio.QueueFull:
             self._log.warning(
                 f"Blocking on `_cmd_queue.put` as queue full at "
-                f"{self._cmd_queue.qsize()} items.",
+                f"{self._cmd_queue.qsize()} items",
             )
             # Schedule the `put` operation to be executed once there is space in the queue
             self._loop.create_task(self._cmd_queue.put(command))
 
     def request(self, request: DataRequest) -> None:
         """
         Handle the given request.
@@ -277,15 +277,15 @@
         # Do not allow None through (None is a sentinel value which stops the queue)
 
         try:
             self._loop.call_soon_threadsafe(self._req_queue.put_nowait, request)
         except asyncio.QueueFull:
             self._log.warning(
                 f"Blocking on `_req_queue.put` as queue full at "
-                f"{self._req_queue.qsize()} items.",
+                f"{self._req_queue.qsize()} items",
             )
             # Schedule the `put` operation to be executed once there is space in the queue
             self._loop.create_task(self._req_queue.put(request))
 
     def response(self, response: DataResponse) -> None:
         """
         Handle the given response.
@@ -308,15 +308,15 @@
         # Do not allow None through (None is a sentinel value which stops the queue)
 
         try:
             self._loop.call_soon_threadsafe(self._res_queue.put_nowait, response)
         except asyncio.QueueFull:
             self._log.warning(
                 f"Blocking on `_res_queue.put` as queue full at "
-                f"{self._res_queue.qsize():_} items.",
+                f"{self._res_queue.qsize():_} items",
             )
             # Schedule the `put` operation to be executed once there is space in the queue
             self._loop.create_task(self._res_queue.put(response))
 
     def process(self, data: Data) -> None:
         """
         Process the given data.
@@ -339,31 +339,31 @@
         # Do not allow None through (None is a sentinel value which stops the queue)
 
         try:
             self._loop.call_soon_threadsafe(self._data_queue.put_nowait, data)
         except asyncio.QueueFull:
             self._log.warning(
                 f"Blocking on `_data_queue.put` as queue full at "
-                f"{self._data_queue.qsize():_} items.",
+                f"{self._data_queue.qsize():_} items",
             )
             # Schedule the `put` operation to be executed once there is space in the queue
             self._loop.create_task(self._data_queue.put(data))
 
     # -- INTERNAL -------------------------------------------------------------------------------------
 
     def _enqueue_sentinels(self) -> None:
         self._loop.call_soon_threadsafe(self._cmd_queue.put_nowait, self._sentinel)
         self._loop.call_soon_threadsafe(self._req_queue.put_nowait, self._sentinel)
         self._loop.call_soon_threadsafe(self._res_queue.put_nowait, self._sentinel)
         self._loop.call_soon_threadsafe(self._data_queue.put_nowait, self._sentinel)
-        self._log.debug("Sentinel messages placed on queues.")
+        self._log.debug("Sentinel messages placed on queues")
 
     def _on_start(self) -> None:
         if not self._loop.is_running():
-            self._log.warning("Started when loop is not running.")
+            self._log.warning("Started when loop is not running")
 
         self._cmd_queue_task = self._loop.create_task(self._run_cmd_queue(), name="cmd_queue")
         self._req_queue_task = self._loop.create_task(self._run_res_queue(), name="res_queue")
         self._res_queue_task = self._loop.create_task(self._run_req_queue(), name="req_queue")
         self._data_queue_task = self._loop.create_task(self._run_data_queue(), name="data_queue")
 
         self._log.debug(f"Scheduled {self._cmd_queue_task}")
@@ -376,86 +376,86 @@
             return  # Avoids queuing redundant sentinel messages
 
         # This will stop the queues processing as soon as they see the sentinel message
         self._enqueue_sentinels()
 
     async def _run_cmd_queue(self) -> None:
         self._log.debug(
-            f"DataCommand message queue processing starting (qsize={self.cmd_qsize()})...",
+            f"DataCommand message queue processing starting (qsize={self.cmd_qsize()})",
         )
         try:
             while True:
                 command: DataCommand | None = await self._cmd_queue.get()
                 if command is self._sentinel:
                     break
                 self._execute_command(command)
         except asyncio.CancelledError:
-            self._log.warning("DataCommand message queue canceled.")
+            self._log.warning("DataCommand message queue canceled")
         except RuntimeError as e:
-            self._log.error(f"RuntimeError: {e}.")
+            self._log.error(f"RuntimeError: {e}")
         finally:
             stopped_msg = "DataCommand message queue stopped"
             if not self._cmd_queue.empty():
-                self._log.warning(f"{stopped_msg} with {self.cmd_qsize()} message(s) on queue.")
+                self._log.warning(f"{stopped_msg} with {self.cmd_qsize()} message(s) on queue")
             else:
-                self._log.debug(stopped_msg + ".")
+                self._log.debug(stopped_msg)
 
     async def _run_req_queue(self) -> None:
         self._log.debug(
-            f"DataRequest message queue processing starting (qsize={self.req_qsize()})...",
+            f"DataRequest message queue processing starting (qsize={self.req_qsize()})",
         )
         try:
             while True:
                 request: DataRequest | None = await self._req_queue.get()
                 if request is self._sentinel:
                     break
                 self._handle_request(request)
         except asyncio.CancelledError:
-            self._log.warning("DataRequest message queue canceled.")
+            self._log.warning("DataRequest message queue canceled")
         except RuntimeError as e:
-            self._log.error(f"RuntimeError: {e}.")
+            self._log.error(f"RuntimeError: {e}")
         finally:
             stopped_msg = "DataRequest message queue stopped"
             if not self._req_queue.empty():
-                self._log.warning(f"{stopped_msg} with {self.req_qsize()} message(s) on queue.")
+                self._log.warning(f"{stopped_msg} with {self.req_qsize()} message(s) on queue")
             else:
-                self._log.debug(stopped_msg + ".")
+                self._log.debug(stopped_msg)
 
     async def _run_res_queue(self) -> None:
         self._log.debug(
-            f"DataResponse message queue processing starting (qsize={self.res_qsize()})...",
+            f"DataResponse message queue processing starting (qsize={self.res_qsize()})",
         )
         try:
             while True:
                 response: DataRequest | None = await self._res_queue.get()
                 if response is self._sentinel:
                     break
                 self._handle_response(response)
         except asyncio.CancelledError:
-            self._log.warning("DataResponse message queue canceled.")
+            self._log.warning("DataResponse message queue canceled")
         except RuntimeError as e:
-            self._log.error(f"RuntimeError: {e}.")
+            self._log.error(f"RuntimeError: {e}")
         finally:
             stopped_msg = "DataResponse message queue stopped"
             if not self._res_queue.empty():
-                self._log.warning(f"{stopped_msg} with {self.res_qsize()} message(s) on queue.")
+                self._log.warning(f"{stopped_msg} with {self.res_qsize()} message(s) on queue")
             else:
-                self._log.debug(stopped_msg + ".")
+                self._log.debug(stopped_msg)
 
     async def _run_data_queue(self) -> None:
-        self._log.debug(f"Data queue processing starting (qsize={self.data_qsize()})...")
+        self._log.debug(f"Data queue processing starting (qsize={self.data_qsize()})")
         try:
             while True:
                 data: Data | None = await self._data_queue.get()
                 if data is self._sentinel:
                     break
                 self._handle_data(data)
         except asyncio.CancelledError:
-            self._log.warning("Data message queue canceled.")
+            self._log.warning("Data message queue canceled")
         except RuntimeError as e:
-            self._log.error(f"RuntimeError: {e}.")
+            self._log.error(f"RuntimeError: {e}")
         finally:
             stopped_msg = "Data message queue stopped"
             if not self._data_queue.empty():
-                self._log.warning(f"{stopped_msg} with {self.data_qsize()} message(s) on queue.")
+                self._log.warning(f"{stopped_msg} with {self.data_qsize()} message(s) on queue")
             else:
-                self._log.debug(stopped_msg + ".")
+                self._log.debug(stopped_msg)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/live/execution_client.py` & `nautilus_trader-1.191.0/nautilus_trader/live/execution_client.py`

 * *Files 9% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 """
 The `LiveExecutionClient` class is responsible for interfacing with a particular API
-which may be presented directly by an exchange, or broker intermediary.
+which may be presented directly by a venue, or through a broker intermediary.
 """
 
 import asyncio
 import functools
 import traceback
 from asyncio import Task
 from collections.abc import Callable
@@ -45,14 +45,15 @@
 from nautilus_trader.execution.messages import SubmitOrderList
 from nautilus_trader.execution.reports import ExecutionMassStatus
 from nautilus_trader.execution.reports import FillReport
 from nautilus_trader.execution.reports import OrderStatusReport
 from nautilus_trader.execution.reports import PositionStatusReport
 from nautilus_trader.model.enums import AccountType
 from nautilus_trader.model.enums import OmsType
+from nautilus_trader.model.enums import order_side_to_str
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import Venue
 from nautilus_trader.model.identifiers import VenueOrderId
 from nautilus_trader.model.objects import Currency
 
@@ -148,55 +149,60 @@
         return await coro
 
     def create_task(
         self,
         coro: Coroutine,
         log_msg: str | None = None,
         actions: Callable | None = None,
-        success: str | None = None,
+        success_msg: str | None = None,
+        success_color: LogColor = LogColor.NORMAL,
     ) -> asyncio.Task:
         """
         Run the given coroutine with error handling and optional callback actions when
         done.
 
         Parameters
         ----------
         coro : Coroutine
             The coroutine to run.
         log_msg : str, optional
             The log message for the task.
         actions : Callable, optional
             The actions callback to run when the coroutine is done.
-        success : str, optional
-            The log message to write on actions success.
+        success_msg : str, optional
+            The log message to write on `actions` success.
+        success_color : str, default ``NORMAL``
+            The log message color for `actions` success.
 
         Returns
         -------
         asyncio.Task
 
         """
         log_msg = log_msg or coro.__name__
-        self._log.debug(f"Creating task {log_msg}.")
+        self._log.debug(f"Creating task {log_msg}")
         task = self._loop.create_task(
             coro,
             name=coro.__name__,
         )
         task.add_done_callback(
             functools.partial(
                 self._on_task_completed,
                 actions,
-                success,
+                success_msg,
+                success_color,
             ),
         )
         return task
 
     def _on_task_completed(
         self,
         actions: Callable | None,
-        success: str | None,
+        success_msg: str | None,
+        success_color: LogColor,
         task: Task,
     ) -> None:
         e: BaseException | None = task.exception()
         if e:
             tb_str = "".join(traceback.format_exception(type(e), e, e.__traceback__))
             self._log.error(
                 f"Error on `{task.get_name()}`: " f"{task.exception()!r}\n{tb_str}",
@@ -207,76 +213,95 @@
                     actions()
                 except Exception as e:
                     tb_str = "".join(traceback.format_exception(type(e), e, e.__traceback__))
                     self._log.error(
                         f"Failed triggering action {actions.__name__} on `{task.get_name()}`: "
                         f"{e!r}\n{tb_str}",
                     )
-            if success:
-                self._log.info(success, LogColor.GREEN)
+            if success_msg:
+                self._log.info(success_msg, success_color)
 
     def connect(self) -> None:
         """
         Connect the client.
         """
         self._log.info("Connecting...")
         self.create_task(
             self._connect(),
             actions=lambda: self._set_connected(True),
-            success="Connected",
+            success_msg="Connected",
+            success_color=LogColor.GREEN,
         )
 
     def disconnect(self) -> None:
         """
         Disconnect the client.
         """
         self._log.info("Disconnecting...")
         self.create_task(
             self._disconnect(),
             actions=lambda: self._set_connected(False),
-            success="Disconnected",
+            success_msg="Disconnected",
+            success_color=LogColor.GREEN,
         )
 
     def submit_order(self, command: SubmitOrder) -> None:
+        self._log.info(f"Submit {command.order}", LogColor.BLUE)
         self.create_task(
             self._submit_order(command),
             log_msg=f"submit_order: {command}",
         )
 
     def submit_order_list(self, command: SubmitOrderList) -> None:
+        self._log.info(f"Submit {command.order_list}", LogColor.BLUE)
         self.create_task(
             self._submit_order_list(command),
             log_msg=f"submit_order_list: {command}",
         )
 
     def modify_order(self, command: ModifyOrder) -> None:
+        venue_order_id_str = (
+            " " + repr(command.venue_order_id) if command.venue_order_id is not None else ""
+        )
+        self._log.info(f"Modify {command.client_order_id!r}{venue_order_id_str}", LogColor.BLUE)
         self.create_task(
             self._modify_order(command),
             log_msg=f"modify_order: {command}",
         )
 
     def cancel_order(self, command: CancelOrder) -> None:
+        venue_order_id_str = (
+            " " + repr(command.venue_order_id) if command.venue_order_id is not None else ""
+        )
+        self._log.info(f"Cancel {command.client_order_id!r}{venue_order_id_str}", LogColor.BLUE)
         self.create_task(
             self._cancel_order(command),
             log_msg=f"cancel_order: {command}",
         )
 
     def cancel_all_orders(self, command: CancelAllOrders) -> None:
+        side_str = f" {order_side_to_str(command.order_side)} " if command.order_side else " "
+        self._log.info(f"Cancel all{side_str}orders", LogColor.BLUE)
         self.create_task(
             self._cancel_all_orders(command),
             log_msg=f"cancel_all_orders: {command}",
         )
 
     def batch_cancel_orders(self, command: BatchCancelOrders) -> None:
+        self._log.info(
+            f"Batch cancel orders {[repr(c.client_order_id) for c in command.cancels]}",
+            LogColor.BLUE,
+        )
         self.create_task(
             self._batch_cancel_orders(command),
             log_msg=f"batch_cancel_orders: {command}",
         )
 
     def query_order(self, command: QueryOrder) -> None:
+        self._log.info(f"Query {command.client_order_id!r}", LogColor.BLUE)
         self.create_task(
             self._query_order(command),
             log_msg=f"query_order: {command}",
         )
 
     async def generate_order_status_report(
         self,
@@ -453,24 +478,24 @@
 
             return mass_status
         except Exception as e:
             self._log.exception("Cannot reconcile execution state", e)
         return None
 
     async def _query_order(self, command: QueryOrder) -> None:
-        self._log.debug(f"Synchronizing order status {command}.")
+        self._log.debug(f"Synchronizing order status {command}")
 
         report: OrderStatusReport | None = await self.generate_order_status_report(
             instrument_id=command.instrument_id,
             client_order_id=command.client_order_id,
             venue_order_id=command.venue_order_id,
         )
 
         if report is None:
-            self._log.warning("Did not receive `OrderStatusReport` from request.")
+            self._log.warning("Did not receive `OrderStatusReport` from request")
             return
 
         self._send_order_status_report(report)
 
     ############################################################################
     # Coroutines to implement
     ############################################################################
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/live/execution_engine.py` & `nautilus_trader-1.191.0/nautilus_trader/live/execution_engine.py`

 * *Files 1% similar despite different names*

```diff
@@ -158,28 +158,28 @@
     def connect(self) -> None:
         """
         Connect the engine by calling connect on all registered clients.
         """
         if self._clients:
             self._log.info("Connecting all clients...")
         else:
-            self._log.warning("No clients to connect.")
+            self._log.warning("No clients to connect")
             return
 
         for client in self._clients.values():
             client.connect()
 
     def disconnect(self) -> None:
         """
         Disconnect the engine by calling disconnect on all registered clients.
         """
         if self._clients:
             self._log.info("Disconnecting all clients...")
         else:
-            self._log.warning("No clients to disconnect.")
+            self._log.warning("No clients to disconnect")
             return
 
         for client in self._clients.values():
             client.disconnect()
 
     def get_cmd_queue_task(self) -> asyncio.Task | None:
         """
@@ -238,23 +238,23 @@
 
     # -- COMMANDS -------------------------------------------------------------------------------------
 
     def kill(self) -> None:
         """
         Kill the engine by abruptly canceling the queue task and calling stop.
         """
-        self._log.warning("Killing engine...")
+        self._log.warning("Killing engine")
         self._kill = True
         self.stop()
         if self._cmd_queue_task:
-            self._log.debug(f"Canceling {self._cmd_queue_task.get_name()}...")
+            self._log.debug(f"Canceling {self._cmd_queue_task.get_name()}")
             self._cmd_queue_task.cancel()
             self._cmd_queue_task = None
         if self._evt_queue_task:
-            self._log.debug(f"Canceling {self._evt_queue_task.get_name()}...")
+            self._log.debug(f"Canceling {self._evt_queue_task.get_name()}")
             self._evt_queue_task.cancel()
             self._evt_queue_task = None
 
     def execute(self, command: TradingCommand) -> None:
         """
         Execute the given command.
 
@@ -276,15 +276,15 @@
         # Do not allow None through (None is a sentinel value which stops the queue)
 
         try:
             self._loop.call_soon_threadsafe(self._cmd_queue.put_nowait, command)
         except asyncio.QueueFull:
             self._log.warning(
                 f"Blocking on `_cmd_queue.put` as queue full "
-                f"at {self._cmd_queue.qsize():_} items.",
+                f"at {self._cmd_queue.qsize():_} items",
             )
             # Schedule the `put` operation to be executed once there is space in the queue
             self._loop.create_task(self._cmd_queue.put(command))
 
     def process(self, event: OrderEvent) -> None:
         """
         Process the given event.
@@ -306,46 +306,46 @@
         PyCondition.not_none(event, "event")
 
         try:
             self._loop.call_soon_threadsafe(self._evt_queue.put_nowait, event)
         except asyncio.QueueFull:
             self._log.warning(
                 f"Blocking on `_evt_queue.put` as queue full "
-                f"at {self._evt_queue.qsize():_} items.",
+                f"at {self._evt_queue.qsize():_} items",
             )
             # Schedule the `put` operation to be executed once there is space in the queue
             self._loop.create_task(self._evt_queue.put(event))
 
     # -- INTERNAL -------------------------------------------------------------------------------------
 
     def _enqueue_sentinel(self) -> None:
         self._loop.call_soon_threadsafe(self._cmd_queue.put_nowait, self._sentinel)
         self._loop.call_soon_threadsafe(self._evt_queue.put_nowait, self._sentinel)
-        self._log.debug("Sentinel messages placed on queues.")
+        self._log.debug("Sentinel messages placed on queues")
 
     def _on_start(self) -> None:
         if not self._loop.is_running():
-            self._log.warning("Started when loop is not running.")
+            self._log.warning("Started when loop is not running")
 
         self._cmd_queue_task = self._loop.create_task(self._run_cmd_queue(), name="cmd_queue")
         self._evt_queue_task = self._loop.create_task(self._run_evt_queue(), name="evt_queue")
-        self._log.debug(f"Scheduled {self._cmd_queue_task}.")
-        self._log.debug(f"Scheduled {self._evt_queue_task}.")
+        self._log.debug(f"Scheduled {self._cmd_queue_task}")
+        self._log.debug(f"Scheduled {self._evt_queue_task}")
 
         if not self._inflight_check_task:
             if self.inflight_check_interval_ms > 0:
                 self._inflight_check_task = self._loop.create_task(
                     self._inflight_check_loop(),
                     name="inflight_check",
                 )
-                self._log.debug(f"Scheduled {self._inflight_check_task}.")
+                self._log.debug(f"Scheduled {self._inflight_check_task}")
 
     def _on_stop(self) -> None:
         if self._inflight_check_task:
-            self._log.info("Canceling in-flight check task...")
+            self._log.info("Canceling in-flight check task")
             self._inflight_check_task.cancel()
             self._inflight_check_task = None
 
         if self._kill:
             return  # Avoids queuing redundant sentinel messages
 
         # This will stop the queues processing as soon as they see the sentinel message
@@ -354,68 +354,68 @@
     async def _wait_for_inflight_check_task(self) -> None:
         if self._inflight_check_task is None:
             return
         await self._inflight_check_task
 
     async def _run_cmd_queue(self) -> None:
         self._log.debug(
-            f"Command message queue processing starting (qsize={self.cmd_qsize()})...",
+            f"Command message queue processing starting (qsize={self.cmd_qsize()})",
         )
         try:
             while True:
                 command: TradingCommand | None = await self._cmd_queue.get()
                 if command is self._sentinel:
                     break
                 self._execute_command(command)
         except asyncio.CancelledError:
-            self._log.warning("Command message queue canceled.")
+            self._log.warning("Command message queue canceled")
         except RuntimeError as e:
-            self._log.error(f"RuntimeError: {e}.")
+            self._log.error(f"RuntimeError: {e}")
         finally:
             stopped_msg = "Command message queue stopped"
             if not self._cmd_queue.empty():
-                self._log.warning(f"{stopped_msg} with {self.cmd_qsize()} message(s) on queue.")
+                self._log.warning(f"{stopped_msg} with {self.cmd_qsize()} message(s) on queue")
             else:
-                self._log.debug(stopped_msg + ".")
+                self._log.debug(stopped_msg)
 
     async def _run_evt_queue(self) -> None:
         self._log.debug(
-            f"Event message queue processing starting (qsize={self.evt_qsize()})...",
+            f"Event message queue processing starting (qsize={self.evt_qsize()})",
         )
         try:
             while True:
                 event: OrderEvent | None = await self._evt_queue.get()
                 if event is self._sentinel:
                     break
                 self._handle_event(event)
         except asyncio.CancelledError:
-            self._log.warning("Event message queue canceled.")
+            self._log.warning("Event message queue canceled")
         except RuntimeError as e:
-            self._log.error(f"RuntimeError: {e}.")
+            self._log.error(f"RuntimeError: {e}")
         finally:
             stopped_msg = "Event message queue stopped"
             if not self._evt_queue.empty():
-                self._log.warning(f"{stopped_msg} with {self.evt_qsize()} message(s) on queue.")
+                self._log.warning(f"{stopped_msg} with {self.evt_qsize()} message(s) on queue")
             else:
-                self._log.debug(stopped_msg + ".")
+                self._log.debug(stopped_msg)
 
     async def _inflight_check_loop(self) -> None:
         try:
             while True:
                 await asyncio.sleep(self.inflight_check_interval_ms / 1000)
                 await self._check_inflight_orders()
         except asyncio.CancelledError:
-            self._log.debug("In-flight check loop task canceled.")
+            self._log.debug("In-flight check loop task canceled")
 
     async def _check_inflight_orders(self) -> None:
         self._log.debug("Checking in-flight orders status...")
 
         inflight_orders: list[Order] = self._cache.orders_inflight()
         inflight_len = len(inflight_orders)
-        self._log.debug(f"Found {inflight_len} order{'' if inflight_len == 1 else 's'} in-flight.")
+        self._log.debug(f"Found {inflight_len} order{'' if inflight_len == 1 else 's'} in-flight")
         for order in inflight_orders:
             ts_now = self._clock.timestamp_ns()
             ts_init_last = order.last_event.ts_event
             self._log.debug(f"Checking in-flight order: {ts_now=}, {ts_init_last=}, {order=}...")
             if ts_now > order.last_event.ts_event + self._inflight_check_threshold_ns:
                 self._log.debug(f"Querying {order} with exchange...")
                 query = QueryOrder(
@@ -451,15 +451,15 @@
         ValueError
             If `timeout_secs` is not positive (> 0).
 
         """
         PyCondition.positive(timeout_secs, "timeout_secs")
 
         if not self.reconciliation:
-            self._log.warning("Reconciliation deactivated.")
+            self._log.warning("Reconciliation deactivated")
             return True
 
         results: list[bool] = []
 
         # Request execution mass status report from clients
         reconciliation_lookback_mins: int | None = (
             self.reconciliation_lookback_mins if self.reconciliation_lookback_mins > 0 else None
@@ -487,28 +487,28 @@
 
         Returns
         -------
         bool
             True if reconciliation successful, else False.
 
         """
-        self._log.debug(f"[RECV][RPT] {report}.")
+        self._log.debug(f"[RECV][RPT] {report}")
         self.report_count += 1
 
-        self._log.info(f"Reconciling {report}.", color=LogColor.BLUE)
+        self._log.info(f"Reconciling {report}", color=LogColor.BLUE)
 
         if isinstance(report, OrderStatusReport):
             result = self._reconcile_order_report(report, [])  # No trades to reconcile
         elif isinstance(report, FillReport):
             result = self._reconcile_fill_report_single(report)
         elif isinstance(report, PositionStatusReport):
             result = self._reconcile_position_report(report)
         else:
             self._log.error(  # pragma: no cover (design-time error)
-                f"Cannot handle unrecognized report: {report}.",  # pragma: no cover (design-time error)
+                f"Cannot handle unrecognized report: {report}",  # pragma: no cover (design-time error)
             )
             return False
 
         self._msgbus.publish(
             topic=f"reports.execution"
             f".{report.instrument_id.venue}"
             f".{report.instrument_id.symbol}",
@@ -529,23 +529,23 @@
         """
         self._reconcile_mass_status(report)
 
     def _reconcile_mass_status(
         self,
         mass_status: ExecutionMassStatus,
     ) -> bool:
-        self._log.debug(f"[RECV][RPT] {mass_status}.")
+        self._log.debug(f"[RECV][RPT] {mass_status}")
         self.report_count += 1
 
         if mass_status is None:
-            self._log.error("Error reconciling mass status (was None).")
+            self._log.error("Error reconciling mass status (was None)")
             return False
 
         self._log.info(
-            f"Reconciling ExecutionMassStatus for {mass_status.venue}.",
+            f"Reconciling ExecutionMassStatus for {mass_status.venue}",
             color=LogColor.BLUE,
         )
 
         results: list[bool] = []
         reconciled_orders: set[ClientOrderId] = set()
         reconciled_trades: set[TradeId] = set()
 
@@ -559,15 +559,15 @@
                 self._log.error(f"Duplicate {client_order_id!r} detected: {order_report}")
                 continue  # Determine how to handle this
 
             # Check for duplicate trade IDs
             for fill_report in trades:
                 if fill_report.trade_id in reconciled_trades:
                     self._log.warning(
-                        f"Duplicate {fill_report.trade_id!r} detected: {fill_report}.",
+                        f"Duplicate {fill_report.trade_id!r} detected: {fill_report}",
                     )
                 reconciled_trades.add(fill_report.trade_id)
 
             try:
                 result = self._reconcile_order_report(order_report, trades)
             except InvalidStateTrigger as e:
                 self._log.error(str(e))
@@ -601,30 +601,30 @@
             client_order_id = self._cache.client_order_id(report.venue_order_id)
             if client_order_id is None:
                 # Generate external client order ID
                 client_order_id = self._generate_client_order_id()
             # Assign to report
             report.client_order_id = client_order_id
 
-        self._log.info(f"Reconciling order for {client_order_id!r}...", LogColor.BLUE)
+        self._log.info(f"Reconciling order for {client_order_id!r}", LogColor.BLUE)
 
         order: Order = self._cache.order(client_order_id)
         if order is None:
             order = self._generate_external_order(report)
             if order is None:
                 # External order dropped
                 return True  # No further reconciliation
             # Add to cache without determining any position ID initially
             self._cache.add_order(order)
 
         instrument: Instrument | None = self._cache.instrument(order.instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot reconcile order {order.client_order_id}: "
-                f"instrument {order.instrument_id} not found.",
+                f"instrument {order.instrument_id} not found",
             )
             return False  # Failed
 
         if report.order_status == OrderStatus.REJECTED:
             if order.status != OrderStatus.REJECTED:
                 self._generate_order_rejected(order, report)
             return True  # Reconciled
@@ -667,15 +667,15 @@
         # Order has some fills from this point
 
         # Reconcile all trades
         for trade in trades:
             self._reconcile_fill_report(order, trade, instrument)
 
         if report.avg_px is None:
-            self._log.warning("report.avg_px was `None` when a value was expected.")
+            self._log.warning("report.avg_px was `None` when a value was expected")
 
         # Check reported filled qty against order filled qty
         if report.filled_qty != order.filled_qty:
             # This is due to missing fill report(s), there may now be some
             # information loss if multiple fills occurred to reach the reported
             # state, or if commissions differed from the default.
             fill: OrderFilled = self._generate_inferred_fill(order, report, instrument)
@@ -690,30 +690,30 @@
 
     def _reconcile_fill_report_single(self, report: FillReport) -> bool:
         client_order_id: ClientOrderId | None = self._cache.client_order_id(
             report.venue_order_id,
         )
         if client_order_id is None:
             self._log.error(
-                f"Cannot reconcile FillReport: client order ID {client_order_id} not found.",
+                f"Cannot reconcile FillReport: client order ID {client_order_id} not found",
             )
             return False  # Failed
 
         order: Order | None = self._cache.order(client_order_id)
         if order is None:
             self._log.error(
-                "Cannot reconcile FillReport: no order for client order ID {client_order_id}",
+                f"Cannot reconcile FillReport: no order for client order ID {client_order_id}",
             )
             return False  # Failed
 
         instrument: Instrument | None = self._cache.instrument(order.instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot reconcile order {order.client_order_id}: "
-                f"instrument {order.instrument_id} not found.",
+                f"instrument {order.instrument_id} not found",
             )
             return False  # Failed
 
         return self._reconcile_fill_report(order, report, instrument)
 
     def _reconcile_fill_report(
         self,
@@ -741,23 +741,23 @@
         else:
             return self._reconcile_position_report_netting(report)
 
     def _reconcile_position_report_hedging(self, report: PositionStatusReport) -> bool:
         position: Position | None = self._cache.position(report.venue_position_id)
         if position is None:
             self._log.error(
-                f"Cannot reconcile position: position ID {report.venue_position_id} not found.",
+                f"Cannot reconcile position: position ID {report.venue_position_id} not found",
             )
             return False  # Failed
         position_signed_decimal_qty: Decimal = position.signed_decimal_qty()
         if position_signed_decimal_qty != report.signed_decimal_qty:
             self._log.error(
                 f"Cannot reconcile {report.instrument_id} {report.venue_position_id}: position "
-                f"net qty {position_signed_decimal_qty} != reported net qty {report.signed_decimal_qty}. "
-                f"{report}.",
+                f"net qty {position_signed_decimal_qty} != reported net qty {report.signed_decimal_qty},"
+                f"{report}",
             )
             return False  # Failed
 
         return True  # Reconciled
 
     def _reconcile_position_report_netting(self, report: PositionStatusReport) -> bool:
         positions_open: list[Position] = self._cache.positions_open(
@@ -767,16 +767,16 @@
 
         position_signed_decimal_qty: Decimal = Decimal()
         for position in positions_open:
             position_signed_decimal_qty += position.signed_decimal_qty()
         if position_signed_decimal_qty != report.signed_decimal_qty:
             self._log.error(
                 f"Cannot reconcile {report.instrument_id}: position "
-                f"net qty {position_signed_decimal_qty} != reported net qty {report.signed_decimal_qty}. "
-                f"{report}.",
+                f"net qty {position_signed_decimal_qty} != reported net qty {report.signed_decimal_qty}, "
+                f"{report}",
             )
             return False  # Failed
 
         return True  # Reconciled
 
     def _generate_client_order_id(self) -> ClientOrderId:
         return ClientOrderId(f"O-{UUID4().value}")
@@ -830,15 +830,15 @@
             liquidity_side=liquidity_side,
             event_id=UUID4(),
             ts_event=report.ts_last,
             ts_init=self._clock.timestamp_ns(),
             reconciliation=True,
         )
 
-        self._log.warning(f"Generated inferred {filled}.")
+        self._log.warning(f"Generated inferred {filled}")
         return filled
 
     def _generate_external_order(self, report: OrderStatusReport) -> Order | None:
         self._log.info(
             f"Generating order {report.client_order_id!r}",
             color=LogColor.BLUE,
         )
@@ -874,15 +874,15 @@
         else:
             tags = None
 
         # Check if filtering
         if self.filter_unclaimed_external_orders and strategy_id.value == "EXTERNAL":
             # Experimental: will call this out with a warning log for now
             self._log.warning(
-                f"Filtering report for unclaimed EXTERNAL order, {report}.",
+                f"Filtering report for unclaimed EXTERNAL order, {report}",
             )
             return None  # No further reconciliation
 
         initialized = OrderInitialized(
             trader_id=self.trader_id,
             strategy_id=strategy_id,
             instrument_id=report.instrument_id,
@@ -907,15 +907,15 @@
             tags=tags,
             event_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
             reconciliation=True,
         )
 
         order: Order = OrderUnpacker.from_init(initialized)
-        self._log.debug(f"Generated {initialized}.")
+        self._log.debug(f"Generated {initialized}")
 
         return order
 
     def _generate_order_rejected(self, order: Order, report: OrderStatusReport) -> None:
         rejected = OrderRejected(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
@@ -924,15 +924,15 @@
             account_id=report.account_id,
             reason=report.cancel_reason or "UNKNOWN",
             event_id=UUID4(),
             ts_event=report.ts_last,
             ts_init=self._clock.timestamp_ns(),
             reconciliation=True,
         )
-        self._log.debug(f"Generated {rejected}.")
+        self._log.debug(f"Generated {rejected}")
         self._handle_event(rejected)
 
     def _generate_order_accepted(self, order: Order, report: OrderStatusReport) -> None:
         accepted = OrderAccepted(
             trader_id=self.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=report.instrument_id,
@@ -940,15 +940,15 @@
             venue_order_id=report.venue_order_id,
             account_id=report.account_id,
             event_id=UUID4(),
             ts_event=report.ts_accepted,
             ts_init=self._clock.timestamp_ns(),
             reconciliation=True,
         )
-        self._log.debug(f"Generated {accepted}.")
+        self._log.debug(f"Generated {accepted}")
         self._handle_event(accepted)
 
     def _generate_order_triggered(self, order: Order, report: OrderStatusReport) -> None:
         triggered = OrderTriggered(
             trader_id=self.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=report.instrument_id,
@@ -956,15 +956,15 @@
             venue_order_id=report.venue_order_id,
             account_id=report.account_id,
             event_id=UUID4(),
             ts_event=report.ts_triggered,
             ts_init=self._clock.timestamp_ns(),
             reconciliation=True,
         )
-        self._log.debug(f"Generated {triggered}.")
+        self._log.debug(f"Generated {triggered}")
         self._handle_event(triggered)
 
     def _generate_order_updated(self, order: Order, report: OrderStatusReport) -> None:
         updated = OrderUpdated(
             trader_id=self.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=report.instrument_id,
@@ -975,15 +975,15 @@
             price=report.price,
             trigger_price=report.trigger_price,
             event_id=UUID4(),
             ts_event=report.ts_accepted,
             ts_init=self._clock.timestamp_ns(),
             reconciliation=True,
         )
-        self._log.debug(f"Generated {updated}.")
+        self._log.debug(f"Generated {updated}")
         self._handle_event(updated)
 
     def _generate_order_canceled(self, order: Order, report: OrderStatusReport) -> None:
         canceled = OrderCanceled(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=report.instrument_id,
@@ -991,15 +991,15 @@
             venue_order_id=report.venue_order_id,
             account_id=report.account_id,
             event_id=UUID4(),
             ts_event=report.ts_last,
             ts_init=self._clock.timestamp_ns(),
             reconciliation=True,
         )
-        self._log.debug(f"Generated {canceled}.")
+        self._log.debug(f"Generated {canceled}")
         self._handle_event(canceled)
 
     def _generate_order_expired(self, order: Order, report: OrderStatusReport) -> None:
         expired = OrderExpired(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=report.instrument_id,
@@ -1007,15 +1007,15 @@
             venue_order_id=report.venue_order_id,
             account_id=report.account_id,
             event_id=UUID4(),
             ts_event=report.ts_last,
             ts_init=self._clock.timestamp_ns(),
             reconciliation=True,
         )
-        self._log.debug(f"Generated {expired}.")
+        self._log.debug(f"Generated {expired}")
         self._handle_event(expired)
 
     def _generate_order_filled(
         self,
         order: Order,
         report: FillReport,
         instrument: Instrument,
@@ -1037,15 +1037,15 @@
             commission=report.commission,
             liquidity_side=report.liquidity_side,
             event_id=UUID4(),
             ts_event=report.ts_event,
             ts_init=self._clock.timestamp_ns(),
             reconciliation=True,
         )
-        self._log.debug(f"Generated {filled}.")
+        self._log.debug(f"Generated {filled}")
         self._handle_event(filled)
 
     def _should_update(self, order: Order, report: OrderStatusReport) -> bool:
         if report.quantity != order.quantity:
             return True
 
         if order.order_type == OrderType.LIMIT and report.price != order.price:
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/live/factories.py` & `nautilus_trader-1.191.0/nautilus_trader/live/factories.py`

 * *Files 2% similar despite different names*

```diff
@@ -42,15 +42,15 @@
         Return a new data client.
 
         Parameters
         ----------
         loop : asyncio.AbstractEventLoop
             The event loop for the client.
         name : str
-            The client name.
+            The custom client ID.
         config : dict[str, object]
             The configuration for the client.
         msgbus : MessageBus
             The message bus for the client.
         cache : Cache
             The cache for the client.
         clock : LiveClock
@@ -84,15 +84,15 @@
         Return a new execution client.
 
         Parameters
         ----------
         loop : asyncio.AbstractEventLoop
             The event loop for the client.
         name : str
-            The client name.
+            The custom client ID.
         config : dict[str, object]
             The configuration for the client.
         msgbus : MessageBus
             The message bus for the client.
         cache : Cache
             The cache for the client.
         clock : LiveClock
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/live/node.py` & `nautilus_trader-1.191.0/nautilus_trader/live/node.py`

 * *Files 1% similar despite different names*

```diff
@@ -286,17 +286,17 @@
                     "Run `node.build()` prior to start.",
                 )
 
             self._is_running = True
             await self.kernel.start_async()
 
             if self.kernel.loop.is_running():
-                self.kernel.logger.info("RUNNING.")
+                self.kernel.logger.info("RUNNING")
             else:
-                self.kernel.logger.warning("Event loop is not running.")
+                self.kernel.logger.warning("Event loop is not running")
 
             # Continue to run while engines are running...
             tasks: list[asyncio.Task] = [
                 self.kernel.data_engine.get_cmd_queue_task(),
                 self.kernel.data_engine.get_req_queue_task(),
                 self.kernel.data_engine.get_res_queue_task(),
                 self.kernel.data_engine.get_data_queue_task(),
@@ -326,15 +326,15 @@
         Parameters
         ----------
         interval : float
             The interval (seconds) between heartbeats.
 
         """
         self.kernel.logger.info(
-            f"Starting heartbeats at {interval}s intervals...",
+            f"Starting task: heartbeats at {interval}s intervals",
             LogColor.BLUE,
         )
         try:
             while True:
                 await asyncio.sleep(interval)
                 msg = self.kernel.clock.utc_now()
                 if self._has_cache_backing:
@@ -354,15 +354,15 @@
         Parameters
         ----------
         interval : float
             The interval (seconds) between open position state snapshotting.
 
         """
         self.kernel.logger.info(
-            f"Starting open position snapshots at {interval}s intervals...",
+            f"Starting task: snapshot open positions at {interval}s intervals",
             LogColor.BLUE,
         )
         try:
             while True:
                 await asyncio.sleep(interval)
                 open_positions = self.kernel.cache.positions_open()
                 for position in open_positions:
@@ -410,20 +410,20 @@
 
         After a specified delay the internal `Trader` residual state will be checked.
 
         If save strategy is configured, then strategy states will be saved.
 
         """
         if self._task_heartbeats:
-            self.kernel.logger.info("Cancelling `task_heartbeats` task...")
+            self.kernel.logger.info("Cancelling `task_heartbeats` task")
             self._task_heartbeats.cancel()
             self._task_heartbeats = None
 
         if self._task_position_snapshots:
-            self.kernel.logger.info("Cancelling `task_position_snapshots` task...")
+            self.kernel.logger.info("Cancelling `task_position_snapshots` task")
             self._task_position_snapshots.cancel()
             self._task_position_snapshots = None
 
         await self.kernel.stop_async()
 
         self._is_running = False
 
@@ -438,61 +438,61 @@
             timeout = self.kernel.clock.utc_now() + timedelta(
                 seconds=self._config.timeout_disconnection,
             )
             while self._is_running:
                 time.sleep(0.1)
                 if self.kernel.clock.utc_now() >= timeout:
                     self.kernel.logger.warning(
-                        f"Timed out ({self._config.timeout_disconnection}s) waiting for node to stop."
+                        f"Timed out ({self._config.timeout_disconnection}s) waiting for node to stop"
                         f"\nStatus"
                         f"\n------"
                         f"\nDataEngine.check_disconnected() == {self.kernel.data_engine.check_disconnected()}"
                         f"\nExecEngine.check_disconnected() == {self.kernel.exec_engine.check_disconnected()}",
                     )
                     break
 
-            self.kernel.logger.debug("DISPOSING...")
+            self.kernel.logger.debug("DISPOSING")
 
             self.kernel.logger.debug(str(self.kernel.data_engine.get_cmd_queue_task()))
             self.kernel.logger.debug(str(self.kernel.data_engine.get_req_queue_task()))
             self.kernel.logger.debug(str(self.kernel.data_engine.get_res_queue_task()))
             self.kernel.logger.debug(str(self.kernel.data_engine.get_data_queue_task()))
             self.kernel.logger.debug(str(self.kernel.exec_engine.get_cmd_queue_task()))
             self.kernel.logger.debug(str(self.kernel.exec_engine.get_evt_queue_task()))
             self.kernel.logger.debug(str(self.kernel.risk_engine.get_cmd_queue_task()))
             self.kernel.logger.debug(str(self.kernel.risk_engine.get_evt_queue_task()))
 
             self.kernel.dispose()
 
             if self.kernel.executor:
-                self.kernel.logger.info("Shutting down executor...")
+                self.kernel.logger.info("Shutting down executor")
                 self.kernel.executor.shutdown(wait=True, cancel_futures=True)
 
-            self.kernel.logger.info("Stopping event loop...")
+            self.kernel.logger.info("Stopping event loop")
             self.kernel.cancel_all_tasks()
             self.kernel.loop.stop()
         except (asyncio.CancelledError, RuntimeError) as e:
             self.kernel.logger.exception("Error on dispose", e)
         finally:
             if self.kernel.loop.is_running():
-                self.kernel.logger.warning("Cannot close a running event loop.")
+                self.kernel.logger.warning("Cannot close a running event loop")
             else:
-                self.kernel.logger.info("Closing event loop...")
+                self.kernel.logger.info("Closing event loop")
                 self.kernel.loop.close()
 
             # Check and log if event loop is running
             if self.kernel.loop.is_running():
                 self.kernel.logger.warning(f"loop.is_running={self.kernel.loop.is_running()}")
             else:
                 self.kernel.logger.info(f"loop.is_running={self.kernel.loop.is_running()}")
 
             # Check and log if event loop is closed
             if not self.kernel.loop.is_closed():
                 self.kernel.logger.warning(f"loop.is_closed={self.kernel.loop.is_closed()}")
             else:
                 self.kernel.logger.info(f"loop.is_closed={self.kernel.loop.is_closed()}")
 
-            self.kernel.logger.info("DISPOSED.")
+            self.kernel.logger.info("DISPOSED")
 
     def _loop_sig_handler(self, sig: signal.Signals) -> None:
-        self.kernel.logger.warning(f"Received {sig!s}, shutting down...")
+        self.kernel.logger.warning(f"Received {sig!s}, shutting down")
         self.stop()
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/live/node_builder.py` & `nautilus_trader-1.191.0/nautilus_trader/live/node_builder.py`

 * *Files 2% similar despite different names*

```diff
@@ -102,15 +102,15 @@
 
         """
         PyCondition.valid_string(name, "name")
         PyCondition.not_none(factory, "factory")
         PyCondition.not_in(name, self._data_factories, "name", "_data_factories")
 
         if not issubclass(factory, LiveDataClientFactory):
-            self._log.error(f"Factory was not of type `LiveDataClientFactory`, was {factory}.")
+            self._log.error(f"Factory was not of type `LiveDataClientFactory`, was {factory}")
             return
 
         self._data_factories[name] = factory
 
     def add_exec_client_factory(self, name: str, factory: type[LiveExecClientFactory]) -> None:
         """
         Add the given client factory to the builder.
@@ -131,15 +131,15 @@
 
         """
         PyCondition.valid_string(name, "name")
         PyCondition.not_none(factory, "factory")
         PyCondition.not_in(name, self._exec_factories, "name", "_exec_factories")
 
         if not issubclass(factory, LiveExecClientFactory):
-            self._log.error(f"Factory was not of type `LiveExecClientFactory`, was {factory}.")
+            self._log.error(f"Factory was not of type `LiveExecClientFactory`, was {factory}")
             return
 
         self._exec_factories[name] = factory
 
     def build_data_clients(
         self,
         config: dict[str, LiveDataClientConfig],
@@ -152,29 +152,29 @@
         config : dict[str, ImportableConfig | LiveDataClientConfig]
             The data clients configuration.
 
         """
         PyCondition.not_none(config, "config")
 
         if not config:
-            self._log.warning("No `data_clients` configuration found.")
+            self._log.warning("No `data_clients` configuration found")
 
         for parts, cfg in config.items():
             name = parts.partition("-")[0]
-            self._log.info(f"Building data client for {name}.")
+            self._log.info(f"Building data client for {name}")
 
             if isinstance(cfg, ImportableConfig):
                 if name not in self._data_factories and cfg.factory is not None:
                     self._data_factories[name] = cfg.factory.create()
                 client_config: LiveDataClientConfig = cfg.create()
             else:
                 client_config: LiveDataClientConfig = cfg  # type: ignore
 
             if name not in self._data_factories:
-                self._log.error(f"No `LiveDataClientFactory` registered for {name}.")
+                self._log.error(f"No `LiveDataClientFactory` registered for {name}")
                 continue
 
             factory = self._data_factories[name]
 
             client = factory.create(
                 loop=self._loop,
                 name=name,
@@ -213,29 +213,29 @@
         config : dict[str, ImportableConfig | LiveExecClientConfig]
             The execution clients configuration.
 
         """
         PyCondition.not_none(config, "config")
 
         if not config:
-            self._log.warning("No `exec_clients` configuration found.")
+            self._log.warning("No `exec_clients` configuration found")
 
         for parts, cfg in config.items():
             name = parts.partition("-")[0]
-            self._log.info(f"Building execution client for {name}.")
+            self._log.info(f"Building execution client for {name}")
 
             if isinstance(cfg, ImportableConfig):
                 if name not in self._exec_factories and cfg.factory is not None:
                     self._exec_factories[name] = cfg.factory.create()
                 client_config: LiveExecClientConfig = cfg.create()
             else:
                 client_config: LiveExecClientConfig = cfg  # type: ignore
 
             if name not in self._exec_factories:
-                self._log.error(f"No `LiveExecClientFactory` registered for {name}.")
+                self._log.error(f"No `LiveExecClientFactory` registered for {name}")
                 continue
 
             factory = self._exec_factories[name]
 
             factory_kws = {
                 "loop": self._loop,
                 "name": name,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/live/risk_engine.py` & `nautilus_trader-1.191.0/nautilus_trader/live/risk_engine.py`

 * *Files 1% similar despite different names*

```diff
@@ -131,23 +131,23 @@
 
     # -- COMMANDS -------------------------------------------------------------------------------------
 
     def kill(self) -> None:
         """
         Kill the engine by abruptly canceling the queue task and calling stop.
         """
-        self._log.warning("Killing engine...")
+        self._log.warning("Killing engine")
         self._kill = True
         self.stop()
         if self._cmd_queue_task:
-            self._log.debug(f"Canceling {self._cmd_queue_task.get_name()}...")
+            self._log.debug(f"Canceling {self._cmd_queue_task.get_name()}")
             self._cmd_queue_task.cancel()
             self._cmd_queue_task = None
         if self._evt_queue_task:
-            self._log.debug(f"Canceling {self._evt_queue_task.get_name()}...")
+            self._log.debug(f"Canceling {self._evt_queue_task.get_name()}")
             self._evt_queue_task.cancel()
             self._evt_queue_task = None
 
     def execute(self, command: Command) -> None:
         """
         Execute the given command.
 
@@ -169,15 +169,15 @@
         # Do not allow None through (None is a sentinel value which stops the queue)
 
         try:
             self._loop.call_soon_threadsafe(self._cmd_queue.put_nowait, command)
         except asyncio.QueueFull:
             self._log.warning(
                 f"Blocking on `_cmd_queue.put` as queue full "
-                f"at {self._cmd_queue.qsize():_} items.",
+                f"at {self._cmd_queue.qsize():_} items",
             )
             # Schedule the `put` operation to be executed once there is space in the queue
             self._loop.create_task(self._cmd_queue.put(command))
 
     def process(self, event: Event) -> None:
         """
         Process the given event.
@@ -200,29 +200,29 @@
         # Do not allow None through (None is a sentinel value which stops the queue)
 
         try:
             self._loop.call_soon_threadsafe(self._evt_queue.put_nowait, event)
         except asyncio.QueueFull:
             self._log.warning(
                 f"Blocking on `_evt_queue.put` as queue full "
-                f"at {self._evt_queue.qsize():_} items.",
+                f"at {self._evt_queue.qsize():_} items",
             )
             # Schedule the `put` operation to be executed once there is space in the queue
             self._loop.create_task(self._evt_queue.put(event))
 
     # -- INTERNAL -------------------------------------------------------------------------------------
 
     def _enqueue_sentinel(self) -> None:
         self._loop.call_soon_threadsafe(self._cmd_queue.put_nowait, self._sentinel)
         self._loop.call_soon_threadsafe(self._evt_queue.put_nowait, self._sentinel)
-        self._log.debug("Sentinel messages placed on queues.")
+        self._log.debug("Sentinel messages placed on queues")
 
     def _on_start(self) -> None:
         if not self._loop.is_running():
-            self._log.warning("Started when loop is not running.")
+            self._log.warning("Started when loop is not running")
 
         self._cmd_queue_task = self._loop.create_task(self._run_cmd_queue(), name="cmd_queue")
         self._evt_queue_task = self._loop.create_task(self._run_evt_queue(), name="evt_queue")
 
         self._log.debug(f"Scheduled {self._cmd_queue_task}")
         self._log.debug(f"Scheduled {self._evt_queue_task}")
 
@@ -230,46 +230,46 @@
         if self._kill:
             return  # Avoids queuing redundant sentinel messages
         # This will stop the queues processing as soon as they see the sentinel message
         self._enqueue_sentinel()
 
     async def _run_cmd_queue(self) -> None:
         self._log.debug(
-            f"Command message queue processing (qsize={self.cmd_qsize()})...",
+            f"Command message queue processing (qsize={self.cmd_qsize()})",
         )
         try:
             while True:
                 command: Command | None = await self._cmd_queue.get()
                 if command is self._sentinel:
                     break
                 self._execute_command(command)
         except asyncio.CancelledError:
-            self._log.warning("Command message queue canceled.")
+            self._log.warning("Command message queue canceled")
         except RuntimeError as e:
-            self._log.error(f"RuntimeError: {e}.")
+            self._log.error(f"RuntimeError: {e}")
         finally:
             stopped_msg = "Command message queue stopped"
             if not self._cmd_queue.empty():
-                self._log.warning(f"{stopped_msg} with {self.cmd_qsize()} message(s) on queue.")
+                self._log.warning(f"{stopped_msg} with {self.cmd_qsize()} message(s) on queue")
             else:
-                self._log.debug(stopped_msg + ".")
+                self._log.debug(stopped_msg)
 
     async def _run_evt_queue(self) -> None:
         self._log.debug(
-            f"Event message queue processing starting (qsize={self.evt_qsize()})...",
+            f"Event message queue processing starting (qsize={self.evt_qsize()})",
         )
         try:
             while True:
                 event: Event | None = await self._evt_queue.get()
                 if event is self._sentinel:
                     break
                 self._handle_event(event)
         except asyncio.CancelledError:
-            self._log.warning("Event message queue canceled.")
+            self._log.warning("Event message queue canceled")
         except RuntimeError as e:
-            self._log.error(f"RuntimeError: {e}.")
+            self._log.error(f"RuntimeError: {e}")
         finally:
             stopped_msg = "Event message queue stopped"
             if not self._evt_queue.empty():
-                self._log.warning(f"{stopped_msg} with {self.evt_qsize()} message(s) on queue.")
+                self._log.warning(f"{stopped_msg} with {self.evt_qsize()} message(s) on queue")
             else:
-                self._log.debug(stopped_msg + ".")
+                self._log.debug(stopped_msg)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/model/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/book.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/book.pxd`

 * *Files 7% similar despite different names*

```diff
@@ -13,14 +13,15 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport uint8_t
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.data cimport Data
+from nautilus_trader.core.rust.model cimport BookType
 from nautilus_trader.core.rust.model cimport Level_API
 from nautilus_trader.core.rust.model cimport OrderBook_API
 from nautilus_trader.core.rust.model cimport OrderSide
 from nautilus_trader.model.data cimport BookOrder
 from nautilus_trader.model.data cimport OrderBookDelta
 from nautilus_trader.model.data cimport OrderBookDeltas
 from nautilus_trader.model.data cimport OrderBookDepth10
@@ -29,19 +30,20 @@
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
 cdef class OrderBook(Data):
     cdef OrderBook_API _mem
+    cdef BookType _book_type
 
     cpdef void reset(self)
-    cpdef void add(self, BookOrder order, uint64_t ts_event, uint64_t sequence=*)
-    cpdef void update(self, BookOrder order, uint64_t ts_event, uint64_t sequence=*)
-    cpdef void delete(self, BookOrder order, uint64_t ts_event, uint64_t sequence=*)
+    cpdef void add(self, BookOrder order, uint64_t ts_event, uint8_t flags=*, uint64_t sequence=*)
+    cpdef void update(self, BookOrder order, uint64_t ts_event, uint8_t flags=*, uint64_t sequence=*)
+    cpdef void delete(self, BookOrder order, uint64_t ts_event, uint8_t flags=*, uint64_t sequence=*)
     cpdef void clear(self, uint64_t ts_event, uint64_t sequence=*)
     cpdef void clear_bids(self, uint64_t ts_event, uint64_t sequence=*)
     cpdef void clear_asks(self, uint64_t ts_event, uint64_t sequence=*)
     cpdef void apply_delta(self, OrderBookDelta delta)
     cpdef void apply_deltas(self, OrderBookDeltas deltas)
     cpdef void apply_depth(self, OrderBookDepth10 depth)
     cpdef void apply(self, Data data)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/book.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/book.pyx`

 * *Files 10% similar despite different names*

```diff
@@ -99,14 +99,15 @@
     """
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
         BookType book_type,
     ) -> None:
+        self._book_type = book_type
         self._mem = orderbook_new(
             instrument_id._mem,
             book_type,
         )
 
     def __repr__(self) -> str:
         return (
@@ -126,14 +127,15 @@
             self.ts_last,
             self.sequence,
             pickle.dumps(orders),
         )
 
     def __setstate__(self, state):
         cdef InstrumentId instrument_id = InstrumentId.from_str_c(state[0])
+        self._book_type = state[1]
         self._mem = orderbook_new(
             instrument_id._mem,
             state[1],
         )
         cdef int64_t ts_last = state[2]
         cdef int64_t sequence = state[3]
         cdef list orders = pickle.loads(state[4])
@@ -160,15 +162,15 @@
         Return the order book type.
 
         Returns
         -------
         BookType
 
         """
-        return <BookType>orderbook_book_type(&self._mem)
+        return self._book_type
 
     @property
     def sequence(self) -> int:
         """
         Return the last sequence number for the book.
 
         Returns
@@ -228,87 +230,99 @@
 
     cpdef void reset(self):
         """
         Reset the order book (clear all stateful values).
         """
         orderbook_reset(&self._mem)
 
-    cpdef void add(self, BookOrder order, uint64_t ts_event, uint64_t sequence=0):
+    cpdef void add(self, BookOrder order, uint64_t ts_event, uint8_t flags=0, uint64_t sequence=0):
         """
         Add the given order to the book.
 
         Parameters
         ----------
         order : BookOrder
             The order to add.
-        sequence : uint64, default 0
+        ts_event : uint64_t
+            The UNIX timestamp (nanoseconds) when the book event occurred.
+        flags : uint8_t, default 0
+            The record flags bit field, indicating packet end and data information.
+        sequence : uint64_t, default 0
             The unique sequence number for the update. If default 0 then will increment the `sequence`.
 
         Raises
         ------
         RuntimeError
             If the book type is L1_MBP.
 
         """
         Condition.not_none(order, "order")
 
-        if self.book_type == BookType.L1_MBP:
+        if self._book_type == BookType.L1_MBP:
             raise RuntimeError("Invalid book operation: cannot add order for L1_MBP book")
 
-        orderbook_add(&self._mem, order._mem, ts_event, sequence)
+        orderbook_add(&self._mem, order._mem, flags, sequence, ts_event)
 
-    cpdef void update(self, BookOrder order, uint64_t ts_event, uint64_t sequence=0):
+    cpdef void update(self, BookOrder order, uint64_t ts_event, uint8_t flags=0, uint64_t sequence=0):
         """
         Update the given order in the book.
 
         Parameters
         ----------
         order : Order
             The order to update.
-        sequence : uint64, default 0
+        ts_event : uint64_t
+            The UNIX timestamp (nanoseconds) when the book event occurred.
+        flags : uint8_t, default 0
+            The record flags bit field, indicating packet end and data information.
+        sequence : uint64_t, default 0
             The unique sequence number for the update. If default 0 then will increment the `sequence`.
 
         """
         Condition.not_none(order, "order")
 
-        orderbook_update(&self._mem, order._mem, ts_event, sequence)
+        orderbook_update(&self._mem, order._mem, flags, sequence, ts_event)
 
-    cpdef void delete(self, BookOrder order, uint64_t ts_event, uint64_t sequence=0):
+    cpdef void delete(self, BookOrder order, uint64_t ts_event, uint8_t flags=0, uint64_t sequence=0):
         """
         Cancel the given order in the book.
 
         Parameters
         ----------
         order : Order
             The order to delete.
-        sequence : uint64, default 0
+        ts_event : uint64_t
+            The UNIX timestamp (nanoseconds) when the book event occurred.
+        flags : uint8_t, default 0
+            The record flags bit field, indicating packet end and data information.
+        sequence : uint64_t, default 0
             The unique sequence number for the update. If default 0 then will increment the `sequence`.
 
         """
         Condition.not_none(order, "order")
 
-        orderbook_delete(&self._mem, order._mem, ts_event, sequence)
+        orderbook_delete(&self._mem, order._mem, flags, sequence, ts_event)
 
     cpdef void clear(self, uint64_t ts_event, uint64_t sequence=0):
         """
         Clear the entire order book.
         """
-        orderbook_clear(&self._mem, ts_event, sequence)
+        orderbook_clear(&self._mem, sequence, ts_event)
 
     cpdef void clear_bids(self, uint64_t ts_event, uint64_t sequence=0):
         """
         Clear the bids from the order book.
         """
-        orderbook_clear_bids(&self._mem, ts_event, sequence)
+        orderbook_clear_bids(&self._mem, sequence, ts_event)
 
     cpdef void clear_asks(self, uint64_t ts_event, uint64_t sequence=0):
         """
         Clear the asks from the order book.
         """
-        orderbook_clear_asks(&self._mem, ts_event, sequence)
+        orderbook_clear_asks(&self._mem, sequence, ts_event)
 
     cpdef void apply_delta(self, OrderBookDelta delta):
         """
         Apply the order book delta.
 
         Parameters
         ----------
@@ -626,32 +640,58 @@
 
         return fills
 
     cpdef void update_quote_tick(self, QuoteTick tick):
         """
         Update the order book with the given quote tick.
 
+        This operation is only valid for ``L1_MBP`` books maintaining a top level.
+
         Parameters
         ----------
         tick : QuoteTick
             The quote tick to update with.
 
+        Raises
+        ------
+        RuntimeError
+            If `book_type` is not ``L1_MBP``.
+
         """
+        if self._book_type != BookType.L1_MBP:
+            raise RuntimeError(
+                "Invalid book operation: "
+                f"cannot update with tick for {book_type_to_str(self.book_type)} book",
+            )
+
         orderbook_update_quote_tick(&self._mem, &tick._mem)
 
     cpdef void update_trade_tick(self, TradeTick tick):
         """
         Update the order book with the given trade tick.
 
+        This operation is only valid for ``L1_MBP`` books maintaining a top level.
+
         Parameters
         ----------
         tick : TradeTick
             The trade tick to update with.
 
+        Raises
+        ------
+        RuntimeError
+            If `book_type` is not ``L1_MBP``.
+
         """
+        if self._book_type != BookType.L1_MBP:
+            raise RuntimeError(
+                "Invalid book operation: "
+                f"cannot update with tick for {book_type_to_str(self.book_type)} book",
+            )
+
         orderbook_update_trade_tick(&self._mem, &tick._mem)
 
     cpdef str pprint(self, int num_levels=3):
         """
         Return a string representation of the order book in a human-readable table format.
 
         Parameters
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/currencies.py` & `nautilus_trader-1.191.0/nautilus_trader/model/currencies.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/data.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/data.pxd`

 * *Files 6% similar despite different names*

```diff
@@ -150,14 +150,28 @@
 
     cdef readonly bint is_revision
     """If this bar is a revision for a previous bar with the same `ts_event`.\n\n:returns: `bool`"""
 
     cdef str to_str(self)
 
     @staticmethod
+    cdef Bar from_raw_c(
+        BarType bar_type,
+        int64_t open,
+        int64_t high,
+        int64_t low,
+        int64_t close,
+        uint8_t price_prec,
+        uint64_t volume,
+        uint8_t size_prec,
+        uint64_t ts_event,
+        uint64_t ts_init,
+    )
+
+    @staticmethod
     cdef Bar from_mem_c(Bar_t mem)
 
     @staticmethod
     cdef Bar from_pyo3_c(pyo3_bar)
 
     @staticmethod
     cdef Bar from_dict_c(dict values)
@@ -224,17 +238,17 @@
 
     @staticmethod
     cdef dict to_dict_c(OrderBookDelta obj)
 
     @staticmethod
     cdef OrderBookDelta clear_c(
         InstrumentId instrument_id,
+        uint64_t sequence,
         uint64_t ts_event,
         uint64_t ts_init,
-        uint64_t sequence=*,
     )
 
     @staticmethod
     cdef list capsule_to_list_c(capsule)
 
     @staticmethod
     cdef object list_to_capsule_c(list items)
@@ -349,14 +363,27 @@
         uint8_t bid_size_prec,
         uint8_t ask_size_prec,
         uint64_t ts_event,
         uint64_t ts_init,
     )
 
     @staticmethod
+    cdef list[QuoteTick] from_raw_arrays_to_list_c(
+        InstrumentId instrument_id,
+        uint8_t price_prec,
+        uint8_t size_prec,
+        int64_t[:] bid_prices_raw,
+        int64_t[:] ask_prices_raw,
+        uint64_t[:] bid_sizes_raw,
+        uint64_t[:] ask_sizes_raw,
+        uint64_t[:] ts_events,
+        uint64_t[:] ts_inits,
+    )
+
+    @staticmethod
     cdef QuoteTick from_mem_c(QuoteTick_t mem)
 
     @staticmethod
     cdef QuoteTick from_pyo3_c(pyo3_quote)
 
     @staticmethod
     cdef list capsule_to_list_c(capsule)
@@ -389,14 +416,27 @@
         AggressorSide aggressor_side,
         TradeId trade_id,
         uint64_t ts_event,
         uint64_t ts_init,
     )
 
     @staticmethod
+    cdef list[TradeTick] from_raw_arrays_to_list_c(
+        InstrumentId instrument_id,
+        uint8_t price_prec,
+        uint8_t size_prec,
+        int64_t[:] prices_raw,
+        uint64_t[:] sizes_raw,
+        uint8_t[:] aggressor_sides,
+        list[str] trade_ids,
+        uint64_t[:] ts_events,
+        uint64_t[:] ts_inits,
+    )
+
+    @staticmethod
     cdef TradeTick from_mem_c(TradeTick_t mem)
 
     @staticmethod
     cdef TradeTick from_pyo3_c(pyo3_trade)
 
     @staticmethod
     cdef list capsule_to_list_c(capsule)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/data.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/data.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -11,14 +11,16 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import pickle
 
+import numpy as np
+
 from nautilus_trader.core import nautilus_pyo3
 
 from cpython.datetime cimport timedelta
 from cpython.mem cimport PyMem_Free
 from cpython.mem cimport PyMem_Malloc
 from cpython.pycapsule cimport PyCapsule_Destructor
 from cpython.pycapsule cimport PyCapsule_GetPointer
@@ -126,14 +128,15 @@
 from nautilus_trader.model.functions cimport market_status_to_str
 from nautilus_trader.model.functions cimport order_side_from_str
 from nautilus_trader.model.functions cimport order_side_to_str
 from nautilus_trader.model.functions cimport price_type_from_str
 from nautilus_trader.model.functions cimport price_type_to_str
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport Symbol
+from nautilus_trader.model.identifiers cimport TradeId
 from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
 cdef inline BookOrder order_from_mem_c(BookOrder_t mem):
     cdef BookOrder order = BookOrder.__new__(BookOrder)
@@ -1014,14 +1017,42 @@
         return self._mem.ts_init
 
     @staticmethod
     cdef Bar from_mem_c(Bar_t mem):
         return bar_from_mem_c(mem)
 
     @staticmethod
+    cdef Bar from_raw_c(
+        BarType bar_type,
+        int64_t open,
+        int64_t high,
+        int64_t low,
+        int64_t close,
+        uint8_t price_prec,
+        uint64_t volume,
+        uint8_t size_prec,
+        uint64_t ts_event,
+        uint64_t ts_init,
+    ):
+        cdef Bar bar = Bar.__new__(Bar)
+        bar._mem = bar_new_from_raw(
+            bar_type._mem,
+            open,
+            high,
+            low,
+            close,
+            price_prec,
+            volume,
+            size_prec,
+            ts_event,
+            ts_init,
+        )
+        return bar
+
+    @staticmethod
     cdef Bar from_dict_c(dict values):
         Condition.not_none(values, "values")
         return Bar(
             bar_type=BarType.from_str_c(values["bar_type"]),
             open=Price.from_str_c(values["open"]),
             high=Price.from_str_c(values["high"]),
             low=Price.from_str_c(values["low"]),
@@ -1051,14 +1082,40 @@
         # SAFETY: Do NOT deallocate the capsule here
         # It is supposed to be deallocated by the creator
         capsule = pyo3_bar.as_pycapsule()
         cdef Data_t* ptr = <Data_t*>PyCapsule_GetPointer(capsule, NULL)
         return bar_from_mem_c(ptr.bar)
 
     @staticmethod
+    def from_raw(
+        BarType bar_type,
+        int64_t open,
+        int64_t high,
+        int64_t low,
+        int64_t close,
+        uint8_t price_prec,
+        uint64_t volume,
+        uint8_t size_prec,
+        uint64_t ts_event,
+        uint64_t ts_init,
+    ) -> Bar:
+        return Bar.from_raw_c(
+            bar_type,
+            open,
+            high,
+            low,
+            close,
+            price_prec,
+            volume,
+            size_prec,
+            ts_event,
+            ts_init,
+        )
+
+    @staticmethod
     def from_dict(dict values) -> Bar:
         """
         Return a bar parsed from the given values.
 
         Parameters
         ----------
         values : dict[str, object]
@@ -1557,34 +1614,36 @@
     ----------
     instrument_id : InstrumentId
         The instrument ID for the book.
     action : BookAction {``ADD``, ``UPDATE``, ``DELETE``, ``CLEAR``}
         The order book delta action.
     order : BookOrder, optional with no default so ``None`` must be passed explicitly
         The book order for the delta.
+    flags : uint8_t
+        The record flags bit field, indicating packet end and data information.
+        A value of zero indicates no flags.
+    sequence : uint64_t
+        The unique sequence number for the update.
+        If no sequence number provided in the source data then use a value of zero.
     ts_event : uint64_t
         The UNIX timestamp (nanoseconds) when the data event occurred.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the data object was initialized.
-    flags : uint8_t, default 0 (no flags)
-        A combination of packet end with matching engine status.
-    sequence : uint64_t, default 0
-        The unique sequence number for the update.
 
     """
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
         BookAction action,
         BookOrder order: BookOrder | None,
+        uint8_t flags,
+        uint64_t sequence,
         uint64_t ts_event,
         uint64_t ts_init,
-        uint8_t flags=0,
-        uint64_t sequence=0,
     ) -> None:
         # Placeholder for now
         cdef BookOrder_t book_order = order._mem if order is not None else book_order_from_raw(
             OrderSide.NO_ORDER_SIDE,
             0,
             0,
             0,
@@ -1871,25 +1930,26 @@
             "ts_event": obj._mem.ts_event,
             "ts_init": obj._mem.ts_init,
         }
 
     @staticmethod
     cdef OrderBookDelta clear_c(
         InstrumentId instrument_id,
+        uint64_t sequence,
         uint64_t ts_event,
         uint64_t ts_init,
-        uint64_t sequence=0,
     ):
         return OrderBookDelta(
             instrument_id=instrument_id,
             action=BookAction.CLEAR,
             order=None,
+            flags=0,
+            sequence=sequence,
             ts_event=ts_event,
             ts_init=ts_init,
-            sequence=sequence,
         )
 
     @staticmethod
     cdef list[OrderBookDelta] capsule_to_list_c(object capsule):
         # SAFETY: Do NOT deallocate the capsule here
         # It is supposed to be deallocated by the creator
         cdef CVec* data = <CVec*>PyCapsule_GetPointer(capsule, NULL)
@@ -1963,17 +2023,19 @@
         size_raw : uint64_t
             The order raw size (as a scaled fixed precision integer).
         size_prec : uint8_t
             The order size precision.
         order_id : uint64_t
             The order ID.
         flags : uint8_t
-            A combination of packet end with matching engine status.
+            The record flags bit field, indicating packet end and data information.
+            A value of zero indicates no flags.
         sequence : uint64_t
             The unique sequence number for the update.
+            If no sequence number provided in the source data then use a value of zero.
         ts_event : uint64_t
             The UNIX timestamp (nanoseconds) when the tick event occurred.
         ts_init : uint64_t
             The UNIX timestamp (nanoseconds) when the data object was initialized.
 
         Returns
         -------
@@ -2021,24 +2083,24 @@
         -------
         dict[str, object]
 
         """
         return OrderBookDelta.to_dict_c(obj)
 
     @staticmethod
-    def clear(InstrumentId instrument_id, uint64_t ts_event, uint64_t ts_init, uint64_t sequence=0):
+    def clear(InstrumentId instrument_id, uint64_t sequence, uint64_t ts_event, uint64_t ts_init):
         """
         Return an order book delta which acts as an initial ``CLEAR``.
 
         Returns
         -------
         OrderBookDelta
 
         """
-        return OrderBookDelta.clear_c(instrument_id, ts_event, ts_init, sequence)
+        return OrderBookDelta.clear_c(instrument_id, sequence, ts_event, ts_init)
 
     @staticmethod
     def to_pyo3_list(list[OrderBookDelta] deltas) -> list[nautilus_pyo3.OrderBookDelta]:
         """
         Return pyo3 Rust order book deltas converted from the given legacy Cython objects.
 
         Parameters
@@ -2415,17 +2477,19 @@
     asks : list[BookOrder]
         The ask side orders for the update.
     bid_counts : list[uint32_t]
         The count of bid orders per level for the update. Can be zeros if data not available.
     ask_counts : list[uint32_t]
         The count of ask orders per level for the update. Can be zeros if data not available.
     flags : uint8_t
-        A combination of packet end with matching engine status.
+        The record flags bit field, indicating packet end and data information.
+        A value of zero indicates no flags.
     sequence : uint64_t
         The unique sequence number for the update.
+        If no sequence number provided in the source data then use a value of zero.
     ts_event : uint64_t
         The UNIX timestamp (nanoseconds) when the tick event occurred.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the data object was initialized.
 
     Raises
     ------
@@ -3179,15 +3243,15 @@
 
         """
         return InstrumentClose.to_dict_c(obj)
 
 
 cdef class QuoteTick(Data):
     """
-    Represents a single quote tick in a financial market.
+    Represents a single quote tick in a market.
 
     Contains information about the best top of book bid and ask.
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The quotes instrument ID.
@@ -3436,14 +3500,78 @@
             ask_size_prec,
             ts_event,
             ts_init,
         )
         return quote
 
     @staticmethod
+    cdef list[QuoteTick] from_raw_arrays_to_list_c(
+        InstrumentId instrument_id,
+        uint8_t price_prec,
+        uint8_t size_prec,
+        int64_t[:] bid_prices_raw,
+        int64_t[:] ask_prices_raw,
+        uint64_t[:] bid_sizes_raw,
+        uint64_t[:] ask_sizes_raw,
+        uint64_t[:] ts_events,
+        uint64_t[:] ts_inits,
+    ):
+        Condition.true(len(bid_prices_raw) == len(ask_prices_raw) == len(bid_sizes_raw) == len(ask_sizes_raw)
+                       == len(ts_events) == len(ts_inits), "Array lengths must be equal")
+
+        cdef int count = ts_events.shape[0]
+        cdef list[QuoteTick] ticks = []
+
+        cdef:
+            int i
+            QuoteTick quote
+        for i in range(count):
+            quote = QuoteTick.__new__(QuoteTick)
+            quote._mem = quote_tick_new(
+                instrument_id._mem,
+                bid_prices_raw[i],
+                ask_prices_raw[i],
+                price_prec,
+                price_prec,
+                bid_sizes_raw[i],
+                ask_sizes_raw[i],
+                size_prec,
+                size_prec,
+                ts_events[i],
+                ts_inits[i],
+            )
+            ticks.append(quote)
+
+        return ticks
+
+    @staticmethod
+    def from_raw_arrays_to_list(
+        instrument_id: InstrumentId,
+        price_prec: int,
+        size_prec: int,
+        bid_prices_raw: np.ndarray,
+        ask_prices_raw: np.ndarray,
+        bid_sizes_raw: np.ndarray,
+        ask_sizes_raw: np.ndarray,
+        ts_events: np.ndarray,
+        ts_inits: np.ndarray,
+    ) -> list[QuoteTick]:
+        return QuoteTick.from_raw_arrays_to_list_c(
+            instrument_id,
+            price_prec,
+            size_prec,
+            bid_prices_raw,
+            ask_prices_raw,
+            bid_sizes_raw,
+            ask_sizes_raw,
+            ts_events,
+            ts_inits,
+        )
+
+    @staticmethod
     cdef list[QuoteTick] capsule_to_list_c(object capsule):
         # SAFETY: Do NOT deallocate the capsule here
         # It is supposed to be deallocated by the creator
         cdef CVec* data = <CVec*>PyCapsule_GetPointer(capsule, NULL)
         cdef QuoteTick_t* ptr = <QuoteTick_t*>data.ptr
         cdef list[QuoteTick] quotes = []
 
@@ -3711,15 +3839,15 @@
             return self.ask_size
         else:
             raise ValueError(f"Cannot extract with PriceType {price_type_to_str(price_type)}")
 
 
 cdef class TradeTick(Data):
     """
-    Represents a single trade tick in a financial market.
+    Represents a single trade tick in a market.
 
     Contains information about a single unique trade which matched buyer and
     seller counterparties.
 
     Parameters
     ----------
     instrument_id : InstrumentId
@@ -3927,14 +4055,80 @@
             trade_id._mem,
             ts_event,
             ts_init,
         )
         return trade
 
     @staticmethod
+    cdef list[TradeTick] from_raw_arrays_to_list_c(
+        InstrumentId instrument_id,
+        uint8_t price_prec,
+        uint8_t size_prec,
+        int64_t[:] prices_raw,
+        uint64_t[:] sizes_raw,
+        uint8_t[:] aggressor_sides,
+        list[str] trade_ids,
+        uint64_t[:] ts_events,
+        uint64_t[:] ts_inits,
+    ):
+        Condition.true(len(prices_raw) == len(sizes_raw) == len(aggressor_sides) == len(trade_ids) ==
+                       len(ts_events) == len(ts_inits), "Array lengths must be equal")
+
+        cdef int count = ts_events.shape[0]
+        cdef list[TradeTick] trades = []
+
+        cdef:
+            int i
+            AggressorSide aggressor_side
+            TradeId trade_id
+            TradeTick trade
+        for i in range(count):
+            aggressor_side = <AggressorSide>aggressor_sides[i]
+            trade_id = TradeId(trade_ids[i])
+            trade = TradeTick.__new__(TradeTick)
+            trade._mem = trade_tick_new(
+                instrument_id._mem,
+                prices_raw[i],
+                price_prec,
+                sizes_raw[i],
+                size_prec,
+                aggressor_side,
+                trade_id._mem,
+                ts_events[i],
+                ts_inits[i],
+            )
+            trades.append(trade)
+
+        return trades
+
+    @staticmethod
+    def from_raw_arrays_to_list(
+        InstrumentId instrument_id,
+        uint8_t price_prec,
+        uint8_t size_prec,
+        int64_t[:] prices_raw,
+        uint64_t[:] sizes_raw,
+        uint8_t[:] aggressor_sides,
+        list[str] trade_ids,
+        uint64_t[:] ts_events,
+        uint64_t[:] ts_inits,
+    ) -> list[TradeTick]:
+        return TradeTick.from_raw_arrays_to_list_c(
+            instrument_id,
+            price_prec,
+            size_prec,
+            prices_raw,
+            sizes_raw,
+            aggressor_sides,
+            trade_ids,
+            ts_events,
+            ts_inits,
+        )
+
+    @staticmethod
     cdef list[TradeTick] capsule_to_list_c(capsule):
         # SAFETY: Do NOT deallocate the capsule here
         # It is supposed to be deallocated by the creator
         cdef CVec* data = <CVec *>PyCapsule_GetPointer(capsule, NULL)
         cdef TradeTick_t* ptr = <TradeTick_t *>data.ptr
         cdef list[TradeTick] trades = []
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/enums.py` & `nautilus_trader-1.191.0/nautilus_trader/model/enums.py`

 * *Files 7% similar despite different names*

```diff
@@ -29,14 +29,15 @@
 from nautilus_trader.core.rust.model import OmsType
 from nautilus_trader.core.rust.model import OptionKind
 from nautilus_trader.core.rust.model import OrderSide
 from nautilus_trader.core.rust.model import OrderStatus
 from nautilus_trader.core.rust.model import OrderType
 from nautilus_trader.core.rust.model import PositionSide
 from nautilus_trader.core.rust.model import PriceType
+from nautilus_trader.core.rust.model import RecordFlag
 from nautilus_trader.core.rust.model import TimeInForce
 from nautilus_trader.core.rust.model import TradingState
 from nautilus_trader.core.rust.model import TrailingOffsetType
 from nautilus_trader.core.rust.model import TriggerType
 from nautilus_trader.model.data import BarAggregation
 from nautilus_trader.model.functions import account_type_from_str
 from nautilus_trader.model.functions import account_type_to_str
@@ -76,14 +77,16 @@
 from nautilus_trader.model.functions import order_status_to_str
 from nautilus_trader.model.functions import order_type_from_str
 from nautilus_trader.model.functions import order_type_to_str
 from nautilus_trader.model.functions import position_side_from_str
 from nautilus_trader.model.functions import position_side_to_str
 from nautilus_trader.model.functions import price_type_from_str
 from nautilus_trader.model.functions import price_type_to_str
+from nautilus_trader.model.functions import record_flag_from_str
+from nautilus_trader.model.functions import record_flag_to_str
 from nautilus_trader.model.functions import time_in_force_from_str
 from nautilus_trader.model.functions import time_in_force_to_str
 from nautilus_trader.model.functions import trading_state_from_str
 from nautilus_trader.model.functions import trading_state_to_str
 from nautilus_trader.model.functions import trailing_offset_type_from_str
 from nautilus_trader.model.functions import trailing_offset_type_to_str
 from nautilus_trader.model.functions import trigger_type_from_str
@@ -106,14 +109,15 @@
     "LiquiditySide",
     "MarketStatus",
     "OmsType",
     "OptionKind",
     "OrderSide",
     "OrderStatus",
     "OrderType",
+    "RecordFlag",
     "PositionSide",
     "PriceType",
     "TimeInForce",
     "TradingState",
     "TrailingOffsetType",
     "TriggerType",
     "account_type_to_str",
@@ -150,14 +154,16 @@
     "option_kind_from_str",
     "order_side_to_str",
     "order_side_from_str",
     "order_status_to_str",
     "order_status_from_str",
     "order_type_to_str",
     "order_type_from_str",
+    "record_flag_to_str",
+    "record_flag_from_str",
     "position_side_to_str",
     "position_side_from_str",
     "price_type_to_str",
     "price_type_from_str",
     "time_in_force_to_str",
     "time_in_force_from_str",
     "trading_state_to_str",
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/events/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/events/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/events/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/model/events/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/events/account.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/events/account.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/events/account.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/events/account.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -31,15 +31,15 @@
     """
     Represents an event which includes information on the state of the account.
 
     Parameters
     ----------
     account_id : AccountId
         The account ID (with the venue).
-    account_type : AccountId
+    account_type : AccountType
         The account type for the event.
     base_currency : Currency, optional
         The account base currency. Use None for multi-currency accounts.
     reported : bool
         If the state is reported from the exchange (otherwise system calculated).
     balances : list[AccountBalance]
         The account balances.
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/events/order.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/events/order.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/events/order.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/events/order.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/events/position.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/events/position.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/events/position.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/events/position.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/functions.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/functions.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -29,14 +29,15 @@
 from nautilus_trader.core.rust.model cimport OmsType
 from nautilus_trader.core.rust.model cimport OptionKind
 from nautilus_trader.core.rust.model cimport OrderSide
 from nautilus_trader.core.rust.model cimport OrderStatus
 from nautilus_trader.core.rust.model cimport OrderType
 from nautilus_trader.core.rust.model cimport PositionSide
 from nautilus_trader.core.rust.model cimport PriceType
+from nautilus_trader.core.rust.model cimport RecordFlag
 from nautilus_trader.core.rust.model cimport TimeInForce
 from nautilus_trader.core.rust.model cimport TradingState
 from nautilus_trader.core.rust.model cimport TrailingOffsetType
 from nautilus_trader.core.rust.model cimport TriggerType
 from nautilus_trader.model.data cimport BarAggregation
 from nautilus_trader.model.objects cimport Currency
 
@@ -94,14 +95,17 @@
 
 cpdef OrderStatus order_status_from_str(str value)
 cpdef str order_status_to_str(OrderStatus value)
 
 cpdef OrderType order_type_from_str(str value)
 cpdef str order_type_to_str(OrderType value)
 
+cpdef RecordFlag record_flag_from_str(str value)
+cpdef str record_flag_to_str(RecordFlag value)
+
 cpdef PositionSide position_side_from_str(str value)
 cpdef str position_side_to_str(PositionSide value)
 
 cpdef PriceType price_type_from_str(str value)
 cpdef str price_type_to_str(PriceType value)
 
 cpdef TimeInForce time_in_force_from_str(str value)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/functions.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/functions.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -53,14 +53,16 @@
 from nautilus_trader.core.rust.model cimport order_status_to_cstr
 from nautilus_trader.core.rust.model cimport order_type_from_cstr
 from nautilus_trader.core.rust.model cimport order_type_to_cstr
 from nautilus_trader.core.rust.model cimport position_side_from_cstr
 from nautilus_trader.core.rust.model cimport position_side_to_cstr
 from nautilus_trader.core.rust.model cimport price_type_from_cstr
 from nautilus_trader.core.rust.model cimport price_type_to_cstr
+from nautilus_trader.core.rust.model cimport record_flag_from_cstr
+from nautilus_trader.core.rust.model cimport record_flag_to_cstr
 from nautilus_trader.core.rust.model cimport time_in_force_from_cstr
 from nautilus_trader.core.rust.model cimport time_in_force_to_cstr
 from nautilus_trader.core.rust.model cimport trading_state_from_cstr
 from nautilus_trader.core.rust.model cimport trading_state_to_cstr
 from nautilus_trader.core.rust.model cimport trailing_offset_type_from_cstr
 from nautilus_trader.core.rust.model cimport trailing_offset_type_to_cstr
 from nautilus_trader.core.rust.model cimport trigger_type_from_cstr
@@ -217,14 +219,22 @@
     return order_type_from_cstr(pystr_to_cstr(value))
 
 
 cpdef str order_type_to_str(OrderType value):
     return cstr_to_pystr(order_type_to_cstr(value))
 
 
+cpdef RecordFlag record_flag_from_str(str value):
+    return record_flag_from_cstr(pystr_to_cstr(value))
+
+
+cpdef str record_flag_to_str(RecordFlag value):
+    return cstr_to_pystr(record_flag_to_cstr(value))
+
+
 cpdef PositionSide position_side_from_str(str value):
     return position_side_from_cstr(pystr_to_cstr(value))
 
 
 cpdef str position_side_to_str(PositionSide value):
     return cstr_to_pystr(position_side_to_cstr(value))
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/identifiers.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/identifiers.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/identifiers.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/identifiers.pyx`

 * *Files 10% similar despite different names*

```diff
@@ -101,15 +101,15 @@
 
         """
         return self.to_str()
 
 
 cdef class Symbol(Identifier):
     """
-    Represents a valid ticker symbol ID for a tradable financial market instrument.
+    Represents a valid ticker symbol ID for a tradable instrument.
 
     Parameters
     ----------
     value : str
         The ticker symbol ID value.
 
     Raises
@@ -135,27 +135,27 @@
 
     def __setstate__(self, state):
         self._mem = symbol_new(pystr_to_cstr(state))
 
     def __eq__(self, Symbol other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return strcmp(self._mem.value, other._mem.value) == 0
+        return strcmp(self._mem._0, other._mem._0) == 0
 
     def __hash__(self) -> int:
         return hash(self.to_str())
 
     @staticmethod
     cdef Symbol from_mem_c(Symbol_t mem):
         cdef Symbol symbol = Symbol.__new__(Symbol)
         symbol._mem = mem
         return symbol
 
     cdef str to_str(self):
-        return ustr_to_pystr(self._mem.value)
+        return ustr_to_pystr(self._mem._0)
 
 
 cdef class Venue(Identifier):
     """
     Represents a valid trading venue ID.
 
     Parameters
@@ -178,21 +178,21 @@
 
     def __setstate__(self, state):
         self._mem = venue_new(pystr_to_cstr(state))
 
     def __eq__(self, Venue other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return strcmp(self._mem.value, other._mem.value) == 0
+        return strcmp(self._mem._0, other._mem._0) == 0
 
     def __hash__(self) -> int:
         return hash(self.to_str())
 
     cdef str to_str(self):
-        return ustr_to_pystr(self._mem.value)
+        return ustr_to_pystr(self._mem._0)
 
     @staticmethod
     cdef Venue from_mem_c(Venue_t mem):
         cdef Venue venue = Venue.__new__(Venue)
         venue._mem = mem
         return venue
 
@@ -290,15 +290,15 @@
         self._mem = instrument_id_from_cstr(
             pystr_to_cstr(state),
         )
 
     def __eq__(self, InstrumentId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return strcmp(self._mem.symbol.value, other._mem.symbol.value) == 0 and strcmp(self._mem.venue.value, other._mem.venue.value) == 0
+        return strcmp(self._mem.symbol._0, other._mem.symbol._0) == 0 and strcmp(self._mem.venue._0, other._mem.venue._0) == 0
 
     def __hash__(self) -> int:
         return hash(self.to_str())
 
     @staticmethod
     cdef InstrumentId from_mem_c(InstrumentId_t mem):
         cdef InstrumentId instrument_id = InstrumentId.__new__(InstrumentId)
@@ -386,27 +386,27 @@
 
     def __setstate__(self, state):
         self._mem = component_id_new(pystr_to_cstr(state))
 
     def __eq__(self, ComponentId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return strcmp(self._mem.value, other._mem.value) == 0
+        return strcmp(self._mem._0, other._mem._0) == 0
 
     def __hash__(self) -> int:
         return hash(self.to_str())
 
     @staticmethod
     cdef ComponentId from_mem_c(ComponentId_t mem):
         cdef ComponentId component_id = ComponentId.__new__(ComponentId)
         component_id._mem = mem
         return component_id
 
     cdef str to_str(self):
-        return ustr_to_pystr(self._mem.value)
+        return ustr_to_pystr(self._mem._0)
 
 
 cdef class ClientId(Identifier):
     """
     Represents a system client ID.
 
     Parameters
@@ -433,27 +433,27 @@
 
     def __setstate__(self, state):
         self._mem = client_id_new(pystr_to_cstr(state))
 
     def __eq__(self, ClientId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return strcmp(self._mem.value, other._mem.value) == 0
+        return strcmp(self._mem._0, other._mem._0) == 0
 
     def __hash__(self) -> int:
         return hash(self.to_str())
 
     @staticmethod
     cdef ClientId from_mem_c(ClientId_t mem):
         cdef ClientId client_id = ClientId.__new__(ClientId)
         client_id._mem = mem
         return client_id
 
     cdef str to_str(self):
-        return ustr_to_pystr(self._mem.value)
+        return ustr_to_pystr(self._mem._0)
 
 
 cdef class TraderId(Identifier):
     """
     Represents a valid trader ID.
 
     Must be correctly formatted with two valid strings either side of a hyphen.
@@ -489,27 +489,27 @@
 
     def __setstate__(self, state):
         self._mem = trader_id_new(pystr_to_cstr(state))
 
     def __eq__(self, TraderId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return strcmp(self._mem.value, other._mem.value) == 0
+        return strcmp(self._mem._0, other._mem._0) == 0
 
     def __hash__(self) -> int:
         return hash(self.to_str())
 
     @staticmethod
     cdef TraderId from_mem_c(TraderId_t mem):
         cdef TraderId trader_id = TraderId.__new__(TraderId)
         trader_id._mem = mem
         return trader_id
 
     cdef str to_str(self):
-        return ustr_to_pystr(self._mem.value)
+        return ustr_to_pystr(self._mem._0)
 
     cpdef str get_tag(self):
         """
         Return the order ID tag value for this ID.
 
         Returns
         -------
@@ -562,15 +562,15 @@
 
     def __setstate__(self, state):
         self._mem = strategy_id_new(pystr_to_cstr(state))
 
     def __eq__(self, StrategyId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return strcmp(self._mem.value, other._mem.value) == 0
+        return strcmp(self._mem._0, other._mem._0) == 0
 
     def __hash__(self) -> int:
         return hash(self.to_str())
 
     @staticmethod
     cdef StrategyId from_mem_c(StrategyId_t mem):
         cdef StrategyId strategy_id = StrategyId.__new__(StrategyId)
@@ -578,15 +578,15 @@
         return strategy_id
 
     @staticmethod
     cdef StrategyId external_c():
         return EXTERNAL_STRATEGY_ID
 
     cdef str to_str(self):
-        return ustr_to_pystr(self._mem.value)
+        return ustr_to_pystr(self._mem._0)
 
     cpdef str get_tag(self):
         """
         Return the order ID tag value for this ID.
 
         Returns
         -------
@@ -633,27 +633,27 @@
 
     def __setstate__(self, state):
         self._mem = exec_algorithm_id_new(pystr_to_cstr(state))
 
     def __eq__(self, ExecAlgorithmId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return strcmp(self._mem.value, other._mem.value) == 0
+        return strcmp(self._mem._0, other._mem._0) == 0
 
     def __hash__(self) -> int:
         return hash(self.to_str())
 
     @staticmethod
     cdef ExecAlgorithmId from_mem_c(ExecAlgorithmId_t mem):
         cdef ExecAlgorithmId exec_algorithm_id = ExecAlgorithmId.__new__(ExecAlgorithmId)
         exec_algorithm_id._mem = mem
         return exec_algorithm_id
 
     cdef str to_str(self):
-        return ustr_to_pystr(self._mem.value)
+        return ustr_to_pystr(self._mem._0)
 
 
 
 cdef class AccountId(Identifier):
     """
     Represents a valid account ID.
 
@@ -688,27 +688,27 @@
 
     def __setstate__(self, state):
         self._mem = account_id_new(pystr_to_cstr(state))
 
     def __eq__(self, AccountId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return strcmp(self._mem.value, other._mem.value) == 0
+        return strcmp(self._mem._0, other._mem._0) == 0
 
     def __hash__(self) -> int:
         return hash(self.to_str())
 
     @staticmethod
     cdef AccountId from_mem_c(AccountId_t mem):
         cdef AccountId account_id = AccountId.__new__(AccountId)
         account_id._mem = mem
         return account_id
 
     cdef str to_str(self):
-        return ustr_to_pystr(self._mem.value)
+        return ustr_to_pystr(self._mem._0)
 
     cpdef str get_issuer(self):
         """
         Return the account issuer for this ID.
 
         Returns
         -------
@@ -757,27 +757,27 @@
 
     def __setstate__(self, state):
         self._mem = client_order_id_new(pystr_to_cstr(state))
 
     def __eq__(self, ClientOrderId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return strcmp(self._mem.value, other._mem.value) == 0
+        return strcmp(self._mem._0, other._mem._0) == 0
 
     def __hash__(self) -> int:
         return hash(self.to_str())
 
     @staticmethod
     cdef ClientOrderId from_mem_c(ClientOrderId_t mem):
         cdef ClientOrderId client_order_id = ClientOrderId.__new__(ClientOrderId)
         client_order_id._mem = mem
         return client_order_id
 
     cdef str to_str(self):
-        return ustr_to_pystr(self._mem.value)
+        return ustr_to_pystr(self._mem._0)
 
     cpdef bint is_this_trader(self, TraderId trader_id):
         """
         Return whether this client order ID is for the given trader ID instance.
 
         Will compare the given `trader_id.get_tag()` with this identifier.
 
@@ -822,27 +822,27 @@
 
     def __setstate__(self, state):
         self._mem = venue_order_id_new(pystr_to_cstr(state))
 
     def __eq__(self, VenueOrderId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return strcmp(self._mem.value, other._mem.value) == 0
+        return strcmp(self._mem._0, other._mem._0) == 0
 
     def __hash__(self) -> int:
         return hash(self.to_str())
 
     @staticmethod
     cdef VenueOrderId from_mem_c(VenueOrderId_t mem):
         cdef VenueOrderId venue_order_id = VenueOrderId.__new__(VenueOrderId)
         venue_order_id._mem = mem
         return venue_order_id
 
     cdef str to_str(self):
-        return ustr_to_pystr(self._mem.value)
+        return ustr_to_pystr(self._mem._0)
 
 
 cdef class OrderListId(Identifier):
     """
     Represents a valid order list ID (assigned by the Nautilus system).
 
     Parameters
@@ -865,27 +865,27 @@
 
     def __setstate__(self, state):
         self._mem = order_list_id_new(pystr_to_cstr(state))
 
     def __eq__(self, OrderListId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return strcmp(self._mem.value, other._mem.value) == 0
+        return strcmp(self._mem._0, other._mem._0) == 0
 
     def __hash__(self) -> int:
         return hash(self.to_str())
 
     @staticmethod
     cdef OrderListId from_mem_c(OrderListId_t mem):
         cdef OrderListId order_list_id = OrderListId.__new__(OrderListId)
         order_list_id._mem = mem
         return order_list_id
 
     cdef str to_str(self):
-        return ustr_to_pystr(self._mem.value)
+        return ustr_to_pystr(self._mem._0)
 
 
 cdef class PositionId(Identifier):
     """
     Represents a valid position ID.
 
     Parameters
@@ -908,27 +908,27 @@
 
     def __setstate__(self, state):
         self._mem = position_id_new(pystr_to_cstr(state))
 
     def __eq__(self, PositionId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return strcmp(self._mem.value, other._mem.value) == 0
+        return strcmp(self._mem._0, other._mem._0) == 0
 
     def __hash__(self) -> int:
         return hash(self.to_str())
 
     @staticmethod
     cdef PositionId from_mem_c(PositionId_t mem):
         cdef PositionId position_id = PositionId.__new__(PositionId)
         position_id._mem = mem
         return position_id
 
     cdef str to_str(self):
-        return ustr_to_pystr(self._mem.value)
+        return ustr_to_pystr(self._mem._0)
 
     cdef bint is_virtual_c(self):
         return self.to_str().startswith("P-")
 
 
 cdef class TradeId(Identifier):
     """
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/base.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/base.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/base.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -37,30 +37,30 @@
 from nautilus_trader.model.tick_scheme.base cimport get_tick_scheme
 
 
 cdef class Instrument(Data):
     """
     The base class for all instruments.
 
-    Represents a tradable financial market instrument. This class can be used to
+    Represents a tradable instrument. This class can be used to
     define an instrument, or act as a parent class for more specific instruments.
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The instrument ID for the instrument.
     raw_symbol : Symbol
         The raw/local/native symbol for the instrument, assigned by the venue.
     asset_class : AssetClass
         The instrument asset class.
     instrument_class : InstrumentClass
         The instrument class.
     quote_currency : Currency
         The quote currency.
-    is_inverse : Currency
+    is_inverse : bool
         If the instrument costing is inverse (quantity expressed in quote currency units).
     price_precision : int
         The price decimal precision.
     size_precision : int
         The trading size decimal precision.
     size_increment : Price
         The minimum size increment.
@@ -229,15 +229,15 @@
 
     def __eq__(self, Instrument other) -> bool:
         return self.id == other.id
 
     def __hash__(self) -> int:
         return hash(self.id)
 
-    def __repr__(self) -> str:  # TODO(cs): tick_scheme_name pending
+    def __repr__(self) -> str:  # TODO: tick_scheme_name pending
         return (
             f"{type(self).__name__}"
             f"(id={self.id.to_str()}, "
             f"raw_symbol={self.raw_symbol}, "
             f"asset_class={asset_class_to_str(self.asset_class)}, "
             f"instrument_class={instrument_class_to_str(self.instrument_class)}, "
             f"quote_currency={self.quote_currency}, "
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/betting.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/betting.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/betting.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/betting.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/crypto_future.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/crypto_future.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/crypto_future.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/crypto_future.pyx`

 * *Files 5% similar despite different names*

```diff
@@ -43,14 +43,18 @@
         The instrument ID for the instrument.
     raw_symbol : Symbol
         The raw/local/native symbol for the instrument, assigned by the venue.
     underlying : Currency
         The underlying asset.
     quote_currency : Currency
         The contract quote currency.
+    settlement_currency : Currency
+        The settlement currency.
+    is_inverse : bool
+        If the instrument costing is inverse (quantity expressed in quote currency units).
     activation_ns : uint64_t
         The UNIX timestamp (nanoseconds) for contract activation.
     expiration_ns : uint64_t
         The UNIX timestamp (nanoseconds) for contract expiration.
     price_precision : int
         The price decimal precision.
     size_precision : int
@@ -119,14 +123,15 @@
     def __init__(
         self,
         InstrumentId instrument_id not None,
         Symbol raw_symbol not None,
         Currency underlying not None,
         Currency quote_currency not None,
         Currency settlement_currency not None,
+        bint is_inverse,
         uint64_t activation_ns,
         uint64_t expiration_ns,
         int price_precision,
         int size_precision,
         Price price_increment not None,
         Quantity size_increment not None,
         margin_init not None: Decimal,
@@ -147,15 +152,15 @@
     ):
         super().__init__(
             instrument_id=instrument_id,
             raw_symbol=raw_symbol,
             asset_class=AssetClass.CRYPTOCURRENCY,
             instrument_class=InstrumentClass.FUTURE,
             quote_currency=quote_currency,
-            is_inverse=False,
+            is_inverse=is_inverse,
             price_precision=price_precision,
             size_precision=size_precision,
             price_increment=price_increment,
             size_increment=size_increment,
             multiplier=multiplier,
             lot_size=lot_size,
             max_quantity=max_quantity,
@@ -219,14 +224,15 @@
     cdef CryptoFuture from_pyo3_c(pyo3_instrument):
         return CryptoFuture(
             instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
             raw_symbol=Symbol(pyo3_instrument.id.symbol.value),
             underlying=Currency.from_str_c(pyo3_instrument.underlying.code),
             quote_currency=Currency.from_str_c(pyo3_instrument.quote_currency.code),
             settlement_currency=Currency.from_str_c(pyo3_instrument.settlement_currency.code),
+            is_inverse=pyo3_instrument.is_inverse,
             activation_ns=pyo3_instrument.activation_ns,
             expiration_ns=pyo3_instrument.expiration_ns,
             price_precision=pyo3_instrument.price_precision,
             size_precision=pyo3_instrument.size_precision,
             price_increment=Price.from_raw_c(pyo3_instrument.price_increment.raw, pyo3_instrument.price_precision),
             size_increment=Quantity.from_raw_c(pyo3_instrument.size_increment.raw, pyo3_instrument.size_precision),
             max_quantity=Quantity.from_raw_c(pyo3_instrument.max_quantity.raw,pyo3_instrument.max_quantity.precision) if pyo3_instrument.max_quantity is not None else None,
@@ -259,14 +265,15 @@
         cdef str min_p = values["min_price"]
         return CryptoFuture(
             instrument_id=InstrumentId.from_str_c(values["id"]),
             raw_symbol=Symbol(values["raw_symbol"]),
             underlying=Currency.from_str_c(values["underlying"]),
             quote_currency=Currency.from_str_c(values["quote_currency"]),
             settlement_currency=Currency.from_str_c(values["settlement_currency"]),
+            is_inverse=values["is_inverse"],
             activation_ns=values["activation_ns"],
             expiration_ns=values["expiration_ns"],
             price_precision=values["price_precision"],
             size_precision=values["size_precision"],
             price_increment=Price.from_str_c(values["price_increment"]),
             size_increment=Quantity.from_str_c(values["size_increment"]),
             max_quantity=Quantity.from_str_c(max_q) if max_q is not None else None,
@@ -290,14 +297,15 @@
         return {
             "type": "CryptoFuture",
             "id": obj.id.to_str(),
             "raw_symbol": obj.raw_symbol.to_str(),
             "underlying": obj.underlying.code,
             "quote_currency": obj.quote_currency.code,
             "settlement_currency": obj.settlement_currency.code,
+            "is_inverse": obj.is_inverse,
             "activation_ns": obj.activation_ns,
             "expiration_ns": obj.expiration_ns,
             "price_precision": obj.price_precision,
             "price_increment": str(obj.price_increment),
             "size_precision": obj.size_precision,
             "size_increment": str(obj.size_increment),
             "lot_size": str(obj.lot_size),
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/crypto_perpetual.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/futures_contract.pxd`

 * *Files 18% similar despite different names*

```diff
@@ -9,27 +9,30 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from libc.stdint cimport uint64_t
+
 from nautilus_trader.model.instruments.base cimport Instrument
-from nautilus_trader.model.objects cimport Currency
 
 
-cdef class CryptoPerpetual(Instrument):
-    cdef readonly Currency base_currency
-    """The base currency for the instrument.\n\n:returns: `Currency`"""
-    cdef readonly Currency settlement_currency
-    """The settlement currency for the instrument.\n\n:returns: `Currency`"""
-    cdef readonly bint is_quanto
-    """If the instrument is quanto.\n\n:returns: `bool`"""
+cdef class FuturesContract(Instrument):
+    cdef readonly str exchange
+    """The exchange ISO 10383 Market Identifier Code (MIC) where the instrument trades.\n\n:returns: `str` or ``None``"""
+    cdef readonly str underlying
+    """The underlying asset for the contract.\n\n:returns: `str`"""
+    cdef readonly uint64_t activation_ns
+    """The UNIX timestamp (nanoseconds) for contract activation.\n\n:returns: `unit64_t`"""
+    cdef readonly uint64_t expiration_ns
+    """The UNIX timestamp (nanoseconds) for contract expiration.\n\n:returns: `unit64_t`"""
 
     @staticmethod
-    cdef CryptoPerpetual from_dict_c(dict values)
+    cdef FuturesContract from_dict_c(dict values)
 
     @staticmethod
-    cdef dict to_dict_c(CryptoPerpetual obj)
+    cdef dict to_dict_c(FuturesContract obj)
 
     @staticmethod
-    cdef CryptoPerpetual from_pyo3_c(pyo3_instrument)
+    cdef FuturesContract from_pyo3_c(pyo3_instrument)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/crypto_perpetual.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/crypto_perpetual.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -42,15 +42,15 @@
         The raw/local/native symbol for the instrument, assigned by the venue.
     base_currency : Currency, optional
         The base currency.
     quote_currency : Currency
         The quote currency.
     settlement_currency : Currency
         The settlement currency.
-    is_inverse : Currency
+    is_inverse : bool
         If the instrument costing is inverse (quantity expressed in quote currency units).
     price_precision : int
         The price decimal precision.
     size_precision : int
         The trading size decimal precision.
     price_increment : Price
         The minimum price increment (tick size).
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/currency_pair.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/currency_pair.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/currency_pair.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/currency_pair.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/equity.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/equity.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/equity.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/equity.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -139,14 +139,15 @@
             isin=values.get("isin"),  # Can be None,
             margin_init=Decimal(values.get("margin_init", 0)) if values.get("margin_init") is not None else None,
             margin_maint=Decimal(values.get("margin_maint", 0)) if values.get("margin_maint") is not None else None,
             maker_fee=Decimal(values.get("maker_fee", 0)) if values.get("maker_fee") is not None else None,
             taker_fee=Decimal(values.get("taker_fee", 0))  if values.get("taker_fee") is not None else None,
             ts_event=values["ts_event"],
             ts_init=values["ts_init"],
+            info=values["info"],
         )
 
     @staticmethod
     cdef dict to_dict_c(Equity obj):
         Condition.not_none(obj, "obj")
         return {
             "type": "Equity",
@@ -163,14 +164,15 @@
             "taker_fee": str(obj.taker_fee),
             "min_price": str(obj.min_price) if obj.min_price is not None else None,
             "max_price": str(obj.max_price) if obj.max_price is not None else None,
             "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
             "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
             "ts_event": obj.ts_event,
             "ts_init": obj.ts_init,
+            "info": obj.info,
         }
 
     @staticmethod
     cdef Equity from_pyo3_c(pyo3_instrument):
         return Equity(
             instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
             raw_symbol=Symbol(pyo3_instrument.id.symbol.value),
@@ -181,14 +183,15 @@
             isin=pyo3_instrument.isin,
             margin_init=None,  # None for now
             margin_maint=None,  # None for now
             maker_fee=None,  # None for now
             taker_fee=None,  # None for now
             ts_event=pyo3_instrument.ts_event,
             ts_init=pyo3_instrument.ts_init,
+            info=pyo3_instrument.info,
         )
 
     @staticmethod
     def from_dict(dict values) -> Instrument:
         """
         Return an instrument from the given initialization values.
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/futures_contract.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/options_spread.pxd`

 * *Files 21% similar despite different names*

```diff
@@ -11,28 +11,32 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport uint64_t
 
+from nautilus_trader.core.rust.model cimport OptionKind
 from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.objects cimport Price
 
 
-cdef class FuturesContract(Instrument):
+cdef class OptionsSpread(Instrument):
     cdef readonly str exchange
-    """The exchange ISO 10383 Market Identifier Code (MIC) where the instrument trades.\n\n:returns: `str` or ``None``"""
+    """The exchang ISO 10383 Market Identifier Code (MIC) where the instrument trades.\n\n:returns: `str` or ``None``"""
     cdef readonly str underlying
     """The underlying asset for the contract.\n\n:returns: `str`"""
+    cdef readonly str strategy_type
+    """The strategy type of the spread.\n\n:returns: `str`"""
     cdef readonly uint64_t activation_ns
     """The UNIX timestamp (nanoseconds) for contract activation.\n\n:returns: `unit64_t`"""
     cdef readonly uint64_t expiration_ns
     """The UNIX timestamp (nanoseconds) for contract expiration.\n\n:returns: `unit64_t`"""
 
     @staticmethod
-    cdef FuturesContract from_dict_c(dict values)
+    cdef OptionsSpread from_dict_c(dict values)
 
     @staticmethod
-    cdef dict to_dict_c(FuturesContract obj)
+    cdef dict to_dict_c(OptionsSpread obj)
 
     @staticmethod
-    cdef FuturesContract from_pyo3_c(pyo3_instrument)
+    cdef OptionsSpread from_pyo3_c(pyo3_instrument)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/futures_contract.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/futures_contract.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/futures_spread.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/futures_spread.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/futures_spread.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/futures_spread.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/options_contract.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/options_contract.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/options_spread.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/list.pxd`

 * *Files 20% similar despite different names*

```diff
@@ -11,32 +11,26 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport uint64_t
 
-from nautilus_trader.core.rust.model cimport OptionKind
-from nautilus_trader.model.instruments.base cimport Instrument
-from nautilus_trader.model.objects cimport Price
-
-
-cdef class OptionsSpread(Instrument):
-    cdef readonly str exchange
-    """The exchang ISO 10383 Market Identifier Code (MIC) where the instrument trades.\n\n:returns: `str` or ``None``"""
-    cdef readonly str underlying
-    """The underlying asset for the contract.\n\n:returns: `str`"""
-    cdef readonly str strategy_type
-    """The strategy type of the spread.\n\n:returns: `str`"""
-    cdef readonly uint64_t activation_ns
-    """The UNIX timestamp (nanoseconds) for contract activation.\n\n:returns: `unit64_t`"""
-    cdef readonly uint64_t expiration_ns
-    """The UNIX timestamp (nanoseconds) for contract expiration.\n\n:returns: `unit64_t`"""
-
-    @staticmethod
-    cdef OptionsSpread from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OptionsSpread obj)
-
-    @staticmethod
-    cdef OptionsSpread from_pyo3_c(pyo3_instrument)
+from nautilus_trader.model.identifiers cimport InstrumentId
+from nautilus_trader.model.identifiers cimport OrderListId
+from nautilus_trader.model.identifiers cimport StrategyId
+from nautilus_trader.model.orders.base cimport Order
+
+
+cdef class OrderList:
+    cdef readonly OrderListId id
+    """The order list ID.\n\n:returns: `OrderListId`"""
+    cdef readonly InstrumentId instrument_id
+    """The instrument ID associated with the list.\n\n:returns: `InstrumentId`"""
+    cdef readonly StrategyId strategy_id
+    """The strategy ID associated with the list.\n\n:returns: `StrategyId`"""
+    cdef readonly list orders
+    """The contained orders list.\n\n:returns: `list[Order]`"""
+    cdef readonly Order first
+    """The first order in the list (typically the parent).\n\n:returns: `list[Order]`"""
+    cdef readonly uint64_t ts_init
+    """The UNIX timestamp (nanoseconds) when the object was initialized.\n\n:returns: `uint64_t`"""
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/options_spread.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/options_spread.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/synthetic.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/synthetic.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/instruments/synthetic.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/instruments/synthetic.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/objects.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/objects.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/objects.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/objects.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -512,15 +512,15 @@
         """
         return self.as_f64_c()
 
 
 @cython.auto_pickle(True)
 cdef class Price:
     """
-    Represents a price in a financial market.
+    Represents a price in a market.
 
     The number of decimal places may vary. For certain asset classes, prices may
     have negative values. For example, prices for options instruments can be
     negative under certain conditions.
 
     Handles up to 9 decimals of precision.
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/base.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/base.pxd`

 * *Files 0% similar despite different names*

```diff
@@ -46,16 +46,16 @@
 from nautilus_trader.model.identifiers cimport TradeId
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.model.identifiers cimport VenueOrderId
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
-cdef set VALID_STOP_ORDER_TYPES
-cdef set VALID_LIMIT_ORDER_TYPES
+cdef set STOP_ORDER_TYPES
+cdef set LIMIT_ORDER_TYPES
 cdef set LOCAL_ACTIVE_ORDER_STATUS
 
 
 cdef class Order:
     cdef list _events
     cdef list _venue_order_ids
     cdef list _trade_ids
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/base.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/base.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -52,22 +52,22 @@
 from nautilus_trader.model.functions cimport time_in_force_to_str
 from nautilus_trader.model.identifiers cimport TradeId
 from nautilus_trader.model.objects cimport Currency
 from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.objects cimport Quantity
 
 
-VALID_STOP_ORDER_TYPES = {
+STOP_ORDER_TYPES = {
     OrderType.STOP_MARKET,
     OrderType.STOP_LIMIT,
     OrderType.MARKET_IF_TOUCHED,
     OrderType.LIMIT_IF_TOUCHED,
 }
 
-VALID_LIMIT_ORDER_TYPES = {
+LIMIT_ORDER_TYPES = {
     OrderType.LIMIT,
     OrderType.STOP_LIMIT,
     OrderType.LIMIT_IF_TOUCHED,
     OrderType.MARKET_TO_LIMIT,
 }
 
 LOCAL_ACTIVE_ORDER_STATUS =  {
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/limit.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/limit.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/limit.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/limit.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -161,15 +161,15 @@
             # Must have an expire time
             Condition.true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
         else:
             # Should not have an expire time
             Condition.true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
         Condition.true(
             display_qty is None or 0 <= display_qty <= quantity,
-            fail_msg="display_qty was negative or greater than order quantity",
+            fail_msg="`display_qty` was negative or greater than `quantity`",
         )
 
         # Set options
         cdef dict options = {
             "price": str(price),
             "display_qty": str(display_qty) if display_qty is not None else None,
             "expire_time_ns": expire_time_ns,
@@ -315,15 +315,15 @@
             "account_id": self.account_id.to_str() if self.account_id is not None else None,
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
             "price": str(self.price),
             "time_in_force": time_in_force_to_str(self.time_in_force),
-            "expire_time_ns": self.expire_time_ns,
+            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
             "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
             "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else {},
             "status": self._fsm.state_string_c(),
             "is_post_only": self.is_post_only,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/limit_if_touched.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/limit_if_touched.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/limit_if_touched.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/limit_if_touched.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -175,15 +175,15 @@
             # Must have an expire time
             Condition.true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
         else:
             # Should not have an expire time
             Condition.true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
         Condition.true(
             display_qty is None or 0 <= display_qty <= quantity,
-            fail_msg="display_qty was negative or greater than order quantity",
+            fail_msg="`display_qty` was negative or greater than `quantity`",
         )
 
         # Set options
         cdef dict options = {
             "price": str(price),
             "trigger_price": str(trigger_price),
             "trigger_type": trigger_type_to_str(trigger_type),
@@ -308,15 +308,15 @@
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
             "price": str(self.price),
             "trigger_price": str(self.trigger_price),
             "trigger_type": trigger_type_to_str(self.trigger_type),
-            "expire_time_ns": self.expire_time_ns,
+            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
             "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
             "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "status": self._fsm.state_string_c(),
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/list.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/stop_limit.pxd`

 * *Files 21% similar despite different names*

```diff
@@ -11,26 +11,35 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport uint64_t
 
-from nautilus_trader.model.identifiers cimport InstrumentId
-from nautilus_trader.model.identifiers cimport OrderListId
-from nautilus_trader.model.identifiers cimport StrategyId
+from nautilus_trader.core.rust.model cimport TriggerType
+from nautilus_trader.model.events.order cimport OrderInitialized
+from nautilus_trader.model.objects cimport Price
+from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class OrderList:
-    cdef readonly OrderListId id
-    """The order list ID.\n\n:returns: `OrderListId`"""
-    cdef readonly InstrumentId instrument_id
-    """The instrument ID associated with the list.\n\n:returns: `InstrumentId`"""
-    cdef readonly StrategyId strategy_id
-    """The strategy ID associated with the list.\n\n:returns: `StrategyId`"""
-    cdef readonly list orders
-    """The contained orders list.\n\n:returns: `list[Order]`"""
-    cdef readonly Order first
-    """The first order in the list (typically the parent).\n\n:returns: `list[Order]`"""
-    cdef readonly uint64_t ts_init
-    """The UNIX timestamp (nanoseconds) when the object was initialized.\n\n:returns: `uint64_t`"""
+cdef class StopLimitOrder(Order):
+    cdef readonly Price price
+    """The order price (LIMIT).\n\n:returns: `Price`"""
+    cdef readonly Price trigger_price
+    """The order trigger price (STOP).\n\n:returns: `Price`"""
+    cdef readonly TriggerType trigger_type
+    """The trigger type for the order.\n\n:returns: `TriggerType`"""
+    cdef readonly uint64_t expire_time_ns
+    """The order expiration (UNIX epoch nanoseconds), zero for no expiration.\n\n:returns: `uint64_t`"""
+    cdef readonly Quantity display_qty
+    """The quantity of the ``LIMIT`` order to display on the public book (iceberg).\n\n:returns: `Quantity` or ``None``"""  # noqa
+    cdef readonly bint is_triggered
+    """If the order has been triggered.\n\n:returns: `bool`"""
+    cdef readonly uint64_t ts_triggered
+    """The UNIX timestamp (nanoseconds) when the order was triggered (0 if not triggered).\n\n:returns: `uint64_t`"""
+
+    @staticmethod
+    cdef StopLimitOrder create(OrderInitialized init)
+
+    @staticmethod
+    cdef StopLimitOrder from_pyo3_c(pyo3_order)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/list.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/list.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/market.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/market.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/market.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/market.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/market_if_touched.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/market_if_touched.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/market_if_touched.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/market_if_touched.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -276,15 +276,15 @@
             "account_id": self.account_id.to_str() if self.account_id is not None else None,
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
             "trigger_price": str(self.trigger_price),
             "trigger_type": trigger_type_to_str(self.trigger_type),
-            "expire_time_ns": self.expire_time_ns,
+            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
             "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
             "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "status": self._fsm.state_string_c(),
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/market_to_limit.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/market_to_limit.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/market_to_limit.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/trailing_stop_market.pyx`

 * *Files 16% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from decimal import Decimal
+
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.datetime cimport format_iso8601
 from nautilus_trader.core.datetime cimport unix_nanos_to_dt
 from nautilus_trader.core.rust.model cimport ContingencyType
 from nautilus_trader.core.rust.model cimport OrderSide
@@ -27,33 +29,32 @@
 from nautilus_trader.model.events.order cimport OrderInitialized
 from nautilus_trader.model.events.order cimport OrderUpdated
 from nautilus_trader.model.functions cimport contingency_type_to_str
 from nautilus_trader.model.functions cimport liquidity_side_to_str
 from nautilus_trader.model.functions cimport order_side_to_str
 from nautilus_trader.model.functions cimport order_type_to_str
 from nautilus_trader.model.functions cimport time_in_force_to_str
+from nautilus_trader.model.functions cimport trailing_offset_type_from_str
+from nautilus_trader.model.functions cimport trailing_offset_type_to_str
+from nautilus_trader.model.functions cimport trigger_type_from_str
+from nautilus_trader.model.functions cimport trigger_type_to_str
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ExecAlgorithmId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport TraderId
+from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class MarketToLimitOrder(Order):
+cdef class TrailingStopMarketOrder(Order):
     """
-    Represents a `Market-To-Limit` (MTL) order.
-
-    A Market-to-Limit (MTL) order is submitted as a market order to execute at
-    the current best market price. If the order is only partially filled, the
-    remainder of the order is canceled and re-submitted as a Limit order with
-    the limit price equal to the price at which the filled portion of the order
-    executed.
+    Represents a `Trailing-Stop-Market` conditional order.
 
     Parameters
     ----------
     trader_id : TraderId
         The trader ID associated with the order.
     strategy_id : StrategyId
         The strategy ID associated with the order.
@@ -61,28 +62,39 @@
         The order instrument ID.
     client_order_id : ClientOrderId
         The client order ID.
     order_side : OrderSide {``BUY``, ``SELL``}
         The order side.
     quantity : Quantity
         The order quantity (> 0).
+    trigger_price : Price, optional with no default so ``None`` must be passed explicitly
+        The order trigger price (STOP). If ``None`` then will typically default
+        to the delta of market price and `trailing_offset`.
+    trigger_type : TriggerType
+        The order trigger type.
+    trailing_offset : Decimal
+        The trailing offset for the trigger price (STOP).
+    trailing_offset_type : TrailingOffsetType
+        The order trailing offset type.
     init_id : UUID4
         The order initialization event ID.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the object was initialized.
     time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
         The order time in force.
     expire_time_ns : uint64_t, default 0 (no expiry)
         The UNIX timestamp (nanoseconds) when the order will expire.
     reduce_only : bool, default False
         If the order carries the 'reduce-only' execution instruction.
     quote_quantity : bool, default False
         If the order quantity is denominated in the quote currency.
-    display_qty : Quantity, optional
-        The quantity of the limit order to display on the public book (iceberg).
+    emulation_trigger : TriggerType, default ``NO_TRIGGER``
+        The order emulation trigger.
+    trigger_instrument_id : InstrumentId, optional
+        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The order contingency type.
     order_list_id : OrderListId, optional
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional
         The order linked client order ID(s).
     parent_order_id : ClientOrderId, optional
@@ -100,116 +112,133 @@
     Raises
     ------
     ValueError
         If `order_side` is ``NO_ORDER_SIDE``.
     ValueError
         If `quantity` is not positive (> 0).
     ValueError
+        If `trigger_type` is ``NO_TRIGGER``.
+    ValueError
+        If `trailing_offset_type` is ``NO_TRAILING_OFFSET``.
+    ValueError
         If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
-
-    References
-    ----------
-    https://www.interactivebrokers.com/en/trading/orders/mtl.php
+    ValueError
+        If `time_in_force` is ``GTD`` and `expire_time_ns` <= UNIX epoch.
     """
 
     def __init__(
         self,
         TraderId trader_id not None,
         StrategyId strategy_id not None,
         InstrumentId instrument_id not None,
         ClientOrderId client_order_id not None,
         OrderSide order_side,
         Quantity quantity not None,
+        Price trigger_price: Price | None,
+        TriggerType trigger_type,
+        trailing_offset: Decimal,
+        TrailingOffsetType trailing_offset_type,
         UUID4 init_id not None,
         uint64_t ts_init,
         TimeInForce time_in_force = TimeInForce.GTC,
         uint64_t expire_time_ns = 0,
         bint reduce_only = False,
         bint quote_quantity = False,
-        Quantity display_qty = None,
+        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
         OrderListId order_list_id = None,
         list linked_order_ids = None,
         ClientOrderId parent_order_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         ClientOrderId exec_spawn_id = None,
         str tags = None,
     ):
         Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
+        Condition.not_equal(trigger_type, TriggerType.NO_TRIGGER, "trigger_type", "NO_TRIGGER")
+        Condition.not_equal(trailing_offset_type, TrailingOffsetType.NO_TRAILING_OFFSET, "trailing_offset_type", "NO_TRAILING_OFFSET")
         Condition.not_equal(time_in_force, TimeInForce.AT_THE_OPEN, "time_in_force", "AT_THE_OPEN`")
         Condition.not_equal(time_in_force, TimeInForce.AT_THE_CLOSE, "time_in_force", "AT_THE_CLOSE`")
 
         if time_in_force == TimeInForce.GTD:
             # Must have an expire time
             Condition.true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
         else:
             # Should not have an expire time
             Condition.true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
 
         # Set options
         cdef dict options = {
-            "display_qty": str(display_qty) if display_qty is not None else None,
+            "trigger_price": str(trigger_price) if trigger_price is not None else None,
+            "trigger_type": trigger_type_to_str(trigger_type),
+            "trailing_offset": str(trailing_offset),
+            "trailing_offset_type": trailing_offset_type_to_str(trailing_offset_type),
             "expire_time_ns": expire_time_ns,
         }
 
         # Create initialization event
         cdef OrderInitialized init = OrderInitialized(
             trader_id=trader_id,
             strategy_id=strategy_id,
             instrument_id=instrument_id,
             client_order_id=client_order_id,
             order_side=order_side,
-            order_type=OrderType.MARKET_TO_LIMIT,
+            order_type=OrderType.TRAILING_STOP_MARKET,
             quantity=quantity,
             time_in_force=time_in_force,
             post_only=False,
             reduce_only=reduce_only,
             quote_quantity=quote_quantity,
             options=options,
-            emulation_trigger=TriggerType.NO_TRIGGER,
-            trigger_instrument_id=None,
+            emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=contingency_type,
             order_list_id=order_list_id,
             linked_order_ids=linked_order_ids,
             parent_order_id=parent_order_id,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             exec_spawn_id=exec_spawn_id,
             tags=tags,
             event_id=init_id,
             ts_init=ts_init,
         )
         super().__init__(init=init)
 
-        self.price = None
+        self.trigger_price = trigger_price
+        self.trigger_type = trigger_type
+        self.trailing_offset = trailing_offset
+        self.trailing_offset_type = trailing_offset_type
         self.expire_time_ns = expire_time_ns
-        self.display_qty = display_qty
 
     cdef void _updated(self, OrderUpdated event):
         if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
             self._venue_order_ids.append(self.venue_order_id)
             self.venue_order_id = event.venue_order_id
         if event.quantity is not None:
             self.quantity = event.quantity
             self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
-        if event.price is not None:
-            self.price = event.price
+        if event.trigger_price is not None:
+            self.trigger_price = event.trigger_price
 
     cdef void _set_slippage(self):
+        if self.trigger_price is None:
+            return  # Prevents an attribute error below
+
         if self.side == OrderSide.BUY:
-            self.slippage = self.avg_px - self.price.as_f64_c()
+            self.slippage = self.avg_px - self.trigger_price.as_f64_c()
         elif self.side == OrderSide.SELL:
-            self.slippage = self.price.as_f64_c() - self.avg_px
+            self.slippage = self.trigger_price.as_f64_c() - self.avg_px
 
     cdef bint has_price_c(self):
-        return self.price is not None
+        return False
 
     cdef bint has_trigger_price_c(self):
-        return False
+        return self.trigger_price is not None
 
     @property
     def expire_time(self):
         """
         Return the expire time for the order (UTC).
 
         Returns
@@ -225,18 +254,22 @@
 
         Returns
         -------
         str
 
         """
         cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {format_iso8601(unix_nanos_to_dt(self.expire_time_ns))}"
+        cdef str emulation_str = "" if self.emulation_trigger == TriggerType.NO_TRIGGER else f" EMULATED[{trigger_type_to_str(self.emulation_trigger)}]"
         return (
             f"{order_side_to_str(self.side)} {self.quantity.to_str()} {self.instrument_id} "
-            f"{order_type_to_str(self.order_type)} @ {self.price} "
+            f"{order_type_to_str(self.order_type)}[{trigger_type_to_str(self.trigger_type)}] "
+            f"{'@ ' + str(self.trigger_price) + '-STOP ' if self.trigger_price else ''}"
+            f"{self.trailing_offset}-TRAILING_OFFSET[{trailing_offset_type_to_str(self.trailing_offset_type)}] "
             f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
+            f"{emulation_str}"
         )
 
     cpdef dict to_dict(self):
         """
         Return a dictionary representation of this object.
 
         Returns
@@ -253,79 +286,88 @@
             "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
             "position_id": self.position_id.to_str() if self.position_id is not None else None,
             "account_id": self.account_id.to_str() if self.account_id is not None else None,
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
-            "price": str(self.price),
+            "trigger_price": str(self.trigger_price) if self.trigger_price is not None else None,
+            "trigger_type": trigger_type_to_str(self.trigger_type),
+            "trailing_offset": str(self.trailing_offset),
+            "trailing_offset_type": trailing_offset_type_to_str(self.trailing_offset_type),
+            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
             "time_in_force": time_in_force_to_str(self.time_in_force),
-            "expire_time_ns": self.expire_time_ns,
-            "is_reduce_only": self.is_reduce_only,
-            "is_quote_quantity": self.is_quote_quantity,
-            "display_qty": str(self.display_qty) if self.display_qty is not None else None,
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
             "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
             "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "status": self._fsm.state_string_c(),
+            "is_reduce_only": self.is_reduce_only,
+            "is_quote_quantity": self.is_quote_quantity,
+            "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
+            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": self.exec_algorithm_params,
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
             "tags": self.tags,
             "ts_init": self.ts_init,
             "ts_last": self.ts_last,
         }
 
     @staticmethod
-    cdef MarketToLimitOrder create(OrderInitialized init):
+    cdef TrailingStopMarketOrder create(OrderInitialized init):
         """
-        Return a `Market-To-Limit` order from the given initialized event.
+        Return a `Trailing-Stop-Market` order from the given initialized event.
 
         Parameters
         ----------
         init : OrderInitialized
             The event to initialize with.
 
         Returns
         -------
-        MarketToLimitOrder
+        TrailingStopMarketOrder
 
         Raises
         ------
         ValueError
-            If `init.order_type` is not equal to ``MARKET_TO_LIMIT``.
+            If `init.order_type` is not equal to ``TRAILING_STOP_MARKET``.
 
         """
         Condition.not_none(init, "init")
-        Condition.equal(init.order_type, OrderType.MARKET_TO_LIMIT, "init.order_type", "OrderType")
+        Condition.equal(init.order_type, OrderType.TRAILING_STOP_MARKET, "init.order_type", "OrderType")
 
-        cdef str display_qty_str = init.options.get("display_qty")
+        cdef str trigger_price_str = init.options.get("trigger_price")
 
-        return MarketToLimitOrder(
+        return TrailingStopMarketOrder(
             trader_id=init.trader_id,
             strategy_id=init.strategy_id,
             instrument_id=init.instrument_id,
             client_order_id=init.client_order_id,
             order_side=init.side,
             quantity=init.quantity,
+            trigger_price=Price.from_str_c(trigger_price_str) if trigger_price_str is not None else None,
+            trigger_type=trigger_type_from_str(init.options["trigger_type"]),
+            trailing_offset=Decimal(init.options["trailing_offset"]),
+            trailing_offset_type=trailing_offset_type_from_str(init.options["trailing_offset_type"]),
             time_in_force=init.time_in_force,
             expire_time_ns=init.options["expire_time_ns"],
-            reduce_only=init.reduce_only,
-            quote_quantity=init.quote_quantity,
-            display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
             init_id=init.id,
             ts_init=init.ts_init,
-            order_list_id=init.order_list_id,
+            reduce_only=init.reduce_only,
+            quote_quantity=init.quote_quantity,
+            emulation_trigger=init.emulation_trigger,
+            trigger_instrument_id=init.trigger_instrument_id,
             contingency_type=init.contingency_type,
+            order_list_id=init.order_list_id,
             linked_order_ids=init.linked_order_ids,
             parent_order_id=init.parent_order_id,
             exec_algorithm_id=init.exec_algorithm_id,
             exec_algorithm_params=init.exec_algorithm_params,
             exec_spawn_id=init.exec_spawn_id,
             tags=init.tags,
         )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/stop_limit.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/stop_market.pxd`

 * *Files 16% similar despite different names*

```diff
@@ -14,29 +14,20 @@
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.rust.model cimport TriggerType
 from nautilus_trader.model.events.order cimport OrderInitialized
 from nautilus_trader.model.objects cimport Price
-from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class StopLimitOrder(Order):
-    cdef readonly Price price
-    """The order price (LIMIT).\n\n:returns: `Price`"""
+cdef class StopMarketOrder(Order):
     cdef readonly Price trigger_price
     """The order trigger price (STOP).\n\n:returns: `Price`"""
     cdef readonly TriggerType trigger_type
     """The trigger type for the order.\n\n:returns: `TriggerType`"""
     cdef readonly uint64_t expire_time_ns
     """The order expiration (UNIX epoch nanoseconds), zero for no expiration.\n\n:returns: `uint64_t`"""
-    cdef readonly Quantity display_qty
-    """The quantity of the ``LIMIT`` order to display on the public book (iceberg).\n\n:returns: `Quantity` or ``None``"""  # noqa
-    cdef readonly bint is_triggered
-    """If the order has been triggered.\n\n:returns: `bool`"""
-    cdef readonly uint64_t ts_triggered
-    """The UNIX timestamp (nanoseconds) when the order was triggered (0 if not triggered).\n\n:returns: `uint64_t`"""
 
     @staticmethod
-    cdef StopLimitOrder create(OrderInitialized init)
+    cdef StopMarketOrder create(OrderInitialized init)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/stop_limit.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/stop_limit.pyx`

 * *Files 10% similar despite different names*

```diff
@@ -23,18 +23,21 @@
 from nautilus_trader.core.rust.model cimport OrderType
 from nautilus_trader.core.rust.model cimport TimeInForce
 from nautilus_trader.core.rust.model cimport TriggerType
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.model.events.order cimport OrderInitialized
 from nautilus_trader.model.events.order cimport OrderTriggered
 from nautilus_trader.model.events.order cimport OrderUpdated
+from nautilus_trader.model.functions cimport contingency_type_from_str
 from nautilus_trader.model.functions cimport contingency_type_to_str
 from nautilus_trader.model.functions cimport liquidity_side_to_str
+from nautilus_trader.model.functions cimport order_side_from_str
 from nautilus_trader.model.functions cimport order_side_to_str
 from nautilus_trader.model.functions cimport order_type_to_str
+from nautilus_trader.model.functions cimport time_in_force_from_str
 from nautilus_trader.model.functions cimport time_in_force_to_str
 from nautilus_trader.model.functions cimport trigger_type_from_str
 from nautilus_trader.model.functions cimport trigger_type_to_str
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ExecAlgorithmId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
@@ -177,15 +180,15 @@
             # Must have an expire time
             Condition.true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
         else:
             # Should not have an expire time
             Condition.true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
         Condition.true(
             display_qty is None or 0 <= display_qty <= quantity,
-            fail_msg="display_qty was negative or greater than order quantity",
+            fail_msg="`display_qty` was negative or greater than `quantity`",
         )
 
         # Set options
         cdef dict options = {
             "price": str(price),
             "trigger_price": str(trigger_price),
             "trigger_type": trigger_type_to_str(trigger_type),
@@ -285,14 +288,50 @@
             f"{order_side_to_str(self.side)} {self.quantity.to_str()} {self.instrument_id} "
             f"{order_type_to_str(self.order_type)} @ {self.trigger_price}-STOP"
             f"[{trigger_type_to_str(self.trigger_type)}] {self.price}-LIMIT "
             f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
             f"{emulation_str}"
         )
 
+    @staticmethod
+    cdef StopLimitOrder from_pyo3_c(pyo3_order):
+        return StopLimitOrder(
+            trader_id=TraderId(str(pyo3_order.trader_id)),
+            strategy_id=StrategyId(str(pyo3_order.strategy_id)),
+            instrument_id=InstrumentId.from_str_c(str(pyo3_order.instrument_id)),
+            client_order_id=ClientOrderId(str(pyo3_order.client_order_id)),
+            order_side=order_side_from_str(str(pyo3_order.side)),
+            quantity=Quantity.from_raw_c(pyo3_order.quantity.raw, pyo3_order.quantity.precision),
+            price=Price.from_raw_c(pyo3_order.price.raw, pyo3_order.price.precision),
+            trigger_price=Price.from_raw_c(pyo3_order.trigger_price.raw, pyo3_order.trigger_price.precision),
+            trigger_type=trigger_type_from_str(str(pyo3_order.trigger_type)),
+            init_id=UUID4(str(pyo3_order.init_id)),
+            ts_init=pyo3_order.ts_init,
+            time_in_force=time_in_force_from_str(str(pyo3_order.time_in_force)),
+            expire_time_ns=pyo3_order.expire_time if pyo3_order.expire_time is not None else 0,
+            post_only=pyo3_order.is_post_only,
+            reduce_only=pyo3_order.is_reduce_only,
+            quote_quantity=pyo3_order.is_quote_quantity,
+            display_qty=Quantity.from_raw_c(pyo3_order.display_qty.raw, pyo3_order.display_qty.precision) if pyo3_order.display_qty is not None else None,
+            emulation_trigger=trigger_type_from_str(str(pyo3_order.emulation_trigger)),
+            trigger_instrument_id=InstrumentId.from_str_c(str(pyo3_order.trigger_instrument_id)) if pyo3_order.trigger_instrument_id is not None else None,
+            contingency_type=contingency_type_from_str(str(pyo3_order.contingency_type)) if pyo3_order.contingency_type is not None else ContingencyType.NO_CONTINGENCY,
+            order_list_id=OrderListId(str(pyo3_order.order_list_id)) if pyo3_order.order_list_id is not None else None,
+            linked_order_ids=[ClientOrderId(str(o)) for o in pyo3_order.linked_order_ids] if pyo3_order.linked_order_ids is not None else None,
+            parent_order_id=ClientOrderId(str(pyo3_order.parent_order_id)) if pyo3_order.parent_order_id is not None else None,
+            exec_algorithm_id=ExecAlgorithmId(str(pyo3_order.exec_algorithm_id)) if pyo3_order.exec_algorithm_id is not None else None,
+            exec_algorithm_params=pyo3_order.exec_algorithm_params,
+            exec_spawn_id=ClientOrderId(str(pyo3_order.exec_spawn_id)) if pyo3_order.exec_spawn_id is not None else None,
+            tags=pyo3_order.tags if pyo3_order.tags is not None else None,
+        )
+
+    @staticmethod
+    def from_pyo3(pyo3_order):
+        return StopLimitOrder.from_pyo3_c(pyo3_order)
+
     cpdef dict to_dict(self):
         """
         Return a dictionary representation of this object.
 
         Returns
         -------
         dict[str, object]
@@ -310,21 +349,22 @@
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
             "price": str(self.price),
             "trigger_price": str(self.trigger_price),
             "trigger_type": trigger_type_to_str(self.trigger_type),
-            "expire_time_ns": self.expire_time_ns,
+            "init_id": str(self.init_id),
+            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
             "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
-            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
+            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else {},
             "status": self._fsm.state_string_c(),
             "is_post_only": self.is_post_only,
             "is_reduce_only": self.is_reduce_only,
             "is_quote_quantity": self.is_quote_quantity,
             "display_qty": str(self.display_qty) if self.display_qty is not None else None,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
             "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/stop_market.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/trailing_stop_market.pxd`

 * *Files 11% similar despite different names*

```diff
@@ -11,23 +11,28 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport uint64_t
 
+from nautilus_trader.core.rust.model cimport TrailingOffsetType
 from nautilus_trader.core.rust.model cimport TriggerType
 from nautilus_trader.model.events.order cimport OrderInitialized
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class StopMarketOrder(Order):
+cdef class TrailingStopMarketOrder(Order):
     cdef readonly Price trigger_price
-    """The order trigger price (STOP).\n\n:returns: `Price`"""
+    """The order trigger price (STOP).\n\n:returns: `Price` or ``None``"""
     cdef readonly TriggerType trigger_type
     """The trigger type for the order.\n\n:returns: `TriggerType`"""
+    cdef readonly object trailing_offset
+    """The trailing offset for the orders trigger price (STOP).\n\n:returns: `Decimal`"""
+    cdef readonly TrailingOffsetType trailing_offset_type
+    """The trailing offset type.\n\n:returns: `TrailingOffsetType`"""
     cdef readonly uint64_t expire_time_ns
     """The order expiration (UNIX epoch nanoseconds), zero for no expiration.\n\n:returns: `uint64_t`"""
 
     @staticmethod
-    cdef StopMarketOrder create(OrderInitialized init)
+    cdef TrailingStopMarketOrder create(OrderInitialized init)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/stop_market.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/stop_market.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -281,15 +281,15 @@
             "account_id": self.account_id.to_str() if self.account_id is not None else None,
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
             "trigger_price": str(self.trigger_price),
             "trigger_type": trigger_type_to_str(self.trigger_type),
-            "expire_time_ns": self.expire_time_ns,
+            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
             "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
             "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "status": self._fsm.state_string_c(),
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/trailing_stop_limit.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/trailing_stop_limit.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/trailing_stop_limit.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/trailing_stop_limit.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -180,15 +180,15 @@
             # Must have an expire time
             Condition.true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
         else:
             # Should not have an expire time
             Condition.true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
         Condition.true(
             display_qty is None or 0 <= display_qty <= quantity,
-            fail_msg="`display_qty` was negative or greater than order quantity",
+            fail_msg="`display_qty` was negative or greater than `quantity`",
         )
 
         # Set options
         cdef dict options = {
             "price": str(price) if price is not None else None,
             "trigger_price": str(trigger_price) if trigger_price is not None else None,
             "trigger_type": trigger_type_to_str(trigger_type),
@@ -325,15 +325,15 @@
             "quantity": str(self.quantity),
             "price": str(self.price) if self.price is not None else None,
             "trigger_price": str(self.trigger_price) if self.trigger_price is not None else None,
             "trigger_type": trigger_type_to_str(self.trigger_type),
             "limit_offset": str(self.limit_offset),
             "trailing_offset": str(self.trailing_offset),
             "trailing_offset_type": trailing_offset_type_to_str(self.trailing_offset_type),
-            "expire_time_ns": self.expire_time_ns,
+            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
             "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
             "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "status": self._fsm.state_string_c(),
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/unpacker.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/unpacker.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/orders/unpacker.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/orders/unpacker.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/position.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/position.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/base.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/base.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/base.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/implementations/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/implementations/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/implementations/fixed.pxd` & `nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/implementations/fixed.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/implementations/fixed.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/implementations/fixed.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/implementations/tiered.pxd` & `nautilus_trader-1.191.0/nautilus_trader/persistence/catalog/types.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,26 +9,26 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-cimport numpy as np
+from __future__ import annotations
 
-from nautilus_trader.model.objects cimport Price
-from nautilus_trader.model.tick_scheme.base cimport TickScheme
+from dataclasses import dataclass
 
+from nautilus_trader.core.data import Data
+from nautilus_trader.model.identifiers import ClientId
+from nautilus_trader.model.instruments import Instrument
 
-cdef class TieredTickScheme(TickScheme):
-    cdef list tiers
-    cdef int max_ticks_per_tier
-    cdef int price_precision
-    cdef int tick_count
 
-    cdef readonly np.ndarray ticks
+@dataclass(frozen=True)
+class CatalogDataResult:
+    """
+    Represents a catalog data query result.
+    """
 
-    cpdef _build_ticks(self)
-
-    cpdef int find_tick_index(self, double value)
-    cpdef Price next_ask_price(self, double value, int n=*)
-    cpdef Price next_bid_price(self, double value, int n=*)
+    data_cls: type
+    data: list[Data]
+    instrument: Instrument | None = None
+    client_id: ClientId | None = None
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/tick_scheme/implementations/tiered.pyx` & `nautilus_trader-1.191.0/nautilus_trader/model/tick_scheme/implementations/tiered.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/model/venues.py` & `nautilus_trader-1.191.0/nautilus_trader/model/venues.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/persistence/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/portfolio/__init__.pxd`

 * *Files 12% similar despite different names*

```diff
@@ -8,11 +8,7 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-"""
-The `persistence` subpackage handles data storage and retrieval, mainly to support
-backtesting.
-"""
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/persistence/catalog/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/persistence/catalog/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/persistence/catalog/parquet.py` & `nautilus_trader-1.191.0/nautilus_trader/persistence/catalog/parquet.py`

 * *Files 0% similar despite different names*

```diff
@@ -408,23 +408,26 @@
         if session is None:
             session = DataBackendSession()
         if session is None:
             raise ValueError("`session` was `None` when a value was expected")
 
         file_prefix = class_to_filename(data_cls)
         glob_path = f"{self.path}/data/{file_prefix}/**/*"
-        dirs = self.fs.glob(glob_path)
+        dirs: list[str] = self.fs.glob(glob_path)
         if self.show_query_paths:
             print(dirs)
 
         for idx, path in enumerate(dirs):
             assert self.fs.exists(path)
-            if instrument_ids and not any(urisafe_instrument_id(x) in path for x in instrument_ids):
+            # Parse the parent directory which *should* be the instrument ID,
+            # this prevents us matching all instrument ID substrings.
+            dir = path.split("/")[-2]
+            if instrument_ids and not any(dir == urisafe_instrument_id(x) for x in instrument_ids):
                 continue
-            if bar_types and not any(urisafe_instrument_id(x) in path for x in bar_types):
+            if bar_types and not any(dir == urisafe_instrument_id(x) for x in bar_types):
                 continue
             table = f"{file_prefix}_{idx}"
             query = self._build_query(
                 table,
                 # instrument_ids=None, # Filtering by filename for now
                 start=start,
                 end=end,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/persistence/catalog/singleton.py` & `nautilus_trader-1.191.0/nautilus_trader/persistence/catalog/singleton.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/persistence/catalog/types.py` & `nautilus_trader-1.191.0/nautilus_core/core/src/lib.rs`

 * *Files 25% similar despite different names*

```diff
@@ -1,34 +1,28 @@
-# -------------------------------------------------------------------------------------------------
-#  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
-#  https://nautechsystems.io
-#
-#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-#  You may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-# -------------------------------------------------------------------------------------------------
-
-from __future__ import annotations
-
-from dataclasses import dataclass
-
-from nautilus_trader.core.data import Data
-from nautilus_trader.model.identifiers import ClientId
-from nautilus_trader.model.instruments import Instrument
-
-
-@dataclass(frozen=True)
-class CatalogDataResult:
-    """
-    Represents a catalog data query result.
-    """
-
-    data_cls: type
-    data: list[Data]
-    instrument: Instrument | None = None
-    client_id: ClientId | None = None
+// -------------------------------------------------------------------------------------------------
+//  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
+//  https://nautechsystems.io
+//
+//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+//  You may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+// -------------------------------------------------------------------------------------------------
+
+pub mod correctness;
+pub mod datetime;
+pub mod message;
+pub mod nanos;
+pub mod parsing;
+pub mod serialization;
+pub mod time;
+pub mod uuid;
+
+#[cfg(feature = "ffi")]
+pub mod ffi;
+#[cfg(feature = "python")]
+pub mod python;
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/persistence/config.py` & `nautilus_trader-1.191.0/nautilus_trader/persistence/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/persistence/funcs.py` & `nautilus_trader-1.191.0/nautilus_trader/persistence/funcs.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/persistence/loaders.py` & `nautilus_trader-1.191.0/nautilus_trader/persistence/loaders.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/persistence/wranglers.pxd` & `nautilus_trader-1.191.0/nautilus_trader/persistence/wranglers.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/persistence/wranglers.pyx` & `nautilus_trader-1.191.0/nautilus_trader/persistence/wranglers.pyx`

 * *Files 18% similar despite different names*

```diff
@@ -23,33 +23,155 @@
 from nautilus_trader.model.enums import order_side_from_str
 
 from libc.stdint cimport int64_t
 from libc.stdint cimport uint8_t
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
-from nautilus_trader.core.data cimport Data
 from nautilus_trader.core.datetime cimport as_utc_index
-from nautilus_trader.core.datetime cimport dt_to_unix_nanos
-from nautilus_trader.core.rust.core cimport CVec
-from nautilus_trader.core.rust.core cimport secs_to_nanos
 from nautilus_trader.core.rust.model cimport AggressorSide
 from nautilus_trader.core.rust.model cimport BookAction
 from nautilus_trader.core.rust.model cimport OrderSide
 from nautilus_trader.model.data cimport Bar
 from nautilus_trader.model.data cimport BarType
 from nautilus_trader.model.data cimport OrderBookDelta
 from nautilus_trader.model.data cimport QuoteTick
 from nautilus_trader.model.data cimport TradeTick
 from nautilus_trader.model.identifiers cimport TradeId
 from nautilus_trader.model.instruments.base cimport Instrument
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
+BAR_PRICES = ('open', 'high', 'low', 'close')
+BAR_COLUMNS = (*BAR_PRICES, 'volume')
+
+
+def preprocess_bar_data(data: pd.DataFrame, is_raw: bool):
+    """
+    Preprocess financial bar data to a standardized format.
+
+    Ensures the DataFrame index is labeled as "timestamp", converts the index to UTC, removes time zone awareness,
+    drops rows with NaN values in critical columns, and optionally scales the data.
+
+    Parameters
+    ----------
+        data : pd.DataFrame
+            The input DataFrame containing financial bar data.
+        is_raw : bool
+            A flag to determine whether the data should be scaled. If False, scales the data by 1e9.
+
+    Returns
+    -------
+        pd.DataFrame: The preprocessed DataFrame with a cleaned and standardized structure.
+
+    """
+    # Ensure index is timestamp
+    if data.index.name != "timestamp":
+        data.index.name = "timestamp"
+
+    # Standardize index to UTC and remove time zone awareness
+    data = as_utc_index(data)
+    data.index = data.index.tz_localize(None).astype("datetime64[ns]")
+
+    # Drop rows with NaN values in critical columns
+    data = data.dropna(subset=BAR_COLUMNS)
+
+    # Scale data if not raw
+    if not is_raw:
+        data[list(BAR_COLUMNS)] = data[list(BAR_COLUMNS)].multiply(1e9)
+
+    return data
+
+
+def calculate_bar_price_offsets(num_records, timestamp_is_close: bool, offset_interval_ms: int, random_seed=None):
+    """
+    Calculate and potentially randomize the time offsets for bar prices based on the closeness of the timestamp.
+
+    Parameters
+    ----------
+        num_records : int
+            The number of records for which offsets are to be generated.
+        timestamp_is_close : bool
+            A flag indicating whether the timestamp is close to the trading time.
+        offset_interval_ms : int
+            The offset interval in milliseconds to be applied.
+        random_seed : Optional[int]
+            The seed for random number generation to ensure reproducibility.
+
+    Returns
+    -------
+        dict: A dictionary with arrays of offsets for open, high, low, and close prices. If random_seed is provided,
+              high and low offsets are randomized.
+    """
+    # Initialize offsets
+    offsets = {
+        "open": np.full(num_records, np.timedelta64((-3 if timestamp_is_close else 0) * offset_interval_ms, "ms")),
+        "high": np.full(num_records, np.timedelta64((-2 if timestamp_is_close else 1) * offset_interval_ms, "ms")),
+        "low": np.full(num_records, np.timedelta64((-1 if timestamp_is_close else 2) * offset_interval_ms, "ms")),
+        "close": np.full(num_records, np.timedelta64((0 if timestamp_is_close else 3) * offset_interval_ms, "ms")),
+    }
+
+    # Randomize high and low if seed is given
+    if random_seed is not None:
+        local_random = random.Random(random_seed)
+        for i in range(num_records):
+            if local_random.getrandbits(1):  # With a 50% chance, swap high and low
+                offsets['high'][i], offsets['low'][i] = offsets['low'][i], offsets['high'][i]
+
+    return offsets
+
+
+def calculate_volume_quarter(volume: np.ndarray, precision: int):
+    """
+    Convert raw volume data to quarter precision.
+
+    Args:
+        volume : np.ndarray
+            An array of volume data to be processed.
+        precision : int
+            The decimal precision to which the volume data is rounded, adjusted by subtracting 9.
+
+    Returns:
+        np.ndarray: The volume data adjusted to quarter precision.
+    """
+    # Convert raw volume to quarter precision
+    return np.round(volume / 4, precision - 9).astype(np.uint64)
+
+
+def align_bid_ask_bar_data(bid_data: pd.DataFrame, ask_data: pd.DataFrame):
+    """
+    Merge bid and ask data into a single DataFrame with prefixed column names.
+
+    Args:
+        bid_data : pd.DataFrame
+            The DataFrame containing bid data.
+        ask_data : pd.DataFrame
+            The DataFrame containing ask data.
+
+    Returns:
+        pd.DataFrame: A merged DataFrame with columns prefixed by 'bid_' for bid data and 'ask_' for ask data, joined on their indexes.
+    """
+    bid_prefixed = bid_data.add_prefix('bid_')
+    ask_prefixed = ask_data.add_prefix('ask_')
+    merged_data = pd.merge(bid_prefixed, ask_prefixed, left_index=True, right_index=True, how='inner')
+    return merged_data
+
+
+def prepare_event_and_init_timestamps(
+    index: pd.DatetimeIndex,
+    ts_init_delta: int,
+):
+    Condition.type(index, pd.DatetimeIndex, "index")
+    Condition.not_negative(ts_init_delta, "ts_init_delta")
+    ts_events = index.view(np.uint64)
+    ts_inits = ts_events + ts_init_delta
+    return ts_events, ts_inits
+
+
 cdef class OrderBookDeltaDataWrangler:
     """
     Provides a means of building lists of Nautilus `OrderBookDelta` objects.
 
     Parameters
     ----------
     instrument : Instrument
@@ -81,16 +203,15 @@
             If `data` is empty.
 
         """
         Condition.not_none(data, "data")
         Condition.false(data.empty, "data.empty")
 
         data = as_utc_index(data)
-        cdef uint64_t[:] ts_events = np.ascontiguousarray([dt_to_unix_nanos(dt) for dt in data.index], dtype=np.uint64)  # noqa
-        cdef uint64_t[:] ts_inits = np.ascontiguousarray([ts_event + ts_init_delta for ts_event in ts_events], dtype=np.uint64)  # noqa
+        ts_events, ts_inits = prepare_event_and_init_timestamps(data.index, ts_init_delta)
 
         if is_raw:
             return list(map(
                 self._build_delta_from_raw,
                 data["action"].apply(book_action_from_str),
                 data["side"].apply(order_side_from_str),
                 data["price"],
@@ -213,29 +334,28 @@
         -------
         list[QuoteTick]
 
         """
         Condition.false(data.empty, "data.empty")
         Condition.not_none(default_volume, "default_volume")
 
-        as_utc_index(data)
+        data = as_utc_index(data)
 
         columns = {
             "bid": "bid_price",
             "ask": "ask_price",
         }
         data.rename(columns=columns, inplace=True)
 
         if "bid_size" not in data.columns:
             data["bid_size"] = float(default_volume)
         if "ask_size" not in data.columns:
             data["ask_size"] = float(default_volume)
 
-        cdef uint64_t[:] ts_events = np.ascontiguousarray([dt_to_unix_nanos(dt) for dt in data.index], dtype=np.uint64)  # noqa
-        cdef uint64_t[:] ts_inits = np.ascontiguousarray([ts_event + ts_init_delta for ts_event in ts_events], dtype=np.uint64)  # noqa
+        ts_events, ts_inits = prepare_event_and_init_timestamps(data.index, ts_init_delta)
 
         return list(map(
             self._build_tick,
             data["bid_price"],
             data["ask_price"],
             data["bid_size"],
             data["ask_size"],
@@ -249,14 +369,15 @@
         ask_data: pd.DataFrame,
         default_volume: float = 1_000_000.0,
         ts_init_delta: int = 0,
         offset_interval_ms: int = 100,
         bint timestamp_is_close: bool = True,
         random_seed: int | None = None,
         bint is_raw: bool = False,
+        bint sort_data: bool = True,
     ):
         """
         Process the given bar datasets into Nautilus `QuoteTick` objects.
 
         Expects columns ['open', 'high', 'low', 'close', 'volume'] with 'timestamp' index.
         Note: The 'volume' column is optional, will then use the `default_volume`.
 
@@ -281,116 +402,101 @@
             data. If random_seed is ``None`` then won't shuffle.
         is_raw : bool, default False
             If the data is scaled to the Nautilus fixed precision.
         timestamp_is_close : bool, default True
             If bar timestamps are at the close.
             If True then open, high, low timestamps are offset before the close timestamp.
             If False then high, low, close timestamps are offset after the open timestamp.
+        sort_data : bool, default True
+            If the data should be sorted by timestamp.
 
         """
-        Condition.not_none(bid_data, "bid_data")
-        Condition.not_none(ask_data, "ask_data")
+        Condition.type(bid_data, pd.DataFrame, "bid_data")
+        Condition.type(ask_data, pd.DataFrame, "ask_data")
         Condition.false(bid_data.empty, "bid_data.empty")
         Condition.false(ask_data.empty, "ask_data.empty")
+        Condition.type(bid_data.index, pd.DatetimeIndex, "bid_data.index")
+        Condition.type(ask_data.index, pd.DatetimeIndex, "ask_data.index")
         Condition.not_none(default_volume, "default_volume")
+        for col in BAR_PRICES:
+            Condition.is_in(col, bid_data.columns, col, "bid_data.columns")
+            Condition.is_in(col, ask_data.columns, col, "ask_data.columns")
         if random_seed is not None:
             Condition.type(random_seed, int, "random_seed")
 
-        # Ensure index is tz-aware UTC
-        bid_data = as_utc_index(bid_data)
-        ask_data = as_utc_index(ask_data)
-
+        # Add default volume if not present
         if "volume" not in bid_data:
-            bid_data["volume"] = float(default_volume * 4)
-
+            bid_data.loc[:, "volume"] = float(default_volume * 4) * (1e9 if is_raw else 1)
         if "volume" not in ask_data:
-            ask_data["volume"] = float(default_volume * 4)
-
-        cdef dict data_open = {
-            "bid_price": bid_data["open"],
-            "ask_price": ask_data["open"],
-            "bid_size": bid_data["volume"] / 4,
-            "ask_size": ask_data["volume"] / 4,
-        }
+            ask_data.loc[:, "volume"] = float(default_volume * 4) * (1e9 if is_raw else 1)
 
-        cdef dict data_high = {
-            "bid_price": bid_data["high"],
-            "ask_price": ask_data["high"],
-            "bid_size": bid_data["volume"] / 4,
-            "ask_size": ask_data["volume"] / 4,
-        }
+        # Standardize and preprocess data
+        bid_data = preprocess_bar_data(bid_data, is_raw)
+        ask_data = preprocess_bar_data(ask_data, is_raw)
 
-        cdef dict data_low = {
-            "bid_price": bid_data["low"],
-            "ask_price": ask_data["low"],
-            "bid_size": bid_data["volume"] / 4,
-            "ask_size": ask_data["volume"] / 4,
-        }
+        merged_data = align_bid_ask_bar_data(bid_data, ask_data)
+        offsets = calculate_bar_price_offsets(len(merged_data), timestamp_is_close, offset_interval_ms, random_seed)
+        ticks_final = self._create_quote_ticks_array(merged_data, is_raw, self.instrument, offsets, ts_init_delta)
 
-        cdef dict data_close = {
-            "bid_price": bid_data["close"],
-            "ask_price": ask_data["close"],
-            "bid_size": bid_data["volume"] / 4,
-            "ask_size": ask_data["volume"] / 4,
-        }
+        # Sort data by timestamp, if required
+        if sort_data:
+            sorted_indices = np.argsort(ticks_final['timestamp'])
+            ticks_final = ticks_final[sorted_indices]
 
-        df_ticks_o = pd.DataFrame(data=data_open)
-        df_ticks_h = pd.DataFrame(data=data_high)
-        df_ticks_l = pd.DataFrame(data=data_low)
-        df_ticks_c = pd.DataFrame(data=data_close)
-
-        # Latency offsets
-        if timestamp_is_close:
-            df_ticks_o.index = df_ticks_o.index.shift(periods=-3 * offset_interval_ms, freq="ms")
-            df_ticks_h.index = df_ticks_h.index.shift(periods=-2 * offset_interval_ms, freq="ms")
-            df_ticks_l.index = df_ticks_l.index.shift(periods=-1 * offset_interval_ms, freq="ms")
-        else:  # timestamp is open
-            df_ticks_h.index = df_ticks_h.index.shift(periods=1 * offset_interval_ms, freq="ms")
-            df_ticks_l.index = df_ticks_l.index.shift(periods=2 * offset_interval_ms, freq="ms")
-            df_ticks_c.index = df_ticks_c.index.shift(periods=3 * offset_interval_ms, freq="ms")
-
-        # Merge tick data
-        df_ticks_final = pd.concat([df_ticks_o, df_ticks_h, df_ticks_l, df_ticks_c])
-        df_ticks_final.dropna(inplace=True)
-        df_ticks_final.sort_index(axis=0, kind="mergesort", inplace=True)
+        ts_events = ticks_final["timestamp"].view(np.uint64)
+        ts_inits = ts_events + ts_init_delta
 
-        cdef int i
-        # Randomly shift high low prices
-        if random_seed is not None:
-            random.seed(random_seed)
-            for i in range(0, len(df_ticks_final), 4):
-                if random.getrandbits(1):
-                    high = copy(df_ticks_final.iloc[i + 1])
-                    low = copy(df_ticks_final.iloc[i + 2])
-                    df_ticks_final.iloc[i + 1] = low
-                    df_ticks_final.iloc[i + 2] = high
+        return QuoteTick.from_raw_arrays_to_list_c(
+            self.instrument.id,
+            self.instrument.price_precision,
+            self.instrument.size_precision,
+            ticks_final["bid_price_raw"],
+            ticks_final["ask_price_raw"],
+            ticks_final["bid_size_raw"],
+            ticks_final["ask_size_raw"],
+            ts_events,
+            ts_inits,
+        )
 
-        cdef uint64_t[:] ts_events = np.ascontiguousarray([secs_to_nanos(dt.timestamp()) for dt in df_ticks_final.index], dtype=np.uint64)  # noqa
-        cdef uint64_t[:] ts_inits = np.ascontiguousarray([ts_event + ts_init_delta for ts_event in ts_events], dtype=np.uint64)  # noqa
+    def _create_quote_ticks_array(
+        self,
+        merged_data,
+        is_raw,
+        instrument: Instrument,
+        offsets,
+        ts_init_delta,
+    ):
+        dtype = [
+            ('bid_price_raw', np.int64), ('ask_price_raw', np.int64),
+            ('bid_size_raw', np.uint64), ('ask_size_raw', np.uint64),
+            ('timestamp', 'datetime64[ns]')
+        ]
+
+        size_precision = instrument.size_precision
+        merged_data.loc[:, 'bid_volume'] = calculate_volume_quarter(merged_data['bid_volume'], size_precision)
+        merged_data.loc[:, 'ask_volume'] = calculate_volume_quarter(merged_data['ask_volume'], size_precision)
+
+        # Convert to record array
+        records = merged_data.to_records()
+
+        # Create structured array
+        total_records = len(records) * 4  # For open, high, low, close
+        tick_data = np.empty(total_records, dtype=dtype)
+
+        for i, price_key in enumerate(BAR_PRICES):
+            start_index = i * len(records)
+            end_index = start_index + len(records)
+
+            tick_data['bid_price_raw'][start_index:end_index] = records[f'bid_{price_key}'].astype(np.int64)
+            tick_data['ask_price_raw'][start_index:end_index] = records[f'ask_{price_key}'].astype(np.int64)
+            tick_data['bid_size_raw'][start_index:end_index] = records['bid_volume'].astype(np.uint64)
+            tick_data['ask_size_raw'][start_index:end_index] = records['ask_volume'].astype(np.uint64)
+            tick_data['timestamp'][start_index:end_index] = records['timestamp'] + offsets[price_key]
 
-        if is_raw:
-            return list(map(
-                self._build_tick_from_raw,
-                df_ticks_final["bid_price"],
-                df_ticks_final["ask_price"],
-                df_ticks_final["bid_size"],
-                df_ticks_final["ask_size"],
-                ts_events,
-                ts_inits,
-            ))
-        else:
-            return list(map(
-                self._build_tick,
-                df_ticks_final["bid_price"],
-                df_ticks_final["ask_price"],
-                df_ticks_final["bid_size"],
-                df_ticks_final["ask_size"],
-                ts_events,
-                ts_inits,
-            ))
+        return tick_data
 
     # cpdef method for Python wrap() (called with map)
     cpdef QuoteTick _build_tick_from_raw(
         self,
         int64_t bid_price_raw,
         int64_t ask_price_raw,
         uint64_t bid_size_raw,
@@ -473,16 +579,15 @@
             If `data` is empty.
 
         """
         Condition.not_none(data, "data")
         Condition.false(data.empty, "data.empty")
 
         data = as_utc_index(data)
-        cdef uint64_t[:] ts_events = np.ascontiguousarray([dt_to_unix_nanos(dt) for dt in data.index], dtype=np.uint64)  # noqa
-        cdef uint64_t[:] ts_inits = np.ascontiguousarray([ts_event + ts_init_delta for ts_event in ts_events], dtype=np.uint64)  # noqa
+        ts_events, ts_inits = prepare_event_and_init_timestamps(data.index, ts_init_delta)
 
         if is_raw:
             return list(map(
                 self._build_tick_from_raw,
                 data["price"],
                 data["quantity"],
                 self._create_side_if_not_exist(data),
@@ -497,19 +602,117 @@
                 data["quantity"],
                 self._create_side_if_not_exist(data),
                 data["trade_id"].astype(str),
                 ts_events,
                 ts_inits,
             ))
 
+    def process_bar_data(
+        self,
+        data: pd.DataFrame,
+        ts_init_delta: int = 0,
+        offset_interval_ms: int = 100,
+        bint timestamp_is_close: bool = True,
+        random_seed: int | None = None,
+        bint is_raw: bool = False,
+        bint sort_data: bool = True,
+    ):
+        """
+        Process the given bar datasets into Nautilus `QuoteTick` objects.
+
+        Expects columns ['open', 'high', 'low', 'close', 'volume'] with 'timestamp' index.
+        Note: The 'volume' column is optional, will then use the `default_volume`.
+
+        Parameters
+        ----------
+        data : pd.DataFrame
+            The trade bar data.
+        ts_init_delta : int
+            The difference in nanoseconds between the data timestamps and the
+            `ts_init` value. Can be used to represent/simulate latency between
+            the data source and the Nautilus system.
+        offset_interval_ms : int, default 100
+            The number of milliseconds to offset each tick for the bar timestamps.
+            If `timestamp_is_close` then will use negative offsets,
+            otherwise will use positive offsets (see also `timestamp_is_close`).
+        random_seed : int, optional
+            The random seed for shuffling order of high and low ticks from bar
+            data. If random_seed is ``None`` then won't shuffle.
+        is_raw : bool, default False
+            If the data is scaled to the Nautilus fixed precision.
+        timestamp_is_close : bool, default True
+            If bar timestamps are at the close.
+            If True then open, high, low timestamps are offset before the close timestamp.
+            If False then high, low, close timestamps are offset after the open timestamp.
+        sort_data : bool, default True
+            If the data should be sorted by timestamp.
+
+        """
+        Condition.type(data, pd.DataFrame, "data")
+        Condition.false(data.empty, "data.empty")
+        Condition.type(data.index, pd.DatetimeIndex, "data.index")
+        for col in BAR_COLUMNS:
+            Condition.is_in(col, data.columns, col, "data.columns")
+        if random_seed is not None:
+            Condition.type(random_seed, int, "random_seed")
+
+        # Standardize and preprocess data
+        data = preprocess_bar_data(data, is_raw)
+        data.loc[:, 'volume'] = calculate_volume_quarter(data['volume'], self.instrument.size_precision)
+        data.loc[:, 'trade_id'] = data.index.view(np.uint64).astype(str)
+
+        records = data.to_records()
+        offsets = calculate_bar_price_offsets(len(records), timestamp_is_close, offset_interval_ms, random_seed)
+        ticks_final = self._create_trade_ticks_array(records, offsets)
+
+        # Sort data by timestamp, if required
+        if sort_data:
+            sorted_indices = np.argsort(ticks_final['timestamp'])
+            ticks_final = ticks_final[sorted_indices]
+
+        ts_events = ticks_final["timestamp"].view(np.uint64)
+        ts_inits = ts_events + ts_init_delta
+
+        cdef uint8_t[:] aggressor_sides = np.full(len(ts_events), AggressorSide.NO_AGGRESSOR, dtype=np.uint8)
+
+        return TradeTick.from_raw_arrays_to_list_c(
+            self.instrument.id,
+            self.instrument.price_precision,
+            self.instrument.size_precision,
+            ticks_final["price"],
+            ticks_final["size"],
+            aggressor_sides,
+            ts_events.astype(str).tolist(),
+            ts_events,
+            ts_inits,
+        )
+
+    def _create_trade_ticks_array(
+        self,
+        records,
+        offsets,
+    ):
+        dtype = [("price", np.int64), ("size", np.uint64), ("timestamp", "datetime64[ns]")]
+        tick_data = np.empty(len(records) * 4, dtype=dtype)
+        for i, price_key in enumerate(BAR_PRICES):
+            start_index = i * len(records)
+            end_index = start_index + len(records)
+            tick_data["price"][start_index:end_index] = records[price_key].astype(np.int64)
+            tick_data["size"][start_index:end_index] = records["volume"].astype(np.uint64)
+            tick_data["timestamp"][start_index:end_index] = records["timestamp"] + offsets[price_key]
+
+        return tick_data
+
     def _create_side_if_not_exist(self, data):
         if "side" in data.columns:
             return data["side"].apply(lambda x: AggressorSide.BUYER if str(x).upper() == "BUY" else AggressorSide.SELLER)
-        else:
+        elif "buyer_maker" in data.columns:
             return data["buyer_maker"].apply(lambda x: AggressorSide.SELLER if x is True else AggressorSide.BUYER)
+        else:
+            return [AggressorSide.NO_AGGRESSOR] * len(data)
 
     # cpdef method for Python wrap() (called with map)
     cpdef TradeTick _build_tick_from_raw(
         self,
         int64_t price_raw,
         uint64_t size_raw,
         AggressorSide aggressor_side,
@@ -615,16 +818,15 @@
         Condition.not_none(default_volume, "default_volume")
 
         data = as_utc_index(data)
 
         if "volume" not in data:
             data["volume"] = float(default_volume)
 
-        cdef uint64_t[:] ts_events = np.ascontiguousarray([secs_to_nanos(dt.timestamp()) for dt in data.index], dtype=np.uint64)  # noqa
-        cdef uint64_t[:] ts_inits = np.ascontiguousarray([ts_event + ts_init_delta for ts_event in ts_events], dtype=np.uint64)  # noqa
+        ts_events, ts_inits = prepare_event_and_init_timestamps(data.index, ts_init_delta)
 
         return list(map(
             self._build_bar,
             data.values,
             ts_events,
             ts_inits
         ))
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/persistence/wranglers_v2.py` & `nautilus_trader-1.191.0/nautilus_trader/persistence/wranglers_v2.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/persistence/writer.py` & `nautilus_trader-1.191.0/nautilus_trader/persistence/writer.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/portfolio/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/risk/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/portfolio/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/portfolio/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/portfolio/base.pxd` & `nautilus_trader-1.191.0/nautilus_trader/portfolio/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/portfolio/base.pyx` & `nautilus_trader-1.191.0/nautilus_trader/portfolio/base.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/portfolio/portfolio.pxd` & `nautilus_trader-1.191.0/nautilus_trader/portfolio/portfolio.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/portfolio/portfolio.pyx` & `nautilus_trader-1.191.0/nautilus_trader/portfolio/portfolio.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -178,24 +178,24 @@
             list orders_open
             AccountState result
         for instrument_id in instruments:
             instrument = self._cache.instrument(instrument_id)
             if instrument is None:
                 self._log.error(
                     f"Cannot update initial (order) margin: "
-                    f"no instrument found for {instrument.id}."
+                    f"no instrument found for {instrument.id}"
                 )
                 initialized = False
                 break
 
             account = self._cache.account_for_venue(self._venue or instrument.id.venue)
             if account is None:
                 self._log.error(
                     f"Cannot update initial (order) margin: "
-                    f"no account registered for {instrument.id.venue}."
+                    f"no account registered for {instrument.id.venue}"
                 )
                 initialized = False
                 break
 
             orders_open = self._cache.orders_open(
                 venue=None,  # Faster query filtering
                 instrument_id=instrument.id,
@@ -208,15 +208,15 @@
                 ts_event=account.last_event_c().ts_event,
             )
             if result is None:
                 initialized = False
 
         cdef int open_count = len(all_orders_open)
         self._log.info(
-            f"Initialized {open_count} open order{'' if open_count == 1 else 's'}.",
+            f"Initialized {open_count} open order{'' if open_count == 1 else 's'}",
             color=LogColor.BLUE if open_count else LogColor.NORMAL,
         )
 
         self.initialized = initialized
 
     cpdef void initialize_positions(self):
         """
@@ -255,27 +255,27 @@
 
             self._unrealized_pnls[instrument_id] = self._calculate_unrealized_pnl(instrument_id)
 
             account = self._cache.account_for_venue(self._venue or instrument_id.venue)
             if account is None:
                 self._log.error(
                     f"Cannot update maintenance (position) margin: "
-                    f"no account registered for {instrument_id.venue}."
+                    f"no account registered for {instrument_id.venue}"
                 )
                 initialized = False
                 break
 
             if account.type == AccountType.CASH:
                 continue
 
             instrument = self._cache.instrument(instrument_id)
             if instrument is None:
                 self._log.error(
                     f"Cannot update maintenance (position) margin: "
-                    f"no instrument found for {instrument.id}."
+                    f"no instrument found for {instrument.id}"
                 )
                 initialized = False
                 break
 
             result = self._accounts.update_positions(
                 account=account,
                 instrument=instrument,
@@ -286,15 +286,15 @@
                 ts_event=account.last_event_c().ts_event,
             )
             if result is None:
                 initialized = False
 
         cdef int open_count = len(all_positions_open)
         self._log.info(
-            f"Initialized {open_count} open position{'' if open_count == 1 else 's'}.",
+            f"Initialized {open_count} open position{'' if open_count == 1 else 's'}",
             color=LogColor.BLUE if open_count else LogColor.NORMAL,
         )
 
         self.initialized = initialized
 
     cpdef void update_quote_tick(self, QuoteTick tick):
         """
@@ -320,15 +320,15 @@
         if tick.instrument_id not in self._pending_calcs:
             return
 
         cdef Account account = self._cache.account_for_venue(self._venue or tick.instrument_id.venue)
         if account is None:
             self._log.error(
                 f"Cannot update tick: "
-                f"no account registered for {tick.instrument_id.venue}."
+                f"no account registered for {tick.instrument_id.venue}"
             )
             return  # No account registered
 
         cdef Instrument instrument = self._cache.instrument(self._venue or tick.instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot update tick: "
@@ -393,15 +393,15 @@
             account = AccountFactory.create_c(event)
             # Add to cache
             self._cache.add_account(account)
         else:
             account.apply(event)
             self._cache.update_account(account)
 
-        self._log.info(f"Updated {event}.")
+        self._log.info(f"Updated {event}")
 
     cpdef void update_order(self, OrderEvent event):
         """
         Update the portfolio with the given order.
 
         Parameters
         ----------
@@ -428,15 +428,15 @@
         if not isinstance(event, _UPDATE_ORDER_EVENTS):
             return  # No change to account state
 
         cdef Order order = self._cache.order(event.client_order_id)
         if order is None:
             self._log.error(
                 f"Cannot update order: "
-                f"{repr(event.client_order_id)} not found in the cache."
+                f"{repr(event.client_order_id)} not found in the cache"
             )
             return  # No order found
 
         if isinstance(event, OrderRejected) and order.order_type != OrderType.STOP_LIMIT:
             return  # No change to account state
 
         cdef Instrument instrument = self._cache.instrument(event.instrument_id)
@@ -466,23 +466,23 @@
             account=account,
             instrument=instrument,
             orders_open=[o for o in orders_open if o.is_passive_c()],
             ts_event=event.ts_event,
         )
 
         if account_state is None:
-            self._log.debug(f"Added pending calculation for {instrument.id}.")
+            self._log.debug(f"Added pending calculation for {instrument.id}")
             self._pending_calcs.add(instrument.id)
         else:
             self._msgbus.publish_c(
                 topic=f"events.account.{account.id}",
                 msg=account_state,
             )
 
-        self._log.debug(f"Updated {event}.")
+        self._log.debug(f"Updated {event}")
 
     cpdef void update_position(self, PositionEvent event):
         """
         Update the portfolio with the given position event.
 
         Parameters
         ----------
@@ -528,23 +528,23 @@
             account=account,
             instrument=instrument,
             positions_open=positions_open,
             ts_event=event.ts_event,
         )
 
         if account_state is None:
-            self._log.debug(f"Added pending calculation for {instrument.id}.")
+            self._log.debug(f"Added pending calculation for {instrument.id}")
             self._pending_calcs.add(instrument.id)
         else:
             self._msgbus.publish_c(
                 topic=f"events.account.{account.id}",
                 msg=account_state,
             )
 
-        self._log.debug(f"Updated {event}.")
+        self._log.debug(f"Updated {event}")
 
     def _reset(self) -> None:
         self._net_positions.clear()
         self._unrealized_pnls.clear()
         self._pending_calcs.clear()
         self.analyzer.reset()
 
@@ -553,32 +553,32 @@
     def reset(self) -> None:
         """
         Reset the portfolio.
 
         All stateful fields are reset to their initial value.
 
         """
-        self._log.debug(f"RESETTING...")
+        self._log.debug(f"RESETTING")
 
         self._reset()
 
-        self._log.info("READY.")
+        self._log.info("READY")
 
     def dispose(self) -> None:
         """
         Dispose of the portfolio.
 
         All stateful fields are reset to their initial value.
 
         """
-        self._log.debug(f"DISPOSING...")
+        self._log.debug(f"DISPOSING")
 
         self._reset()
 
-        self._log.info("DISPOSED.")
+        self._log.info("DISPOSED")
 
 # -- QUERIES --------------------------------------------------------------------------------------
 
     cpdef Account account(self, Venue venue):
         """
         Return the account for the given venue (if found).
 
@@ -595,15 +595,15 @@
         Condition.not_none(venue, "venue")
         Condition.not_none(self._cache, "self._cache")
 
         cdef Account account = self._cache.account_for_venue(venue)
         if account is None:
             self._log.error(
                 f"Cannot get account: "
-                f"no account registered for {venue}."
+                f"no account registered for {venue}"
             )
 
         return account
 
     cpdef dict balances_locked(self, Venue venue):
         """
         Return the balances locked for the given venue (if found).
@@ -620,15 +620,15 @@
         """
         Condition.not_none(venue, "venue")
 
         cdef Account account = self._cache.account_for_venue(venue)
         if account is None:
             self._log.error(
                 f"Cannot get balances locked: "
-                f"no account registered for {venue}."
+                f"no account registered for {venue}"
             )
             return None
 
         return account.balances_locked()
 
     cpdef dict margins_init(self, Venue venue):
         """
@@ -646,15 +646,15 @@
         """
         Condition.not_none(venue, "venue")
 
         cdef Account account = self._cache.account_for_venue(venue)
         if account is None:
             self._log.error(
                 f"Cannot get initial (order) margins: "
-                f"no account registered for {venue}."
+                f"no account registered for {venue}"
             )
             return None
 
         if account.is_cash_account:
             return None
 
         return account.margins_init()
@@ -675,15 +675,15 @@
         """
         Condition.not_none(venue, "venue")
 
         cdef Account account = self._cache.account_for_venue(venue)
         if account is None:
             self._log.error(
                 f"Cannot get maintenance (position) margins: "
-                f"no account registered for {venue}."
+                f"no account registered for {venue}"
             )
             return None
 
         if account.is_cash_account:
             return None
 
         return account.margins_maint()
@@ -745,15 +745,15 @@
         """
         Condition.not_none(venue, "venue")
 
         cdef Account account = self._cache.account_for_venue(venue)
         if account is None:
             self._log.error(
                 f"Cannot calculate net exposures: "
-                f"no account registered for {venue}."
+                f"no account registered for {venue}"
             )
             return None  # Cannot calculate
 
         cdef list positions_open = self._cache.positions_open(venue)
         if not positions_open:
             return {}  # Nothing to calculate
 
@@ -766,36 +766,43 @@
             Currency settlement_currency
             double xrate
         for position in positions_open:
             instrument = self._cache.instrument(position.instrument_id)
             if instrument is None:
                 self._log.error(
                     f"Cannot calculate net exposures: "
-                    f"no instrument for {position.instrument_id}."
+                    f"no instrument for {position.instrument_id}"
                 )
                 return None  # Cannot calculate
 
+            if position.side == PositionSide.FLAT:
+                self._log.error(
+                    f"Cannot calculate net exposures: "
+                    f"position is flat for {position.instrument_id}"
+                )
+                continue  # Nothing to calculate
+
             last = self._get_last_price(position)
             if last is None:
                 self._log.error(
                     f"Cannot calculate net exposures: "
-                    f"no prices for {position.instrument_id}."
+                    f"no prices for {position.instrument_id}"
                 )
                 continue  # Cannot calculate
 
             xrate = self._calculate_xrate_to_base(
                 instrument=instrument,
                 account=account,
                 side=position.entry,
             )
 
             if xrate == 0.0:
                 self._log.error(
                     f"Cannot calculate net exposures: "
-                    f"insufficient data for {instrument.get_settlement_currency()}/{account.base_currency}."
+                    f"insufficient data for {instrument.get_settlement_currency()}/{account.base_currency}"
                 )
                 return None  # Cannot calculate
 
             if account.base_currency is not None:
                 settlement_currency = account.base_currency
             else:
                 settlement_currency = instrument.get_settlement_currency()
@@ -854,23 +861,23 @@
         """
         Condition.not_none(instrument_id, "instrument_id")
 
         cdef Account account = self._cache.account_for_venue(self._venue or instrument_id.venue)
         if account is None:
             self._log.error(
                 f"Cannot calculate net exposure: "
-                f"no account registered for {instrument_id.venue}."
+                f"no account registered for {instrument_id.venue}"
             )
             return None  # Cannot calculate
 
         cdef instrument = self._cache.instrument(instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot calculate net exposure: "
-                f"no instrument for {instrument_id}."
+                f"no instrument for {instrument_id}"
             )
             return None  # Cannot calculate
 
         cdef list positions_open = self._cache.positions_open(
             venue=None,  # Faster query filtering
             instrument_id=instrument_id,
         )
@@ -885,28 +892,28 @@
             double xrate
             Money notional_value
         for position in positions_open:
             last = self._get_last_price(position)
             if last is None:
                 self._log.error(
                     f"Cannot calculate net exposure: "
-                    f"no prices for {position.instrument_id}."
+                    f"no prices for {position.instrument_id}"
                 )
                 continue  # Cannot calculate
 
             xrate = self._calculate_xrate_to_base(
                 instrument=instrument,
                 account=account,
                 side=position.entry,
             )
 
             if xrate == 0.0:
                 self._log.error(
                     f"Cannot calculate net exposure: "
-                    f"insufficient data for {instrument.get_settlement_currency()}/{account.base_currency}."
+                    f"insufficient data for {instrument.get_settlement_currency()}/{account.base_currency}"
                 )
                 return None  # Cannot calculate
 
             notional_value = instrument.notional_value(
                 position.quantity,
                 last,
             )
@@ -1030,23 +1037,23 @@
             self._log.info(f"{instrument_id} net_position={net_position}")
 
     cdef Money _calculate_unrealized_pnl(self, InstrumentId instrument_id):
         cdef Account account = self._cache.account_for_venue(self._venue or instrument_id.venue)
         if account is None:
             self._log.error(
                 f"Cannot calculate unrealized PnL: "
-                f"no account registered for {instrument_id.venue}."
+                f"no account registered for {instrument_id.venue}"
             )
             return None  # Cannot calculate
 
         cdef Instrument instrument = self._cache.instrument(instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot calculate unrealized PnL: "
-                f"no instrument for {instrument_id}."
+                f"no instrument for {instrument_id}"
             )
             return None  # Cannot calculate
 
         cdef Currency currency
         if account.base_currency is not None:
             currency = account.base_currency
         else:
@@ -1066,18 +1073,21 @@
             Price last
             double pnl
             double xrate
         for position in positions_open:
             if position.instrument_id != instrument_id:
                 continue  # Nothing to calculate
 
+            if position.side == PositionSide.FLAT:
+                continue  # Nothing to calculate
+
             last = self._get_last_price(position)
             if last is None:
                 self._log.debug(
-                    f"Cannot calculate unrealized PnL: no prices for {instrument_id}."
+                    f"Cannot calculate unrealized PnL: no prices for {instrument_id}"
                 )
                 self._pending_calcs.add(instrument.id)
                 return None  # Cannot calculate
 
             pnl = position.unrealized_pnl(last).as_f64_c()
 
             if account.base_currency is not None:
@@ -1086,39 +1096,44 @@
                     account=account,
                     side=position.entry,
                 )
 
                 if xrate == 0.0:
                     self._log.debug(
                         f"Cannot calculate unrealized PnL: "
-                        f"insufficient data for {instrument.get_settlement_currency()}/{account.base_currency}."
+                        f"insufficient data for {instrument.get_settlement_currency()}/{account.base_currency}"
                     )
                     self._pending_calcs.add(instrument.id)
                     return None  # Cannot calculate
 
                 pnl = round(pnl * xrate, currency.get_precision())
 
             total_pnl += pnl
 
         return Money(total_pnl, currency)
 
     cdef Price _get_last_price(self, Position position):
-        cdef QuoteTick quote_tick = self._cache.quote_tick(position.instrument_id)
-        if quote_tick is not None:
-            if position.side == PositionSide.LONG:
-                return quote_tick.bid_price
-            elif position.side == PositionSide.SHORT:
-                return quote_tick.ask_price
-            else:  # pragma: no cover (design-time error)
-                raise RuntimeError(
-                    f"invalid `PositionSide`, was {position_side_to_str(position.side)}",
-                )
-
-        cdef TradeTick trade_tick = self._cache.trade_tick(position.instrument_id)
-        return trade_tick.price if trade_tick is not None else None
+        cdef PriceType price_type
+        if position.side == PositionSide.LONG:
+            price_type = PriceType.BID
+        elif position.side == PositionSide.SHORT:
+            price_type = PriceType.ASK
+        else:  # pragma: no cover (design-time error)
+            raise RuntimeError(
+                f"invalid `PositionSide`, was {position_side_to_str(position.side)}",
+            )
+
+        cdef Price price
+        return self._cache.price(
+            instrument_id=position.instrument_id,
+            price_type=price_type,
+        ) or self._cache.price(
+            instrument_id=position.instrument_id,
+            price_type=PriceType.LAST,
+        )
 
     cdef double _calculate_xrate_to_base(self, Account account, Instrument instrument, OrderSide side):
         if account.base_currency is not None:
             return self._cache.get_xrate(
                 venue=self._venue or instrument.id.venue,
                 from_currency=instrument.get_settlement_currency(),
                 to_currency=account.base_currency,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/risk/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/serialization/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/risk/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/risk/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/risk/config.py` & `nautilus_trader-1.191.0/nautilus_trader/risk/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/risk/engine.pxd` & `nautilus_trader-1.191.0/nautilus_trader/risk/engine.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/risk/engine.pyx` & `nautilus_trader-1.191.0/nautilus_trader/risk/engine.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -31,14 +31,15 @@
 from nautilus_trader.common.component cimport LogColor
 from nautilus_trader.common.component cimport MessageBus
 from nautilus_trader.common.component cimport Throttler
 from nautilus_trader.common.messages cimport TradingStateChanged
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.message cimport Command
 from nautilus_trader.core.message cimport Event
+from nautilus_trader.core.rust.model cimport AccountType
 from nautilus_trader.core.rust.model cimport InstrumentClass
 from nautilus_trader.core.rust.model cimport OrderSide
 from nautilus_trader.core.rust.model cimport OrderStatus
 from nautilus_trader.core.rust.model cimport OrderType
 from nautilus_trader.core.rust.model cimport TradingState
 from nautilus_trader.core.rust.model cimport TriggerType
 from nautilus_trader.core.uuid cimport UUID4
@@ -143,15 +144,15 @@
             output_send=self._send_to_execution,
             output_drop=self._deny_new_order,
             clock=clock,
         )
 
         self._log.info(
             f"Set MAX_ORDER_SUBMIT_RATE: "
-            f"{order_submit_rate_limit}/{str(order_submit_rate_interval).replace('0 days ', '')}.",
+            f"{order_submit_rate_limit}/{str(order_submit_rate_interval).replace('0 days ', '')}",
             color=LogColor.BLUE,
         )
 
         pieces = config.max_order_modify_rate.split("/")
         order_modify_rate_limit = int(pieces[0])
         order_modify_rate_interval = pd.to_timedelta(pieces[1])
         self._order_modify_throttler = Throttler(
@@ -161,15 +162,15 @@
             output_send=self._send_to_execution,
             output_drop=self._deny_modify_order,
             clock=clock,
         )
 
         self._log.info(
             f"Set MAX_ORDER_MODIFY_RATE: "
-            f"{order_modify_rate_limit}/{str(order_modify_rate_interval).replace('0 days ', '')}.",
+            f"{order_modify_rate_limit}/{str(order_modify_rate_interval).replace('0 days ', '')}",
             color=LogColor.BLUE,
         )
 
         # Risk settings
         self._max_notional_per_order: dict[InstrumentId, Decimal] = {}
 
         # Configure
@@ -227,15 +228,15 @@
         state : TradingState
             The state to set.
 
         """
         if state == self.trading_state:
             self._log.warning(
                 f"No change to trading state: "
-                f"already set to {trading_state_to_str(self.trading_state)}.",
+                f"already set to {trading_state_to_str(self.trading_state)}",
             )
             return
 
         self.trading_state = state
 
         cdef uint64_t ts_now = self._clock.timestamp_ns()
         cdef TradingStateChanged event = TradingStateChanged(
@@ -253,21 +254,21 @@
     cpdef void _log_state(self):
         cdef LogColor color = LogColor.BLUE
         if self.trading_state == TradingState.REDUCING:
             color = LogColor.YELLOW
         elif self.trading_state == TradingState.HALTED:
             color = LogColor.RED
         self._log.info(
-            f"TradingState is {trading_state_to_str(self.trading_state)}.",
+            f"TradingState is {trading_state_to_str(self.trading_state)}",
             color=color,
         )
 
         if self.is_bypassed:
             self._log.info(
-                "PRE-TRADE RISK CHECKS BYPASSED. This is not advisable for live trading.",
+                "PRE-TRADE RISK CHECKS BYPASSED. This is not advisable for live trading",
                 color=LogColor.RED,
             )
 
     cpdef void set_max_notional_per_order(self, InstrumentId instrument_id, new_value):
         """
         Set the maximum notional value per order for the given instrument ID.
 
@@ -295,15 +296,15 @@
             Condition.positive(new_value, "new_value")
 
         old_value: Decimal = self._max_notional_per_order.get(instrument_id)
         self._max_notional_per_order[instrument_id] = new_value
 
         cdef str new_value_str = f"{new_value:,}" if new_value is not None else str(None)
         self._log.info(
-            f"Set MAX_NOTIONAL_PER_ORDER: {instrument_id} {new_value_str}.",
+            f"Set MAX_NOTIONAL_PER_ORDER: {instrument_id} {new_value_str}",
             color=LogColor.BLUE,
         )
 
 # -- RISK SETTINGS --------------------------------------------------------------------------------
 
     cpdef tuple max_order_submit_rate(self):
         """
@@ -385,25 +386,25 @@
         pass
         # Nothing to dispose for now
 
 # -- COMMAND HANDLERS -----------------------------------------------------------------------------
 
     cpdef void _execute_command(self, Command command):
         if self.debug:
-            self._log.debug(f"{RECV}{CMD} {command}.", LogColor.MAGENTA)
+            self._log.debug(f"{RECV}{CMD} {command}", LogColor.MAGENTA)
         self.command_count += 1
 
         if isinstance(command, SubmitOrder):
             self._handle_submit_order(command)
         elif isinstance(command, SubmitOrderList):
             self._handle_submit_order_list(command)
         elif isinstance(command, ModifyOrder):
             self._handle_modify_order(command)
         else:
-            self._log.error(f"Cannot handle command: {command}.")
+            self._log.error(f"Cannot handle command: {command}")
 
     cpdef void _handle_submit_order(self, SubmitOrder command):
         if self.is_bypassed:
             # Perform no further risk checks or throttling
             self._send_to_execution(command)
             return
 
@@ -473,15 +474,15 @@
     cpdef void _handle_modify_order(self, ModifyOrder command):
         ########################################################################
         # VALIDATE COMMAND
         ########################################################################
         cdef Order order = self._cache.order(command.client_order_id)
         if order is None:
             self._log.error(
-                f"ModifyOrder DENIED: Order with {command.client_order_id!r} not found.",
+                f"ModifyOrder DENIED: Order with {command.client_order_id!r} not found",
             )
             return  # Denied
         elif order.is_closed_c():
             self._reject_modify_order(
                 order=order,
                 reason=f"Order with {command.client_order_id!r} already closed",
             )
@@ -598,27 +599,29 @@
         cdef Price last_px = None
         cdef Money free
 
         # Determine max notional
         cdef Money max_notional = None
         max_notional_setting: Decimal | None = self._max_notional_per_order.get(instrument.id)
         if max_notional_setting:
-            # TODO(cs): Improve efficiency of this
+            # TODO: Improve efficiency of this
             max_notional = Money(float(max_notional_setting), instrument.quote_currency)
 
         # Get account for risk checks
         cdef Account account = self._cache.account_for_venue(instrument.id.venue)
         if account is None:
-            self._log.debug(f"Cannot find account for venue {instrument.id.venue}.")
+            self._log.debug(f"Cannot find account for venue {instrument.id.venue}")
             return True  # TODO: Temporary early return until handling routing/multiple venues
 
         if account.is_margin_account:
             return True  # TODO: Determine risk controls for margin
 
         free = account.balance_free(instrument.quote_currency)
+        if self.debug:
+            self._log.debug(f"Free: {free!r}", LogColor.MAGENTA)
 
         cdef:
             Order order
             Money notional
             Money cum_notional_buy = None
             Money cum_notional_sell = None
             Money order_balance_impact = None
@@ -639,32 +642,34 @@
                             raise RuntimeError(f"invalid `OrderSide`")
                     else:
                         last_trade = self._cache.trade_tick(instrument.id)
                         if last_trade is not None:
                             last_px = last_trade.price
                         else:
                             self._log.warning(
-                                f"Cannot check MARKET order risk: no prices for {instrument.id}.",
+                                f"Cannot check MARKET order risk: no prices for {instrument.id}",
                             )
                             continue  # Cannot check order risk
             elif order.order_type == OrderType.STOP_MARKET or order.order_type == OrderType.MARKET_IF_TOUCHED:
                 last_px = order.trigger_price
             elif order.order_type == OrderType.TRAILING_STOP_MARKET or order.order_type == OrderType.TRAILING_STOP_LIMIT:
                 if order.trigger_price is None:
                     self._log.warning(
                         f"Cannot check {order_type_to_str(order.order_type)} order risk: "
-                        f"no trigger price was set.",  # TODO(cs): Use last_trade += offset
+                        f"no trigger price was set",  # TODO: Use last_trade += offset
                     )
                     continue  # Cannot assess risk
                 else:
                     last_px = order.trigger_price
             else:
                 last_px = order.price
 
             notional = instrument.notional_value(order.quantity, last_px, use_quote_for_inverse=True)
+            if self.debug:
+                self._log.debug(f"Notional: {order_balance_impact!r}", LogColor.MAGENTA)
 
             if max_notional and notional._mem.raw > max_notional._mem.raw:
                 self._deny_order(
                     order=order,
                     reason=f"NOTIONAL_EXCEEDS_MAX_PER_ORDER: max_notional={max_notional.to_str()}, notional={notional.to_str()}",
                 )
                 return False  # Denied
@@ -690,14 +695,16 @@
                 self._deny_order(
                     order=order,
                     reason=f"NOTIONAL_GREATER_THAN_MAX_FOR_INSTRUMENT: max_notional={instrument.max_notional.to_str()}, notional={notional.to_str()}",
                 )
                 return False  # Denied
 
             order_balance_impact = account.balance_impact(instrument, order.quantity, last_px, order.side)
+            if self.debug:
+                self._log.debug(f"Balance impact: {order_balance_impact!r}", LogColor.MAGENTA)
 
             if free is not None and (free._mem.raw + order_balance_impact._mem.raw) < 0:
                 self._deny_order(
                     order=order,
                     reason=f"NOTIONAL_EXCEEDS_FREE_BALANCE: free={free.to_str()}, notional={order_balance_impact.to_str()}",
                 )
                 return False  # Denied
@@ -706,39 +713,50 @@
                 base_currency = instrument.get_base_currency()
 
             if order.is_buy_c():
                 if cum_notional_buy is None:
                     cum_notional_buy = Money(-order_balance_impact, order_balance_impact.currency)
                 else:
                     cum_notional_buy._mem.raw += -order_balance_impact._mem.raw
+
+                if self.debug:
+                    self._log.debug(f"Cumulative notional BUY: {cum_notional_buy!r}")
                 if free is not None and cum_notional_buy._mem.raw > free._mem.raw:
                     self._deny_order(
                         order=order,
                         reason=f"CUM_NOTIONAL_EXCEEDS_FREE_BALANCE: free={free.to_str()}, cum_notional={cum_notional_buy.to_str()}",
                     )
                     return False  # Denied
             elif order.is_sell_c():
                 if account.base_currency is not None:
                     if cum_notional_sell is None:
                         cum_notional_sell = Money(order_balance_impact, order_balance_impact.currency)
                     else:
                         cum_notional_sell._mem.raw += order_balance_impact._mem.raw
+
+                    if self.debug:
+                        self._log.debug(f"Cumulative notional SELL: {cum_notional_sell!r}")
                     if free is not None and cum_notional_sell._mem.raw > free._mem.raw:
                         self._deny_order(
                             order=order,
                             reason=f"CUM_NOTIONAL_EXCEEDS_FREE_BALANCE: free={free.to_str()}, cum_notional={cum_notional_sell.to_str()}",
                         )
                         return False  # Denied
-                elif base_currency is not None:
+                elif base_currency is not None and account.type == AccountType.CASH:
                     cash_value = Money(order.quantity.as_f64_c(), base_currency)
+                    self._log.debug(f"Cash value: {cash_value!r}", LogColor.MAGENTA)
                     free = account.balance_free(base_currency)
+                    self._log.debug(f"Free: {free!r}", LogColor.MAGENTA)
                     if cum_notional_sell is None:
                         cum_notional_sell = cash_value
                     else:
                         cum_notional_sell._mem.raw += cash_value._mem.raw
+
+                    if self.debug:
+                        self._log.debug(f"Cumulative notional SELL: {cum_notional_sell!r}")
                     if free is not None and cum_notional_sell._mem.raw > free._mem.raw:
                         self._deny_order(
                             order=order,
                             reason=f"CUM_NOTIONAL_EXCEEDS_FREE_BALANCE: free={free.to_str()}, cum_notional={cum_notional_sell.to_str()}",
                         )
                         return False  # Denied
 
@@ -788,20 +806,20 @@
         elif isinstance(command, SubmitOrderList):
             self._deny_order_list(command.order_list, reason="Exceeded MAX_ORDER_SUBMIT_RATE")
 
     # Needs to be `cpdef` due being called from throttler
     cpdef void _deny_modify_order(self, ModifyOrder command):
         cdef Order order = self._cache.order(command.client_order_id)
         if order is None:
-            self._log.error(f"Order with {command.client_order_id!r} not found.")
+            self._log.error(f"Order with {command.client_order_id!r} not found")
             return
         self._reject_modify_order(order, reason="Exceeded MAX_ORDER_MODIFY_RATE")
 
     cpdef void _deny_order(self, Order order, str reason):
-        self._log.error(f"SubmitOrder for {order.client_order_id.to_str()} DENIED: {reason}.")
+        self._log.warning(f"SubmitOrder for {order.client_order_id.to_str()} DENIED: {reason}")
 
         if order is None:
             # Nothing to deny
             return
 
         if order.status_c() != OrderStatus.INITIALIZED:
             # Already denied or duplicated (INITIALIZED -> DENIED only valid state transition)
@@ -902,9 +920,9 @@
 
         self._msgbus.send(endpoint="ExecEngine.process", msg=denied)
 
 # -- EVENT HANDLERS -------------------------------------------------------------------------------
 
     cpdef void _handle_event(self, Event event):
         if self.debug:
-            self._log.debug(f"{RECV}{EVT} {event}.", LogColor.MAGENTA)
+            self._log.debug(f"{RECV}{EVT} {event}", LogColor.MAGENTA)
         self.event_count += 1
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/risk/sizing.pxd` & `nautilus_trader-1.191.0/nautilus_trader/risk/sizing.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/risk/sizing.pyx` & `nautilus_trader-1.191.0/nautilus_trader/risk/sizing.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/__init__.pxd` & `nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/implementations/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -8,15 +8,7 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-"""
-The `serialization` subpackage groups all serialization components and serializer
-implementations.
-
-Base classes are defined which can allow for other serialization implementations beside
-the built-in specification serializers.
-
-"""
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/system/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/implementations/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/implementations/account_state.py` & `nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/implementations/account_state.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/implementations/component_events.py` & `nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/implementations/component_events.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/implementations/instruments.py` & `nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/implementations/instruments.py`

 * *Files 2% similar despite different names*

```diff
@@ -113,14 +113,15 @@
     CryptoFuture: pa.schema(
         {
             "id": pa.dictionary(pa.int64(), pa.string()),
             "raw_symbol": pa.string(),
             "underlying": pa.dictionary(pa.int16(), pa.string()),
             "quote_currency": pa.dictionary(pa.int16(), pa.string()),
             "settlement_currency": pa.dictionary(pa.int16(), pa.string()),
+            "is_inverse": pa.bool_(),
             "activation_ns": pa.uint64(),
             "expiration_ns": pa.uint64(),
             "price_precision": pa.uint8(),
             "size_precision": pa.uint8(),
             "price_increment": pa.dictionary(pa.int16(), pa.string()),
             "size_increment": pa.dictionary(pa.int16(), pa.string()),
             "max_quantity": pa.dictionary(pa.int16(), pa.string()),
@@ -147,14 +148,15 @@
             "price_increment": pa.dictionary(pa.int16(), pa.string()),
             "lot_size": pa.dictionary(pa.int16(), pa.string()),
             "isin": pa.string(),
             "margin_init": pa.string(),
             "margin_maint": pa.string(),
             "maker_fee": pa.string(),
             "taker_fee": pa.string(),
+            "info": pa.binary(),
             "ts_event": pa.uint64(),
             "ts_init": pa.uint64(),
         },
     ),
     FuturesContract: pa.schema(
         {
             "id": pa.dictionary(pa.int64(), pa.string()),
@@ -167,14 +169,15 @@
             "size_precision": pa.uint8(),
             "price_increment": pa.dictionary(pa.int16(), pa.string()),
             "size_increment": pa.dictionary(pa.int16(), pa.string()),
             "multiplier": pa.dictionary(pa.int16(), pa.string()),
             "lot_size": pa.dictionary(pa.int16(), pa.string()),
             "activation_ns": pa.uint64(),
             "expiration_ns": pa.uint64(),
+            "info": pa.binary(),
             "ts_event": pa.uint64(),
             "ts_init": pa.uint64(),
         },
     ),
     FuturesSpread: pa.schema(
         {
             "id": pa.dictionary(pa.int64(), pa.string()),
@@ -188,14 +191,15 @@
             "size_precision": pa.uint8(),
             "price_increment": pa.dictionary(pa.int16(), pa.string()),
             "size_increment": pa.dictionary(pa.int16(), pa.string()),
             "multiplier": pa.dictionary(pa.int16(), pa.string()),
             "lot_size": pa.dictionary(pa.int16(), pa.string()),
             "activation_ns": pa.uint64(),
             "expiration_ns": pa.uint64(),
+            "info": pa.binary(),
             "ts_event": pa.uint64(),
             "ts_init": pa.uint64(),
         },
     ),
     OptionsContract: pa.schema(
         {
             "id": pa.dictionary(pa.int64(), pa.string()),
@@ -210,14 +214,15 @@
             "size_increment": pa.dictionary(pa.int16(), pa.string()),
             "multiplier": pa.dictionary(pa.int16(), pa.string()),
             "lot_size": pa.dictionary(pa.int16(), pa.string()),
             "activation_ns": pa.uint64(),
             "expiration_ns": pa.uint64(),
             "strike_price": pa.dictionary(pa.int64(), pa.string()),
             "option_kind": pa.dictionary(pa.int8(), pa.string()),
+            "info": pa.binary(),
             "ts_event": pa.uint64(),
             "ts_init": pa.uint64(),
         },
     ),
     OptionsSpread: pa.schema(
         {
             "id": pa.dictionary(pa.int64(), pa.string()),
@@ -231,14 +236,15 @@
             "size_precision": pa.uint8(),
             "price_increment": pa.dictionary(pa.int16(), pa.string()),
             "size_increment": pa.dictionary(pa.int16(), pa.string()),
             "multiplier": pa.dictionary(pa.int16(), pa.string()),
             "lot_size": pa.dictionary(pa.int16(), pa.string()),
             "activation_ns": pa.uint64(),
             "expiration_ns": pa.uint64(),
+            "info": pa.binary(),
             "ts_event": pa.uint64(),
             "ts_init": pa.uint64(),
         },
     ),
 }
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/implementations/order_events.py` & `nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/implementations/order_events.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/implementations/position_events.py` & `nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/implementations/position_events.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/schema.py` & `nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/schema.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/arrow/serializer.py` & `nautilus_trader-1.191.0/nautilus_trader/serialization/arrow/serializer.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/base.pxd` & `nautilus_trader-1.191.0/nautilus_trader/serialization/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/base.pyx` & `nautilus_trader-1.191.0/nautilus_trader/serialization/base.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -214,51 +214,51 @@
     VenueStatus,
     InstrumentClose,
     BinanceBar,
     BinanceTicker,
 }
 
 
-cpdef void register_serializable_object(
-    obj: type,
+cpdef void register_serializable_type(
+    cls: type,
     to_dict: Callable[[Any], dict[str, Any]],
     from_dict: Callable[[dict[str, Any]], Any],
 ):
     """
-    Register the given object with the global serialization object maps.
+    Register the given type with the global serialization type maps.
 
     The `type` will also be registered as an external publishable type and
     will be published externally on the message bus unless also added to
     the `MessageBusConfig.types_filter`.
 
     Parameters
     ----------
-    obj : type
-        The object type to register.
+    cls : type
+        The type to register.
     to_dict : Callable[[Any], dict[str, Any]]
-        The delegate to instantiate a dict of primitive types from the object.
+        The delegate to instantiate a dict of primitive types from an object.
     from_dict : Callable[[dict[str, Any]], Any]
-        The delegate to instantiate the object from a dict of primitive types.
+        The delegate to instantiate an object from a dict of primitive types.
 
     Raises
     ------
     TypeError
         If `to_dict` or `from_dict` are not of type `Callable`.
     KeyError
-        If obj already registered with the global object maps.
+        If `type` already registered with the global type maps.
 
     """
     Condition.callable(to_dict, "to_dict")
     Condition.callable(from_dict, "from_dict")
-    Condition.not_in(obj.__name__, _OBJECT_TO_DICT_MAP, "obj.__name__", "_OBJECT_TO_DICT_MAP")
-    Condition.not_in(obj.__name__, _OBJECT_FROM_DICT_MAP, "obj.__name__", "_OBJECT_FROM_DICT_MAP")
+    Condition.not_in(cls.__name__, _OBJECT_TO_DICT_MAP, "cls.__name__", "_OBJECT_TO_DICT_MAP")
+    Condition.not_in(cls.__name__, _OBJECT_FROM_DICT_MAP, "cls.__name__", "_OBJECT_FROM_DICT_MAP")
 
-    _OBJECT_TO_DICT_MAP[obj.__name__] = to_dict
-    _OBJECT_FROM_DICT_MAP[obj.__name__] = from_dict
-    _EXTERNAL_PUBLISHABLE_TYPES.add(obj)
+    _OBJECT_TO_DICT_MAP[cls.__name__] = to_dict
+    _OBJECT_FROM_DICT_MAP[cls.__name__] = from_dict
+    _EXTERNAL_PUBLISHABLE_TYPES.add(cls)
 
 
 cdef class Serializer:
     """
     The base class for all serializers.
 
     Warnings
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/serializer.pxd` & `nautilus_trader-1.191.0/nautilus_trader/serialization/serializer.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/serialization/serializer.pyx` & `nautilus_trader-1.191.0/nautilus_trader/serialization/serializer.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/system/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/system/config.py` & `nautilus_trader-1.191.0/nautilus_trader/system/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/system/kernel.py` & `nautilus_trader-1.191.0/nautilus_trader/system/kernel.py`

 * *Files 8% similar despite different names*

```diff
@@ -29,14 +29,15 @@
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.cache.database import CacheDatabaseAdapter
 from nautilus_trader.common import Environment
 from nautilus_trader.common.actor import Actor
 from nautilus_trader.common.component import Clock
 from nautilus_trader.common.component import LiveClock
 from nautilus_trader.common.component import Logger
+from nautilus_trader.common.component import LogGuard
 from nautilus_trader.common.component import MessageBus
 from nautilus_trader.common.component import TestClock
 from nautilus_trader.common.component import init_logging
 from nautilus_trader.common.component import is_logging_initialized
 from nautilus_trader.common.component import log_header
 from nautilus_trader.common.component import register_component_clock
 from nautilus_trader.common.component import set_logging_pyo3
@@ -154,14 +155,15 @@
             raise NotImplementedError(  # pragma: no cover (design-time error)
                 f"environment {self._environment} not recognized",  # pragma: no cover (design-time error)
             )
 
         register_component_clock(self._instance_id, self._clock)
 
         # Initialize logging system
+        self._log_guard: nautilus_pyo3.LogGuard | LogGuard | None = None
         logging: LoggingConfig = config.logging or LoggingConfig()
 
         if not is_logging_initialized():
             if not logging.bypass_logging:
                 if logging.use_pyo3:
                     set_logging_pyo3(True)
                     # Initialize tracing for async Rust
@@ -214,15 +216,15 @@
             elif self._environment == Environment.LIVE:
                 raise InvalidConfiguration(
                     "`LoggingConfig.bypass_logging` was set `True` "
                     "when not safe to bypass logging in a LIVE context",
                 )
 
         self._log: Logger = Logger(name=name)
-        self._log.info("Building system kernel...")
+        self._log.info("Building system kernel")
 
         # Setup loop (if sandbox live)
         self._loop: asyncio.AbstractEventLoop | None = None
         if self._environment != Environment.BACKTEST:
             self._loop = loop or asyncio.get_running_loop()
             if loop is not None:
                 self._executor = concurrent.futures.ThreadPoolExecutor()
@@ -230,14 +232,35 @@
                 self._loop.set_debug(config.loop_debug)
                 self._loop_sig_callback = loop_sig_callback
                 if platform.system() != "Windows":
                     # Windows does not support signal handling
                     # https://stackoverflow.com/questions/45987985/asyncio-loops-add-signal-handler-in-windows
                     self._setup_loop()
 
+        ########################################################################
+        # MessageBus database
+        ########################################################################
+        if not config.message_bus or not config.message_bus.database:
+            msgbus_db = None
+        elif config.message_bus.database.type == "redis":
+            msgbus_db = nautilus_pyo3.RedisMessageBusDatabase(
+                trader_id=nautilus_pyo3.TraderId(self._trader_id.value),
+                instance_id=nautilus_pyo3.UUID4(self._instance_id.value),
+                config_json=msgspec.json.encode(config.message_bus),
+            )
+        else:
+            raise ValueError(
+                f"Unrecognized `config.message_bus.database.type`, was '{config.message_bus.database.type}'. "
+                "The only database type currently supported is 'redis', if you don't want a message bus database backing "
+                "then you can pass `None` for the `message_bus.database` ('in-memory' is no longer valid)",
+            )
+
+        ########################################################################
+        # Cache database
+        ########################################################################
         if not config.cache or not config.cache.database:
             cache_db = None
         elif config.cache.database.type == "redis":
             encoding = config.cache.encoding.lower()
             cache_db = CacheDatabaseAdapter(
                 trader_id=self._trader_id,
                 instance_id=self._instance_id,
@@ -254,38 +277,28 @@
                 "The only database type currently supported is 'redis', if you don't want a cache database backing "
                 "then you can pass `None` for the `cache.database` ('in-memory' is no longer valid)",
             )
 
         ########################################################################
         # Core components
         ########################################################################
-        if (
-            config.message_bus
-            and config.message_bus.database
-            and config.message_bus.database.type != "redis"
-        ):
-            raise ValueError(
-                f"Unrecognized `config.message_bus.type`, was '{config.message_bus.database.type}'. "
-                "The only database type currently supported is 'redis', if you don't want a message bus database backing "
-                "then you can pass `None` for the `message_bus.database`",
-            )
-
         msgbus_serializer = None
         if config.message_bus:
             encoding = config.message_bus.encoding.lower()
             msgbus_serializer = MsgSpecSerializer(
                 encoding=msgspec.msgpack if encoding == "msgpack" else msgspec.json,
                 timestamps_as_str=True,  # Hardcoded for now
                 timestamps_as_iso8601=config.message_bus.timestamps_as_iso8601,
             )
         self._msgbus = MessageBus(
             trader_id=self._trader_id,
             instance_id=self._instance_id,
             clock=self._clock,
             serializer=msgbus_serializer,
+            database=msgbus_db,
             snapshot_orders=config.snapshot_orders,
             snapshot_positions=config.snapshot_positions,
             config=config.message_bus,
         )
 
         self._cache = Cache(
             database=cache_db,
@@ -423,14 +436,15 @@
         # Add controller
         self._controller: Controller | None = None
         if self._config.controller:
             self._controller = ControllerFactory.create(
                 config=self._config.controller,
                 trader=self._trader,
             )
+            assert self._controller is not None  # Type checking
             self._controller.register_base(
                 portfolio=self._portfolio,
                 msgbus=self._msgbus,
                 cache=self._cache,
                 clock=self._clock,
             )
 
@@ -461,33 +475,33 @@
 
         # Create importable execution algorithms
         for exec_algorithm_config in config.exec_algorithms:
             exec_algorithm: ExecAlgorithm = ExecAlgorithmFactory.create(exec_algorithm_config)
             self._trader.add_exec_algorithm(exec_algorithm)
 
         build_time_ms = nanos_to_millis(time.time_ns() - self.ts_created)
-        self._log.info(f"Initialized in {build_time_ms}ms.")
+        self._log.info(f"Initialized in {build_time_ms}ms")
 
     def __del__(self) -> None:
         if hasattr(self, "_writer") and self._writer and not self._writer.is_closed:
             self._writer.close()
 
     def _setup_loop(self) -> None:
         if self._loop is None:
             raise RuntimeError("No event loop available for the node")
 
         if self._loop.is_closed():
-            self._log.error("Cannot setup signal handling (event loop was closed).")
+            self._log.error("Cannot setup signal handling (event loop was closed)")
             return
 
         signal.signal(signal.SIGINT, signal.SIG_DFL)
         signals = (signal.SIGTERM, signal.SIGINT, signal.SIGABRT)
         for sig in signals:
             self._loop.add_signal_handler(sig, self._loop_sig_handler, sig)
-        self._log.debug(f"Event loop signal handling setup for {signals}.")
+        self._log.debug(f"Event loop signal handling setup for {signals}")
 
     def _loop_sig_handler(self, sig: signal.Signals) -> None:
         if self._loop is None:
             raise RuntimeError("No event loop available for the node")
 
         self._loop.remove_signal_handler(signal.SIGTERM)
         self._loop.add_signal_handler(signal.SIGINT, lambda: None)
@@ -783,19 +797,32 @@
         Returns
         -------
         ParquetDataCatalog or ``None``
 
         """
         return self._catalog
 
+    def get_log_guard(self) -> nautilus_pyo3.LogGuard | LogGuard | None:
+        """
+        Return the global logging systems log guard.
+
+        May return ``None`` if the logging system was already initialized.
+
+        Returns
+        -------
+        nautilus_pyo3.LogGuard | LogGuard | None
+
+        """
+        return self._log_guard
+
     def start(self) -> None:
         """
         Start the Nautilus system kernel.
         """
-        self._log.info("STARTING...")
+        self._log.info("STARTING")
 
         self._start_engines()
         self._connect_clients()
         self._emulator.start()
         self._initialize_portfolio()
         self._trader.start()
 
@@ -811,15 +838,15 @@
         RuntimeError
             If no event loop has been assigned to the kernel.
 
         """
         if self.loop is None:
             raise RuntimeError("no event loop has been assigned to the kernel")
 
-        self._log.info("STARTING...")
+        self._log.info("STARTING")
 
         self._register_executor()
         self._start_engines()
         self._connect_clients()
 
         if not await self._await_engines_connected():
             return
@@ -838,15 +865,15 @@
         if self._controller:
             self._controller.start()
 
     async def stop(self) -> None:
         """
         Stop the Nautilus system kernel.
         """
-        self._log.info("STOPPING...")
+        self._log.info("STOPPING")
 
         if self._controller:
             self._controller.stop()
 
         if self._trader.is_running:
             self._trader.stop()
 
@@ -855,15 +882,15 @@
 
         self._disconnect_clients()
 
         self._stop_engines()
         self._cancel_timers()
         self._flush_writer()
 
-        self._log.info("STOPPED.")
+        self._log.info("STOPPED")
 
     async def stop_async(self) -> None:
         """
         Stop the Nautilus system kernel asynchronously.
 
         After a specified delay the internal `Trader` residual state will be checked.
 
@@ -874,15 +901,15 @@
         RuntimeError
             If no event loop has been assigned to the kernel.
 
         """
         if self.loop is None:
             raise RuntimeError("no event loop has been assigned to the kernel")
 
-        self._log.info("STOPPING...")
+        self._log.info("STOPPING")
 
         if self._trader.is_running:
             self._trader.stop()
             await self._await_trader_residuals()
 
         if self.save_state:
             self._trader.save()
@@ -891,15 +918,15 @@
 
         await self._await_engines_disconnected()
 
         self._stop_engines()
         self._cancel_timers()
         self._flush_writer()
 
-        self._log.info("STOPPED.")
+        self._log.info("STOPPED")
 
     def dispose(self) -> None:
         """
         Dispose of the Nautilus kernel, releasing system resources.
 
         Calling this method multiple times has the same effect as calling it once (it is
         idempotent). Once called, it cannot be reversed, and no other methods should be
@@ -912,14 +939,17 @@
         if not self.data_engine.is_disposed:
             self.data_engine.dispose()
         if not self.risk_engine.is_disposed:
             self.risk_engine.dispose()
         if not self.exec_engine.is_disposed:
             self.exec_engine.dispose()
 
+        self._cache.dispose()
+        self._msgbus.dispose()
+
         if not self.trader.is_disposed:
             self.trader.dispose()
 
         if self._writer:
             self._writer.close()
 
     def cancel_all_tasks(self) -> None:
@@ -933,23 +963,23 @@
 
         """
         if self.loop is None:
             raise RuntimeError("no event loop has been assigned to the kernel")
 
         to_cancel = asyncio.tasks.all_tasks(self.loop)
         if not to_cancel:
-            self._log.info("All tasks canceled.")
+            self._log.info("All tasks canceled")
             return
 
         for task in to_cancel:
             self._log.warning(f"Canceling pending task {task}")
             task.cancel()
 
         if self.loop and self.loop.is_running():
-            self._log.warning("Event loop still running during `cancel_all_tasks`.")
+            self._log.warning("Event loop still running during `cancel_all_tasks`")
             return
 
         finish_all_tasks: asyncio.Future = asyncio.tasks.gather(*to_cancel)
         self.loop.run_until_complete(finish_all_tasks)
 
         self._log.debug(f"{finish_all_tasks}")
 
@@ -1007,15 +1037,15 @@
         self._log.info(
             f"Awaiting engine connections and initializations "
             f"({self._config.timeout_connection}s timeout)...",
             color=LogColor.BLUE,
         )
         if not await self._check_engines_connected():
             self._log.warning(
-                f"Timed out ({self._config.timeout_connection}s) waiting for engines to connect and initialize."
+                f"Timed out ({self._config.timeout_connection}s) waiting for engines to connect and initialize"
                 f"\nStatus"
                 f"\n------"
                 f"\nDataEngine.check_connected() == {self._data_engine.check_connected()}"
                 f"\nExecEngine.check_connected() == {self._exec_engine.check_connected()}",
             )
             return False
 
@@ -1025,15 +1055,15 @@
         self._log.info(
             f"Awaiting engine disconnections "
             f"({self._config.timeout_disconnection}s timeout)...",
             color=LogColor.BLUE,
         )
         if not await self._check_engines_disconnected():
             self._log.error(
-                f"Timed out ({self._config.timeout_disconnection}s) waiting for engines to disconnect."
+                f"Timed out ({self._config.timeout_disconnection}s) waiting for engines to disconnect"
                 f"\nStatus"
                 f"\n------"
                 f"\nDataEngine.check_disconnected() == {self._data_engine.check_disconnected()}"
                 f"\nExecEngine.check_disconnected() == {self._exec_engine.check_disconnected()}",
             )
 
     async def _await_execution_reconciliation(self) -> bool:
@@ -1041,35 +1071,35 @@
             f"Awaiting execution state reconciliation "
             f"({self._config.timeout_reconciliation}s timeout)...",
             color=LogColor.BLUE,
         )
         if not await self._exec_engine.reconcile_state(
             timeout_secs=self._config.timeout_reconciliation,
         ):
-            self._log.error("Execution state could not be reconciled.")
+            self._log.error("Execution state could not be reconciled")
             return False
 
-        self._log.info("Execution state reconciled.", color=LogColor.GREEN)
+        self._log.info("Execution state reconciled", color=LogColor.GREEN)
         return True
 
     async def _await_portfolio_initialization(self) -> bool:
         self._log.info(
             "Awaiting portfolio initialization " f"({self._config.timeout_portfolio}s timeout)...",
             color=LogColor.BLUE,
         )
         if not await self._check_portfolio_initialized():
             self._log.warning(
-                f"Timed out ({self._config.timeout_portfolio}s) waiting for portfolio to initialize."
+                f"Timed out ({self._config.timeout_portfolio}s) waiting for portfolio to initialize"
                 f"\nStatus"
                 f"\n------"
                 f"\nPortfolio.initialized == {self._portfolio.initialized}",
             )
             return False
 
-        self._log.info("Portfolio initialized.", color=LogColor.GREEN)
+        self._log.info("Portfolio initialized", color=LogColor.GREEN)
         return True
 
     async def _await_trader_residuals(self) -> None:
         self._log.info(
             f"Awaiting post stop ({self._config.timeout_post_stop}s timeout)...",
             color=LogColor.BLUE,
         )
@@ -1129,12 +1159,12 @@
         return True
 
     def _cancel_timers(self) -> None:
         timer_names = self._clock.timer_names
         self._clock.cancel_timers()
 
         for name in timer_names:
-            self._log.info(f"Canceled Timer(name={name}).")
+            self._log.info(f"Canceled Timer(name={name})")
 
     def _flush_writer(self) -> None:
         if self._writer is not None:
             self._writer.flush()
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/functions.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/functions.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/actors.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/actors.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/cache_database.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/cache_database.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/controller.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/controller.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/data.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/data.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/engines.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/engines.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/mocks/exec_clients.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/mocks/exec_clients.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/providers.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/providers.py`

 * *Files 0% similar despite different names*

```diff
@@ -21,16 +21,14 @@
 
 import fsspec
 import numpy as np
 import pandas as pd
 import pytz
 from fsspec.implementations.local import LocalFileSystem
 
-from nautilus_trader.adapters.betfair.constants import BETFAIR_PRICE_PRECISION
-from nautilus_trader.adapters.betfair.constants import BETFAIR_QUANTITY_PRECISION
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.datetime import dt_to_unix_nanos
 from nautilus_trader.core.datetime import secs_to_nanos
 from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.model.currencies import ADA
 from nautilus_trader.model.currencies import BTC
 from nautilus_trader.model.currencies import ETH
@@ -322,14 +320,15 @@
                 symbol=Symbol(f"BTCUSDT_{expiration.strftime('%y%m%d')}"),
                 venue=Venue("BINANCE"),
             ),
             raw_symbol=Symbol("BTCUSDT"),
             underlying=BTC,
             quote_currency=USDT,
             settlement_currency=USDT,
+            is_inverse=False,
             activation_ns=activation.value,
             expiration_ns=expiration.value,
             price_precision=2,
             size_precision=6,
             price_increment=Price(1e-02, precision=2),
             size_increment=Quantity(1e-06, precision=6),
             max_quantity=Quantity(9000, precision=6),
@@ -612,16 +611,16 @@
             market_name="AFC Conference Winner",
             market_start_time=pd.Timestamp("2022-02-07 23:30:00+00:00"),
             market_type="SPECIAL",
             selection_handicap=null_handicap(),
             selection_id=50214,
             selection_name="Kansas City Chiefs",
             currency="GBP",
-            price_precision=BETFAIR_PRICE_PRECISION,
-            size_precision=BETFAIR_QUANTITY_PRECISION,
+            price_precision=2,  # BETFAIR_PRICE_PRECISION,
+            size_precision=2,  # BETFAIR_QUANTITY_PRECISION,
             ts_event=0,
             ts_init=0,
         )
 
 
 def first_friday_two_years_six_months_ago(year: int, month: int) -> dt.date:
     target_year = year - 2
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/trading/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/accounting_pyo3.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/accounting_pyo3.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/data_pyo3.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/data_pyo3.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/events_pyo3.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/events_pyo3.py`

 * *Files 0% similar despite different names*

```diff
@@ -479,15 +479,15 @@
             venue_order_id=venue_order_id,
             account_id=account_id,
             trade_id=trade_id,
             position_id=position_id,
             order_side=order.side,
             order_type=order.order_type,
             last_qty=last_qty,
-            last_px=last_px or order.price,
+            last_px=last_px or order.price or Price.from_str("1.00000"),
             currency=instrument.quote_currency,
             commission=commission,
             liquidity_side=liquidity_side,
             ts_event=ts_filled_ns,
             event_id=TestIdProviderPyo3.uuid(),
             ts_init=0,
             reconciliation=False,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/identifiers_pyo3.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/identifiers_pyo3.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/instruments_pyo3.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/instruments_pyo3.py`

 * *Files 0% similar despite different names*

```diff
@@ -215,14 +215,15 @@
         instrument_id_str = f"{symbol}.BINANCE"
         return CryptoFuture(
             id=InstrumentId.from_str(instrument_id_str),
             raw_symbol=Symbol(symbol),
             underlying=_BTC,
             quote_currency=_USDT,
             settlement_currency=_USDT,
+            is_inverse=False,
             activation_ns=activation.value,
             expiration_ns=expiration.value,
             price_precision=2,
             size_precision=6,
             price_increment=Price.from_str("0.01"),
             size_increment=Quantity.from_str("0.000001"),
             maker_fee=Decimal("0"),
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/orders_pyo3.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/orders_pyo3.py`

 * *Files 20% similar despite different names*

```diff
@@ -17,17 +17,19 @@
 from nautilus_trader.core.nautilus_pyo3 import ExecAlgorithmId
 from nautilus_trader.core.nautilus_pyo3 import InstrumentId
 from nautilus_trader.core.nautilus_pyo3 import LimitOrder
 from nautilus_trader.core.nautilus_pyo3 import MarketOrder
 from nautilus_trader.core.nautilus_pyo3 import OrderSide
 from nautilus_trader.core.nautilus_pyo3 import Price
 from nautilus_trader.core.nautilus_pyo3 import Quantity
+from nautilus_trader.core.nautilus_pyo3 import StopLimitOrder
 from nautilus_trader.core.nautilus_pyo3 import StrategyId
 from nautilus_trader.core.nautilus_pyo3 import TimeInForce
 from nautilus_trader.core.nautilus_pyo3 import TraderId
+from nautilus_trader.core.nautilus_pyo3 import TriggerType
 from nautilus_trader.test_kit.rust.identifiers_pyo3 import TestIdProviderPyo3
 
 
 class TestOrderProviderPyo3:
     @staticmethod
     def market_order(
         instrument_id: InstrumentId | None = None,
@@ -77,7 +79,43 @@
             reduce_only=False,
             quote_quantity=False,
             init_id=TestIdProviderPyo3.uuid(),
             ts_init=0,
             exec_algorithm_id=exec_algorithm_id,
             exec_spawn_id=TestIdProviderPyo3.client_order_id(1),
         )
+
+    @staticmethod
+    def stop_limit_order(
+        instrument_id: InstrumentId,
+        order_side: OrderSide,
+        quantity: Quantity,
+        price: Price,
+        trigger_price: Price,
+        trigger_type: TriggerType = TriggerType.MID_POINT,
+        trader_id: TraderId | None = None,
+        strategy_id: StrategyId | None = None,
+        client_order_id: ClientOrderId | None = None,
+        time_in_force: TimeInForce | None = None,
+        exec_algorithm_id: ExecAlgorithmId | None = None,
+        tags: str | None = None,
+    ) -> StopLimitOrder:
+        return StopLimitOrder(
+            trader_id=trader_id or TestIdProviderPyo3.trader_id(),
+            strategy_id=strategy_id or TestIdProviderPyo3.strategy_id(),
+            instrument_id=instrument_id or TestIdProviderPyo3.audusd_id(),
+            client_order_id=client_order_id or TestIdProviderPyo3.client_order_id(1),
+            order_side=order_side or OrderSide.BUY,
+            quantity=quantity or Quantity.from_str("100"),
+            price=price,
+            trigger_price=trigger_price,
+            trigger_type=trigger_type,
+            time_in_force=time_in_force or TimeInForce.GTC,
+            post_only=False,
+            reduce_only=False,
+            quote_quantity=False,
+            init_id=TestIdProviderPyo3.uuid(),
+            ts_init=0,
+            exec_algorithm_id=exec_algorithm_id,
+            exec_spawn_id=TestIdProviderPyo3.client_order_id(1),
+            tags=tags,
+        )
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/rust/types_pyo3.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/rust/types_pyo3.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/__init__.py` & `nautilus_trader-1.191.0/nautilus_core/common/src/ffi/mod.rs`

 * *Files 19% similar despite different names*

```diff
@@ -1,14 +1,19 @@
-# -------------------------------------------------------------------------------------------------
-#  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
-#  https://nautechsystems.io
-#
-#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-#  You may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-# -------------------------------------------------------------------------------------------------
+// -------------------------------------------------------------------------------------------------
+//  Copyright (C) 2015-2024 Nautech Systems Pty Ltd. All rights reserved.
+//  https://nautechsystems.io
+//
+//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+//  You may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+// -------------------------------------------------------------------------------------------------
+
+pub mod clock;
+pub mod enums;
+pub mod logging;
+pub mod timer;
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/commands.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/commands.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/component.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/component.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/config.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/config.py`

 * *Files 5% similar despite different names*

```diff
@@ -91,20 +91,20 @@
                     "max_trade_size": 50,
                 },
             ),
         ]
 
     @staticmethod
     def backtest_engine_config(
+        catalog: ParquetDataCatalog,
         log_level="INFO",
         bypass_logging: bool = True,
         bypass_risk: bool = False,
         allow_cash_position: bool = True,
         persist: bool = False,
-        catalog: ParquetDataCatalog | None = None,
         strategies: list[ImportableStrategyConfig] | None = None,
     ) -> BacktestEngineConfig:
         if persist:
             assert catalog is not None, "If `persist=True`, must pass `catalog`"
         return BacktestEngineConfig(
             logging=LoggingConfig(log_level=log_level, bypass_logging=bypass_logging),
             exec_engine=ExecEngineConfig(allow_cash_positions=allow_cash_position),
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/data.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/data.py`

 * *Files 2% similar despite different names*

```diff
@@ -117,14 +117,18 @@
         return ticks
 
     @staticmethod
     def bar_spec_1min_bid() -> BarSpecification:
         return BarSpecification(1, BarAggregation.MINUTE, PriceType.BID)
 
     @staticmethod
+    def bar_spec_5min_bid() -> BarSpecification:
+        return BarSpecification(5, BarAggregation.MINUTE, PriceType.BID)
+
+    @staticmethod
     def bar_spec_1min_ask() -> BarSpecification:
         return BarSpecification(1, BarAggregation.MINUTE, PriceType.ASK)
 
     @staticmethod
     def bar_spec_1min_last() -> BarSpecification:
         return BarSpecification(1, BarAggregation.MINUTE, PriceType.LAST)
 
@@ -141,14 +145,18 @@
         return BarSpecification(100, BarAggregation.TICK, PriceType.LAST)
 
     @staticmethod
     def bartype_audusd_1min_bid() -> BarType:
         return BarType(TestIdStubs.audusd_id(), TestDataStubs.bar_spec_1min_bid())
 
     @staticmethod
+    def bartype_audusd_5min_bid() -> BarType:
+        return BarType(TestIdStubs.audusd_id(), TestDataStubs.bar_spec_5min_bid())
+
+    @staticmethod
     def bartype_audusd_1min_ask() -> BarType:
         return BarType(TestIdStubs.audusd_id(), TestDataStubs.bar_spec_1min_ask())
 
     @staticmethod
     def bartype_gbpusd_1min_bid() -> BarType:
         return BarType(TestIdStubs.gbpusd_id(), TestDataStubs.bar_spec_1min_bid())
 
@@ -186,14 +194,27 @@
             close=Price.from_str("1.00003"),
             volume=Quantity.from_int(1_000_000),
             ts_event=0,
             ts_init=0,
         )
 
     @staticmethod
+    def bar_5decimal_5min_bid() -> Bar:
+        return Bar(
+            bar_type=TestDataStubs.bartype_audusd_5min_bid(),
+            open=Price.from_str("1.00101"),
+            high=Price.from_str("1.00208"),
+            low=Price.from_str("1.00100"),
+            close=Price.from_str("1.00205"),
+            volume=Quantity.from_int(1_000_000),
+            ts_event=0,
+            ts_init=0,
+        )
+
+    @staticmethod
     def bar_3decimal() -> Bar:
         return Bar(
             bar_type=TestDataStubs.bartype_usdjpy_1min_bid(),
             open=Price.from_str("90.002"),
             high=Price.from_str("90.004"),
             low=Price.from_str("90.001"),
             close=Price.from_str("90.003"),
@@ -291,35 +312,39 @@
                 instrument.make_price(ask_price + i),
                 instrument.make_qty(ask_size * (1 + i)),
                 0,
             )
             for i in range(ask_levels)
         ]
 
-        deltas = [OrderBookDelta.clear(instrument.id, ts_event, ts_init)]
+        deltas = [OrderBookDelta.clear(instrument.id, 0, ts_event, ts_init)]
         deltas += [
-            OrderBookDelta(instrument.id, BookAction.ADD, order, ts_event, ts_init)
+            OrderBookDelta(instrument.id, BookAction.ADD, order, 0, 0, ts_event, ts_init)
             for order in bids + asks
         ]
         return OrderBookDeltas(
             instrument_id=instrument.id,
             deltas=deltas,
         )
 
     @staticmethod
     def order_book_delta(
         instrument_id: InstrumentId | None = None,
         order: BookOrder | None = None,
+        flags: int = 0,
+        sequence: int = 0,
         ts_event: int = 0,
         ts_init: int = 0,
     ) -> OrderBookDeltas:
         return OrderBookDelta(
             instrument_id=instrument_id or TestIdStubs.audusd_id(),
             action=BookAction.UPDATE,
             order=order or TestDataStubs.order(),
+            flags=flags,
+            sequence=sequence,
             ts_event=ts_event,
             ts_init=ts_init,
         )
 
     @staticmethod
     def order_book_depth10(
         instrument_id: InstrumentId | None = None,
@@ -388,14 +413,16 @@
     def order_book_delta_clear(
         instrument_id: InstrumentId | None = None,
     ) -> OrderBookDeltas:
         return OrderBookDelta(
             instrument_id=instrument_id or TestIdStubs.audusd_id(),
             action=BookAction.CLEAR,
             order=NULL_ORDER,
+            flags=0,
+            sequence=0,
             ts_event=0,
             ts_init=0,
         )
 
     @staticmethod
     def order_book_deltas(
         instrument_id: InstrumentId | None = None,
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/events.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/events.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/execution.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/execution.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/identifiers.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/identifiers.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/test_kit/stubs/persistence.py` & `nautilus_trader-1.191.0/nautilus_trader/test_kit/stubs/persistence.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/trading/__init__.py` & `nautilus_trader-1.191.0/nautilus_trader/trading/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/trading/config.py` & `nautilus_trader-1.191.0/nautilus_trader/trading/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/trading/controller.py` & `nautilus_trader-1.191.0/nautilus_trader/trading/controller.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/trading/filters.py` & `nautilus_trader-1.191.0/nautilus_trader/trading/filters.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/trading/strategy.pxd` & `nautilus_trader-1.191.0/nautilus_trader/trading/strategy.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.190.0/nautilus_trader/trading/strategy.pyx` & `nautilus_trader-1.191.0/nautilus_trader/trading/strategy.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -89,16 +89,16 @@
 from nautilus_trader.model.identifiers cimport ExecAlgorithmId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport PositionId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
-from nautilus_trader.model.orders.base cimport VALID_LIMIT_ORDER_TYPES
-from nautilus_trader.model.orders.base cimport VALID_STOP_ORDER_TYPES
+from nautilus_trader.model.orders.base cimport LIMIT_ORDER_TYPES
+from nautilus_trader.model.orders.base cimport STOP_ORDER_TYPES
 from nautilus_trader.model.orders.base cimport Order
 from nautilus_trader.model.orders.list cimport OrderList
 from nautilus_trader.model.orders.market cimport MarketOrder
 from nautilus_trader.model.position cimport Position
 from nautilus_trader.portfolio.base cimport PortfolioFacade
 
 
@@ -200,39 +200,39 @@
 # -- REGISTRATION ---------------------------------------------------------------------------------
 
     cpdef void on_start(self):
         # Should override in subclass
         self.log.warning(
             "The `Strategy.on_start` handler was called when not overridden. "
             "It's expected that any actions required when starting the strategy "
-            "occur here, such as subscribing/requesting data.",
+            "occur here, such as subscribing/requesting data",
         )
 
     cpdef void on_stop(self):
         # Should override in subclass
         self.log.warning(
             "The `Strategy.on_stop` handler was called when not overridden. "
             "It's expected that any actions required when stopping the strategy "
-            "occur here, such as unsubscribing from data.",
+            "occur here, such as unsubscribing from data",
         )
 
     cpdef void on_resume(self):
         # Should override in subclass
         self.log.warning(
             "The `Strategy.on_resume` handler was called when not overridden. "
             "It's expected that any actions required when resuming the strategy "
-            "following a stop occur here."
+            "following a stop occur here"
         )
 
     cpdef void on_reset(self):
         # Should override in subclass
         self.log.warning(
             "The `Strategy.on_reset` handler was called when not overridden. "
             "It's expected that any actions required when resetting the strategy "
-            "occur here, such as resetting indicators and other state."
+            "occur here, such as resetting indicators and other state"
         )
 
 # -- REGISTRATION ---------------------------------------------------------------------------------
 
     cpdef void register(
         self,
         TraderId trader_id,
@@ -287,15 +287,15 @@
             msgbus=msgbus,
             cache=cache,
             component_name=type(self).__name__,
             active_local=False,
             submit_order_handler=None,
             cancel_order_handler=self.cancel_order,
             modify_order_handler=self.modify_order,
-            debug=True,  # Set True for debugging
+            debug=False,  # Set True for debugging
         )
 
         # Required subscriptions
         self._msgbus.subscribe(topic=f"events.order.{self.id}", handler=self.handle_event)
         self._msgbus.subscribe(topic=f"events.position.{self.id}", handler=self.handle_event)
 
     cpdef void change_id(self, StrategyId strategy_id):
@@ -346,20 +346,20 @@
             strategy_id=self.id,
         )
 
         cdef int order_id_count = len(client_order_ids)
         cdef int order_list_id_count = len(order_list_ids)
         self.order_factory.set_client_order_id_count(order_id_count)
         self.log.info(
-            f"Set ClientOrderIdGenerator client_order_id count to {order_id_count}.",
+            f"Set ClientOrderIdGenerator client_order_id count to {order_id_count}",
             LogColor.BLUE,
         )
         self.order_factory.set_order_list_id_count(order_list_id_count)
         self.log.info(
-            f"Set ClientOrderIdGenerator order_list_id count to {order_list_id_count}.",
+            f"Set ClientOrderIdGenerator order_list_id count to {order_list_id_count}",
             LogColor.BLUE,
         )
 
         cdef list open_orders = self.cache.orders_open(
             venue=None,
             instrument_id=None,
             strategy_id=self.id,
@@ -1049,33 +1049,33 @@
         for order in orders:
             if first is None:
                 first = order
             else:
                 if first.instrument_id != order.instrument_id:
                     self._log.error(
                         "Cannot cancel all orders: instrument_id mismatch "
-                        f"{first.instrument_id} vs {order.instrument_id}.",
+                        f"{first.instrument_id} vs {order.instrument_id}",
                     )
                     return
                 if order.is_emulated_c():
                     self._log.error(
-                        "Cannot include emulated orders in a batch cancel."
+                        "Cannot include emulated orders in a batch cancel"
                     )
                     return
 
             cancel = self._create_cancel_order(
                 order=order,
                 client_id=client_id,
             )
             if cancel is None:
                 continue
             cancels.append(cancel)
 
         if not cancels:
-            self._log.warning("Cannot send `BatchCancelOrders`, no valid cancel commands.")
+            self._log.warning("Cannot send `BatchCancelOrders`, no valid cancel commands")
             return
 
         cdef command = BatchCancelOrders(
             trader_id=self.trader_id,
             strategy_id=self.id,
             instrument_id=first.instrument_id,
             cancels=cancels,
@@ -1126,29 +1126,29 @@
             side=order_side,
         )
 
         cdef str order_side_str = " " + order_side_to_str(order_side) if order_side != OrderSide.NO_ORDER_SIDE else ""
         if not open_orders and not emulated_orders:
             self.log.info(
                 f"No {instrument_id.to_str()} open or emulated{order_side_str} "
-                f"orders to cancel.")
+                f"orders to cancel")
             return
 
         cdef int open_count = len(open_orders)
         if open_count:
             self.log.info(
                 f"Canceling {open_count} open{order_side_str} "
-                f"{instrument_id.to_str()} order{'' if open_count == 1 else 's'}...",
+                f"{instrument_id.to_str()} order{'' if open_count == 1 else 's'}",
             )
 
         cdef int emulated_count = len(emulated_orders)
         if emulated_count:
             self.log.info(
                 f"Canceling {emulated_count} emulated{order_side_str} "
-                f"{instrument_id.to_str()} order{'' if emulated_count == 1 else 's'}...",
+                f"{instrument_id.to_str()} order{'' if emulated_count == 1 else 's'}",
             )
 
         cdef:
             OrderPendingCancel event
             Order order
         for order in open_orders + emulated_orders:
             if order.status_c() == OrderStatus.INITIALIZED or order.is_emulated_c():
@@ -1212,15 +1212,15 @@
         Condition.not_none(position, "position")
         Condition.not_none(self.trader_id, "self.trader_id")
         Condition.not_none(self.order_factory, "self.order_factory")
 
         if position.is_closed_c():
             self.log.warning(
                 f"Cannot close position "
-                f"(the position is already closed), {position}."
+                f"(the position is already closed), {position}"
             )
             return  # Invalid command
 
         # Create closing order
         cdef MarketOrder order = self.order_factory.market(
             instrument_id=position.instrument_id,
             order_side=Order.closing_side_c(position.side),
@@ -1267,21 +1267,21 @@
             strategy_id=self.id,
             side=position_side,
         )
 
         cdef str position_side_str = " " + position_side_to_str(position_side) if position_side != PositionSide.NO_POSITION_SIDE else ""
         if not positions_open:
             self.log.info(
-                f"No {instrument_id.to_str()} open{position_side_str} positions to close.",
+                f"No {instrument_id.to_str()} open{position_side_str} positions to close",
             )
             return
 
         cdef int count = len(positions_open)
         self.log.info(
-            f"Closing {count} open{position_side_str} position{'' if count == 1 else 's'}...",
+            f"Closing {count} open{position_side_str} position{'' if count == 1 else 's'}",
         )
 
         cdef Position position
         for position in positions_open:
             self.close_position(position, client_id, tags)
 
     cpdef void query_order(self, Order order, ClientId client_id = None):
@@ -1329,40 +1329,42 @@
         cdef bint updating = False  # Set validation flag (must become true)
 
         if quantity is not None and quantity != order.quantity:
             updating = True
 
         if price is not None:
             Condition.true(
-                order.order_type in VALID_LIMIT_ORDER_TYPES,
+                order.order_type in LIMIT_ORDER_TYPES,
                 fail_msg=f"{order.type_string_c()} orders do not have a LIMIT price",
             )
             if price != order.price:
                 updating = True
 
         if trigger_price is not None:
             Condition.true(
-                order.order_type in VALID_STOP_ORDER_TYPES,
+                order.order_type in STOP_ORDER_TYPES,
                 fail_msg=f"{order.type_string_c()} orders do not have a STOP trigger price",
             )
             if trigger_price != order.trigger_price:
                 updating = True
 
         if not updating:
+            price_str = f", {order.price=}" if order.has_price_c() else ""
+            trigger_str = f", {order.trigger_price=}" if order.has_trigger_price_c() else ""
             self.log.error(
                 "Cannot create command ModifyOrder: "
-                "quantity, price and trigger were either None "
-                "or the same as existing values.",
+                f"{quantity=}, {price=}, {trigger_price=} were either None "
+                f"or the same as existing values: {order.quantity=}{price_str}{trigger_str}",
             )
             return None  # Cannot send command
 
         if order.is_closed_c() or order.is_pending_cancel_c():
             self.log.warning(
                 f"Cannot create command ModifyOrder: "
-                f"state is {order.status_string_c()}, {order}.",
+                f"state is {order.status_string_c()}, {order}",
             )
             return None  # Cannot send command
 
         cdef OrderPendingUpdate event
         if not order.is_active_local_c():
             # Generate and apply event
             event = self._generate_order_pending_update(order)
@@ -1392,15 +1394,15 @@
             ts_init=self.clock.timestamp_ns(),
             client_id=client_id,
         )
 
     cdef CancelOrder _create_cancel_order(self, Order order, ClientId client_id = None):
         if order.is_closed_c() or order.is_pending_cancel_c():
             self.log.warning(
-                f"Cannot cancel order: state is {order.status_string_c()}, {order}.",
+                f"Cannot cancel order: state is {order.status_string_c()}, {order}",
             )
             return None  # Cannot send command
 
         cdef OrderStatus order_status = order.status_c()
 
         cdef OrderPendingCancel event
         if not order.is_active_local_c():
@@ -1448,15 +1450,15 @@
         cdef str expire_time_str = f" @ {order.expire_time.isoformat()}" if hasattr(order, "expire_time") else ""
 
         if timer_name not in self._clock.timer_names:
             self._log.error(f"Cannot find managed GTD timer for order {order.client_order_id!r}")
             return
 
         self._log.info(
-            f"Canceling managed GTD expiry timer for {order.client_order_id}{expire_time_str}.",
+            f"Canceling managed GTD expiry timer for {order.client_order_id}{expire_time_str}",
             LogColor.BLUE,
         )
         self._clock.cancel_timer(name=timer_name)
 
     cdef str _get_gtd_expiry_timer_name(self, ClientOrderId client_order_id):
         return f"GTD-EXPIRY:{client_order_id.to_str()}"
 
@@ -1469,31 +1471,31 @@
         self._clock.set_time_alert_ns(
             name=timer_name,
             alert_time_ns=order.expire_time_ns,
             callback=self._expire_gtd_order,
         )
 
         self._log.info(
-            f"Set managed GTD expiry timer for {order.client_order_id} @ {order.expire_time.isoformat()}.",
+            f"Set managed GTD expiry timer for {order.client_order_id} @ {order.expire_time.isoformat()}",
             LogColor.BLUE,
         )
 
     cpdef void _expire_gtd_order(self, TimeEvent event):
         cdef ClientOrderId client_order_id = ClientOrderId(event.to_str().partition(":")[2])
         cdef Order order = self.cache.order(client_order_id)
         if order is None:
             self._log.warning(
-                f"Order with {repr(client_order_id)} not found in the cache to apply {event}."
+                f"Order with {repr(client_order_id)} not found in the cache to apply {event}"
             )
 
         if order.is_closed_c():
-            self._log.warning(f"GTD expired order {order.client_order_id} was already closed.")
+            self._log.warning(f"GTD expired order {order.client_order_id} was already closed")
             return  # Already closed
 
-        self._log.info(f"Expiring GTD order {order.client_order_id}.", LogColor.BLUE)
+        self._log.info(f"Expiring GTD order {order.client_order_id}", LogColor.BLUE)
         self.cancel_order(order)
 
     # -- HANDLERS -------------------------------------------------------------------------------------
 
     cpdef void handle_event(self, Event event):
         """
         Handle the given event.
@@ -1509,17 +1511,17 @@
         --------
         System method (not intended to be called by user code).
 
         """
         Condition.not_none(event, "event")
 
         if type(event) in self._warning_events:
-            self.log.warning(f"{RECV}{EVT} {event}.")
+            self.log.warning(f"{RECV}{EVT} {event}")
         else:
-            self.log.info(f"{RECV}{EVT} {event}.")
+            self.log.info(f"{RECV}{EVT} {event}")
 
         cdef Order order
         if self.manage_gtd_expiry and isinstance(event, OrderEvent):
             order = self.cache.order(event.client_order_id)
             if order is not None and order.is_closed_c() and self._has_gtd_expiry_timer(order.client_order_id):
                 self.cancel_gtd_expiry(order)
 
@@ -1634,15 +1636,15 @@
             account_id=order.account_id,
             event_id=UUID4(),
             ts_event=ts_now,
             ts_init=ts_now,
         )
 
     cdef void _deny_order(self, Order order, str reason):
-        self._log.error(f"Order denied: {reason}.")
+        self._log.error(f"Order denied: {reason}")
 
         if not self.cache.order_exists(order.client_order_id):
             self.cache.add_order(order)
 
         # Generate event
         cdef OrderDenied event = self._generate_order_denied(order, reason)
```

### Comparing `nautilus_trader-1.190.0/nautilus_trader/trading/trader.py` & `nautilus_trader-1.191.0/nautilus_trader/trading/trader.py`

 * *Files 2% similar despite different names*

```diff
@@ -253,27 +253,27 @@
             exec_algorithm.start()
 
     def _stop(self) -> None:
         for actor in self._actors.values():
             if actor.is_running:
                 actor.stop()
             else:
-                self._log.warning(f"{actor} already stopped.")
+                self._log.warning(f"{actor} already stopped")
 
         for strategy in self._strategies.values():
             if strategy.is_running:
                 strategy.stop()
             else:
-                self._log.warning(f"{strategy} already stopped.")
+                self._log.warning(f"{strategy} already stopped")
 
         for exec_algorithm in self._exec_algorithms.values():
             if exec_algorithm.is_running:
                 exec_algorithm.stop()
             else:
-                self._log.warning(f"{exec_algorithm} already stopped.")
+                self._log.warning(f"{exec_algorithm} already stopped")
 
     def _reset(self) -> None:
         for actor in self._actors.values():
             actor.reset()
 
         for strategy in self._strategies.values():
             strategy.reset()
@@ -309,15 +309,15 @@
             If `actor.id` already exists in the trader.
 
         """
         PyCondition.true(not actor.is_running, "actor.state was RUNNING")
         PyCondition.true(not actor.is_disposed, "actor.state was DISPOSED")
 
         if self.is_running and not self._has_controller:
-            self._log.error("Cannot add an actor/component to a running trader.")
+            self._log.error("Cannot add an actor/component to a running trader")
             return
 
         if actor.id in self._actors:
             raise RuntimeError(
                 f"Already registered an actor with ID {actor.id}, "
                 "try specifying a different actor ID.",
             )
@@ -331,15 +331,15 @@
             msgbus=self._msgbus,
             cache=self._cache,
             clock=clock,
         )
 
         self._actors[actor.id] = actor
 
-        self._log.info(f"Registered Component {actor}.")
+        self._log.info(f"Registered Component {actor}")
 
     def add_actors(self, actors: list[Actor]) -> None:
         """
         Add the given actors to the trader.
 
         Parameters
         ----------
@@ -375,15 +375,15 @@
 
         """
         PyCondition.not_none(strategy, "strategy")
         PyCondition.true(not strategy.is_running, "strategy.state was RUNNING")
         PyCondition.true(not strategy.is_disposed, "strategy.state was DISPOSED")
 
         if self.is_running and not self._has_controller:
-            self._log.error("Cannot add a strategy to a running trader.")
+            self._log.error("Cannot add a strategy to a running trader")
             return
 
         if strategy.id in self._strategies:
             raise RuntimeError(
                 f"Already registered a strategy with ID {strategy.id}, "
                 "try specifying a different strategy ID.",
             )
@@ -416,15 +416,15 @@
             clock=clock,
         )
 
         self._exec_engine.register_oms_type(strategy)
         self._exec_engine.register_external_order_claims(strategy)
         self._strategies[strategy.id] = strategy
 
-        self._log.info(f"Registered Strategy {strategy}.")
+        self._log.info(f"Registered Strategy {strategy}")
 
     def add_strategies(self, strategies: list[Strategy]) -> None:
         """
         Add the given trading strategies to the trader.
 
         Parameters
         ----------
@@ -460,15 +460,15 @@
 
         """
         PyCondition.not_none(exec_algorithm, "exec_algorithm")
         PyCondition.true(not exec_algorithm.is_running, "exec_algorithm.state was RUNNING")
         PyCondition.true(not exec_algorithm.is_disposed, "exec_algorithm.state was DISPOSED")
 
         if self.is_running:
-            self._log.error("Cannot add an execution algorithm to a running trader.")
+            self._log.error("Cannot add an execution algorithm to a running trader")
             return
 
         if exec_algorithm.id in self._exec_algorithms:
             raise RuntimeError(
                 f"Already registered an execution algorithm with ID {exec_algorithm.id}, "
                 "try specifying a different `exec_algorithm_id`.",
             )
@@ -483,15 +483,15 @@
             msgbus=self._msgbus,
             cache=self._cache,
             clock=clock,
         )
 
         self._exec_algorithms[exec_algorithm.id] = exec_algorithm
 
-        self._log.info(f"Registered ExecAlgorithm {exec_algorithm}.")
+        self._log.info(f"Registered ExecAlgorithm {exec_algorithm}")
 
     def add_exec_algorithms(self, exec_algorithms: list[Any]) -> None:
         """
         Add the given execution algorithms to the trader.
 
         Parameters
         ----------
@@ -527,15 +527,15 @@
         PyCondition.not_none(actor_id, "actor_id")
 
         actor = self._actors.get(actor_id)
         if actor is None:
             raise ValueError(f"Cannot start actor, {actor_id} not found.")
 
         if actor.is_running:
-            self._log.warning(f"Actor {actor_id} already running.")
+            self._log.warning(f"Actor {actor_id} already running")
             return
 
         actor.start()
 
     def start_strategy(self, strategy_id: StrategyId) -> None:
         """
         Start the strategy with the given `strategy_id`.
@@ -554,15 +554,15 @@
         PyCondition.not_none(strategy_id, "strategy_id")
 
         strategy = self._strategies.get(strategy_id)
         if strategy is None:
             raise ValueError(f"Cannot start strategy, {strategy_id} not found.")
 
         if strategy.is_running:
-            self._log.warning(f"Strategy {strategy_id} already running.")
+            self._log.warning(f"Strategy {strategy_id} already running")
             return
 
         strategy.start()
 
     def stop_actor(self, actor_id: ComponentId) -> None:
         """
         Stop the actor with the given `actor_id`.
@@ -581,15 +581,15 @@
         PyCondition.not_none(actor_id, "actor_id")
 
         actor = self._actors.get(actor_id)
         if actor is None:
             raise ValueError(f"Cannot stop actor, {actor_id} not found.")
 
         if not actor.is_running:
-            self._log.warning(f"Actor {actor_id} not running.")
+            self._log.warning(f"Actor {actor_id} not running")
             return
 
         actor.stop()
 
     def stop_strategy(self, strategy_id: StrategyId) -> None:
         """
         Stop the strategy with the given `strategy_id`.
@@ -608,15 +608,15 @@
         PyCondition.not_none(strategy_id, "strategy_id")
 
         strategy = self._strategies.get(strategy_id)
         if strategy is None:
             raise ValueError(f"Cannot stop strategy, {strategy_id} not found.")
 
         if not strategy.is_running:
-            self._log.warning(f"Strategy {strategy_id} not running.")
+            self._log.warning(f"Strategy {strategy_id} not running")
             return
 
         strategy.stop()
 
     def remove_actor(self, actor_id: ComponentId) -> None:
         """
         Remove the actor with the given `actor_id`.
@@ -682,65 +682,65 @@
         Raises
         ------
         ValueError
             If state is ``RUNNING``.
 
         """
         if self.is_running:
-            self._log.error("Cannot clear the actors of a running trader.")
+            self._log.error("Cannot clear the actors of a running trader")
             return
 
         for actor in self._actors.values():
             actor.dispose()
             deregister_component_clock(self._instance_id, actor.clock)
 
         self._actors.clear()
-        self._log.info("Cleared all actors.")
+        self._log.info("Cleared all actors")
 
     def clear_strategies(self) -> None:
         """
         Dispose and clear all strategies held by the trader.
 
         Raises
         ------
         ValueError
             If state is ``RUNNING``.
 
         """
         if self.is_running:
-            self._log.error("Cannot clear the strategies of a running trader.")
+            self._log.error("Cannot clear the strategies of a running trader")
             return
 
         for strategy in self._strategies.values():
             strategy.dispose()
             deregister_component_clock(self._instance_id, strategy.clock)
 
         self._strategies.clear()
-        self._log.info("Cleared all trading strategies.")
+        self._log.info("Cleared all trading strategies")
 
     def clear_exec_algorithms(self) -> None:
         """
         Dispose and clear all execution algorithms held by the trader.
 
         Raises
         ------
         ValueError
             If state is ``RUNNING``.
 
         """
         if self.is_running:
-            self._log.error("Cannot clear the execution algorithm of a running trader.")
+            self._log.error("Cannot clear the execution algorithm of a running trader")
             return
 
         for exec_algorithm in self._exec_algorithms.values():
             exec_algorithm.dispose()
             deregister_component_clock(self._instance_id, exec_algorithm.clock)
 
         self._exec_algorithms.clear()
-        self._log.info("Cleared all execution algorithms.")
+        self._log.info("Cleared all execution algorithms")
 
     def subscribe(self, topic: str, handler: Callable[[Any], None]) -> None:
         """
         Subscribe to the given message topic with the given callback handler.
 
         Parameters
         ----------
```

### Comparing `nautilus_trader-1.190.0/pyproject.toml` & `nautilus_trader-1.191.0/pyproject.toml`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [tool.poetry]
 name = "nautilus_trader"
-version = "1.190.0"
+version = "1.191.0"
 description = "A high-performance algorithmic trading platform and event-driven backtester"
 authors = ["Nautech Systems <info@nautechsystems.io>"]
 license = "LGPL-3.0-or-later"
 readme = "README.md"
 homepage = "https://nautilustrader.io"
 repository = "https://github.com/nautechsystems/nautilus_trader"
 classifiers = [
@@ -36,58 +36,58 @@
 ]
 
 [build-system]
 requires = [
     "setuptools",
     "poetry-core>=1.9.0",
     "numpy>=1.26.4",
-    "Cython==3.0.9",
+    "Cython==3.0.10",
     "toml>=0.10.2",
 ]
 build-backend = "poetry.core.masonry.api"
 
 [tool.poetry.build]
 script = "build.py"
 generate-setup-file = false
 
 [tool.poetry.dependencies]
 python = ">=3.10,<3.13"
-cython = "==3.0.9"  # Build dependency (pinned for stability)
+cython = "==3.0.10"  # Build dependency (pinned for stability)
 numpy = "^1.26.4"  # Build dependency
 toml = "^0.10.2"  # Build dependency
 click = "^8.1.7"
 fsspec = "==2023.6.0"  # Pinned due breaking changes
 msgspec = "^0.18.6"
-pandas = "^2.2.1"
+pandas = "^2.2.2"
 pyarrow = ">=15.0.2"
 pytz = ">=2023.4.0"
 tqdm = "^4.66.2"
 uvloop = {version = "^0.19.0", markers = "sys_platform != 'win32'"}
 
 async-timeout = {version = "^4.0.3", optional = true}
-betfair_parser = {version = "==0.10.0", optional = true}  # Pinned for stability
+betfair_parser = {version = "==0.11.1", optional = true}  # Pinned for stability
 defusedxml = {version = "^0.7.1", optional = true}
 docker = {version = "^7.0.0", optional = true}
 nautilus_ibapi = {version = "==10.19.2", optional = true}  # Pinned for stability
 
 [tool.poetry.extras]
 betfair = ["betfair_parser"]
 docker = ["docker"]
 ib = ["nautilus_ibapi", "async-timeout", "defusedxml"]
 
 [tool.poetry.group.dev]
 optional = true
 
 [tool.poetry.group.dev.dependencies]
-black = "^24.3.0"
+black = "^24.4.0"
 docformatter = "^1.7.5"
 mypy = "^1.9.0"
 pandas-stubs = "^2.2.1"
-pre-commit = "^3.6.2"
-ruff = "^0.3.4"
+pre-commit = "^3.7.0"
+ruff = "^0.3.7"
 types-pytz = "^2023.3"
 types-requests = "^2.31"
 types-toml = "^0.10.2"
 
 [tool.poetry.group.test]
 optional = true
 
@@ -255,18 +255,29 @@
 
 [tool.mypy]
 python_version = "3.10"
 disallow_incomplete_defs = true
 explicit_package_bases = true
 ignore_missing_imports = true
 namespace_packages = true
+no_strict_optional = false
 warn_no_return = true
 warn_unused_configs = true
 warn_unused_ignores = true
 
+[[tool.mypy.overrides]]
+no_strict_optional = true
+module = [
+    "examples/*",
+    "nautilus_trader/adapters/betfair/*",
+    "nautilus_trader/adapters/binance/*",
+    "nautilus_trader/adapters/interactive_brokers/*",
+    "nautilus_trader/indicators/ta_lib/*",
+]
+
 [tool.pytest.ini_options]
 testpaths = ["tests"]
 addopts = "-ra --new-first --failed-first --doctest-modules --doctest-glob=\"*.pyx\""
 asyncio_mode = "strict"
 filterwarnings = [
     "ignore::UserWarning",
     "ignore::DeprecationWarning",
```

### Comparing `nautilus_trader-1.190.0/PKG-INFO` & `nautilus_trader-1.191.0/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: nautilus_trader
-Version: 1.190.0
+Version: 1.191.0
 Summary: A high-performance algorithmic trading platform and event-driven backtester
 Home-page: https://nautilustrader.io
 License: LGPL-3.0-or-later
 Author: Nautech Systems
 Author-email: info@nautechsystems.io
 Requires-Python: >=3.10,<3.13
 Classifier: Development Status :: 4 - Beta
@@ -22,24 +22,24 @@
 Classifier: Topic :: Scientific/Engineering
 Classifier: Topic :: Software Development :: Libraries
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Provides-Extra: betfair
 Provides-Extra: docker
 Provides-Extra: ib
 Requires-Dist: async-timeout (>=4.0.3,<5.0.0) ; extra == "ib"
-Requires-Dist: betfair_parser (==0.10.0) ; extra == "betfair"
+Requires-Dist: betfair_parser (==0.11.1) ; extra == "betfair"
 Requires-Dist: click (>=8.1.7,<9.0.0)
-Requires-Dist: cython (==3.0.9)
+Requires-Dist: cython (==3.0.10)
 Requires-Dist: defusedxml (>=0.7.1,<0.8.0) ; extra == "ib"
 Requires-Dist: docker (>=7.0.0,<8.0.0) ; extra == "docker"
 Requires-Dist: fsspec (==2023.6.0)
 Requires-Dist: msgspec (>=0.18.6,<0.19.0)
 Requires-Dist: nautilus_ibapi (==10.19.2) ; extra == "ib"
 Requires-Dist: numpy (>=1.26.4,<2.0.0)
-Requires-Dist: pandas (>=2.2.1,<3.0.0)
+Requires-Dist: pandas (>=2.2.2,<3.0.0)
 Requires-Dist: pyarrow (>=15.0.2)
 Requires-Dist: pytz (>=2023.4.0)
 Requires-Dist: toml (>=0.10.2,<0.11.0)
 Requires-Dist: tqdm (>=4.66.2,<5.0.0)
 Requires-Dist: uvloop (>=0.19.0,<0.20.0) ; sys_platform != "win32"
 Project-URL: Repository, https://github.com/nautechsystems/nautilus_trader
 Description-Content-Type: text/markdown
@@ -57,18 +57,18 @@
 | :-------- | :-------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
 | `master`  | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fmaster%2Fversion.json)  | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=master)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml)  |
 | `nightly` | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fnightly%2Fversion.json) | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=nightly)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml) |
 | `develop` | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fdevelop%2Fversion.json) | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=develop)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml) |
 
 | Platform           | Rust    | Python |
 | :----------------- | :------ | :----- |
-| `Linux (x86_64)`   | 1.77.0+ | 3.10+  |
-| `macOS (x86_64)`   | 1.77.0+ | 3.10+  |
-| `macOS (arm64)`    | 1.77.0+ | 3.10+  |
-| `Windows (x86_64)` | 1.77.0+ | 3.10+  |
+| `Linux (x86_64)`   | 1.77.1+ | 3.10+  |
+| `macOS (x86_64)`   | 1.77.1+ | 3.10+  |
+| `macOS (arm64)`    | 1.77.1+ | 3.10+  |
+| `Windows (x86_64)` | 1.77.1+ | 3.10+  |
 
 - **Website:** https://nautilustrader.io
 - **Docs:** https://docs.nautilustrader.io
 - **Support:** [support@nautilustrader.io](mailto:support@nautilustrader.io)
 
 ## Introduction
 
@@ -187,15 +187,15 @@
 
 | Name                                                      | ID                    | Type                    | Status                                                  | Docs                                                                |
 | :-------------------------------------------------------- | :-------------------- | :---------------------- | :------------------------------------------------------ | :------------------------------------------------------------------ |
 | [Betfair](https://betfair.com)                            | `BETFAIR`             | Sports Betting Exchange | ![status](https://img.shields.io/badge/stable-green)    | [Guide](https://docs.nautilustrader.io/integrations/betfair.html)   |
 | [Binance](https://binance.com)                            | `BINANCE`             | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/stable-green)    | [Guide](https://docs.nautilustrader.io/integrations/binance.html)   |
 | [Binance US](https://binance.us)                          | `BINANCE`             | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/stable-green)    | [Guide](https://docs.nautilustrader.io/integrations/binance.html)   |
 | [Binance Futures](https://www.binance.com/en/futures)     | `BINANCE`             | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/stable-green)    | [Guide](https://docs.nautilustrader.io/integrations/binance.html)   |
-| [Bybit](https://www.bybit.com)                            | `BYBIT`               | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/building-orange) |                                                                     |
+| [Bybit](https://www.bybit.com)                            | `BYBIT`               | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow)     | [Guide](https://docs.nautilustrader.io/integrations/bybit.html)     |
 | [Databento](https://databento.com)                        | `DATABENTO`           | Data Provider           | ![status](https://img.shields.io/badge/beta-yellow)     | [Guide](https://docs.nautilustrader.io/integrations/databento.html) |
 | [Interactive Brokers](https://www.interactivebrokers.com) | `INTERACTIVE_BROKERS` | Brokerage (multi-venue) | ![status](https://img.shields.io/badge/stable-green)    | [Guide](https://docs.nautilustrader.io/integrations/ib.html)        |
 
 - `ID:` The default client ID for the integrations adapter clients
 - `Type:` The type of integration (often the venue type)
 
 ### Status
```

